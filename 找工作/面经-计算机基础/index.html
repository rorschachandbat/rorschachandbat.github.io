

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/cute.jpg">
  <link rel="icon" href="/img/cute.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="R">
  <meta name="keywords" content="">
  
    <meta name="description" content="痛定思痛决定好好重新整理一份八股文">
<meta property="og:type" content="article">
<meta property="og:title" content="面经-计算机基础">
<meta property="og:url" content="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="R">
<meta property="og:description" content="痛定思痛决定好好重新整理一份八股文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-04eed39e986d359dcdd32ac2b8c5e658_720w.webp">
<meta property="og:image" content="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-01056f4f051d715cc5de57314b0e9ba1_720w.webp">
<meta property="og:image" content="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220309220924444.png">
<meta property="article:published_time" content="2024-03-25T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-09T02:45:05.568Z">
<meta property="article:author" content="R">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-04eed39e986d359dcdd32ac2b8c5e658_720w.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>面经-计算机基础 - R</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"rorschachandbat.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
 <meta name="referrer" content="no-referrer" />
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="R" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>R君的秘密基地</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-douban-fill"></i>
                <span>书影音</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/books/">
                    
                    <span>读过</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/movies/">
                    
                    <span>看过</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/games/">
                    
                    <span>玩过</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gdc/">
                <i class="iconfont icon-xbox-fill"></i>
                <span>gdc</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/elder%20ring.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面经-计算机基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-26 00:00" pubdate>
          2024年3月26日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          160 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面经-计算机基础</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2025年1月9日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销；</p>
<p>内联函数是⼀种特殊的函数，会进行类型检查；对编译器的⼀种请求，编译器有可能拒绝这种请求； </p>
<p>C++中inline编译限制：</p>
<ol>
<li>不能存在任何形式的循环语句</li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞⼤</li>
<li>内联函数声明必须在调⽤语句之前</li>
</ol>
<p><strong>和difine相比有什么优点？</strong></p>
<ol>
<li>类型安全</li>
<li>可以访问类成员</li>
<li>调试友好，可以设置断电</li>
<li>参数求值一次，比如下面这种用define可能会求值多次，造成错误。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;  <span class="hljs-comment">// x只被求值一次</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">square</span>(a++);  <span class="hljs-comment">// 安全的行为</span><br></code></pre></td></tr></table></figure>



<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>修饰变量<br>修改了变量的作用域和生命周期，存储在静态区域。生命周期和程序相同，作用域分为全局变量和局部变量。局部变量仅在函数内可用，全局变量仅在当前源文件中可用。</li>
<li>修饰函数<br>表明函数的作用域仅在当前源文件中。</li>
<li>修饰成员变量<br>静态成员变量为全局类对象所共享，仅有一份拷贝。类中声明，类外定义和初始化。所有实例共享一份数据，不依赖类的实例存在，可以通过类名访问</li>
<li>修饰成员函数<br>静态成员函数为全局类对象所共享。没有this指针，仅能访问静态成员变量和函数，虚函数不能为静态成员函数。【虚函数运行时绑定，静态成员函数编译时绑定】</li>
</ol>
<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ol>
<li><p>修饰变量：变量声明，表明变量在此处引用，在其他源文件中定义。</p>
</li>
<li><p>修饰函数：表明函数在其他源文件中定义。</p>
</li>
<li><p>extern “C”：编译器用C的命名规范去编译函数，链接器用C的命名规范进行链接。因为C++支持函数重载，而C不支持。</p>
<p>例如，假设某个函数的原型为：void</p>
<p>foo( int x, int y);该函数被C编译器编译后在符号库中的名字为 _ foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</p>
</li>
</ol>
<h3 id="constexpr-和-const"><a href="#constexpr-和-const" class="headerlink" title="constexpr 和 const"></a>constexpr 和 const</h3><p>constexpr：告诉编译器我可以是编译期间可知的，尽情的优化我吧。</p>
<p>const：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p>
<p>修饰对象的时候两者之间最基本的区别是：</p>
<ul>
<li>const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。</li>
<li>constexpr是修饰一个常量表达式。但请注意constexpr不是修饰常量表达式的唯一途径。</li>
</ul>
<p>修饰函数的时候两者之间最基本的区别是：</p>
<ul>
<li>const只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。</li>
<li>constexpr可以用于含参和无参函数。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数：                                                        </li>
<li>1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素      (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了)                                                                       2.参数和返回值必须是字面值类</li>
</ul>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof计算的是在栈中分配的内存大小。</p>
<p>（1） sizeof不计算static变量占的内存；</p>
<p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p>
<p>（3） char型占1个字节，int占4个字节，short int占2个字节</p>
<p>long int占4个字节，float占4字节，double占8字节，string占4字节</p>
<p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p>
<p>（4） 数组的长度：</p>
<p>若指定了数组长度，则不看元素个数，总字节数&#x3D;数组长度*sizeof（元素类型）</p>
<p>若没有指定长度，则按实际元素个数类确定</p>
<p>Ps：若是字符数组，则应考虑末尾的空字符。</p>
<p>（5） 结构体对象的长度</p>
<p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p>
<p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）&#x3D;4</p>
<p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p>
<p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p>
<p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p>
<p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p>
<p><strong>为什么空类大小不是0？</strong></p>
<p>为了确保两个不同对象的地址不同，必须如此。</p>
<p>类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独⼀⽆⼆的地址。 </p>
<p>同样，空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有独⼀⽆⼆的地址了。 </p>
<p>所以，空类的sizeof为1，⽽不是0。</p>
<p><strong>为什么不计算函数的大小？</strong></p>
<p>函数代码存储在代码段</p>
<p>所有实例共享函数代码</p>
<p>sizeof只计算实例数据成员</p>
<p>虚函数只计算vptr大小</p>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>不会计算字符串最末尾的’&#x2F;0’，sizeof会计算</p>
<h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack()"></a>#pragma pack()</h3><p>#pragma pack()不带参数时，可以取消之前自定义的字节对齐方式，恢复默认的自然对齐。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>int i &#x3D; (int)p; 等同于 int i &#x3D; static_cast<int>(p);</p>
<p>(int)p是C风格的强制类型转换</p>
<p>static_cast<int>(p)是C++的类型转换</p>
<p>对于指针到整数的转换，使用static_cast</p>
<p>各种类型转换：</p>
<p>const_cast：去除const属性</p>
<p>dynamic_cast：安全的向下转型</p>
<p>static_cast：编译时静态转换</p>
<p>reinterpret_cast：重新解释底层内存</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p> dynamic_cast 是 C++中的一个类型转换操作符，它主要用于处理多态类型的安全向下转换（<strong>也就是父类向子类转换</strong>）。 如果转换不合法，对于指针类型，dynamic_cast 会返回空指针 nullptr ； 对于<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B&zhida_source=entity">引用类型</a>，它会抛出 std::bda_cast 异常</p>
<blockquote>
<p>注意：dynamic_cast是在运行时检查，并且 使用dynamic_cast 转换时，涉及的类通常至少需要有一个虚函数（比如<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">虚析构函数</a>），这样编译器才能再运行时使用类型信息和执行转换。<br>另外在转换前，也得 Base* base &#x3D;new Derived1; 指向这个对象，不然会存在 和reinterpret_cast一样的问题</p>
</blockquote>
<h4 id="static-cast和dynamic-cast的区别"><a href="#static-cast和dynamic-cast的区别" class="headerlink" title="static_cast和dynamic_cast的区别"></a>static_cast和dynamic_cast的区别</h4><ol>
<li><strong>类型检查时机</strong> ：</li>
</ol>
<ul>
<li><code>static_cast</code>：在编译时进行类型检查。它根据转换语句中提供的信息（尖括号中的类型）进行转换，不执行运行时类型检查。</li>
<li><code>dynamic_cast</code>：在运行时进行类型检查。它通过检查对象的实际类型来确定转换是否安全。如果转换不安全，<code>dynamic_cast</code>会返回空指针（对于指针类型）或抛出<code>std::bad_cast</code>异常（对于引用类型）。</li>
</ul>
<ol>
<li><strong>安全性</strong> ：</li>
</ol>
<ul>
<li><code>static_cast</code>：不如<code>dynamic_cast</code>安全，因为它不进行运行时类型检查，可能会在类型不匹配的情况下导致未定义行为。例如，将一个子类对象强制转换为父类对象是安全的，但将一个父类对象强制转换为子类对象可能会导致错误。</li>
<li><code>dynamic_cast</code>：在类层次结构中用于安全的下行转换（从基类指针或引用转换为派生类指针或引用）。它依赖于虚函数表（vtable）来确保转换的安全性。如果基类没有虚函数，<code>dynamic_cast</code>将无法进行类型检查，从而无法保证转换的安全性。</li>
</ul>
<h3 id="funture和promise"><a href="#funture和promise" class="headerlink" title="funture和promise"></a>funture和promise</h3><h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h4><ul>
<li>**<code>std::promise</code>**：<ul>
<li>用于在一个线程中设置值或异常。</li>
<li>与 <code>std::future</code> 配对使用。</li>
</ul>
</li>
<li>**<code>std::future</code>**：<ul>
<li>用于在另一个线程中获取由 <code>std::promise</code> 设置的值或异常。</li>
</ul>
</li>
</ul>
<h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ol>
<li><strong>绑定关系</strong>：<ul>
<li>一个 <code>std::promise</code> 与一个 <code>std::future</code> 成对使用。</li>
<li>当通过 <code>std::promise</code> 设置值时，绑定的 <code>std::future</code> 可以访问该值。</li>
</ul>
</li>
<li><strong>线程间通信</strong>：<ul>
<li><code>std::promise</code> 通常由生产者线程持有，用于设置数据。</li>
<li><code>std::future</code> 通常由消费者线程持有，用于获取数据。</li>
</ul>
</li>
<li><strong>延迟获取</strong>：<ul>
<li>使用 <code>future.get()</code> 阻塞当前线程，直到 <code>promise</code> 提供值。</li>
</ul>
</li>
</ol>
<h4 id="3-通信方式"><a href="#3-通信方式" class="headerlink" title="3. 通信方式"></a>3. 通信方式</h4><ul>
<li><strong>传递值</strong>：通过 <code>promise.set_value()</code> 设置值，<code>future.get()</code> 获取值。</li>
<li><strong>传递异常</strong>：通过 <code>promise.set_exception()</code> 传递异常，<code>future.get()</code> 捕获异常。</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用和指针的区别？从底层角度考虑"><a href="#引用和指针的区别？从底层角度考虑" class="headerlink" title="引用和指针的区别？从底层角度考虑"></a>引用和指针的区别？从底层角度考虑</h3><p>引用必须初始化，不能改变引用的指向，从汇编的角度来看，引用就是一个const指针</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="C-中的智能指针有哪些，各自有什么作用"><a href="#C-中的智能指针有哪些，各自有什么作用" class="headerlink" title="C++中的智能指针有哪些，各自有什么作用?"></a>C++中的智能指针有哪些，各自有什么作用?</h3><p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/SaXIX">C++智能指针weak_ptr详解</a></p>
<p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：</p>
<p>（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p>
<p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p>
<p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<h3 id="shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"><a href="#shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？" class="headerlink" title="shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"></a>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？</h3><p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p>
<p>（2）具体实现：</p>
<p>1）构造函数：将指针指向该对象，引用计数置为1；</p>
<p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p>
<p>3）赋值运算符：&#x3D;号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p>
<h3 id="shareptr引用计数数据类型"><a href="#shareptr引用计数数据类型" class="headerlink" title="shareptr引用计数数据类型"></a>shareptr引用计数数据类型</h3><p>long</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><h3 id="静态多态和动态多态的区别？"><a href="#静态多态和动态多态的区别？" class="headerlink" title="静态多态和动态多态的区别？"></a>静态多态和动态多态的区别？</h3><p><strong>何为静态多态</strong>？</p>
<p>又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数。例如：函数重载，通过类成员运算符指定的运算。</p>
<p><strong>何为动态多态？</strong></p>
<p>动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。<br>动态多态是在虚函数的基础上实现的，而实现的条件有：<br>(1) 在类中声明为虚函数</p>
<p>(2) 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同（否则是函数重载的条件）</p>
<p>(3) 将子类对象的指针（或以引用形式）赋值给父类对象的指针（或引用），再用该指向父类对象的指针（或引用）调用虚函数<br>如此，便可以实现动态多态，程序会按照实际对象类型来选择要实行的函数具体时哪一个。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/688090551">C++11、C++14、C++17、C++20新特性总结 - cpp后端技术的文章 - 知乎</a></p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><h3 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h3><h3 id="函数模板的更改"><a href="#函数模板的更改" class="headerlink" title="函数模板的更改"></a>函数模板的更改</h3><p>支持默认参数</p>
<p>支持可变参数</p>
<h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>新的std</p>
<p>tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p>
<p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p>
<h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>Lambda可以很方便的定义函数列表的个数，以及获取方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">[] 什么也不捕获，无法lambda函数体使用任何<br><br>[=] 按值的方式捕获所有变量<br><br>[&amp;] 按引用的方式捕获所有变量<br><br>[=, &amp;a] 除了变量a之外，按值的方式捕获所有局部变量，变量a使用引用的方式来捕获。这里可以按引用捕获多个，例如 [=, &amp;a, &amp;b,&amp;c]。这里注意，如果前面加了=，后面加的具体的参数必须以引用的方式来捕获，否则会报错。<br><br>[&amp;, a] 除了变量a之外，按引用的方式捕获所有局部变量，变量a使用值的方式来捕获。这里后面的参数也可以多个，例如 [&amp;, a, b, c]。这里注意，如果前面加了&amp;，后面加的具体的参数必须以值的方式来捕获。<br><br>[a, &amp;b] 以值的方式捕获a，引用的方式捕获b，也可以捕获多个。<br><br>[<span class="hljs-keyword">this</span>] 在成员函数中，也可以直接捕获<span class="hljs-keyword">this</span>指针，其实在成员函数中，[=]和[&amp;]也会捕获<span class="hljs-keyword">this</span>指针。<br></code></pre></td></tr></table></figure>

<p>如果想要修改外部变量，可以用mutable，但是也只是修改拷贝的那一份变量，真正外部不会修改</p>
<h3 id="for循环的新方式"><a href="#for循环的新方式" class="headerlink" title="for循环的新方式"></a>for循环的新方式</h3><p>之前只能三段式，现在可以直接auto来for循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> arc[] = <span class="hljs-string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;<br>    <span class="hljs-comment">//for循环遍历普通数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : arc) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span> &lt;&lt; endl;<br>    vector&lt;<span class="hljs-type">char</span>&gt;<span class="hljs-built_in">myvector</span>(arc, arc + <span class="hljs-number">23</span>);<br>    <span class="hljs-comment">//for循环遍历 vector 容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : myvector) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 2)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">6</span> + <span class="hljs-number">4</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 3)</span><br><span class="hljs-type">int</span> length = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> url[length];<span class="hljs-comment">//错误，length是变量</span><br></code></pre></td></tr></table></figure>

<p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<h4 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h4><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<h4 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h4><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<p>1.整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const最好只用来用作只读的作用，要注意只读不意味不可以修改，可以通过其他的来改</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是当外部函数返回内部函数时，内部函数随后在不同的范围内执行，内部函数继续保持对外部函数变量的访问，即使外部函数不再存在。</p>
<p>就比如一个function再套一个function</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> helloWorld = <span class="hljs-title function_">hello</span>();<br><br><span class="hljs-title function_">helloWorld</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure>



<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>1.定义一个函数(outer)，该函数存在声明的局部变量(b)</p>
<p>2.该函数的返回值也是一个函数(inner)</p>
<p>3.返回的函数(inner)调用了该函数声明的局部变量(b)</p>
<p>4.该函数被调用(outer)</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23971699/answer/2358595798">c++虚函数的作用是什么？ - 心试的回答 - 知乎</a></p>
<p>每个子类会生成一个虚函数表，根据这个子类有无重写父类的虚函数，重写了会覆盖对应的内存空间</p>
<p>一个继承一个比较好理解，一个继承了多个可以看下面的图</p>
<p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-04eed39e986d359dcdd32ac2b8c5e658_720w.webp" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-01056f4f051d715cc5de57314b0e9ba1_720w.webp" srcset="/img/loading.gif" lazyload></p>
<p>每一个类会有一个虚函数表，然后这个类的多个对象都会共享这一张虚函数表，新创建的对象会保存虚函数指针。</p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p><strong>纯虚函数是指在基类中定义的没有实现的虚函数</strong>。使用纯虚函数可以使该函数只有<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22629281871%22%7D">函数原型</a>，而没有具体的实现。注：这里的“&#x3D;0”表示该函数为纯虚函数。</p>
<p>纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。</p>
<p><strong>抽象类是包含纯虚函数的类</strong>，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。</p>
<h3 id="哪些函数不能声明成虚函数？"><a href="#哪些函数不能声明成虚函数？" class="headerlink" title="哪些函数不能声明成虚函数？"></a>哪些函数不能声明成虚函数？</h3><p><strong>非成员函数</strong></p>
<p>非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？</p>
<p><strong>构造函数</strong></p>
<p>要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了。</p>
<p>友元函数</p>
<p><strong>静态成员函数</strong></p>
<p>静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上才可以的，两者一个是与实例相关，一个是与类相关。</p>
<p><strong>内联成员函数</strong></p>
<p>内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数。</p>
<h3 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h3><p>在Effective C++ 中，Scott Meyers在《条款07:为多态基类声明virtual析构函数》中提到，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没有被销毁。也就是说，如果派生类继承了父类的情况下，如果父类的析构函数不是虚函数，而在使用中用了多态的写法，就会导致没有调用到派生类的析构函数，导致资源没有释放，造成泄漏。</p>
<p>总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说<strong>虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的</strong>。<br> （1）<strong>如果父类的析构函数不加virtual关键字</strong><br> 当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。<br> （2）<strong>如果父类的析构函数加virtual关键字</strong><br> 当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。</p>
<h3 id="一个指向nullptr的类能调用虚函数吗？"><a href="#一个指向nullptr的类能调用虚函数吗？" class="headerlink" title="一个指向nullptr的类能调用虚函数吗？"></a>一个指向nullptr的类能调用虚函数吗？</h3><p>这种情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f1&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f2&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> </span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;f4&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	A* pa = <span class="hljs-literal">NULL</span>;<br>	pa-&gt;<span class="hljs-built_in">f1</span>();	<span class="hljs-comment">//正常</span><br>	pa-&gt;<span class="hljs-built_in">f2</span>();   <span class="hljs-comment">//正常</span><br>	pa-&gt;<span class="hljs-built_in">f3</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>	pa-&gt;<span class="hljs-built_in">f4</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>不能，但是可以调用成员函数和static的成员函数（不能使用这个类的成员变量），因为成员函数地址已经确定了，和你的类其实是无关的，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">A *pa = <span class="hljs-literal">NULL</span>;<br>pa-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func(pa, 2);且pa==NULL</span><br>((A*)<span class="hljs-literal">NULL</span>)-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func( ((A*)NULL), 2);</span><br></code></pre></td></tr></table></figure>

<p>类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针，成员函数中对成员变量的访问都是转化成”this-&gt;数据成员”的方式。因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的this指针。而类的静态成员函数只能访问<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">静态成员变量</a>，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。<br>有了上面的分析，就可以解释为什么空对象指针对f1, f2的调用成功，对f3的调用不成功。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存空间有哪些分类？"><a href="#内存空间有哪些分类？" class="headerlink" title="内存空间有哪些分类？"></a>内存空间有哪些分类？</h3><p>（1）堆，使用malloc、free动态分配和释放空间，能分配较大的内存；</p>
<p>（2）栈，为函数的局部变量分配内存，能分配较小的内存；</p>
<p>（3）全局&#x2F;静态存储区，用于存储全局变量和静态变量；</p>
<p>（4）常量存储区，专门用来存放常量；</p>
<p>（5）自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。</p>
<h3 id="malloc和new有什么区别？"><a href="#malloc和new有什么区别？" class="headerlink" title="malloc和new有什么区别？"></a>malloc和new有什么区别？</h3><p>（1）new分配内存空间无需指定分配内存大小，malloc需要；</p>
<p>（2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；</p>
<p>（3）new是从自由存储区获得内存，malloc从堆中获取内存；</p>
<p>（4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。</p>
<p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220309220924444.png" srcset="/img/loading.gif" lazyload alt="image-20220309220924444"></p>
<h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>直接用new是自动给你分配，但是要用placement new可以在已分配的内存里面创建对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">A* p=<span class="hljs-built_in">new</span> (ptr)A<br></code></pre></td></tr></table></figure>

<p>1）用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。如本例就是在栈上生成一个对象。</p>
<p>（2）使用语句A* p&#x3D;new (mem) A;定位生成对象时，指针p和数组名mem指向同一片存储区。所以，与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。</p>
<p>（3）使用语句A *p&#x3D;new (mem) A;定位生成对象时，会自动调用类A的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&zhida_source=entity">构造函数</a>，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">析构函数</a>，如本例中的p-&gt;~A()。</p>
<p>（4）如果有这样一个场景，我们需要大量的申请一块类似的内存空间，然后又释放掉，比如在在一个server中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合c++的内存管理要求，没有什么错误，但是仔细想想很不合理，为什么我们每个请求都要重新申请一块内存呢，要知道每一次内从的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言)，极端情况下，如果当前系统中有大量的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87&zhida_source=entity">内存碎片</a>，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=2&q=placement+new&zhida_source=entity">placement new</a>来<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1&zhida_source=entity">构造对象</a>，那么就会在我们指定的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=3&q=%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4&zhida_source=entity">内存空间</a>中构造对象。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><ol>
<li><p>默认构造函数（Default Constructor）：没有参数的构造函数。如果在类中没有定义构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时进行默认的初始化操作。</p>
</li>
<li><p>参数化构造函数（Parameterized Constructor）：带有参数的构造函数。参数化构造函数可以接受不同的参数，并根据参数的值来初始化对象的数据成员。</p>
</li>
<li><p>拷贝构造函数：使用一个对象初始化另一个对象。拷贝构造函数的参数为同类对象的引用。它将被复制的对象的数据成员值复制给新创建的对象。</p>
</li>
<li><p>移动构造函数（Move Constructor）：C++11引入的特性，用于实现对象的移动语义。移动构造函数通过接管另一个对象的资源而避免进行深拷贝，提高了性能。</p>
</li>
</ol>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>传入右值，直接浅拷贝，右值用std::move来生成</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="stl底层实现"><a href="#stl底层实现" class="headerlink" title="stl底层实现"></a><strong>stl底层实现</strong></h3><p>vector：数组</p>
<p>Dequeue（双端队列）：二维数组</p>
<p>List：环状双向链表</p>
<p>set（集合）：平衡的红黑树</p>
<p>multiset：红黑树</p>
<p>map：平衡二叉树</p>
<p>unordered_map：散列表（哈希表）</p>
<p><strong>而C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表。</strong></p>
<h3 id="哈希表原理"><a href="#哈希表原理" class="headerlink" title="哈希表原理"></a>哈希表原理</h3><p>首先是哈希函数，就是把一个长的二级制数据转换成一个短的二进制数据的函数；然后就是解决哈希冲突的方法，常见的有开放寻址法和链表法，前者是通过探测并占用下一个可用的存储位置，后者是在冲突的位置用链表记录多个值。</p>
<h3 id="哈希函数原理"><a href="#哈希函数原理" class="headerlink" title="哈希函数原理"></a>哈希函数原理</h3><p>哈希函数的目标是将任意长度的输入数据转换为固定长度的输出值，同时要尽量避免冲突。下面介绍几种常见的哈希函数实现方法：</p>
<h4 id="除法散列"><a href="#除法散列" class="headerlink" title="除法散列"></a>除法散列</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DivisionHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> tableSize; <span class="hljs-comment">// 哈希表大小（最好是质数）</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DivisionHash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span> <br>    &#123;<br>        tableSize = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Hash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key</span>)</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.Abs(key) % tableSize;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 字符串的哈希</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">HashString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span> <br>    &#123;<br>        <span class="hljs-built_in">int</span> hash = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> str) <br>        &#123;<br>            hash = (hash * <span class="hljs-number">31</span> + c) % tableSize;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.Abs(hash);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MultiplicationHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> tableSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> A = <span class="hljs-number">0.6180339887</span>; <span class="hljs-comment">// 黄金分割比例</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiplicationHash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span> <br>    &#123;<br>        tableSize = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Hash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key</span>)</span> <br>    &#123;<br>        <span class="hljs-built_in">double</span> temp = key * A;<br>        <span class="hljs-built_in">double</span> fractional = temp - Math.Floor(temp); <span class="hljs-comment">// 取小数部分</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)(tableSize * fractional);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> BASE = <span class="hljs-number">31</span>; <span class="hljs-comment">// 基数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MOD = <span class="hljs-number">1000000007</span>; <span class="hljs-comment">// 大质数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">ComputeHash</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span> <br>    &#123;<br>        <span class="hljs-built_in">long</span> hash = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">long</span> power = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> str) <br>        &#123;<br>            hash = (hash + (c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>) * power) % MOD;<br>            power = (power * BASE) % MOD;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> hash;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>有三种类型</p>
<p>模板实际上分为三类：</p>
<p>类型模板参数（类型模板）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure>

<p>非类型模板参数（常量模板）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> Size&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123; &#125;;<br></code></pre></td></tr></table></figure>

<p>模板模板参数（模板的模板参数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure>

<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="类型模板参数（通用游戏对象）"><a href="#类型模板参数（通用游戏对象）" class="headerlink" title="类型模板参数（通用游戏对象）"></a>类型模板参数（通用游戏对象）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameObject</span> &#123;<br>    T position;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(T delta)</span> </span>&#123;<br>        position += delta;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 可以用于不同类型的位置表示</span><br>GameObject&lt;Vector2&gt; player;<br>GameObject&lt;Vector3&gt; enemy3D;<br></code></pre></td></tr></table></figure>

<h3 id="非类型模板参数（固定大小游戏数组）"><a href="#非类型模板参数（固定大小游戏数组）" class="headerlink" title="非类型模板参数（固定大小游戏数组）"></a>非类型模板参数（固定大小游戏数组）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> MaxUnits = <span class="hljs-number">100</span>&gt;<br><span class="hljs-keyword">class</span> ArmyManager &#123;<br>    Unit units[MaxUnits];<br>    <span class="hljs-type">int</span> currentUnitCount = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 编译期确定最大单位数</span><br>ArmyManager&lt;<span class="hljs-number">50</span>&gt; smallArmy;<br>ArmyManager&lt;<span class="hljs-number">200</span>&gt; largeArmy;<br></code></pre></td></tr></table></figure>

<h3 id="模板模板参数（容器策略）"><a href="#模板模板参数（容器策略）" class="headerlink" title="模板模板参数（容器策略）"></a>模板模板参数（容器策略）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inventory</span> &#123;<br>    Container&lt;T&gt; items;<br>&#125;;<br><br><span class="hljs-comment">// 可以使用不同容器</span><br>Inventory&lt;Weapon, vector&gt; playerWeapons;<br>Inventory&lt;Weapon, list&gt; backupWeapons;<br></code></pre></td></tr></table></figure>

<h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>（1）预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件；包括展开宏定义，处理条件编译指令，包含头文件</p>
<p>（2）编译阶段将预编译文件编译，删除注释，生成汇编文件（编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码)；</p>
<p>（3）汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件）（汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）；</p>
<p>（4）链接阶段，将多个目标文件和所需要的库连接成可执行文件（.exe文件）</p>
<h3 id="＃include-lt-file-h-gt-与-＃include-“file-h”的区别？"><a href="#＃include-lt-file-h-gt-与-＃include-“file-h”的区别？" class="headerlink" title="＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？"></a>＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？</h3><p>前者从标准库查找寻找和引用file.h，后者从当前路径寻找和引用</p>
<h3 id="main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>main函数执行之前会执行什么？执行之后还能执行代码吗？</h3><p>（1）全局对象的构造函数会在main函数之前执行；</p>
<p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p>
<p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。	</p>
<p>比如全局变量的初始化，就不是由main函数引起的</p>
<p>举例： class A{};</p>
<p>A a; &#x2F;&#x2F;a的构造函数限执行</p>
<p>int main() {}</p>
<h3 id="动态库和静态库优缺点"><a href="#动态库和静态库优缺点" class="headerlink" title="动态库和静态库优缺点"></a>动态库和静态库优缺点</h3><p><strong>静态库</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>代码装载速度快，执行速度比动态链接库略快</li>
<li>只需要开发者有lib就行，不需要考虑用户电脑上有无lib。</li>
</ol>
<p><strong>缺点</strong></p>
<p>生成的体积较大，包含相同的公共代码，造成浪费</p>
<p><strong>动态库</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>节省内存</li>
<li>dll和exe独立，更换dll就可以改变函数内容，提高可维护性和可拓展性</li>
<li>不同编程语言只要按照函数调用约定可以用同一个dll</li>
<li>耦合度小，开发过程独立</li>
</ol>
<p><strong>缺点</strong></p>
<p>用户电脑里面需要有dll</p>
<h1 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h1><h2 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h2><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>在C#中，unsafe 关键字用于标识包含不安全代码块的上下文，允许直接使用指针和执行不安全的操作。</p>
<p>优点：</p>
<ol>
<li><p>更高的性能： 使用指针直接操作内存可以提高性能，特别是在处理大量数据或需要高效访问内存的场景下。</p>
</li>
<li><p>与非托管代码交互： 允许与非托管代码进行更直接的交互，例如调用 Windows API 或者使用一些底层的系统功能。</p>
</li>
<li><p>灵活性： 可以执行一些 C# 中无法直接实现的操作，如访问特定的内存地址或进行底层的位操作。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>安全性风险： 使用 unsafe 可能导致程序出现潜在的安全漏洞，因为绕过了 C# 的类型安全检查和边界检查。</p>
</li>
<li><p>可读性下降： 使用指针和不安全的操作会增加代码的复杂性，并且降低代码的可读性和可维护性。</p>
</li>
<li><p>难以调试： 不安全的代码可能更难调试和定位错误，因为涉及到直接操作内存的技术细节。</p>
</li>
</ol>
<h3 id="const和readonly有什么区别？"><a href="#const和readonly有什么区别？" class="headerlink" title="const和readonly有什么区别？"></a>const和readonly有什么区别？</h3><p>都可以标识一个常量。主要有以下区别：<br>1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值;<br>2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段<br>3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。<br>4、const默认是静态的；而readonly如果设置成静态需要显示声明<br>5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。</p>
<h2 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h2><p>要用到特性就必须要用反射，比如说你要序列化一个类，如果直接写接口来实现，你不知道这个类有哪些属性，而且还要写很多不同的接口，但是用反射可以很优雅地实现，如下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Serialize</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>&#123;<br>     <span class="hljs-keyword">var</span> res = obj<br>         .GetType()<br>         .GetProperties(BindingFlag.Public | BindingFlags.Instance)<br>         .Where(pi =&gt;<br>                &#123;<br>                    <span class="hljs-keyword">var</span> attr = pi.GetCustomAttribute&lt;BrowsableAtrribute&gt;();<br>                    <span class="hljs-keyword">if</span>(attr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> attr.Browable;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;)<br>         .Select(pi =&gt; <span class="hljs-keyword">new</span>&#123;Key = pi.Name, Value = pi.GetValue(obj)&#125;)<br>         .Select(o =&gt; <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;o.Key&#125;</span> : <span class="hljs-subst">&#123;o.Value&#125;</span>&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Join(Environment.NewLine, res);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    [<span class="hljs-meta">Browsable(false)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><h2 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h2><p>C#中定义的值类型包括原类型（Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举(enum)、结构(struct)，引用类型包括：类、数组、接口、委托、字符串等，引用型是在堆中分配内存，初始化为null，引用型是需要GARBAGE COLLECTION来回收内存的，值型不用，超出了作用范围，系统就会自动释放！</p>
<h2 id="结构体和类区别"><a href="#结构体和类区别" class="headerlink" title="结构体和类区别"></a>结构体和类区别</h2><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="死锁需要的条件"><a href="#死锁需要的条件" class="headerlink" title="死锁需要的条件"></a>死锁需要的条件</h2><ol>
<li><strong>互斥条件</strong> ：资源是独占的，即同一时间只能被一个进程使用。如果资源正在被一个进程使用，其他请求该资源的进程必须等待，直到资源被释放。</li>
<li><strong>请求与保持条件</strong> ：一个进程在已经持有一个资源的情况下，又请求新的资源，但新的资源已经被其他进程占用，因此请求的进程被阻塞，并且保持已    获得的资源不放。</li>
<li><strong>不可剥夺条件</strong> ：进程已经获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由进程自己释放。</li>
<li><strong>循环等待条件</strong> ：存在一个进程等待队列，其中每个进程都在等待下一个进程持有的资源，形成一个循环等待链。</li>
</ol>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="多个进程共享同一个库"><a href="#多个进程共享同一个库" class="headerlink" title="多个进程共享同一个库"></a>多个进程共享同一个库</h3><p>当多个进程加载同一个共享库时，操作系统会采用以下策略：</p>
<p>代码段（Text Section）</p>
<p>共享库的代码段会被映射到不同进程的虚拟地址空间中</p>
<p>实际上，代码段在物理内存中只有一份拷贝</p>
<p>多个进程共享这同一份物理内存，达到节省内存的目的</p>
<p>数据段（Data Section）</p>
<p>每个进程会获得共享库数据段的独立副本</p>
<p>这确保了进程间数据的隔离性</p>
<p>包括：</p>
<p>全局变量</p>
<p>静态变量</p>
<h3 id="线程和进程和协程"><a href="#线程和进程和协程" class="headerlink" title="线程和进程和协程"></a>线程和进程和协程</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/279383752">Unity协程的原理与应用 - 宇亓的文章 - 知乎</a></p>
<p>（1）进程是运行时的程序，是系统进行资源分配和调度的基本单位，它实现了系统的并发；</p>
<p>（2）线程是进程的子单位，也称为轻量级进程，它是CPU进行分配和调度的基本单位，也是独立运行的基本单位，它实现了进程内部的并发；</p>
<p>（3）一个程序至少拥有一个进程，一个进程至少拥有一个线程，线程依赖于进程而存在；</p>
<p>（4）进程拥有独立的内存空间，而线程是共享进程的内存空间的，自己不占用资源；</p>
<p>（5）线程的优势：线程之间的信息共享和通讯比较方便，不需要资源的切换等.</p>
<p>每一个进程都独立拥有自己的指令和数据，所以称为资源分配的基本单位。其中数据又分布在内存的不同区域，我们在C语言课程中学习过内存四区的概念，一个运行中的进程所占有的内存大体可以分为四个区域：栈区、堆区、数据区、代码区。其中代码区存储指令，另外三个区存储数据。</p>
<p>线程是处理器调度和执行的基本单位，一个线程往往和一个函数调用栈绑定，一个进程有多个线程，每个线程拥有自己的函数调用栈，同时共用进程的堆区，数据区，代码区。操作系统会不停地在不同线程之间切换来营造出一个并行的效果，这个策略称为时间片轮转法。</p>
<p>那么协程在其中又处于什么地位呢？ <strong>一切用户自己实现的，类似于线程的轮子，都可以称之为是协程。</strong></p>
<h3 id="线程的独占资源和共享资源"><a href="#线程的独占资源和共享资源" class="headerlink" title="线程的独占资源和共享资源"></a>线程的独占资源和共享资源</h3><p><strong>独占资源</strong></p>
<ol>
<li>线程就是函数的运行，所以运行时候的信息都是独占的，包括返回值，局部变量，寄存器信息等，每个进程有自己独占的栈区。</li>
<li>每个线程有自己独立的线程id，独立的调度优先级和错误返回码。</li>
</ol>
<p><strong>共享资源</strong></p>
<ol>
<li>共享进程的代码区</li>
<li>共享进程的数据区，即全局变量和静态变量。</li>
<li>共享进程的堆区。</li>
<li>动态链接库。</li>
<li>文件，打开的文件信息。</li>
<li>共享当前工作目录，以及用户id和组id。</li>
</ol>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>“线程安全”也不是指线程的安全，而是指内存的安全，在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。</p>
<p><strong>如何避免</strong>？</p>
<p>私有化内存</p>
<p>栈内存</p>
<h3 id="使用多进程与多线程的区别？"><a href="#使用多进程与多线程的区别？" class="headerlink" title="使用多进程与多线程的区别？"></a>使用多进程与多线程的区别？</h3><p>（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。</p>
<p>（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；</p>
<p>（3）线程产生的速度快，线程间通信快、切换快；</p>
<p>（4）线程的资源利用率比较好；</p>
<p>（5）线程使用公共变量或者资源时需要同步机制。</p>
<h3 id="操作系统如何保证每个进程都有独立的空间？"><a href="#操作系统如何保证每个进程都有独立的空间？" class="headerlink" title="操作系统如何保证每个进程都有独立的空间？"></a>操作系统如何保证每个进程都有独立的空间？</h3><p>通过虚拟内存来实现，</p>
<p>首先是虚拟内存分页，</p>
<p>然后是页表映射，给每个进程维护一个页表，记录了虚拟地址和物理地址的映射关系</p>
<p>之后是内存保护，操作系统会给分配的进程页表有一些额外的标志，用于控制进程对内存的访问权限。</p>
<p>之后是上下文切换，<strong>当操作系统切换到一个新的进程时，它会保存当前进程的页表以及其他的上下文信息，并加载下一个进程的页表</strong>。这样，每个进程在运行时拥有自己独立的虚拟地址空间，与其他进程的内存空间相隔离。</p>
<p>通过虚拟内存机制，操作系统能够为每个进程提供独立的内存空间，<strong>无论是代码、数据还是堆栈，每个进程都认为自己独占系统的整个内存空间</strong>。这种内存隔离保证了每个进程的数据安全和保密性，并且允许操作系统有效地管理和保护进城间的内存使用</p>
<h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/461063930">线程同步的几种方式 - TOMOCAT的文章 - 知乎</a></p>
<p>同步指的是按一定的顺序依次执行</p>
<p><strong>互斥锁</strong></p>
<p><strong>读写锁</strong></p>
<p><strong>条件变量</strong></p>
<p><strong>信号量</strong></p>
<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3><p>（1）TCP是传输控制协议，UDP是用户数据报协议；</p>
<p>（2）TCP是面向连接的，可靠的数据传输协议，它要通过三次握手来建立连接，UDP是无连接的，不可靠的数据传输协议，采取尽力而为的策略，不保证接收方一定能收到正确的数据；</p>
<p>（3）TCP面向的是字节流，UDP面向的是数据报；</p>
<p>（4）TCP只支持点对点，UDP支持一对一，一对多和多对多；</p>
<p>（5）TCP有拥塞控制机制，UDP没有。</p>
<h3 id="tcp三次握手的过程"><a href="#tcp三次握手的过程" class="headerlink" title="tcp三次握手的过程"></a>tcp三次握手的过程</h3><p>三次握手的本质是确认通信双方收发数据的能力</p>
<p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</strong></p>
<p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</strong></p>
<p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次<strong>，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</strong></p>
<h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="https为什么更加安全？"><a href="#https为什么更加安全？" class="headerlink" title="https为什么更加安全？"></a>https为什么更加安全？</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理 - 顾伊凡 YGY的文章 - 知乎</a></p>
<p>http是明文传输，对称加密虽然性能好但有密钥泄漏的风险，非对称加密（2组公钥+2私钥双向传输）安全但性能低下，因此考虑用非对称加密来传输对称加密所需的密钥，然后进行对称加密，但是为了防止非对称过程产生的中间人攻击，需要对服务器公钥和服务器身份进行配对的数字认证，然后引入了CA数字签名+数字证书验证的方式！</p>
<p>https基本采用以下流程，即非对称+对称</p>
<ol>
<li><p>某网站拥有用于非对称加密的公钥A、私钥A’。</p>
</li>
<li><p>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</p>
</li>
<li><p>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</p>
</li>
<li><p>服务器拿到后用私钥A’解密得到密钥X。</p>
</li>
<li><p>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</p>
</li>
</ol>
<p>但是可能会遭受中间人攻击，即在传输过程中把明文的公钥替换，那么如何保证浏览器收到的公钥就是服务器的公钥？所以就需要CA证书，CA证书本身也需要加密生成一个签名来保证没有被掉包。</p>
<p>而且也不用每次传输都传输密钥，服务器会为每个浏览器（或<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2243789231%22%7D">客户端</a>软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>（1）应用程序阶段，该阶段主要是在软件层面上执行的一些工作，包括空间加速算法、视锥剔除、碰撞检测、动画物理模拟等。大体逻辑是：执行视锥剔除，查询出可能需要绘制的图元并生成渲染数据，设置渲染状态和绑定各种Shader参数，调用DrawCall，进入到下一个阶段，GPU渲染管线。</p>
<p>（2）几何阶段，包含顶点着色、投影变换、裁剪和屏幕映射阶段。</p>
<p>a. 顶点处理阶段：这个阶段会执行<strong>顶点变换</strong>和<strong>顶点着色</strong>的工作。通过模型矩阵、观察矩阵和投影矩阵(也就是MVP矩阵)计算出顶点在裁剪空间下的位置(clip space)，以便后续阶段转化为标准化设备坐标系(NDC)下的位置。也可能会计算出顶点的法线(需要有法线变换矩阵)和纹理坐标等。同时，在这个阶段也可能会进行顶点的着色计算，如平面着色 (Flat Shading)和高洛德着色 (Gouraud Shading)都是在顶点着色器中进行着色计算。因为这个阶段是完全可控制的，因此执行什么样的操作由程序员来决定。（此外，在顶点处理阶段的末尾，还有一些可选的阶段，包括曲面细分(tessellation)、几何着色(geometry shading)和流输出(stream output)，此处不详细描述）</p>
<p>b. 裁剪阶段：简单来说就是两次裁剪的粒度不同，前者是在物体对象层面的，一般对对象的包围盒做剔除，剔除掉不在视锥体内的物体，NDC裁剪是在三角形层面做的，裁剪掉不在屏幕内的像素。</p>
<p>c. 屏幕映射阶段：主要目的是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p>
<p>（3）光栅化阶段，包含三角形设置和三角形遍历阶段。</p>
<p>a. 三角形设置(图元装配)，计算出三角形的一些重要数据(如三条边的方程、深度值等)以供三角形遍历阶段使用，这些数据同样可用于各种着色数据的插值。</p>
<p>b. 三角形遍历，找到哪些像素被三角形所覆盖，并对这些像素的属性值进行插值。通过判断像素的中心采样点是否被三角形覆盖来决定该像素是否要生成片段。通过三角形三个顶点的属性数据，插值得到每个像素的属性值。此外透视校正插值也在这个阶段执行。</p>
<p>这两个阶段是完全硬件控制的，不可进行任何操作。</p>
<p>（4）<strong>像素处理阶段</strong>，包括像素着色和测试合并。</p>
<p>a. 像素着色，进行光照计算和阴影处理，决定屏幕像素的最终颜色。各种复杂的着色模型、光照计算都是在这个阶段完成。</p>
<p>b. 测试合并，包括各种测试和混合操作，如裁剪测试、透明测试、模板测试、深度测试以及色彩混合等。经过了测试合并阶段，并存到帧缓冲的像素值，才是最终呈现在屏幕上的图像。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>面经：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/417640759">https://zhuanlan.zhihu.com/p/417640759</a></p>
<p>设计模式：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23821422">https://zhuanlan.zhihu.com/p/23821422</a></p>
<p>C++面经：<a target="_blank" rel="noopener" href="https://github.com/huihut/interview?tab=readme-ov-file">https://github.com/huihut/interview?tab=readme-ov-file</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file">https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/" class="category-chain-item">找工作</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面经-计算机基础</div>
      <div>https://rorschachandbat.github.io/找工作/面经-计算机基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>R</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/" title="面经-刷题语法和一些经典算法题思路">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面经-刷题语法和一些经典算法题思路</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%8A%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%97%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="《妙趣横生的游戏制作之旅》读书笔记">
                        <span class="hidden-mobile">《妙趣横生的游戏制作之旅》读书笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment.rorschachblog.cn/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>

 
    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
