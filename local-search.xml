<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/01/02/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/02/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><strong>椭球公式</strong></p><p>x2 &#x2F; a2+y2 &#x2F; b2+z2 &#x2F; c2&#x3D;1。</p><p>当x^2&#x2F;a^2+y^2&#x2F;b^2+z^2&#x2F;c^2&lt;1时　则点(x,y,z)在内部</p><p><strong>反转链表</strong></p><p><strong>删除导数第N个数</strong></p><p>总体很简单，有两个特殊的需要注意，第一是只有一个数或者零个数，第二个是需要删除的是第一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!head || !head -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//判断是否只有一个数或者零个数</span><br>ListNode* first = head;<br>ListNode* second = head;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) second = second-&gt;next;<br><span class="hljs-keyword">if</span>(!second) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">//判断是否要删的是第一个数，因为你要是走完发现走到了尽头就说明倒数第N个数是开头，那么久直接返回head-&gt;next就行，用源代码会有bug</span><br></code></pre></td></tr></table></figure><p><strong>高精度加法</strong></p><p>一个很妙的不用判断进位并且前面0的处理方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n1&gt;=<span class="hljs-number">0</span> || n2&gt;=<span class="hljs-number">0</span> || jw)&#123;<br>    <span class="hljs-type">int</span> x = n1 &gt;= <span class="hljs-number">0</span> ? num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = n2 &gt;= <span class="hljs-number">0</span> ? num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>n变成1</strong></p><p>n如果是奇数就变成n-1或者n+1，如果是偶数就变成n&#x2F;2</p><p>用动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; dp;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) dp[i] = dp[i/<span class="hljs-number">2</span>] +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure><p>static</p><p><a href="https://zhuanlan.zhihu.com/p/37439983">https://zhuanlan.zhihu.com/p/37439983</a></p><p>为什么需要虚继承</p><p><strong>1</strong>、为了解决多继承时的命名冲突和冗余数据问题</p><p>C++ 提出了虚继承，使得在派⽣类中只保留⼀份间接基类的成员。其中多继承（Multiple Inheritance）是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有⽗类的成员。 </p><p><strong>2</strong>、虚继承的⽬的是让某个类做出声明，承诺愿意共享它的基类</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220304124225209.png" alt="image-20220304124225209"></p><h1 id="多益笔试"><a href="#多益笔试" class="headerlink" title="多益笔试"></a>多益笔试</h1><p>数据库保护四种</p><p>安全性控制，完整性控制，并发性控制和数据恢复</p><h1 id="中望龙腾面试"><a href="#中望龙腾面试" class="headerlink" title="中望龙腾面试"></a>中望龙腾面试</h1><p><strong>stl底层实现</strong></p><p>vector：数组</p><p>Dequeue（双端队列）：二维数组</p><p>List：环状双向链表</p><p>set（集合）：平衡的红黑树</p><p>multiset：红黑树</p><p>map：平衡二叉树</p><p><strong>哈希表相关</strong></p><p>哈希函数</p><p>避免冲突</p><p>一个是开放寻址法，一个是拉链法</p><p><strong>指针常量和常量指针</strong></p><p>指针常量就是指针本身是常量，换句话说，就是指针里面所存储的内容（内存地址）是常量，不能改变。但是，内存地址所对应的内容是可以通过指针改变的。</p><p>常量指针就是指向常量的指针，换句话说，就是指针指向的是常量，它指向的内容不能发生改变，不能通过指针来修改它指向的内容。但是，指针自身不是常量，它自身的值可以改变，从而指向另一个常量。</p><p><strong>线程和进程</strong></p><p>cpu分配时间片的最小单位是什么？</p><p>答：线程，进程是资源分配的最小单位，线程是运行调度的最小单位。</p><p>cpu分配时间片的算法</p><p><strong>实现一个SolidWorks包括什么部分？技术栈是怎样？</strong></p><p><strong>c++与c的区别，面向对象体现在哪里</strong></p><h1 id="字节一面"><a href="#字节一面" class="headerlink" title="字节一面"></a>字节一面</h1><ol><li><p>指针和引用区别</p><p>在C和C++中，指针一般指的是某块内存的<strong>地址</strong>，通过这个地址，我们可以寻址到这块内存；而引用是一个变量的<strong>别名</strong>，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明。</p><p><strong>指针可以为空，引用不能为空</strong></p></li><li><p>如何解释函数指针</p><p>让函数数据化的东西，比如说可以优化很多的if-else语句，</p></li><li><p>多态底层实现</p></li><li><p>编译过程，是否生成dll，替换库行不行</p></li><li><p>如何捕捉未定义的内存错误</p></li><li><p>有哪些内存泄露，如何解决</p><p>常见错误：<a href="https://blog.csdn.net/Joker_N/article/details/102688822">https://blog.csdn.net/Joker_N/article/details/102688822</a></p><p>如何解决：<a href="https://blog.csdn.net/daaikuaichuan/article/details/80874436">https://blog.csdn.net/daaikuaichuan/article/details/80874436</a></p><p><strong>申请和释放不一致</strong></p><p>由于 C++ 兼容 C，而 C 与 C++ 的内存申请和释放函数是不同的，因此在 C++ 程序中，就有两套<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22110313333%22%7D">动态内存管理函数</a>。一条不变的规则就是采用 C 方式申请的内存就用 C 方式释放；用 C++ 方式申请的内存，用 C++ 方式释放。也就是用 malloc&#x2F;alloc&#x2F;realloc 方式申请的内存，用 free 释放；用 new 方式申请的内存用 delete 释放。在上述程序中，用 malloc 方式申请了内存却用 delete 来释放，虽然这在很多情况下不会有问题，但这绝对是潜在的问题。</p><p><strong>申请和释放不匹配</strong></p><p>申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存泄露；多释放了也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释放两次。</p><p><strong>释放后仍然读写</strong></p><p>本质上说，系统会在堆上维护一个<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22110313333%22%7D">动态内存链表</a>，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误，上述程序第16行中就在释放后仍然写这块内存。</p></li></ol><p>对策</p><p>1.避免在堆上分配内存</p><p>既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。</p><ol start="7"><li>生产者消费者模型，怎么优化</li><li>进程之间的通信</li></ol><p>1、管道</p><p>2、消息队列</p><p>3、共享内存</p><p>4、信号量</p><p>5、Socket</p><ol start="9"><li><p>进程内存划分</p><p>如上图，<strong>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等</strong>组成。</p><ol><li><p><strong>数据段：</strong>存放程序中已初始化的全局变量和静态变量的一块内存区域。</p></li><li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p></li><li><p><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p></li><li><p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p><p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长。</p><p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p></li><li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间。</p></li></ol></li><li><p>三次握手四次握手过程，timewait作用</p><p><a href="https://zhuanlan.zhihu.com/p/86426969">https://zhuanlan.zhihu.com/p/86426969</a></p><p>为什么握手要三次</p><p><img src="https://pic3.zhimg.com/v2-2a54823bd63e16674874aa46a67c6c72_r.jpg" alt="preview"></p><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常</p><p>为什么挥手要四次</p><p><img src="https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_r.jpg" alt="preview"></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p></li><li><p>一个用户上网的过程</p><p>1.在浏览器的地址栏中输入<strong>URL</strong>。</p><p>2.浏览器检查缓存中的<strong>DNS记录</strong>，以找到<strong>URL对应的IP地址</strong>。</p><ul><li><ul><li>DNS：域名系统。DNS是互联网的一项服务，他作为将<strong>域名和IP地址相互映射的一个分布式数据库</strong>。互联网上的每个URL都有一个分配给它的唯一IP地址，DNS是URL及其IP地址的列表，就像是电话簿是名称及其对应电话号码的列表一样。为了查找DNS记录，浏览器会检查四个缓存。</li><li>第一，检查<strong>浏览器缓存</strong>。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。</li><li>第二，浏览器检查<strong>操作系统缓存</strong>。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。</li><li>第三，检查<strong>路由器缓存</strong>。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。</li><li>第四，检查<strong>ISP缓存</strong>。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。</li></ul></li></ul><p>3.如果请求的URL不在缓存中，ISP的DNS服务器将发起<strong>DNS查询</strong>以查找托管URL的服务器的IP地址。</p><ul><li><ul><li>DNS查询的目的是在Internet上搜索多个DNS服务器，直到找到网站正确的IP地址。这种类型的搜索称为递归搜索，因为搜索将重复从DNS服务器到DNS服务器继续进行，知道找到我们需要的IP地址会返回错误响应表示无法找到它。</li><li>我们将<strong>ISP的DNS服务器</strong>称为<strong>DNS递归器</strong>，其职责是通过向Internet上的其他DNS服务器咨询答案来找到预期域名的正确IP地址，其他DNS服务器被称为名称服务器，因为它们根据网站域名的域架构执行<strong>DNS搜索</strong>。</li></ul></li><li><p>中间还有一段</p></li><li><p><strong>第五步</strong>，回应报文经过封装，在网络中进行转发（利用各种<a href="https://www.zhihu.com/search?q=%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">路由协议</a>如OSPF在网络中进行路由转发，利用ARP协议在二层设备上进行数据转发），最后发送到请求域名解析的主机。</p></li><li><p>主机分析数据包，知道IP地址后，写入DNS缓存表，浏览器接着给这个IP的服务器发送HTTP请求。</p></li><li><p><strong>第六步</strong>，已经知道目标IP地址了，但是为了将消息传到服务器上要经过OSPF<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">动态路由算法</a>去进行路由转发，然后IP地址使用的是IP协议，整个发送过程中只涉及出发地和目的地2个IP地址，而<a href="https://www.zhihu.com/search?q=ARP%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">ARP协议</a>使用的是MAC地址，整个发送过程中涉及到每一个节点的MAC地址 。<br>4.浏览器发起与服务器的<strong>TCP连接</strong>。</p></li><li><ul><li>一旦浏览器接收到正确的IP地址，他就会与匹配IP地址的服务器建立连接以传输信息，浏览器使用互联网协议来建立这样的连接。可以使用多种不同的Internet协议，但<strong>TCP</strong>是用于多种HTTP请求最常用协议。</li><li>在客户端和服务器之间传输数据报，建立TCP连接很重要，此连接时使用<strong>TCP&#x2F;IP三次握手</strong>来完成，其中客户端和服务器交换SYN(同步)和ACK(确认)消息以建立连接。</li><li>三次握手</li></ul></li></ul><ol><li>客户端通过Internet向服务器发送SYN<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%8C%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">数据包</a>，询问它是否已打开新连接。</li><li>如果服务器有可以接收和启动新连接的开发端口，它将使用SYN&#x2F;ACK数据包的ACKnowledgment进行响应。</li><li><a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">客户端</a>将收到来自服务器的SYN&#x2F;ACK数据包，并通过发送ACK数据包进行确认。然后建立TCP连接进行数据传输！</li></ol></li></ol><p>5.<a href="https://www.zhihu.com/search?q=%E6%B5%8F%E8%A7%88%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">浏览器</a>向网络服务器发送<strong>HTTP请求</strong>。</p><ul><li><ul><li>一旦建立了TCP连接，就可以开始传输数据了，浏览器将发送一个GET请求，请求获取URL网页，如果您正在输入或提交表单，则可能是POST请求。</li></ul></li></ul><p>​    </p><p>6.服务器<strong>处理请求</strong>并<strong>发回响应</strong>。</p><ul><li><ul><li>服务器包含一个web服务器（Apache、IIS），它接收来自浏览器请求并将其传递给请求处理程序以读取和生成响应。请求处理程序是一个程序，它读取请求、请求头和cookie，以检查请求的内容并在需要的时候更新服务器上的信息，然后它将以特定格式（JSON、XML、HTML）组装响应。</li></ul></li></ul><p>​    </p><p>7.服务器发出<strong>HTTP响应</strong>。</p><ul><li><ul><li><p>服务器响应包含你<strong>请求的网页</strong>以及<strong>状态码</strong>、<strong>压缩类型（Content-Encoding）</strong>、<strong>如何缓存页面（Cache-Control）</strong>、要<strong>设置的任何cookie</strong>。<strong>隐私信息</strong>等。</p><ul><li>状态码：</li></ul><ol><li><strong>1xx</strong>仅表示信息性消息。</li><li><strong>2xx</strong>表示某种成功。</li><li><strong>3xx</strong>将客户端重定向到另一个URL。</li><li><strong>4xx</strong>表示客户端错误。</li><li><strong>5xx</strong>表示服务器端出错</li></ol></li></ul></li></ul><p>​    </p><p>8.浏览器显示<strong>HTML内容</strong>（对应HTML响应，这是最常见的）。</p><ul><li><ul><li>浏览器分阶段显示HTML内容，首先，它将呈现HTML骨架，然后它会检查HTML标签并发送GET请求来获取网页上的其他元素，例如图像、CSS样式表、JavaScript文件等。这些静态文件由浏览器缓存，因此不必获取它们在下次访问页面的时候</li></ul></li></ul><ol start="12"><li>单链表如何判断有没有环，数学依据</li></ol><p>快慢指针</p><ol start="13"><li>两个栈实现一个队列</li></ol><p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 }pop 和 peek 操作。</p><p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><ol start="14"><li>设计模式相关，读源码的时候有没有注意他的设计模式</li></ol><p><a href="https://zhuanlan.zhihu.com/p/431714886">https://zhuanlan.zhihu.com/p/431714886</a></p><h1 id="乐易公司面试记录"><a href="#乐易公司面试记录" class="headerlink" title="乐易公司面试记录"></a>乐易公司面试记录</h1><ol><li><p>vector容量上限，扩容策略</p><p>动态扩容，每次都增加到当前的2倍，然后如果超过max</p></li><li><p>map一一对应可以是类吗，类的话怎么实现一一对应</p><p>可以，因为map的底层实现是红黑树，只要保证你定义的类有比较符号即可</p></li><li><p>多态</p></li><li><p>双端队列</p><p>元素可以从队头出队和入队，也可以从队尾出队和入队</p></li><li><p>手写二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; ary, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = ary.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> m = ary[mid];<br>        <span class="hljs-keyword">if</span>(m==target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m&lt;target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>手写快排</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span><span class="hljs-comment">//应用二分思想</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mid=a[(l+r)/<span class="hljs-number">2</span>];<span class="hljs-comment">//中间数</span><br>    <span class="hljs-type">int</span> i=l,j=r;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">while</span>(a[i]&lt;mid) i++;<span class="hljs-comment">//查找左半部分比中间数大的数</span><br>        <span class="hljs-keyword">while</span>(a[j]&gt;mid) j--;<span class="hljs-comment">//查找右半部分比中间数小的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;=j)<span class="hljs-comment">//如果有一组不满足排序条件（左小右大）的数</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//交换</span><br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(i&lt;=j);<span class="hljs-comment">//这里注意要有=</span><br>    <span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-built_in">qsort</span>(l,j);<span class="hljs-comment">//递归搜索左半部分</span><br>    <span class="hljs-keyword">if</span>(i&lt;r) <span class="hljs-built_in">qsort</span>(i,r);<span class="hljs-comment">//递归搜索右半部分</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用和指针（才知道引用直接传名字就可以，然后不用传指针）</p></li><li><p>进程间通信，（注意和进程中通信区别，并且问你有没有实践过）</p></li><li><p>网络编程</p></li><li><p>三次握手</p></li><li><p>数据库，非关系型和关系型，MongoDB和MySQL有啥区别，为啥选MongoDB</p></li></ol><h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><p>一面</p><p>寻找第k大</p><h1 id="vivo笔试"><a href="#vivo笔试" class="headerlink" title="vivo笔试"></a>vivo笔试</h1><p>1.找钱的方案数变种，拿手机，每次可以拿1、2、3、4，问有几种拿法，爬楼梯变种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">作者：拼子<br>链接：https:<span class="hljs-comment">//www.nowcoder.com/discuss/856152?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=DCFD5C44A0863546D8B2F332A84B6BCB-1646712477134</span><br>来源：牛客网<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-keyword">while</span> (in.hasNext()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">20000</span>];<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>            dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br>            dp[<span class="hljs-number">4</span>] = <span class="hljs-number">8</span>;<br>            <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123;<br>                System.out.println(dp[n]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; i &lt;= n; i++) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">3</span>] + dp[i - <span class="hljs-number">4</span>];<br>                &#125;<br>                System.out.println(dp[n]);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2.滑动窗口，LeetCode原题：<a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/</a></p><p>3.多重背包+最小值，没写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">作者：衣冠胜雪<br>链接：https:<span class="hljs-comment">//www.nowcoder.com/discuss/856152?type=all&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_all_nctrack&amp;gio_id=DCFD5C44A0863546D8B2F332A84B6BCB-1646712477134</span><br>来源：牛客网<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCost</span><span class="hljs-params">(<span class="hljs-type">int</span> rooms, <span class="hljs-type">int</span> staffNum, <span class="hljs-type">int</span>[] count, <span class="hljs-type">int</span>[] roomCapacity, <span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-comment">//rooms房间种类，staffNum总员工数，count 是每种房间的数量，roomCapacity是每种房间的承载人数，cost是每种房间的花费</span><br>        <span class="hljs-comment">//dp[i][j]表示前i种房间住j个staff的最小花费</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[rooms][staffNum+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= staffNum; i++) &#123; <span class="hljs-comment">// 设置只住第一种旅馆的花费</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">roomNum</span> <span class="hljs-operator">=</span> Math.min(i%roomCapacity[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>?i/roomCapacity[<span class="hljs-number">0</span>]:i/roomCapacity[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,count[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span>(roomNum*roomCapacity[<span class="hljs-number">0</span>]&gt;=i) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = roomNum * cost[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[<span class="hljs-number">0</span>][i]=Integer.MAX_VALUE/<span class="hljs-number">2</span>;<span class="hljs-comment">//超出第1种房间承受范围的员工数设为最大值的一半，防止后面加法越界</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; rooms; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= staffNum; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevMin</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j]; <span class="hljs-comment">//求出0～i-1种房间中住j个人的最小花费</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">curMin</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<span class="hljs-comment">//设置当前花费为最大</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= count[i]; k++) &#123;<span class="hljs-comment">//遍历当前房间承受最大范围，求出该范围内花费最小值</span><br>                    <span class="hljs-keyword">if</span>(j&lt;k*roomCapacity[i])&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    curMin = Math.min(curMin,dp[i-<span class="hljs-number">1</span>][j-k*roomCapacity[i]]+k*cost[i]);<br>                &#125;<br>                dp[i][j]=Math.min(prevMin,curMin);<span class="hljs-comment">//和i-1种房间最小值比较，较小的则为i种房间j个员工的最小值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[rooms-<span class="hljs-number">1</span>][staffNum];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="完美世界"><a href="#完美世界" class="headerlink" title="完美世界"></a>完美世界</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li><p>为什么选择客户端</p></li><li><p>对游戏引擎了解吗？</p></li><li><p>玩过什么游戏</p></li><li><p>说一下多态</p></li><li><p>说一下虚函数表保存在哪里</p><p>当生成类对象的时候，编译器会自动的将类对象的前四个字节设置为虚表的地址，而这四个字节就可以看作是一个指向虚函数表的指针。虚函数表可以看做一个函数指针数组。</p></li><li><p>构造函数初始化链表和直接在构造函数里面初始化有什么区别？</p><p>一句话，在进入派生类的构造函数内的时候，基类的部分已经构造完成了，你没有使用成员初始化列表初始化基类，因此基类采用的是基类自己默认的构造函数初始化的，然后进入构造函数后，你又使用基类的构造函数构造一次，说明基类部分构造了两次，肯定报错。</p><p>在构造函数初始化赋值效率低</p><p>常数据成员的初始化必须在初始化列表里完成</p></li><li><p>设计模式了解吗？平时用过吗？</p><p>1.单一职责。每个类只实现一个功能，而不要融合太多功能在一个类里</p><p>2.开放封闭原则。对增加开放，对修改关闭（增加功能可以）<br>3.依赖倒转原则。依赖于抽象（接口或父类），而不依赖于实现（子类）<br>4.迪米特法则（模块A只接触和自己有直接关系的模块B，如果模块B和模块C有直接关系， 而 模块A和模块C，没有，则A调用C ,要通过B,而不是直接调用）</p><p>危险的事情：</p><p>  1.复制代码是危险的。如果有两段相同的代码，几乎可以说一定是有问题的，因为每次改动，要维护两段代码<br>  2.尽量减少IO操作，如操作数据库，网络发送，甚至printf ，这些操作比直接操作内存，慢很多倍、<br>  3.修改Bug时，一定要从最简单的基本的地方开始检查，不要检查到最底层没问题，发现是传入的某个参数是错的。先不要怀疑系统的部分。<br>   4.设计架构，同时了解细节<br>   5.有些Bug,调起来可能费时费力，甚至花个二三天，其实当时写的时候，只要稍微注意，就可以轻松避免。避免Bug的代价与找出并修改Bug的代价，实在是差太多了。<br>6.把一段长代码，分成很多小函数，便于维护，连自己都不愿看，不愿改的代码，百分百有问题。<br>7.写程序时，先把流程搞清楚。把各个流程用的函数写清楚，函数可以留空，这样编程就变成了填空题。<br>做新功能时，把数据结构的设计，放在较重要的位置</p></li><li><p>数据结构知道什么？平时项目用过什么？（说了一个多叉树，然后说了一下和红黑树和哈希表的优劣对比）</p></li><li><p>构建堆的算法。时间复杂度是多少</p></li><li><p>如何不排序找中位数，时间复杂度是多少？</p></li></ol><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>主要根据你的简历问了很多，所以要细心准备简历上每一个东西，包括但不限于：</p><ol><li>项目实现细节，如何改进？</li><li>项目用了什么数据结构，用了什么设计模式？</li><li>你看的书哪些印象最深刻（回去整理一下笔记，争取有话可讲）</li><li>你是机器人专业，为啥想做游戏？</li><li>你课外有学一些游戏相关的东西吗？（这个也要去准备一下）</li></ol><h1 id="智加"><a href="#智加" class="headerlink" title="智加"></a>智加</h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ol><li><p>进程间通信</p></li><li><p>signal kill</p></li><li><p>程序内存结构</p></li><li><p>static的作用</p></li><li><p>单例模式怎么实现？构造函数怎么写？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++">作者：Zopen<br>链接：https:<span class="hljs-comment">//zhuanlan.zhihu.com/p/62014096</span><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::once_flag flag;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::<span class="hljs-built_in">call_once</span>(flag, []() &#123;instance_.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>()); &#125;);<br><span class="hljs-keyword">return</span> *instance_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> std::unique_ptr&lt;Singleton&gt; instance_;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp; other) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br>std::unique_ptr&lt;Singleton&gt; Singleton::instance_;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_onceflag</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Singleton&amp; s = Singleton::<span class="hljs-built_in">getInstance</span>();<br>cout &lt;&lt; &amp;s &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(do_onceflag)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(do_onceflag)</span></span>;<br><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>寻找共同最近祖先</p></li><li><p>多态了解吗？</p></li><li><p>知道右值吗？</p><p>可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p><p>右值就是拷贝了之后删了原来的，左值就是直接深拷贝？</p><p>大象的例子可以改成：大象本来放到A冰箱的， 后来想移动到B冰箱，移动语义的做法就是把冰箱上的A标志改成B标志， 这样就相当于放到了B冰箱，也不用重新去打造一个新的B冰箱了</p></li><li><p>最大连续子序列和</p></li></ol><h1 id="米哈游"><a href="#米哈游" class="headerlink" title="米哈游"></a>米哈游</h1><h2 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h2><ol><li>版本控制知道吗？git的原理？是分布式还是中心式？</li><li>bash用过吗？C#用过吗</li><li>对象的地址，new了之后在哪里？堆区和栈区的区别？</li><li>指针和引用</li><li>vector扩容机制</li><li>map？</li><li>哈希函数</li><li>迭代器指导吗？</li><li>struct和class的区别。C#里面struct可以继承吗？</li><li>C#的内存回收机制？原理？</li><li>bash管道怎么写？</li><li>手写一个排序算法，什么都可以，然后就默了一个快排。</li></ol><h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><ol><li>了解CICD吗？</li><li>了解自动化管线吗？</li><li>指针有什么用？为什么c++会要有这种东西啊</li><li>malloc和new和区别？他们调用incline</li><li>自己写一个动态数组（然后接下来的问题</li><li>解释</li></ol><h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><ol><li><p>问了项目，什么比较难，问了一下做的微信小程序，要怎么改进？</p></li><li><p>快排复杂度，比快排好的有什么</p></li><li><p>B树和B+树对比，应用场景？</p></li><li><p>平衡二叉树定义？插入了怎么维护性质</p></li><li><p>动态规划是什么？举个例子</p></li><li><p>深拷贝浅拷贝区别？有什么要注意的地方</p></li><li><p>虚函数有什么用</p></li><li><p>C++11特性知道吗？智能指针知道吗？</p></li><li><p>vector和list的扩容</p></li><li><p>任务调度算法？猜一下windows是用了什么</p></li><li><p>如何避免死锁？</p></li><li><p>如何实现同步？</p></li><li><p>HTTP和TCP的区别</p></li><li><p>HTTPS和HTTP的区别</p></li><li><p>get和pos区别</p></li><li><p>外件和组件</p></li><li><p>数据库相关：事物知道吗？索引知道吗</p></li></ol><p>笔试题三道：</p><p>1.设定如下的对应关系( A&#x3D;0,B&#x3D;1,C&#x3D;2,…,Z&#x3D;25,AA&#x3D;26,AB&#x3D;27,…,AAA&#x3D;xxx,… )，编写一个转换函数，根据上面的规则把一个字符串转换为数字</p><p>int StrToInt( const char * str ){</p><p> int length &#x3D; str.size();</p><p>int sum &#x3D; 0;</p><p>for(int i &#x3D; 0;i&lt;length);i++){</p><p>int temp &#x3D; str[i] - ‘A’;</p><p>if (temp&gt;&#x3D;26 || temp&lt;0){</p><p>return -1;</p><p>}</p><p>sum &#x3D; 26 * sum + temp; </p><p>}</p><p>return sum;</p><p>}</p><p>2.从有序链表中去除重复的元素</p><p>(1, 1, 3, 3, 3, 5, 5, 5, 9, 9, 9, 9) -&gt; (1, 3, 5, 9).</p><p>struct LinkNode {</p><p>int val;</p><p>struct LinkNode * next;</p><p>};</p><p>void remove( LinkNode * head ){</p><p>if (head &#x3D;&#x3D; nullptr) return head;</p><p>LinkNode* L &#x3D; head;</p><p>while(L-&gt;next){</p><p>if(L-&gt;val &#x3D;&#x3D; l-&gt;next-&gt;val){</p><p>L-&gt;next &#x3D; L-&gt;next-&gt;next;</p><p>}</p><p>}</p><p>return head;</p><p>}</p><p>\3. 费南德的金币游戏：费南德和你抢到20个银币和一个金币，你们的分赃规则：俩人轮流拿，每次至少拿一个最多不能超过四个(可以等于四个)，金币和银币不能混合拿，金币最后拿！如果由你先拿，怎么才可以拿到那个金币？(写拿的方法，不是写代码)</p><p>拿四个稳赢，接下来他拿i个，你就拿5-i，这样一定会剩一个给他拿，这样我们就赢了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/01/02/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8D%E4%BC%9A%E7%9A%84/"/>
    <url>/2023/01/02/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8D%E4%BC%9A%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><strong>椭球公式</strong></p><p>x2 &#x2F; a2+y2 &#x2F; b2+z2 &#x2F; c2&#x3D;1。</p><p>当x^2&#x2F;a^2+y^2&#x2F;b^2+z^2&#x2F;c^2&lt;1时　则点(x,y,z)在内部</p><p><strong>反转链表</strong></p><p><strong>删除导数第N个数</strong></p><p>总体很简单，有两个特殊的需要注意，第一是只有一个数或者零个数，第二个是需要删除的是第一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!head || !head -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//判断是否只有一个数或者零个数</span><br>ListNode* first = head;<br>ListNode* second = head;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) second = second-&gt;next;<br><span class="hljs-keyword">if</span>(!second) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">//判断是否要删的是第一个数，因为你要是走完发现走到了尽头就说明倒数第N个数是开头，那么久直接返回head-&gt;next就行，用源代码会有bug</span><br></code></pre></td></tr></table></figure><p><strong>高精度加法</strong></p><p>一个很妙的不用判断进位并且前面0的处理方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n1&gt;=<span class="hljs-number">0</span> || n2&gt;=<span class="hljs-number">0</span> || jw)&#123;<br>    <span class="hljs-type">int</span> x = n1 &gt;= <span class="hljs-number">0</span> ? num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = n2 &gt;= <span class="hljs-number">0</span> ? num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p><strong>n变成1</strong></p><p>n如果是奇数就变成n-1或者n+1，如果是偶数就变成n&#x2F;2</p><p>用动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; dp;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) dp[i] = dp[i/<span class="hljs-number">2</span>] +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure><p>static</p><p><a href="https://zhuanlan.zhihu.com/p/37439983">https://zhuanlan.zhihu.com/p/37439983</a></p><p>为什么需要虚继承</p><p><strong>1</strong>、为了解决多继承时的命名冲突和冗余数据问题</p><p>C++ 提出了虚继承，使得在派⽣类中只保留⼀份间接基类的成员。其中多继承（Multiple Inheritance）是指从多个直接基类中产⽣派⽣类的能⼒，多继承的派⽣类继承了所有⽗类的成员。 </p><p><strong>2</strong>、虚继承的⽬的是让某个类做出声明，承诺愿意共享它的基类</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220304124225209.png" alt="image-20220304124225209"></p><h1 id="多益笔试"><a href="#多益笔试" class="headerlink" title="多益笔试"></a>多益笔试</h1><p>数据库保护四种</p><p>安全性控制，完整性控制，并发性控制和数据恢复</p><h1 id="中望龙腾面试"><a href="#中望龙腾面试" class="headerlink" title="中望龙腾面试"></a>中望龙腾面试</h1><p><strong>stl底层实现</strong></p><p>vector：数组</p><p>Dequeue（双端队列）：二维数组</p><p>List：环状双向链表</p><p>set（集合）：平衡的红黑树</p><p>multiset：红黑树</p><p>map：平衡二叉树</p><p><strong>哈希表相关</strong></p><p>哈希函数</p><p>避免冲突</p><p>一个是开放寻址法，一个是拉链法</p><p><strong>指针常量和常量指针</strong></p><p>指针常量就是指针本身是常量，换句话说，就是指针里面所存储的内容（内存地址）是常量，不能改变。但是，内存地址所对应的内容是可以通过指针改变的。</p><p>常量指针就是指向常量的指针，换句话说，就是指针指向的是常量，它指向的内容不能发生改变，不能通过指针来修改它指向的内容。但是，指针自身不是常量，它自身的值可以改变，从而指向另一个常量。</p><p><strong>线程和进程</strong></p><p>cpu分配时间片的最小单位是什么？</p><p>答：线程，进程是资源分配的最小单位，线程是运行调度的最小单位。</p><p>cpu分配时间片的算法</p><p><strong>技术栈</strong></p><p><strong>c++与c的区别，面向对象体现在哪里</strong></p><h1 id="字节一面"><a href="#字节一面" class="headerlink" title="字节一面"></a>字节一面</h1><ol><li><p>指针和引用区别</p><p>在C和C++中，指针一般指的是某块内存的<strong>地址</strong>，通过这个地址，我们可以寻址到这块内存；而引用是一个变量的<strong>别名</strong>，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明。</p><p><strong>指针可以为空，引用不能为空</strong></p></li><li><p>如何解释函数指针</p><p>让函数数据化的东西，比如说可以优化很多的if-else语句，</p></li><li><p>多态底层实现</p></li><li><p>编译过程，是否生成dll，替换库行不行</p></li><li><p>如何捕捉未定义的内存错误</p></li><li><p>有哪些内存泄露，如何解决</p><p>常见错误：<a href="https://blog.csdn.net/Joker_N/article/details/102688822">https://blog.csdn.net/Joker_N/article/details/102688822</a></p><p>如何解决：<a href="https://blog.csdn.net/daaikuaichuan/article/details/80874436">https://blog.csdn.net/daaikuaichuan/article/details/80874436</a></p><p><strong>申请和释放不一致</strong></p><p>由于 C++ 兼容 C，而 C 与 C++ 的内存申请和释放函数是不同的，因此在 C++ 程序中，就有两套<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22110313333%22%7D">动态内存管理函数</a>。一条不变的规则就是采用 C 方式申请的内存就用 C 方式释放；用 C++ 方式申请的内存，用 C++ 方式释放。也就是用 malloc&#x2F;alloc&#x2F;realloc 方式申请的内存，用 free 释放；用 new 方式申请的内存用 delete 释放。在上述程序中，用 malloc 方式申请了内存却用 delete 来释放，虽然这在很多情况下不会有问题，但这绝对是潜在的问题。</p><p><strong>申请和释放不匹配</strong></p><p>申请了多少内存，在使用完成后就要释放多少。如果没有释放，或者少释放了就是内存泄露；多释放了也会产生问题。上述程序中，指针p和pt指向的是同一块内存，却被先后释放两次。</p><p><strong>释放后仍然读写</strong></p><p>本质上说，系统会在堆上维护一个<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22110313333%22%7D">动态内存链表</a>，如果被释放，就意味着该块内存可以继续被分配给其他部分，如果内存被释放后再访问，就可能覆盖其他部分的信息，这是一种严重的错误，上述程序第16行中就在释放后仍然写这块内存。</p></li></ol><p>对策</p><p>1.避免在堆上分配内存</p><p>既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。</p><ol start="7"><li>生产者消费者模型，怎么优化</li><li>进程之间的通信</li></ol><p>1、管道</p><p>2、消息队列</p><p>3、共享内存</p><p>4、信号量</p><p>5、Socket</p><ol start="9"><li><p>进程内存划分</p><p>如上图，<strong>从低地址到高地址，一个程序由代码段、数据段、BSS段、堆、共享区、栈等</strong>组成。</p><ol><li><p><strong>数据段：</strong>存放程序中已初始化的全局变量和静态变量的一块内存区域。</p></li><li><p><strong>代码段：</strong>存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。</p></li><li><p><strong>BSS</strong> 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。</p></li><li><p>可执行程序在运行时又会多出两个区域：堆区和栈区。</p><p><strong>堆区：</strong>动态申请内存用。堆从低地址向高地址增长。</p><p><strong>栈区：</strong>存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。</p></li><li><p>最后还有一个<strong>共享区</strong>，位于堆和栈之间。</p></li></ol></li><li><p>三次握手四次握手过程，timewait作用</p><p><a href="https://zhuanlan.zhihu.com/p/86426969">https://zhuanlan.zhihu.com/p/86426969</a></p><p>为什么握手要三次</p><p><img src="https://pic3.zhimg.com/v2-2a54823bd63e16674874aa46a67c6c72_r.jpg" alt="preview"></p><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p><p>第一次握手：客户端发送网络包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。</p><p>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。</p><p>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常</p><p>为什么挥手要四次</p><p><img src="https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_r.jpg" alt="preview"></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p></li><li><p>一个用户上网的过程</p><p>1.在浏览器的地址栏中输入<strong>URL</strong>。</p><p>2.浏览器检查缓存中的<strong>DNS记录</strong>，以找到<strong>URL对应的IP地址</strong>。</p><ul><li><ul><li>DNS：域名系统。DNS是互联网的一项服务，他作为将<strong>域名和IP地址相互映射的一个分布式数据库</strong>。互联网上的每个URL都有一个分配给它的唯一IP地址，DNS是URL及其IP地址的列表，就像是电话簿是名称及其对应电话号码的列表一样。为了查找DNS记录，浏览器会检查四个缓存。</li><li>第一，检查<strong>浏览器缓存</strong>。浏览器缓存会为您之前访问过的网站维护一个固定期限的DNS记录存储库，因此，它是运行DNS查询的第一个位置。</li><li>第二，浏览器检查<strong>操作系统缓存</strong>。如果它不在浏览器缓存中，浏览器将对您的底层计算机操作系统进行系统调用以获取记录，因为操作系统也会维护DNS记录的缓存。</li><li>第三，检查<strong>路由器缓存</strong>。如果它不在你的计算机上，浏览器将与维护其自己的DNS记录缓存的路由器进行通信。</li><li>第四，检查<strong>ISP缓存</strong>。如果所有步骤都找不到DNS记录，浏览器将转到ISP，ISP维护着自己的DNS服务器，其中包括一个DNS记录缓存，浏览器将检查这些缓存，以确保找到你请求的URL。</li></ul></li></ul><p>3.如果请求的URL不在缓存中，ISP的DNS服务器将发起<strong>DNS查询</strong>以查找托管URL的服务器的IP地址。</p><ul><li><ul><li>DNS查询的目的是在Internet上搜索多个DNS服务器，直到找到网站正确的IP地址。这种类型的搜索称为递归搜索，因为搜索将重复从DNS服务器到DNS服务器继续进行，知道找到我们需要的IP地址会返回错误响应表示无法找到它。</li><li>我们将<strong>ISP的DNS服务器</strong>称为<strong>DNS递归器</strong>，其职责是通过向Internet上的其他DNS服务器咨询答案来找到预期域名的正确IP地址，其他DNS服务器被称为名称服务器，因为它们根据网站域名的域架构执行<strong>DNS搜索</strong>。</li></ul></li><li><p>中间还有一段</p></li><li><p><strong>第五步</strong>，回应报文经过封装，在网络中进行转发（利用各种<a href="https://www.zhihu.com/search?q=%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">路由协议</a>如OSPF在网络中进行路由转发，利用ARP协议在二层设备上进行数据转发），最后发送到请求域名解析的主机。</p></li><li><p>主机分析数据包，知道IP地址后，写入DNS缓存表，浏览器接着给这个IP的服务器发送HTTP请求。</p></li><li><p><strong>第六步</strong>，已经知道目标IP地址了，但是为了将消息传到服务器上要经过OSPF<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">动态路由算法</a>去进行路由转发，然后IP地址使用的是IP协议，整个发送过程中只涉及出发地和目的地2个IP地址，而<a href="https://www.zhihu.com/search?q=ARP%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22371620790%22%7D">ARP协议</a>使用的是MAC地址，整个发送过程中涉及到每一个节点的MAC地址 。<br>4.浏览器发起与服务器的<strong>TCP连接</strong>。</p></li><li><ul><li>一旦浏览器接收到正确的IP地址，他就会与匹配IP地址的服务器建立连接以传输信息，浏览器使用互联网协议来建立这样的连接。可以使用多种不同的Internet协议，但<strong>TCP</strong>是用于多种HTTP请求最常用协议。</li><li>在客户端和服务器之间传输数据报，建立TCP连接很重要，此连接时使用<strong>TCP&#x2F;IP三次握手</strong>来完成，其中客户端和服务器交换SYN(同步)和ACK(确认)消息以建立连接。</li><li>三次握手</li></ul></li></ul><ol><li>客户端通过Internet向服务器发送SYN<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%8C%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">数据包</a>，询问它是否已打开新连接。</li><li>如果服务器有可以接收和启动新连接的开发端口，它将使用SYN&#x2F;ACK数据包的ACKnowledgment进行响应。</li><li><a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">客户端</a>将收到来自服务器的SYN&#x2F;ACK数据包，并通过发送ACK数据包进行确认。然后建立TCP连接进行数据传输！</li></ol></li></ol><p>5.<a href="https://www.zhihu.com/search?q=%E6%B5%8F%E8%A7%88%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22404766497%22%7D">浏览器</a>向网络服务器发送<strong>HTTP请求</strong>。</p><ul><li><ul><li>一旦建立了TCP连接，就可以开始传输数据了，浏览器将发送一个GET请求，请求获取URL网页，如果您正在输入或提交表单，则可能是POST请求。</li></ul></li></ul><p>​    </p><p>6.服务器<strong>处理请求</strong>并<strong>发回响应</strong>。</p><ul><li><ul><li>服务器包含一个web服务器（Apache、IIS），它接收来自浏览器请求并将其传递给请求处理程序以读取和生成响应。请求处理程序是一个程序，它读取请求、请求头和cookie，以检查请求的内容并在需要的时候更新服务器上的信息，然后它将以特定格式（JSON、XML、HTML）组装响应。</li></ul></li></ul><p>​    </p><p>7.服务器发出<strong>HTTP响应</strong>。</p><ul><li><ul><li><p>服务器响应包含你<strong>请求的网页</strong>以及<strong>状态码</strong>、<strong>压缩类型（Content-Encoding）</strong>、<strong>如何缓存页面（Cache-Control）</strong>、要<strong>设置的任何cookie</strong>。<strong>隐私信息</strong>等。</p><ul><li>状态码：</li></ul><ol><li><strong>1xx</strong>仅表示信息性消息。</li><li><strong>2xx</strong>表示某种成功。</li><li><strong>3xx</strong>将客户端重定向到另一个URL。</li><li><strong>4xx</strong>表示客户端错误。</li><li><strong>5xx</strong>表示服务器端出错</li></ol></li></ul></li></ul><p>​    </p><p>8.浏览器显示<strong>HTML内容</strong>（对应HTML响应，这是最常见的）。</p><ul><li><ul><li>浏览器分阶段显示HTML内容，首先，它将呈现HTML骨架，然后它会检查HTML标签并发送GET请求来获取网页上的其他元素，例如图像、CSS样式表、JavaScript文件等。这些静态文件由浏览器缓存，因此不必获取它们在下次访问页面的时候</li></ul></li></ul><ol start="12"><li>单链表如何判断有没有环，数学依据</li></ol><p>快慢指针</p><ol start="13"><li>两个栈实现一个队列</li></ol><p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 }pop 和 peek 操作。</p><p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><ol start="14"><li>设计模式相关，读源码的时候有没有注意他的设计模式</li></ol><p><a href="https://zhuanlan.zhihu.com/p/431714886">https://zhuanlan.zhihu.com/p/431714886</a></p><h1 id="乐易公司面试记录"><a href="#乐易公司面试记录" class="headerlink" title="乐易公司面试记录"></a>乐易公司面试记录</h1><ol><li><p>vector容量上限，扩容策略</p><p>动态扩容，每次都增加到当前的2倍，然后如果超过max</p></li><li><p>map一一对应可以是类吗，类的话怎么实现一一对应</p><p>可以，因为map的底层实现是红黑树，只要保证你定义的类有比较符号即可</p></li><li><p>多态</p></li><li><p>双端队列</p><p>元素可以从队头出队和入队，也可以从队尾出队和入队</p></li><li><p>手写二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; ary, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = ary.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> m = ary[mid];<br>        <span class="hljs-keyword">if</span>(m==target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m&lt;target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>手写快排</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span><span class="hljs-comment">//应用二分思想</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mid=a[(l+r)/<span class="hljs-number">2</span>];<span class="hljs-comment">//中间数</span><br>    <span class="hljs-type">int</span> i=l,j=r;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">while</span>(a[i]&lt;mid) i++;<span class="hljs-comment">//查找左半部分比中间数大的数</span><br>        <span class="hljs-keyword">while</span>(a[j]&gt;mid) j--;<span class="hljs-comment">//查找右半部分比中间数小的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;=j)<span class="hljs-comment">//如果有一组不满足排序条件（左小右大）的数</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//交换</span><br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(i&lt;=j);<span class="hljs-comment">//这里注意要有=</span><br>    <span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-built_in">qsort</span>(l,j);<span class="hljs-comment">//递归搜索左半部分</span><br>    <span class="hljs-keyword">if</span>(i&lt;r) <span class="hljs-built_in">qsort</span>(i,r);<span class="hljs-comment">//递归搜索右半部分</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用和指针（才知道引用直接传名字就可以，然后不用传指针）</p></li><li><p>进程间通信，（注意和进程中通信区别，并且问你有没有实践过）</p></li><li><p>网络编程</p></li><li><p>三次握手</p></li><li><p>数据库，非关系型和关系型，MongoDB和MySQL有啥区别，为啥选MongoDB</p></li></ol><h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><p>一面</p><p>寻找第k大</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo框架快速从0到1搭建个人博客 -- 文章发布</title>
    <link href="/2022/08/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/08/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="一个文件从源码到可执行文件所经历的过程"><a href="#一个文件从源码到可执行文件所经历的过程" class="headerlink" title="一个文件从源码到可执行文件所经历的过程"></a>一个文件从源码到可执行文件所经历的过程</h3><p>1.预处理，产生.ii文件<br>2.编译，产生汇编文件(.s文件)<br>3.汇编，产生目标文件(.o或.obj文件)<br>4.链接,产生可执行文件(.out或.exe文件)</p><h3 id="struct和class区别？"><a href="#struct和class区别？" class="headerlink" title="struct和class区别？"></a>struct和class区别？</h3><p>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。</p><p>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</p><p>class 可以使用模板，而 struct 不能。</p><h3 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h3><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220309220924444.png" alt="image-20220309220924444"></p><h3 id="incline"><a href="#incline" class="headerlink" title="incline"></a>incline</h3><p>inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。没有普通</p><p>函数调⽤时的额外开销；</p><p>内联函数是⼀种特殊的函数，会进行类型检查；对编译器的⼀种请求，编译器有可能拒绝这种请求； </p><p>C++中inline编译限制：</p><ol><li><p>不能存在任何形式的循环语句</p></li><li><p>不能存在过多的条件判断语句</p></li><li><p>函数体不能过于庞⼤</p></li><li><p>内联函数声明必须在调⽤语句之前</p></li></ol><h3 id="static有啥用"><a href="#static有啥用" class="headerlink" title="static有啥用"></a>static有啥用</h3><ol><li>修饰变量<br>修改了变量的作用域和生命周期，存储在静态区域。生命周期和程序相同，作用域分为全局变量和局部变量。局部变量仅在函数内可用，全局变量仅在当前源文件中可用。</li><li>修饰函数<br>表明函数的作用域仅在当前源文件中。</li><li>修饰成员变量<br>静态成员变量为全局类对象所共享，仅有一份拷贝。类中声明，类外定义和初始化。</li><li>修饰成员函数<br>静态成员函数为全局类对象所共享。没有this指针，仅能访问静态成员变量和函数，虚函数不能为静态成员函数。【虚函数运行时绑定，静态成员函数编译时绑定】</li></ol><h3 id="extern有啥用"><a href="#extern有啥用" class="headerlink" title="extern有啥用"></a>extern有啥用</h3><ol><li><p>修饰变量：变量声明，表明变量在此处引用，在其他源文件中定义。</p></li><li><p>修饰函数：表明函数在其他源文件中定义。</p></li><li><p>extern “C”：编译器用C的命名规范去编译函数，链接器用C的命名规范进行链接。因为C++支持函数重载，而C不支持。</p><p>例如，假设某个函数的原型为：void</p><p>foo( int x, int y);该函数被C编译器编译后在符号库中的名字为 _ foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</p></li></ol><h3 id="＃include-lt-file-h-gt-与-＃include-“file-h”的区别？"><a href="#＃include-lt-file-h-gt-与-＃include-“file-h”的区别？" class="headerlink" title="＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？"></a>＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？</h3><p>前者从标准库查找寻找和引用file.h，后者从当前路径寻找和引用</p><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof计算的是在栈中分配的内存大小。</p><p>（1） sizeof不计算static变量占得内存；</p><p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p><p>（3） char型占1个字节，int占4个字节，short int占2个字节</p><p>long int占4个字节，float占4字节，double占8字节，string占4字节</p><p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p><p>（4） 数组的长度：</p><p>若指定了数组长度，则不看元素个数，总字节数&#x3D;数组长度*sizeof（元素类型）</p><p>若没有指定长度，则按实际元素个数类确定</p><p>Ps：若是字符数组，则应考虑末尾的空字符。</p><p>（5） 结构体对象的长度</p><p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p><p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）&#x3D;4</p><p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p><p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p><p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p><p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p><h3 id="C-空类默认有哪些成员函数？"><a href="#C-空类默认有哪些成员函数？" class="headerlink" title="C++空类默认有哪些成员函数？"></a>C++空类默认有哪些成员函数？</h3><p>默认构造函数、析构函数、复制构造函数、赋值函数</p><h3 id="main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>main函数执行之前会执行什么？执行之后还能执行代码吗？</h3><p>（1）全局对象的构造函数会在main函数之前执行；</p><p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p><p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。</p><p>比如全局变量的初始化，就不是由main函数引起的</p><p>举例： class A{};</p><p>A a; &#x2F;&#x2F;a的构造函数限执行</p><p>int main() {}</p><h3 id="对于一个频繁使用的短小函数-在C语言中应用什么实现-在C-中应用什么实现"><a href="#对于一个频繁使用的短小函数-在C语言中应用什么实现-在C-中应用什么实现" class="headerlink" title="对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?"></a>对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?</h3><p>c用宏定义，c++用inline</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">dbtest</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;  <br>&#125; <br></code></pre></td></tr></table></figure><p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p><p>其实这种有点类似咱们前面学习的动态库和静态库的问题，使 dbtest 函数中的代码直接被放到main 函数中，执行for 循环时，会不断调用这段代码，而不是不断地开辟一个函数栈。</p><p>缺点：</p><p> inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。</p><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p><h3 id="使用多进程与多线程的区别？"><a href="#使用多进程与多线程的区别？" class="headerlink" title="使用多进程与多线程的区别？"></a>使用多进程与多线程的区别？</h3><p>（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。</p><p>（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；</p><p>（3）线程产生的速度快，线程间通信快、切换快；</p><p>（4）线程的资源利用率比较好；</p><p>（5）线程使用公共变量或者资源时需要同步机制。</p><h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>（1）栈区：由编译器自动分配和释放，存放函数的参数值、局部变量的值等；</p><p>（2）堆：一般由程序员分配和释放，存放动态分配的变量；</p><p>（3）全局区（静态区）：全局变量和静态变量存放在这一块，初始化的和未初始化的分开放；</p><p>（4）文字常量区：常量字符串就放在这里，程序结束自动释放；</p><p>（5）程序代码区：参访函数体的二进制代码。</p><p>当需要的空间特别大的时候，就必须使用堆，因为栈的大小是有限制的，一般为5MB左右，所以当需要一个大块空间是，必须在堆上开辟空间。</p><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p><a href="https://www.cnblogs.com/scut-linmaojiang/p/5281369.html">https://www.cnblogs.com/scut-linmaojiang/p/5281369.html</a></p><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p>1  在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。<br>2 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p><h3 id="析构函数和构造函数是什么？"><a href="#析构函数和构造函数是什么？" class="headerlink" title="析构函数和构造函数是什么？"></a>析构函数和构造函数是什么？</h3><p>类的数据成员不能在类的声明时候初始化,为了解决这个问题? 使用构造函数处理对对象的初始化。构造函数是一种特殊的成员函数,与其他函数不同,不需要用户调用它,而是创建对象的时候自动调用。析构函数是对象不再使用的时候,需要清理资源的时候调用。</p><h3 id="初始化时构造函数的调用顺序"><a href="#初始化时构造函数的调用顺序" class="headerlink" title="初始化时构造函数的调用顺序"></a>初始化时构造函数的调用顺序</h3><p>1、虚基类的构造函数按照继承顺序调用<br>2、非虚基类的构造函数按照继承顺序调用<br>3、成员类对象的构造函数按照声明顺序调用<br>4、本类的构造函数；</p><h3 id="为什么构造函数不能是虚函数？"><a href="#为什么构造函数不能是虚函数？" class="headerlink" title="为什么构造函数不能是虚函数？"></a>为什么构造函数不能是虚函数？</h3><p>1.创建一个对象必须明确指出它的类型，否则无法创建，一个对象创建成功编译器获得它的实际类型，然后去调用对应的函数，而如果构造函数声明为虚函数，会形成一个死锁，虚函数是在运行才能确定确定其调用哪一个类型的函数，而具体哪一个类型是编译器通过对象的类型去确定的，但是此时对象还未创建也就没法知道其真实类型。</p><p>虚函数必须通过具体的实例对象决定调用对应的函数，当将构造函数定义为虚函数时，此时无法生成具体的实例对象（因为不知道调用哪一个构造函数）</p><p>无法生成具体的实例对象就无法调用虚函数，无法调用虚函数就无法生成具体的对象，因此陷入死锁</p><p>2.虚函数对应一张虚函数表，这个虚函数表是存储在对象的内存空间的，如果构造函数是虚函数就需要通过虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，找不到虚函数表，所以构造函数是不能声明为虚函数的。</p><p>因为虚指针的初始化和虚表的创建是在构造函数中完成的。先执行构造函数，再创建虚指针和虚函数表，假设构造函数是虚函数，构造函数的调用依赖于虚指针和虚函数表创建，出现矛盾。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员–虚拟函数表指针是在运行期–也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p><h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>纯虚函数相当于一个函数接口，只声明不定义。在其派生类里会重写。有纯虚函数的类为抽象类，不能实例化出对象。</p><p>上述代码体现了最经典的所谓多态的场景，给Jack不同的飞机，就能表现不同的结果。虚函数和纯虚函数都能做到这一点，区别是，子类如果不提供虚函数的实现，那就会自动调用基类的缺省方案。而子类如果不提供纯虚函数的实现，则编译将会失败。基类提供的纯虚函数实现版本，无法通过指向子类对象的基类类型指针或引用来调用，因此不能作为子类相应虚函数的备选方案。下面给出总结。</p><p>第一，<strong>当基类的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供一个备选方案的时候，请将其设计为虚函数</strong>。例如飞行器的加油动作，每种不同的飞行器原则上都应该有自己的个性化的加充燃油的方式，但也不免可以有一种通用的燃油及其加充方式。</p><p>第二，<strong>当基类的某个成员方法，必须由子类提供个性化实现的时候，请将其设计为纯虚函数</strong>。例如飞行器的飞行动作，逻辑上每种飞行器都必须提供为其特殊设计的个性化飞行行为，而不应该有任何一种“通用的飞行方式”。</p><p>第三，<strong>使用一个基类类型的指针或者引用，来指向子类对象，进而调用经由子类复写了的个性化的虚函数，这是C++实现多态性的一个最经典的场景</strong>。</p><p>第四，基类提供的纯虚函数的实现版本，并非为了多态性考虑，因为指向子类对象的基类指针和引用无法调用该版本。<strong>纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路</strong>。</p><p>第五，<strong>虚函数和普通的函数实际上是存储在不同的区域的</strong>，虚函数所在的区域是可被覆盖（也称复写override）的，每当子类定义相同名称的虚函数时就将原来基类的版本给覆盖了，另一侧面也说明了为什么基类中声明的虚函数在后代类中不需要另加声明一律自动为虚函数，因为它所存储的位置不会发生改变。而普通函数的存储区域不会覆盖，每个类都有自己独立的区域互不相干。</p><h3 id="父类析构函数为什么要用虚函数？"><a href="#父类析构函数为什么要用虚函数？" class="headerlink" title="父类析构函数为什么要用虚函数？"></a>父类析构函数为什么要用虚函数？</h3><p>在Effective C++ 中，Scott Meyers在《条款07:为多态基类声明virtual析构函数》中提到，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没有被销毁。也就是说，如果派生类继承了父类的情况下，如果父类的析构函数不是虚函数，而在使用中用了多态的写法，就会导致没有调用到派生类的析构函数，导致资源没有释放，造成泄漏。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>重载和重写</p><p>重写规则：</p><ol><li><p>写⽅法的参数列表，返回值，所抛出的异常与被写⽅法⼀致</p></li><li><p>被写的⽅法不能为private</p></li><li><p>静态⽅法不能被᯿写为⾮静态的⽅法</p></li><li><p>写方法的访问修饰符⼀定要⼤于被写⽅法的访问修饰符（public&gt;protected&gt;default&gt;private）</p></li></ol><h3 id="为什么空类大小不是0？"><a href="#为什么空类大小不是0？" class="headerlink" title="为什么空类大小不是0？"></a>为什么空类大小不是0？</h3><p>为了确保两个不同对象的地址不同，必须如此。</p><p>类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独⼀⽆⼆的地址。 </p><p>同样，空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有独⼀⽆⼆的地址了。 </p><p>所以，空类的sizeof为1，⽽不是0。 </p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><a href="http://c.biancheng.net/view/410.html">http://c.biancheng.net/view/410.html</a></p><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><h3 id="constexpr-和-const"><a href="#constexpr-和-const" class="headerlink" title="constexpr 和 const"></a>constexpr 和 const</h3><p>constexpr：告诉编译器我可以是编译期间可知的，尽情的优化我吧。</p><p>const：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p><p>修饰对象的时候两者之间最基本的区别是：</p><ul><li>const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。</li><li>constexpr是修饰一个常量表达式。但请注意constexpr不是修饰常量表达式的唯一途径。</li></ul><p>修饰函数的时候两者之间最基本的区别是：</p><ul><li>const只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。</li><li>constexpr可以用于含参和无参函数。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数：                                                        </li><li>1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素      (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了)                                                                       2.参数和返回值必须是字面值类</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>map用的是红黑树，unordered_map用的是hash表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>列表推导式</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-c42f9c518932b4fa5e1507562fcdfbdb_r.jpg" alt="preview"></p><h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><h3 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h3><p>浅拷贝仅仅复制了容器中元素的地址</p><p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</p><h3 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h3><p>可变对象与不可变对象的区别在于对象本身是否可变。</p><p>python内置的一些类型中</p><ul><li>可变对象：list dict set</li><li>不可变对象：tuple string int float bool</li></ul><p>python中向函数传递参数只能是引用传递，表示把它的地址都传进去了，这才会带来上面的现象。</p><p>有的编程语言允许值传递，即只是把值传进去，在里面另外找一个地址来放，这样就不会影响全局中的变量。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h2 id="程序的内存模型"><a href="#程序的内存模型" class="headerlink" title="程序的内存模型"></a>程序的内存模型</h2><h2 id="多进程与多线程的区别以及使用场景"><a href="#多进程与多线程的区别以及使用场景" class="headerlink" title="多进程与多线程的区别以及使用场景?"></a>多进程与多线程的区别以及使用场景?</h2><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><h2 id="上网的全过程"><a href="#上网的全过程" class="headerlink" title="上网的全过程"></a>上网的全过程</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220305190803022.png" alt="image-20220305190803022"></p><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a><strong>http</strong>和<strong>https</strong>的区别</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>Mysql</strong>了解吗，讲⼀下事务，那<strong>mysql</strong>是如何保证<strong>ACID</strong>的呢（答了undo-log,redo-log,加锁,mvcc），那讲⼀下MVCC</p><p>事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。事务的四⼤特性原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 </p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</p><p>设计模式包含哪些？</p><ul><li><strong>意图</strong>部分简单描述问题和解决方案。</li><li><strong>动机</strong>部分将进一步解释问题并说明模式会如何提供解决方案。</li><li><strong>结构</strong>部分展示模式的每个部分和它们之间的关系。</li><li><strong>在不同语言中的实现</strong>提供流行编程语言的代码， 让读者更好地理解模式背后的思想。</li></ul><p>设计模式的分类</p><ul><li><strong>创建型模式</strong>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li><li><strong>结构型模式</strong>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li><strong>行为模式</strong>负责对象间的高效沟通和职责委派。</li></ul><p><strong>创建型模式</strong></p><p><strong>工厂模式</strong></p><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="手写二分查找"><a href="#手写二分查找" class="headerlink" title="手写二分查找"></a>手写二分查找</h2><h2 id="手写快排"><a href="#手写快排" class="headerlink" title="手写快排"></a>手写快排</h2>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
