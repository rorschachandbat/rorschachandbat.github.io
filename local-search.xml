<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024年度总结</title>
    <link href="/%E9%9A%8F%E7%AC%94/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%9A%8F%E7%AC%94/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="桌游"><a href="#桌游" class="headerlink" title="桌游"></a><strong>桌游</strong></h1><p>今年桌游开的少多了，离开了北京帮之后没有稳定的每周末约局了，不过也能和咩神zzh重温一些旧毛线，还是非常有趣的，相同的游戏和不同的人玩也相当快乐，总而言之桌游的精髓就是面对面交流。</p><h2 id="合作：炸弹克星"><a href="#合作：炸弹克星" class="headerlink" title="合作：炸弹克星"></a>合作：炸弹克星</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114214049.jpg"></p><p>这两个真是不分伯仲，都是非常有趣的合作游戏，论耐玩性和人数性质上来说炸弹克星要更好一点，可以2-5人的传承式合作桌游，途中你会经历找猪鼻、互相甩锅、被迫出猫、我觉得你觉得我知道的逻辑困境，强烈推荐。但是配件有些垃圾，如果数字板件换成塑料的就耐用很多了，全是纸板让人不敢大力使用。</p><h2 id="毛线：印加宝藏"><a href="#毛线：印加宝藏" class="headerlink" title="毛线：印加宝藏"></a>毛线：印加宝藏</h2><p>玩法相当简单，每回合你都要选择逃跑或者留下，每回合翻一张牌，选择跑的人可以和一起跑的人平分目前的宝藏，逃跑可能能遇到更好的金子，当然也可能遇到灾难血本无归。</p><p>这个游戏人数相当自由，2-7个人都可以，非常简单的数学模型但也充满博弈，</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/2.jpg"></p><h2 id="美术：流画溢彩"><a href="#美术：流画溢彩" class="headerlink" title="美术：流画溢彩"></a>美术：流画溢彩</h2><p>玩法很无聊但是美术很棒，玩法是从抽到的牌里面组合成自己的一幅画，会根据画上的图标来算分，相当无聊，但是能看到自己创造一幅画的感觉非常棒，我甚至觉得这有做成电子游戏的潜力。</p><p>组图</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/1.jpg"></div><div class="group-image-wrap"><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/3.jpg"></div></div></div><h2 id="猜词：巧手猜图"><a href="#猜词：巧手猜图" class="headerlink" title="猜词：巧手猜图"></a>猜词：巧手猜图</h2><p>非常有童真趣味的一个猜词游戏，有五套道具，例如积木、绳子、木块、数字、画板，每人轮换着用道具表示自己的目标图。这个设计精妙的地方就在于，你完全可以自制一套自己的道具，甚至要猜的图也可以自己自制，比如自己和朋友出行的合照，风景图，如果做一套作为礼物送给朋友一定相当的有意义，有机会试试！</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114220029.jpg"></p><h2 id="重策：神秘大地"><a href="#重策：神秘大地" class="headerlink" title="重策：神秘大地"></a>重策：神秘大地</h2><p>说实话今年因为回广州了没什么人开重策捏，离开了北京帮真是孤独呢，既然只玩了这一个重策那就只能是你了！游戏是多维度跑分，每个种族有截然不同的跑分策略和能力，虽然没有战斗但是互相卡人也相当恶心，但我也没玩多少把就是了。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114220144.jpg"></p><h1 id="书"><a href="#书" class="headerlink" title="书"></a><strong>书</strong></h1><p>今年看的书大多都是小说，印象较深刻的都是一些短中篇小说集，这是否说明我逐渐短平快化了…</p><h2 id="深河"><a href="#深河" class="headerlink" title="深河"></a>深河</h2><p>一群日本人的印度之旅，没心没肺的新婚夫妇；失去妻子相信她会在印度转世的中年男人；得了胃病觉得是鹦鹉替自己死去的童话作家；经历了越南战争又目睹自己战友死亡的老兵；以及寻找着神质疑自己的信仰的“异端神父”，曾经捉弄过他后来又念念不忘，有些虚无主义的美津子。每个人都怀揣着自己的秘密，其中最让人动容的就是大津，辗转多地，寻求着“洋葱”是什么，其他人来到印度之后也都十分有触动，人生意义这种东西说白了感觉是一个无法思考清楚的问题啊….</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34666637.jpg"></p><h2 id="山月记"><a href="#山月记" class="headerlink" title="山月记"></a>山月记</h2><p>zz推荐，相当有意思，日本人写的他眼里的中国神话历史鬼怪故事，不知是翻译还是原文本就如此，文字很平淡克制，读起来很舒服。第一篇同名篇就很有意思，因为欲望而变成老虎的落魄诗人；李陵这篇把各种心理描写和挣扎写的很详细；很喜欢讲沙和尚这篇，很有悉达多的感觉，迷茫的沙僧各种寻找人生的意义，见识各种哲学流派，有意思；后面这篇对西游记师徒四人的“曲解”相当耐人寻味；最后这个讲子路与孔子的看得很感人，从小就接触论语，或多或少的对孔子的各种故事有所了解，完完整整的读一遍这种带有文学色彩的小传还是蛮感人的。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34264489.jpg"></p><h2 id="世上为什么要有图书馆"><a href="#世上为什么要有图书馆" class="headerlink" title="世上为什么要有图书馆"></a>世上为什么要有图书馆</h2><p>相当精彩的纪实文学，能看到作者对于图书、文字的热爱，略微文不对题但是还是相当精彩，其实讲了作者作为一个大学老师转换成政府官员的各种见闻。前半部分讲了从零到一建一个图书馆的方方面面，后半部分讲了许多小故事。关于书也关于人，作者是热爱书的，肆无忌惮买书的欣喜令人感同身受，但是在政府工作也有许许多多的不适应和脱离实际，这些看着也蛮有意思。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34705784.jpg"></p><h2 id="妙趣横生的游戏制作之旅"><a href="#妙趣横生的游戏制作之旅" class="headerlink" title="妙趣横生的游戏制作之旅"></a>妙趣横生的游戏制作之旅</h2><p>如果你想做线性的3A剧情游戏，比如神秘海域啊，战神啊这种，那么这本书的方法论非常有用，从项目管理的各个方面讲了游戏是怎么制作的，受益匪浅，算是从制作人的角度解释了游戏制作的流程。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34314229.jpg"></p><h2 id="平滑世界和它的敌人"><a href="#平滑世界和它的敌人" class="headerlink" title="平滑世界和它的敌人"></a>平滑世界和它的敌人</h2><p>太有意思了！第一篇同名篇一开始看设定感觉一头雾水，读起来感觉能不停穿越世界的感觉画面感太有意思了，女主那种感受到视线无法集中的心情也很有意思；《零零时代科幻史》成功骗到我了，还以为是真有此事哈哈哈；《献给美亚羽的手枪》是很标准的科幻啊，“如果明天的我喝今天的我想法不同了，那么我就不是我了吗？”，关于人类意识的探讨相当有意思；《神圣铁处女》有点推理小说的意思，最后漏底很惊讶；《奇点时代》太酷了，开头给人红色大超那个世界的感觉，然后是两个人工智能精彩的对垒，人类一方进入睡梦，一方沦为ai的计算资源，各种反转；《快于光，慢于光》太适合新海诚了啊，也是那种灾难科幻背景，男主女主奋不顾身地奔向对方，非常期待能改编成动画电影。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34233946.jpg"></p><h2 id="不间断的人"><a href="#不间断的人" class="headerlink" title="不间断的人"></a>不间断的人</h2><p>越来越喜欢双雪涛了，烦躁的时候翻来看看总能让我平静下来，双雪涛真是一个很标准很工整的小说家，前面的每一个引子后面都会用到。最喜欢《刺客爱人》这一篇，很长但是每个人的故事环环相扣，非常让人有读下去的欲望；同名篇的开头就很意思，“起来听钢琴声”，周易，第二部分的ai也很有意思，但是第三部分就显得有些看不懂了，有些过于奇怪；《淑女的选择》作为插在中间的小短篇恰到好处，也非常喜欢，结局猛烈而惊奇；三个小短篇给人感觉都差不多，读起来味道是有的，最喜欢《烟花》这一篇，中间一度以为是女孩的恶作剧，然而并不是，不过结局感觉有些草率；《拳击手》这篇感觉太多隐喻了，不太喜欢。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34765667.jpg"></p><h2 id="我们生活在南京"><a href="#我们生活在南京" class="headerlink" title="我们生活在南京"></a>我们生活在南京</h2><p>竟然是网文，令人惊讶，点子是挺不错的，主角作为一个无线电爱好者竟然收到了未来的来电，于是一场跨越时代的救援就这样展开了。行文有些口语化以及频繁重复词，这也是网文的通病了。女主是一个像夏弥一样乐天派坚强的姑娘，真讨喜。剧情有一点bug，两次时间胶囊看上去是验证了，但是完全有可能是对面看到了里面的东西然后根据二十年的推演来骗他们，然而主角团都没有考虑过这个问题。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34387186.jpg"></p><h2 id="第欧根尼变奏曲"><a href="#第欧根尼变奏曲" class="headerlink" title="第欧根尼变奏曲"></a>第欧根尼变奏曲</h2><p>超级好看的短篇集，推理元素没那么强，但是很有趣，有几篇比较水，首尾都相当有意思，窥伺蓝色的蓝的叙诡惊了，反转有意思；时间就是金钱有人生遥控器的味道了，最后的感慨特别有意思；作家出道杀人事件很有意思，直接从真实杀人体会自己的构想不足让人毛骨悚然啊；恶魔党杀（怪）人事件有种看日本漫画的感觉，真搞笑；隐身的X全场最佳，如果大学真的有这么有趣的课我一定会去上！陈浩基真喜欢叙诡啊！感觉这一篇改编成什么小短片很有意思</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s32295113.jpg"></p><h1 id="观影"><a href="#观影" class="headerlink" title="观影"></a><strong>观影</strong></h1><p>今年来的观影体验是经常落泪，可能是因为太容易触景生情，经历了生离死别之后再看电影中的场景，煽情的片段总是令我无法控制地落下眼泪。</p><h2 id="好东西"><a href="#好东西" class="headerlink" title="好东西"></a>好东西</h2><p>年度最佳喜剧，虽然有被批评太过碎片化段子化，不过还是相当精彩，很喜欢听声音那段，小孩耳中惊天动地的声音，其实只是母亲做家务的声音，这段蒙太奇绝了。许多台词也让人捧腹大笑，“你读过基本上野千纸鹤？”，“你怎么打女孩就怎么打”。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2915454411.webp" alt="好东西"></p><h2 id="里斯本丸沉没"><a href="#里斯本丸沉没" class="headerlink" title="里斯本丸沉没"></a>里斯本丸沉没</h2><p>太沉重了，这大概是我第一次感受到历史的力量，看着亲历者的讲述，真的很难想象他们是经历这些悲惨的日子之后 ，为何还能这样平淡地讲出来这些事。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2912588024.webp"></p><h2 id="白色巨塔"><a href="#白色巨塔" class="headerlink" title="白色巨塔"></a>白色巨塔</h2><p>最后一集哭了一整集，纵使财前多么的不择手段，在死亡面前一切都显得微不足道，其实财前内心深处还是对医学对生命充满敬畏的，只是大环境让他扭曲了太多😭😭😭看得我真的好伤心💔</p><p>看完白色巨塔之后，逐渐认识到没有什么事情是非黑即白的，理想主义也需要现实主义来支撑，要对抗腐朽的制度，得需要身怀理想主义的人深入其中，才能逐渐改变这种制度，财前是支撑白色巨塔建成的人，是支撑每一个里间这样的人能安稳研究的基础。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2892515613.webp" alt="白い巨塔"></p><h2 id="薄荷糖"><a href="#薄荷糖" class="headerlink" title="薄荷糖"></a>薄荷糖</h2><p>倒叙的讲述结构，一个人的毁灭是一瞬间的吗？还是缓慢地多方面地演变而来的，男主大声的呼喊着我要回去，但是似乎每一个节点他都不是很如意，该如何改变呢？</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2519637549.webp" alt="박하사탕"></p><h2 id="葬送的芙莉莲"><a href="#葬送的芙莉莲" class="headerlink" title="葬送的芙莉莲"></a>葬送的芙莉莲</h2><p>我向来是很喜欢公路片的，温暖的缓慢的旅途，真让人开心呢。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2897218476.webp" alt="葬送のフリーレン"></p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a><strong>游戏</strong></h1><h2 id="puzzle-game：LOK-Digital"><a href="#puzzle-game：LOK-Digital" class="headerlink" title="puzzle game：LOK Digital"></a>puzzle game：LOK Digital</h2><p>怪兽远征制作组的新作，依旧是高质量的puzzle game，游戏的主要玩法是连线一笔画，需要逐渐的探寻不同咒语的效果</p><h2 id="肉鸽：Genome-Guardian"><a href="#肉鸽：Genome-Guardian" class="headerlink" title="肉鸽：Genome Guardian"></a>肉鸽：Genome Guardian</h2><p>设计相当扎实的肉鸽弹幕设计游戏，你将扮演一个细胞，不断升级自己的武器，挺过一波又一波的关卡，听起来平平无奇，但是他的设计和主题融合的非常精妙。你升级武器的过程是获得不同的遗传因子，分别是ATCG，这个又对应武器的射速、射程、威力和范围，不同的枪就是不同遗传因子的组合，所以在解锁武器的时候就非常有期待感，同时这些武器又非常地符合直觉，比如AAAA，攻速的极致就变成了加特林，CCCC，射程的机制就变成了一个激光炮。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230649042.png" alt="丰富的武器系统"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230714360.png" alt="丰富的武器系统"></p><p>游戏还有一点非常棒的是局外养成，你每次刷了一局之后都有相当丰富的局外养成可以点，这就非常有刷感，我觉得这对于一个现代的rougelite游戏非常重要，你需要给玩家逐渐变强的感觉，不仅是自己技术的提升，也要有属性的加成，当然必须要精确控制好这个数值的度，要让玩家一次能看到提升，但是又不能太繁重，同时你也要局内足够有趣，才能让玩家不是只为了刷东西而玩。这一点做的很好的还有星界战士。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230810905.png"></p><p>其他还有一些小细节，比如敌人也是ATCG组成的， 会根据这个有不同的特性，还可以给每个武器上buff，会和自己的子弹有相当奇异的丰富（类似</p><p><strong>辐射谷物语</strong></p><p>一款缝合怪游戏，缝了星露谷和肉鸽，相当有创新的缝合，分为白天探险打怪收集种子和废料，晚上守卫家园和种菜，不过游戏的教程有点弱，很多东西不知道有什么用。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120233238871.png"></p><h2 id="最佳创意：动物井"><a href="#最佳创意：动物井" class="headerlink" title="最佳创意：动物井"></a>最佳创意：动物井</h2><p>今年独立游戏的真正神中神，解谜类型的银河恶魔城，一开始玩的有点云里雾里，没有任何教程，规则本身就变成了谜题的一种，很有吹哥的味道，道具的用途也需要玩家去观察，试错，寻找，联想。</p><p>游戏设计的教科书，每个机制的关卡都非常自然的教会了你简单到复杂的过程，并且机制和机制之间融合的非常融洽，比如溜溜球和老鼠，弹弹圈和飞盘，谜题设计的相当有趣，真的难以想象这么一款游戏只有33MB，请原谅我夸都不知道怎么夸了，总之玩就对了。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/800"></p><p><strong>Leap Year</strong></p><p>一跳就会死的平台跳跃游戏，点子相当精妙，非常喜欢这种知识锁的设定，你的一切能力一开始就告诉你了，但是你没法学习到所以你无法通过这些道路，核心点子是跳跃的高度不同会导致不同的性质，比如反弹，穿地甚至重力翻转，最后要反着重新走一遍所有的路实在是太惊艳了！唯一的缺点就是流程太短了，不过考虑到要设计一条完全重复的路确实需要考虑。</p><p>玩了leap year之后发现这个相当神奇的制作组，袜子社，对他们的制作模式感到非常敬佩，往往是一两周就出一个小游戏，美术和音乐非常魔性，但是机制都非常有趣，也试了好多个，都非常有意思，之前也出过一个爆款，stack land，期待他们能做出更长的作品。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120232351042.png"></p><h2 id="AVG：灵视异闻FILE23-本所七大不可思议"><a href="#AVG：灵视异闻FILE23-本所七大不可思议" class="headerlink" title="AVG：灵视异闻FILE23 本所七大不可思议"></a>AVG：灵视异闻FILE23 本所七大不可思议</h2><p>剧透预警！！！</p><p>相同紧凑的一款avg，开局贼恐怖，因为能自由转视角然后开局略微jump scare让我序章玩的战战兢兢的；中间的故事部分也不错，你将扮演不同的主角共同解决复活秘术的危机，很有428的感觉，同时推进来推动故事，各种伏笔都回收了，虽然推理元素和时间跳跃元素没那么强但是也相当有意思；结局更加是让人眼前一亮。</p><p>值得一提的是游戏有三处meta元素，挺创新的啊，分别是声音，存档和自己的名字，声音那里让人吃瘪笑死了，存档很感动，名字那里也相当的有意思啊，好玩！</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34516771.jpg"></p><p><strong>尘埃终须落定</strong></p><p>比较有意识的推理小游戏，通过摆放不同人的叙述顺序来还原真相，需要认真推理才能想明白，蛮有趣的。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120233646410.png"></p><h2 id="party-game：Astro-Duel2"><a href="#party-game：Astro-Duel2" class="headerlink" title="party game：Astro Duel2"></a>party game：Astro Duel2</h2><p>epic送的小游戏，完成度相当高的同屏共斗小游戏，可以2-4人游玩，操纵的主角可以在飞船和船员中间切换，操纵飞船互殴的感觉真的太符合我小时候梦想的游戏了。操纵手感很棒，动作机制非常丰富：冲刺、弹反、拼刀、下砍；同时拥有许多机制不同的地图，每个地图有可以破坏的区域；还有不同类型的飞船，钻头、重型和平衡性；</p><p>可以观看我和陈医的<a href="https://www.bilibili.com/video/BV1Lr421t7Kt/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">欢乐录播</a>，真是欢乐的时光~</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/astreal%20duel22.gif"></p><p><strong>Samurai Gunn2</strong></p><p>这个游戏的画风也非常棒，每个人物有特殊的技能，但是跳跃的手感有点飘，而且没有中文，只能纯拼刀，玩起来没有astro duel那么刺激。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120214200715.png"></p><p><strong>TowerFall</strong></p><p>蔚蓝制作组的新作，可以看到许多蔚蓝的影子，酒店关的刺，随音乐跳动的砖块，跳跃手感自然是很优秀的，不过</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120214342733.png" alt="image-20250120214342733"></p><p><strong>一些碎碎念</strong></p><p>说实话2024蛮坎坷的，工作不是很顺利，一度产生了对自己的怀疑，也有些迷茫，当然我还是觉得自己是有passion的，只是不知道如何发展。所幸目前是又能重新出发了，2025年得更认真一点了，无论是工作上还是体验娱乐上。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>games104学习笔记</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/games104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/games104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><strong>面临的挑战</strong></p><p>玩家行为是不可控的，要和gameplay互动；实时性；真实性（Motion Matching）</p><h2 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h2><p><strong>精灵动画（Sprite）</strong>：一帧一帧循环播放</p><p><strong>Live2D</strong></p><p>把每个图元都分隔，然后各种拉伸的时候可以做出各种动作</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173000363.png"></p><p>每一个部位生成一个图元来控制，非常直观的动画系统，简单又生动</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110163825295.png"></p><h2 id="3D动画分类"><a href="#3D动画分类" class="headerlink" title="3D动画分类"></a>3D动画分类</h2><p>基于层次的刚体动画，是一个树形结构，但是可能会穿帮，因为只操纵骨骼会互相穿插有可能。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110165402649.png"></p><p>顶点动画，存offerset的texture和法向的texture，然后根据帧数来计算，可以做一些布料或者流体什么的</p><p><strong>蒙皮动画</strong></p><p><strong>基于物理的动画</strong>：衣料、布娃娃系统、IK（反向动力学）</p><h2 id="蒙皮动画"><a href="#蒙皮动画" class="headerlink" title="蒙皮动画"></a>蒙皮动画</h2><p>蒙皮动画步骤</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110170653403.png"></p><p>坐标系的转换，要理解怎么变化的，乘旋转和平移矩阵，每一个骨骼都有自己的Local Space，并且会是一个一直传递相乘的矩阵（正向运动学），比如手指要一直乘各个手臂</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110170946080.png"></p><p>骨骼树的起点是胯部（脊椎的最后一块骨头）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171338432.png"></p><p>可能会加入一些额外的骨骼，比如什么眼球啊，翅膀啊，斗篷，武器，绑定节点（人骑在马上）这些都是用骨骼来驱动的</p><p>为了更好地计算移速、离地高度，会加一个root</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171929544.png"></p><p>四足动物的位置如下：</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171955248.png"></p><h2 id="3D旋转数学基础"><a href="#3D旋转数学基础" class="headerlink" title="3D旋转数学基础"></a>3D旋转数学基础</h2><p><strong>2d旋转</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110172921112.png"></p><p><strong>3D旋转</strong></p><p>可以证明任何旋转都可以用xyz旋转等价，也就是欧拉角</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173332296.png"></p><p>但是欧拉角是有很多问题的，首先他顺序乘的不同会导致结果不同</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173510295.png"></p><p>其次欧拉角会有锁死的情况，比如y轴转了90度，这时x轴和z轴是同轴了，那么就两个的旋转等于只有一个旋转了，造成退化的情况。</p><p>非常难插值</p><p>传递的时候不能直接相乘</p><p>并且很难绕着一个任意的轴来旋转</p><p><strong>四元数</strong></p><p>这时候就要用到四元数（Quaternion）了</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110175428592.png"></p><p>没太听懂，到时候仔细研究一下四元数吧</p><p><a href="https://www.bilibili.com/video/BV1SW411y7W1/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">四元数的可视化</a></p><h2 id="关节与蒙皮"><a href="#关节与蒙皮" class="headerlink" title="关节与蒙皮"></a>关节与蒙皮</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110235935822.png"></p><p>MJm，是从root上一步一步累计的transform矩阵，记住要乘一个自己绑定的时候的逆，然后可能还要乘一个骨骼到世界坐标的transform，一般编程的时候会把这个逆直接存储下来。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111000422109.png"></p><p>因为动画的帧数不够，所以需要插值，NLERP，然后可能要满足最短路径，这样才能看起来比较自然一点，夹角小的时候用NLERP，大的时候用SLEPR</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001302077.png"></p><h2 id="动画压缩"><a href="#动画压缩" class="headerlink" title="动画压缩"></a>动画压缩</h2><p>动画一个帧就三十个pose，然后几十个骨骼，每个都要存旋转位移scale，这种时候就需要压缩，因为很多时候他们的数据是不变的</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001647296.png"></p><p>首先不变的值直接干掉，然后可以用keyframe插值，如果插值造成的误差没超过阈值，那么就可以接受。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001908597.png"></p><p>直接线性插值会对旋转矩阵会比较差，可以用catmull-rom spline</p><p>如果浮点数的范围是有限的，可以转成定点数，归一数压缩一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111002200716.png"></p><p>如果避免error累积，防止出现动画飘来飘去的情况？要更换计算error的方式，直接比较矩阵函数和插值之后的差值其实不太直观，最好的是visual error，但是又不可能真的直接算，所以会在每个joint拿两个垂直的点，然后来计算这个前后的差值。敏感的可以给大一点。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111002713988.png"></p><h2 id="动画制作流程（DCC）"><a href="#动画制作流程（DCC）" class="headerlink" title="动画制作流程（DCC）"></a>动画制作流程（DCC）</h2><p>先用低模做，但是在关节地方会多加一点mesh</p><p><strong>骨骼绑定</strong></p><p><strong>Skinning</strong></p><p>一般自动计算权重，但是也可能要手动调整一下</p><p><strong>动画制作</strong></p><p><strong>Exporting</strong></p><p>要注意跳跃的时候root可能会变化，</p><h2 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h2><p>两个动作之间插值，比如走到跑，weight根据速度来变化，要保证两个动作的时间是一样的，这样才能确定是哪一帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111091311695.png"></p><h2 id="混合空间（Blending-Space）"><a href="#混合空间（Blending-Space）" class="headerlink" title="混合空间（Blending Space）"></a>混合空间（Blending Space）</h2><p>2d空间中，动作不是一维的，所以有可能有些地方动作密（因为觉得这里需要更细腻的表现），然后插值的时候，不可能把全部动作都插值，这时候就需要用到delaunay三角化，其实也就是把每三个点都连成三角形，然后你插值的时候判断是在哪个三角形里面，只插值这最近的三角形的动作。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111092138796.png"></p><p>鼓掌可以有一个mask，某些动作只应用到上半身</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111092612627.png"></p><p><strong>Additive Blending</strong></p><p>混合之后再叠加一个blend，比如旋转，可以做一直朝着一个地方点头</p><h2 id="动画状态机（Action-State-Machine）"><a href="#动画状态机（Action-State-Machine）" class="headerlink" title="动画状态机（Action State Machine）"></a>动画状态机（Action State Machine）</h2><p>每一个状态也可以是一个动画状态空间</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100048688.png"></p><p>一般还可以是多层状态机，分开独立控制</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100201347.png"></p><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>定义控制变量，暴露给gameplay系统，让他们来改变，然后通过这些变量来选择当前树该选择哪个节点</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100545330.png"></p><p>也可以通过事件来控制，比如切枪（从步枪变成火箭筒）</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/skeletal-mesh-animation-system-in-unreal-engine?application_version=5.4">UE骨架动画文档</a></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100825429.png"></p><h2 id="Inverse-Kinematics-IK反向动力学"><a href="#Inverse-Kinematics-IK反向动力学" class="headerlink" title="Inverse Kinematics(IK反向动力学)"></a>Inverse Kinematics(IK反向动力学)</h2><p>ik可能是多解的，所以这时候需要一个指定朝向，相当于再多加一个平面</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111101948230.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102021279.png"></p><p>如果不止两个，有多个关节，该怎么解？（解有无穷多种可能）</p><p>首先要判断解空间，考虑最大和最小，并且还有考虑关节的约束度</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102213306.png"></p><p><strong>CCD</strong>，不断地翻滚骨头，循环到目标</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102609241.png"></p><p><strong>FABRIK</strong></p><p>把末端直接放在终点，这时候那个骨头会突出去，然后把这个作为下一个的起点，最后迭代过去会导致root也有偏差，这时候再backward一遍，把root拉过去，然后一直这样forward和backward迭代，设置一个error误差。</p><p><strong>多目标约束</strong>怎么办？共同的节点发生变化，可以用雅可比矩阵+逼近的方式。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111111624550.png" alt="一些其他的IK技术"></p><h2 id="面部动画"><a href="#面部动画" class="headerlink" title="面部动画"></a>面部动画</h2><p>Facical Action Code System</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111112344279.png" alt="46个基础表情"></p><p>存的是顶点动画，每一个node相对于自然状态的delta，morph target animation</p><p>也有些使用骨骼动画，捏脸，眼球，这些需要。</p><p>2d的话也可以直接用uv texture</p><h2 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h2><p>Source Character-&gt;Target Character</p><p>Source Animation-&gt;Target Animation</p><p>重定向的时候存的是相对旋转、scale和位移</p><p>要根据腰线的高度等比例放缩一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111113632285.png"></p><p>如果还不行就得用IK</p><p>有些时候，如果骨骼数量不一样怎么办？简单的办法就是把数量不一样的地方，按照数量的差异，做一个插值，4-&gt;3就是0.3，0.7，然后把插值找到的位置直接认为是少的那个骨骼的终点位置。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E9%AA%A8%E9%AA%BC%E6%8F%92%E5%80%BC.gif"></p><p>也存在一些问题，比如自身穿模，或者没达到效果，因为有些动作是有语义的，比如鼓掌没合手，可以加一些约束</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E9%97%AE%E9%A2%98.gif"></p><h1 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h1><h1 id="Gameplay框架"><a href="#Gameplay框架" class="headerlink" title="Gameplay框架"></a>Gameplay框架</h1><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>一般是用<strong>观察者模式</strong>，需要定义以下三个东西</p><p><strong>Event Definition</strong></p><p>有一个enum和parament，要做到可拓展，能实时修改</p><p><strong>Callback Registration</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111124936819.png"></p><p>要考虑事件和回调的线程安全性问题，比如有可能你invoke的时候那个对象已经被销毁了</p><p>可以用强引用，保证invoke的的对象一定不被销毁；或这软引用，使用之前先判断是否已经被销毁了。</p><p><strong>Event Dispatching</strong></p><p>派发，如果来一个事件就直接派发，可能会产生堵塞、或者可能发生链式反应，事件一直会有。</p><p>一般会实现一个消息队列，把一帧到来的事件全部收集好，然后下一帧统一执行。</p><p>要实现序列化和反序列化，以及Ring buffer，这样就不用重复申请和释放内存，好处是不会崩，顶多是那一瞬间卡一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/ringbuffer.gif" alt="ringbuffer"></p><p>不同的类型要分批分发</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111145922323.png"></p><p>也会有问题，比如有些事件就需要即时发生；以及delay会一直累积</p><h2 id="游戏逻辑和脚本系统"><a href="#游戏逻辑和脚本系统" class="headerlink" title="游戏逻辑和脚本系统"></a>游戏逻辑和脚本系统</h2><p>热更新所以得用脚本语言？</p><p>GO的管理靠谁来管理？一般是脚本，因为很多跟逻辑相关，一般是靠GC</p><p>如果本身对象没有那么多，比如单机游戏，更加注重ai动画，那么就直接引擎来管理</p><p>解释性语言可能会比较慢，可以用JIT（一边执行一边编译）</p><h2 id="可视化脚本"><a href="#可视化脚本" class="headerlink" title="可视化脚本"></a>可视化脚本</h2><p>面向设计师，让他们免于管理生命周期。可视化脚本也要实现编程语言的那些共同的要素。</p><p><strong>变量</strong>：类型和作用域（管脚不一样，同颜色对同颜色就可以了）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111164800906.png"></p><p><strong>语句和表达式</strong></p><p><strong>Control Flow</strong></p><p><strong>函数</strong>：input，body和return</p><p><strong>类</strong>：蓝图本身就是一个类</p><p><strong>debug</strong>：直接可视化一步一步走</p><h2 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h2><p><strong>Character</strong></p><p>各种复杂的状态</p><p><strong>Control</strong></p><p>处理各种输入设备</p><p>细节很多，比如会自动锁定，反馈，多态的输入</p><p><strong>Camera</strong></p><p>不能穿墙</p><p>Camera Effect</p><p>Cmmera Manager:会有很多不同视角的相机</p><h2 id="寻路（Navigation）"><a href="#寻路（Navigation）" class="headerlink" title="寻路（Navigation）"></a>寻路（Navigation）</h2><p>地图的表达；寻路；path smoothing</p><h3 id="表达的不同形式"><a href="#表达的不同形式" class="headerlink" title="表达的不同形式"></a>表达的不同形式</h3><p><strong>路点网络</strong></p><p>类似地铁，但是每次地图变化也改变路网的图，而且npc很容易往中间走</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112094034081.png"></p><p><strong>Grid</strong></p><p>障碍物可以自动更新，类似于光栅化的方式；</p><p>存储空间可能比较浪费；而且很难表达3d的层叠结构（桥上桥下）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%AF%BB%E8%B7%AF.gif" alt="动态更新"></p><p><strong>寻路网格（Navigation Mesh）</strong></p><p>需要用凸三多边形</p><p>寻路比较快，内存占用比较低。</p><p>生成比较复杂，且不支持3d空间</p><p><strong>八叉树</strong></p><p>可以表达3d空间</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112100838253.png"></p><h3 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h3><p>其实不管什么表达方式连接点都可以变成一张图</p><p><strong>dfs</strong></p><p><strong>bfs</strong></p><p><strong>Dijkstra算法</strong></p><p><strong>Astar</strong></p><p>navmesh里面直接用多边形相交边的中点的欧拉距离</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112102944686.png"></p><h3 id="Path-Smoothing"><a href="#Path-Smoothing" class="headerlink" title="Path Smoothing"></a>Path Smoothing</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112103423743.png"></p><p><strong>funnel算法</strong></p><p>从几何理解比较简单</p><ol><li>创建沿 A* 路径的portal（多边形交线）列表。确保每个portal的点相对于起点以相同的方式存储。您需要知道某个点是在起点的左侧还是右侧。</li><li>创建一个由三个点组成的“漏斗”：角色的起始位置（顶点）、portal的右侧和portal的左侧。</li><li>交替更新funnel的左右两侧，每次都使其变窄</li><li>当funnel的两侧交叉时，请注意不要更新新漏斗的顶点，并将其存储为平滑路径的一部分。</li></ol><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/Funnel-Algorithm.png" alt="Funnel-Algorithm"></p><p>假如创建的funnel里面直接包含了终点，那么直接连过去就行</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112105406114.png"></p><h3 id="Navmesh-Generation"><a href="#Navmesh-Generation" class="headerlink" title="Navmesh Generation"></a>Navmesh Generation</h3><p><strong>voxelization（体素化）</strong></p><p>先体素化，然后标记出能通行的区域（通过高度差距），然后用洪水算法，从一个最深的点开始判断哪些是可达的，然后再根据这个生成多边形</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112110114138.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112105958036.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112110056936.png"></p><p>还可以给navmesh添加flag，比如水陆地，来实现复杂的寻路算法，习性不同的怪物会走不同的路，一般是直接在地图上放flag然后映射到navmesh上面。</p><p>tile：大的meshmp可以分隔成多个小的tilie，因为实际游戏中map可能会变</p><h2 id="转向系统"><a href="#转向系统" class="headerlink" title="转向系统"></a>转向系统</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113145756701.png"></p><p>需要更自然，先加速再匀速然后减速</p><h2 id="群体模拟"><a href="#群体模拟" class="headerlink" title="群体模拟"></a>群体模拟</h2><p>微观的方法，定义每个个体的规则</p><p>鱼群效果：远离、接近和跟随</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113153524365.png"></p><p>宏观</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113153730001.png"></p><p>两者结合，比如说蜂群，多个结合成一个小团体，有一个大趋势，然后团体内部每个个体有自己的规则</p><p>如何避免碰撞？</p><p>直接加斥力or方向场</p><p><strong>RVO</strong></p><p>计算别人的速度向量是否在自己的路径上，如果在路径上就各自调整速度向量</p><h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><p><strong>自身信息</strong></p><p>位置、HP</p><p>地形信息：寻路、战术信息、可交互物体、掩护点</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113155904232.png"></p><p>动态数据：影响力图，动态寻路数据、视线图、游戏中的object（它身上的各种信息）</p><p>视觉感知、听觉感知</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113161310624.png"></p><p>状态太多就不好处理，可以分层，但是不太好飞线</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113161458366.png"></p><h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h3><p><strong>Sequence</strong></p><p>所有子节点依次执行，每个都要执行</p><p><strong>Selector</strong></p><p>一直试，直到某个节点成功完成</p><p><strong>Parallel</strong></p><p>同时执行所有节点</p><p>比如一边走向目标一边开枪</p><p><strong>Decorator</strong></p><p>有各种判断条件，以及loop，time这种</p><p><strong>Blackboard</strong></p><p>行为树的各个节点直接互相通信，存储一些变量</p><p>没有目标，只是遇到情况就来判断做什么</p><h3 id="层次任务网络（HTN）"><a href="#层次任务网络（HTN）" class="headerlink" title="层次任务网络（HTN）"></a>层次任务网络（HTN）</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224202070.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224616620.png"></p><p>首先要定义task：primitive task（原子性任务），要有前置条件，动作和产生影响（effect）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224904756.png" alt="解毒"></p><p>复合任务：会有多个条件，根据优先级哪个满足做哪个，类似行为树的selector，method也可以是复合行为，类似行为树的sequence。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225317501.png" alt="两种选择"></p><p><strong>HTN Domain</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225410417.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225428214.png" alt="简单小怪逻辑"></p><p><strong>Planning</strong></p><p>根据world state的各种propety，来选择做哪个method，计划的时候根据当前的world state来做假设，拷贝一份，但是会假设能做的action都能成功，这里是有可能会有问题的。</p><p><strong>Replan</strong></p><p>计划失败了需要计划</p><p>会更快，plan会有长期影响</p><p>行为是不可预测的，会对本身world state有状态变化</p><h3 id="目标导向行为规划（GOAP）"><a href="#目标导向行为规划（GOAP）" class="headerlink" title="目标导向行为规划（GOAP）"></a>目标导向行为规划（GOAP）</h3><p>多了一个目标集，HTN里面只是写在了注释里面</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114101310541.png"></p><p>goal会有precondition和目标state</p><p>Action加了一个cost，比如路径的远近，风险，这个需要策划凭借经验来填</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114102906359.png"></p><p>state满足的情况下，cost要尽可能地小</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114104334074.png"></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h1 id="面向数据编程和任务系统"><a href="#面向数据编程和任务系统" class="headerlink" title="面向数据编程和任务系统"></a>面向数据编程和任务系统</h1><h1 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h1><h1 id="Nanite"><a href="#Nanite" class="headerlink" title="Nanite"></a>Nanite</h1>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【UE官方培训】Sequence相关</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>动画</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107192455758.png"></p><p>MAYA导出FBX有许多需要注意的地方</p><p>模型的旋转，采样率</p><p>MAYA中起始帧需要是0</p><p>UE动画曲线默认是线性，MAYA是曲线，这个得改，不然时间数值对不上</p><p>如果不想改MAYA的这个曲线，就得增加UE的采样率（缺点是会增加内存）</p><p>UE动画数学是单精度浮点数，但是MAYA是双精度浮点数..</p><p>UE会自动压缩，可以关闭或者采用压缩破坏最小的选项</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107233622228.png"></p><p><strong>最佳实践</strong>总结如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234310586.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234405315.png"></p><p><strong>具体分类</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234511264.png"></p><p>Live Link插件</p><p>可以实时更新动画数据，达到所见即所得的工作体验。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234724416.png"></p><p>Sequence其实就是时间和变量的对应，组织方式如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108093831342.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113220499.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113227088.png"></p><p>用场（levelSequence）、次（take）来管理不同的Sequence</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113508355.png"></p><ul><li>长期存在的，总是会被镜头拍到的，比如建筑、地形（可理解为静态模型），这种最好是可控制对象绑定在Sequence里面，如果是一些特定时间在存在的，可以直接变成可生成对象。</li><li>毛发可以先预先浏览，再导入精确的</li><li>如何管理可见性：1.关卡可见性轨道 2.蓝图里面有函数和事件可以卸载和加载关卡，缺点是不够直观 3.世界分区，将整个关卡放在一个大的关卡，可以自动加载和卸载</li><li>白模和资产制作可以并行制作，因为资源都是引用，后期再替换就可以了</li><li><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108115515103.png"></li></ul><p>如何用c++ Add Track？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加一个新的 Track</span><br><span class="hljs-function">FMovieSceneTrack* <span class="hljs-title">AddNewTrack</span><span class="hljs-params">(ULevelSequence* Sequence, UClass* TrackClass, FName TrackName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取 MovieScene</span><br>    UMovieScene* MovieScene = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>();<br>    <br>    <span class="hljs-comment">// 创建新的 Track</span><br>    FMovieSceneTrackMetaData MetaData;<br>    MetaData.DisplayName = FText::<span class="hljs-built_in">FromName</span>(TrackName);<br>    <br>    FMovieSceneTrack* NewTrack = MovieScene-&gt;<span class="hljs-built_in">AddTrack</span>(TrackClass, MetaData);<br>    <br>    <span class="hljs-keyword">return</span> NewTrack;<br>&#125;<br><br><span class="hljs-comment">// 使用示例 - 添加一个 Transform Track</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformTrack</span><span class="hljs-params">(ULevelSequence* Sequence, AActor* TargetActor)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 确保序列和Actor都有效</span><br>    <span class="hljs-keyword">if</span> (!Sequence || !TargetActor)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Transform Track</span><br>    FMovieSceneTrack* TransformTrack = <span class="hljs-built_in">AddNewTrack</span>(<br>        Sequence, <br>        UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(),<br>        <span class="hljs-built_in">FName</span>(*FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;%s Transform&quot;</span>), *TargetActor-&gt;<span class="hljs-built_in">GetName</span>()))<br>    );<br><br>    <span class="hljs-comment">// 绑定 Actor</span><br>    FGuid ObjectBinding = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddPossessable</span>(<br>        TargetActor-&gt;<span class="hljs-built_in">GetActorLabel</span>(), <br>        TargetActor-&gt;<span class="hljs-built_in">GetClass</span>()<br>    );<br>    <br>    <span class="hljs-comment">// 将 Track 添加到绑定对象</span><br>    Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddTrack</span>(UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(), ObjectBinding);<br>&#125;<br></code></pre></td></tr></table></figure><p>常见的 Track 类型包括:</p><p>UMovieScene3DTransformTrack - 变换轨道</p><p>UMovieSceneFloatTrack - 浮点值轨道</p><p>UMovieSceneEventTrack - 事件轨道</p><p>UMovieSceneAudioTrack - 音频轨道</p><p>UMovieSceneCameraAnimTrack - 相机动画轨道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加关键帧示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformKeyframe</span><span class="hljs-params">(UMovieScene3DTransformTrack* TransformTrack, FFrameNumber TimeFrame, FTransform Transform)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (UMovieScene3DTransformSection* Section = <span class="hljs-built_in">Cast</span>&lt;UMovieScene3DTransformSection&gt;(TransformTrack-&gt;<span class="hljs-built_in">CreateNewSection</span>()))<br>    &#123;<br>        TransformTrack-&gt;<span class="hljs-built_in">AddSection</span>(*Section);<br>        Section-&gt;<span class="hljs-built_in">AddKey</span>(TimeFrame, Transform);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【UE官方培训】UE渲染管线介绍</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>【[官方培训]01-实时渲染基础上 | 陈拓 Epic】 <a href="https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&amp;vd_source=5d07d04eb2516df147034367e7af6fd2</a></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106223718712.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224045881.png"></p><h1 id="渲染前准备"><a href="#渲染前准备" class="headerlink" title="渲染前准备"></a>渲染前准备</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224513490.png"></p><p>会有多个线程在跑，游戏线程、渲染线程和GPU线程，这样流水线的走，如果比较理想，就是稳定30帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224728083.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224816969.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224858383.png"></p><p><strong>距离</strong></p><p>距离阈值(Desired Max draw distance)</p><p>如果不想对每一个物体都设置这个距离，可以用Cull Distance Volume，包围的东西都会应用culling，可以设置size和distance，是一个数组，比如0-500size的东西应用一个culling，500-10000的又应用一个culling</p><p>如果想某些不被剔除可以用Never distance Cull，或者勾掉那个volume</p><p><strong>视锥</strong></p><p>这个很好理解，也就是在相机里面才会渲染</p><p>可以用FreezeRendering来跳出观察</p><p>ToggleDebugCamera</p><p><strong>预计算可见性</strong></p><p>Precomputed Visibility Volume</p><p>然后得编译一下，Compile-&gt;Precompute Static Visibility</p><p>要用这个得在Setting里面开启Precompute Visibility</p><p><strong>遮挡剔除</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106233936337.png"></p><h1 id="几何体渲染"><a href="#几何体渲染" class="headerlink" title="几何体渲染"></a>几何体渲染</h1><p>通过以上的步骤，可以拿到该被渲染的物体列表，但是如果直接渲染，会造成一些像素重复绘制，所以需要找出哪些模型应该先被渲染。</p><p>Early Z：GPU驱动会在执行像素着色器前先检查改点深度，提前跳过不符合条件的像素。为了利用这个特性，可以开启Prepass，提前把深度写入buffer里面，可以加快速度。</p><p>Drawcall：绘制拥有相同属性的一组多边形。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235242724.png"></p><p>不同的材质会不同的drawcall（*2是因为有earlyz）</p><p>切换材质影响性能开销，GPU渲染时，引擎会根据材质对物体进行排序，相同材质的会在同一个批次里绘制。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235428006.png"></p><p>stat RHI命令可以查看drawcall数量</p><p>drawcall数量比三角形数量更影响性能。</p><p>引擎有一些基础的drawcall开销</p><p>降低drawcall方法：</p><p><strong>模型合并（Merge Actor）</strong>，但是有副作用：</p><p>遮挡检测性能更差（因为合批模型会变大）</p><p>计算碰撞性能更差（合并之后更大）</p><p>占用更大内存</p><p><strong>Modular Meshes</strong></p><p><strong>Instanceing</strong>（只针对相同模型 ）</p><p><strong>Level Of Detail(LOD)和HLOD</strong></p><p>降低模型面数</p><p>合并模型假如有多个材质还是会多个drawcaal，可以考虑合并材质</p><p>调试可以用Render Doc插件，来看详细的DrawCall信息</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000456448.png"></p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><h3 id="VertexShader"><a href="#VertexShader" class="headerlink" title="VertexShader"></a>VertexShader</h3><p>1.坐标转换（局部空间-&gt;世界空间-&gt;投影空间）</p><p>2.顶点着色</p><p>3.应用世界坐标偏移（WPO）：鸟、水体、飘动的草（<strong>顶点动画</strong>）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000703048.png" alt="image-20250107000703048"></p><p>VS并不直接修改模型，只是视觉上的效果，CPU无法察觉VS的修改，所以物理和碰撞都不会发生变化。</p><p>动画越复杂、顶点越多性能越慢</p><p>对远距离的物体应该禁用顶点动画（反正也看不到）</p><p>对高精度的模型应该应用简单的VS</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001225370.png"></p><h1 id="光栅化和G-Buffer"><a href="#光栅化和G-Buffer" class="headerlink" title="光栅化和G-Buffer"></a>光栅化和G-Buffer</h1><p>经过这些之后，可以得到每个顶点在屏幕上的坐标</p><p>因为硬件问题，计算一个像素还需要计算周边2*2的像素，所以会造成overShading</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001502973.png"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001803628.png"></p><p>因为法向是归一化，所以只需要知道两个就够了</p><p>采用mipmap，会让内存变大1.3倍（一直1&#x2F;4)，但是会清晰很多(远处的物体也能平均取到)</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002050255.png"></p><h1 id="像素着色器和材质"><a href="#像素着色器和材质" class="headerlink" title="像素着色器和材质"></a>像素着色器和材质</h1><p>Pixel shader，实现光照、雾这些效果</p><p>UE里面会有一个连线的材质器，然后会自动转成不同平台的shader语言嵌入进去</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002941208.png"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>反射捕获</strong></p><p>Reflection Capture</p><p>cubemap，预先计算，但是不太准确，而且分辨率会影响反射效果</p><p><strong>屏幕空间反射</strong></p><p>默认开启，准确，有噪点，只会反射能看到的物体（根据G-Buffer算出来的）</p><p><strong>平面反射</strong></p><p>Planar Reflection</p><p>适合需要精确反射的表面（镜子）</p><p>其实就是相机换了一个位置，重新渲染了一遍，所以比较损耗性能，但是比较精确。</p><p>Lumen</p><p>RT Reflection</p><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093512026.png"></p><h2 id="静态光照"><a href="#静态光照" class="headerlink" title="静态光照"></a>静态光照</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093736129.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093830617.png"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250107094207091.png"></p><p>UE里面生成lightmap用lightmass</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107100807363.png"></p><h2 id="动态光照"><a href="#动态光照" class="headerlink" title="动态光照"></a>动态光照</h2><h3 id="动态阴影"><a href="#动态阴影" class="headerlink" title="动态阴影"></a>动态阴影</h3><p><strong>常规动态阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107102137758.png"></p><p>以光的视角作为摄像机渲染，能看到的就会被点亮 </p><p>把需要渲染的物体在光源的矩阵下转换，然后计算深度，如果前面有东西挡住了，就说这里是阴影</p><p><strong>级联阴影</strong></p><p>因为普通的阴影只有一张map，级联阴影就是分隔了多个视锥，然后叠加</p><p><strong>逐对象阴影</strong></p><p>固定光源，对每个对象都生成阴影</p><p><strong>距离场阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107170233535.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174700602.png"></p><h2 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h2><p>UE5全新的全局光照，有一些新特性</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174936082.png"></p><p>Color Bleeding：物品本身颜色对周围光照的影响</p><p>Soft indirect shadow:间接软阴影，当前帧和前几帧的混合</p><h1 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h1><p>延迟渲染难以处理半透明材质，可以考虑在前向渲染管线渲染</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183709373.png"></p><h1 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183752385.png"></p><p>自带的效果，Post Process Volume（可以设置为无限大）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107184011328.png"></p><h1 id="实时Ray-Tracing"><a href="#实时Ray-Tracing" class="headerlink" title="实时Ray Tracing"></a>实时Ray Tracing</h1><h1 id="性能调试"><a href="#性能调试" class="headerlink" title="性能调试"></a>性能调试</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107185002691.png"></p>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-Ts语法相关</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="TS基础写法"><a href="#TS基础写法" class="headerlink" title="TS基础写法"></a>TS基础写法</h1><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">PlayStateCheckHandle</span>: <span class="hljs-title class_">TimerHandle</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>|表示联合类型，表示既可以是TimerHandle也可以是undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Proto</span><span class="hljs-attr">_Nodes</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">IProto_NodeInfo</span> &#125;;<br></code></pre></td></tr></table></figure><p> 表示一个索引签名（index signature），用于定义一个对象类型，其中键（key）是字符串类型，而值（value）是 <code>Aki.Protocol.IProto_NodeInfo</code> 类型</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长参数</p><p>…args</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">first: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First argument is <span class="hljs-subst">$&#123;first&#125;</span>`</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);  <span class="hljs-comment">// 输出: First argument is 1, hello, world, !</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，函数内部创建的局部变量确实可以返回并在函数外部被直接修改，但这通常适用于可变类型（mutable types），如对象（包括 <code>Map</code>、<code>Set</code>、数组等）和函数。对于不可变类型（immutable types），如原始数据类型（数字、字符串、布尔值等），则不能直接修改。</p><p><strong>可变类型：</strong></p><p>当函数返回一个可变类型的值时，实际上返回的是这个值的引用（reference）。因此，通过这个引用所做的任何修改都会反映到原始对象上。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">复制function createObject() &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-keyword">prop</span>: 1 &#125;;<br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回对象的引用</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = createObject();<br>myObj.<span class="hljs-keyword">prop</span> = 2; <span class="hljs-comment">// 直接修改了 createObject 函数内部创建的对象</span><br>console.<span class="hljs-built_in">log</span>(myObj.<span class="hljs-keyword">prop</span>); <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><p>这个是因为看的时候看到一段对我来说比较吊诡的代码，在一个私有函数创建了一个map(nodes)，直接set到了另一个map(NodesGroupByStatus)里面，但是直接返回nodes，在另一个函数里面可以直接修改，后面查了才知道，ts如果返回maps这种可修改的变量相当于返回的是引用，所以就是改的原始的nodes</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">AddNodeGroup</span>(<span class="hljs-attr">group</span>: <span class="hljs-title class_">ENodeGroup</span>): <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt;();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">NodesGroupByStatus</span>!.<span class="hljs-title function_">set</span>(group, nodes);<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">AddNodeToStatusGroup</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TBehaviorNode</span>, <span class="hljs-attr">newStatus</span>: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">Proto_NodeStatus</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> groupId = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetGroupIdByStatus</span>(newStatus);<br>    <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetNodesByGroupId</span>(groupId);<br>    <span class="hljs-keyword">if</span> (!nodes) &#123;<br>        nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">AddNodeGroup</span>(groupId);<br>    &#125;<br><br>    nodes.<span class="hljs-title function_">set</span>(node.<span class="hljs-property">NodeId</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>继承extends</p><p><strong>super关键字</strong></p><ol><li><strong>调用父类构造函数</strong>：当你定义一个子类时，如果需要调用其父类的构造函数，可以使用 <code>super()</code>。这是必须的步骤，因为子类的实例在JavaScript&#x2F;TypeScript中总是通过父类的构造函数创建的。</li><li><strong>访问父类成员</strong>：<code>super</code> 也可以用来访问父类中定义的属性和方法，这在你想要扩展或重写父类成员时非常有用。</li><li><strong>访问父类的静态成员</strong>：使用 <code>super</code> 关键字，也可以访问父类的静态属性或方法</li><li><strong>在构造函数中</strong>：在构造函数中使用 <code>super</code> 必须作为第一条语句，因为子类实例的创建是基于父类构造函数的。</li><li><strong>在派生类的静态方法中</strong>：在静态方法中使用 <code>super</code> 来访问父类的静态成员。</li><li><strong>在派生类的方法中</strong>：在非静态方法中使用 <code>super</code> 来访问父类的非静态成员。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>1.基础泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 不使用泛型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnString</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnNumber</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型</span><br><span class="hljs-keyword">function</span> returnItem&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> str = returnItem&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 类型为 string</span><br><span class="hljs-keyword">const</span> num = returnItem&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 类型为 number</span><br><span class="hljs-keyword">const</span> bool = <span class="hljs-title function_">returnItem</span>(<span class="hljs-literal">true</span>);            <span class="hljs-comment">// 类型推断为 boolean</span><br></code></pre></td></tr></table></figure><p>2.泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义一个泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">value</span>: T;<br>    <span class="hljs-title function_">getValue</span>(): T;<br>&#125;<br><br><span class="hljs-comment">// 实现泛型接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">number</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBox</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">const</span> numberBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberBox</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>3.泛型约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用extends关键字约束泛型类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasLength</span> &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> logLength&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HasLength</span>&gt;(<span class="hljs-attr">value</span>: T): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">// 可以使用的类型</span><br><span class="hljs-title function_">logLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>);          <span class="hljs-comment">// 字符串有length属性</span><br><span class="hljs-title function_">logLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);       <span class="hljs-comment">// 数组有length属性</span><br><span class="hljs-title function_">logLength</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> &#125;);   <span class="hljs-comment">// 对象有length属性</span><br><br><span class="hljs-comment">// 会报错，因为number没有length属性</span><br><span class="hljs-comment">// logLength(42);  // Error</span><br></code></pre></td></tr></table></figure><p>4.多个类型参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 键值对映射</span><br><span class="hljs-keyword">function</span> getPair&lt;K, V&gt;(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): &#123; <span class="hljs-attr">key</span>: K; <span class="hljs-attr">value</span>: V &#125; &#123;<br>    <span class="hljs-keyword">return</span> &#123; key, value &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> pair1 = getPair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">const</span> pair2 = <span class="hljs-title function_">getPair</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);  <span class="hljs-comment">// 类型推断</span><br></code></pre></td></tr></table></figure><p>5.泛型类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStorage</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: T[] = [];<br><br>    <span class="hljs-title function_">addItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br><br>    <span class="hljs-title function_">removeItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">indexOf</span>(item);<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">getItems</span>(): T[] &#123;<br>        <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> textStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [&quot;Hello&quot;, &quot;World&quot;]</span><br><br><span class="hljs-keyword">const</span> numberStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">10</span>);<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [10, 20]</span><br></code></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>一开始看这个OnUpdate的时候非常懵逼</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">OnUpdate</span>(<span class="hljs-attr">newUpdate</span>: $Undefinable&lt;$Delegate&lt;<span class="hljs-function">(<span class="hljs-params">InProgress: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt;) : $Undefinable&lt;<span class="hljs-title class_">LTweener</span>&gt;;    <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnTick</span>(<span class="hljs-attr">deltaTime</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> tween = <span class="hljs-variable language_">this</span>.<span class="hljs-property">TextPlayTweenComp</span>!.<span class="hljs-title class_">GetPlayTween</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">LGUIPlayTween_Int</span>;<br>        <span class="hljs-keyword">const</span> tweener = tween?.<span class="hljs-title class_">GetTweener</span>();<br>        <span class="hljs-keyword">if</span> (tweener) &#123;<br>            tweener.<span class="hljs-title class_">OnUpdate</span>(<br>                <span class="hljs-title function_">toManualReleaseDelegate</span>((<span class="hljs-attr">progress</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">const</span> pro = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(progress * (tween.<span class="hljs-property">to</span> - tween.<span class="hljs-property">from</span>)) + tween.<span class="hljs-property">from</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> &lt; pro) &#123;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> = pro;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Text</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span>));<br>                    &#125;<br>                &#125;),<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>类型断言，有点类似其他语言的类型转换，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>const id &#x3D; a ? b : c;</p><p>条件 ? 表达式1 : 表达式2</p><ul><li>如果 <code>条件</code>（在这里是变量 <code>a</code>）为真（truthy），那么整个表达式的结果是 <code>表达式1</code>（在这里是变量 <code>b</code>）。</li><li>如果 <code>条件</code> 为假（falsy），那么结果是 <code>表达式2</code>（在这里是变量 <code>c</code>）。</li></ul><h3 id="x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</h3><ol><li><strong>严格等于 (<code>===</code>)</strong>:<ul><li><code>===</code> 是严格等于运算符，它比较两个值是否完全相等，包括它们的类型。</li><li>如果两个操作数的类型不同，<code>===</code> 返回 <code>false</code>。</li><li>只有当两个操作数的类型和值都相同时，<code>===</code> 才返回 <code>true</code>。</li></ul></li><li><strong>等于 (<code>==</code>)</strong>:<ul><li><code>==</code> 是等于运算符，它比较两个值是否等价。</li><li>如果操作数的类型不同，JavaScript 会进行类型转换，然后再比较它们的值。</li><li><code>==</code> 会根据需要将操作数转换为数字或字符串，然后进行比较。</li></ul></li><li>!&#x3D;&#x3D;</li></ol><p>​不相等，但是不会进行类型转换</p><h3 id="和"><a href="#和" class="headerlink" title="?.和!."></a>?.和!.</h3><p><code>!</code> 被称为非空断言操作符，它用来告诉 TypeScript 编译器，某个位置的值不应该为 <code>null</code> 或 <code>undefined</code>。</p><p>?.是一种语法糖， 如果多层访问中间有null或者undefined就会返回undefined，不用自己再另写类型检查</p><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>表示调用这个对象或者参数的时候这个参数可选</p><h3 id="-1"><a href="#-1" class="headerlink" title="??"></a>??</h3><p>逻辑运算符，用于返回两个操作数中第一个非空值（non-nullish value），或者在两个操作数都为空值（null 或 undefined）时返回右侧的操作数。</p><h1 id="UE4容器使用"><a href="#UE4容器使用" class="headerlink" title="UE4容器使用"></a>UE4容器使用</h1><h2 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/">TArray：虚幻引擎中的数组 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h3 id="创建和填充"><a href="#创建和填充" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建</span><br>TArray&lt;int32&gt; IntArray;<br><br><span class="hljs-comment">// 填充</span><br>IntArray.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 等价于下面</span><br><span class="hljs-comment">// IntArray = [10, 10, 10, 10, 10]</span><br><br><span class="hljs-comment">// 在末尾增加用Add或者Emplace</span><br><span class="hljs-comment">// Add会创建一个新实例，Emplace不会</span><br><br>TArray&lt;FString&gt; StrArr;<br>StrArr.<span class="hljs-built_in">Add</span>    (<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>StrArr.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;]</span><br><br><span class="hljs-comment">// 利用 Append 可一次性添加其他 TArray 中的多个元素</span><br><br>FString Arr[] = &#123; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;of&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Tomorrow&quot;</span>) &#125;;<br>StrArr.<span class="hljs-built_in">Append</span>(Arr, <span class="hljs-built_in">ARRAY_COUNT</span>(Arr));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;]</span><br><br><span class="hljs-comment">// 仅在尚不存在等值元素时， AddUnique 才会向容器添加新元素。</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;,&quot;!&quot;]</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr is unchanged as &quot;!&quot; is already an element</span><br><br><span class="hljs-comment">// Insert</span><br><br>StrArr.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Brave&quot;</span>), <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// SetNum,如新数量大于当前数量，则使用元素类型的默认构造函数新建元素</span><br><span class="hljs-comment">// 如新数量小于当前数量， SetNum 将移除元素。</span><br><br><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ranged-for</span><br>FString JoinedStr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; Str :StrArr)<br>&#123;<br>    JoinedStr+=Str;<br>&#125;<br><br><span class="hljs-comment">// 直接for循环</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index != StrArr.<span class="hljs-built_in">Num</span>(); ++Index)<br>&#123;<br>    JoinedStr += StrArr[Index];<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 数组迭代器:CreateIterator读写；CreateConstIterator只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> It = StrArr.<span class="hljs-built_in">CreateConstIterator</span>();It;++It)<br>&#123;<br>    JoinedStr += *It;<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Sort，基于快排</span><br><span class="hljs-comment">// HeapSort，堆排序</span><br><span class="hljs-comment">// StableSort，基于归并排序，可以保证等值元素的相对顺序，上面两个无法保证</span><br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Num，查询数量</span><br><br><span class="hljs-comment">// GetData,返回指针元素</span><br><br><span class="hljs-comment">// Contains，查询是否包含特定元素</span><br><br><span class="hljs-comment">// ContainsByPredicate,可自己写规则</span><br><br><span class="hljs-type">bool</span> bHello   = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-type">bool</span> bGoodbye = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>));<br><span class="hljs-comment">// bHello   == true</span><br><span class="hljs-comment">// bGoodbye == false</span><br><br><span class="hljs-type">bool</span> bLen5 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">5</span>;<br>&#125;);<br><span class="hljs-type">bool</span> bLen6 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">6</span>;<br>&#125;);<br><span class="hljs-comment">// bLen5 == true</span><br><span class="hljs-comment">// bLen6 == false</span><br><br><span class="hljs-comment">// Find，返回找到的第一个元素的索引</span><br><span class="hljs-comment">// FindLast,范围找到的最后一个元素的索引</span><br>int32 IndexLast;<br><span class="hljs-keyword">if</span> (StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>), IndexLast))<br>&#123;<br>    <span class="hljs-comment">// IndexLast == 3, because there aren&#x27;t any duplicates</span><br>&#125;<br><br><span class="hljs-comment">// 上面时返回布尔值，也可以直接返回索引，未找到时INDEX_NONE</span><br>int32 Index2     = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexLast2 = StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexNone  = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><span class="hljs-comment">// Index2     == 3</span><br><span class="hljs-comment">// IndexLast2 == 3</span><br><span class="hljs-comment">// IndexNone  == INDEX_NONE</span><br><br><span class="hljs-comment">// IndexOfByKey</span><br><span class="hljs-comment">// IndexOfByPredicate</span><br><br><span class="hljs-comment">// FilterByPredicate可以直接找到匹配的元素数组</span><br><span class="hljs-keyword">auto</span> Filter = StrArray.<span class="hljs-built_in">FilterByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> !Str.<span class="hljs-built_in">IsEmpty</span>() &amp;&amp; Str[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&#x27;M&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除所有提供元素等值的元素</span><br><span class="hljs-comment">// RemoveSingle,移除首个匹配元素</span><br><span class="hljs-comment">// RemoveAt，移除特定位置元素</span><br><span class="hljs-comment">// RemoveAll,可以自己定义规则</span><br><br><br><span class="hljs-comment">// 如果不需要保证排序，可以用下面的来加快速度</span><br><span class="hljs-comment">// RemoveSwap,RemoveAtSwap,RemoveAllSwap</span><br><br><span class="hljs-comment">// Empty 清空</span><br></code></pre></td></tr></table></figure><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// +=，串联</span><br><br><span class="hljs-comment">// MoveTemp，移动语义，清空源数组</span><br>ValArr3 = <span class="hljs-built_in">MoveTemp</span>(ValArr4);<br><span class="hljs-comment">// ValArr3 == [5,2,3,1,2,3]</span><br><span class="hljs-comment">// ValArr4 == []</span><br><br><span class="hljs-comment">// == 和 != 进行比较，必须排序和数量都一样</span><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h2 id="TMap"><a href="#TMap" class="headerlink" title="TMap"></a>TMap</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">TMap | 虚幻引擎4.27文档 (unrealengine.com)</a></p><p>TMap键不能重复，TMultiMap键不唯一</p><h3 id="创建和填充-1"><a href="#创建和填充-1" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TMap&lt;int32, FString&gt; FruiMap;<br><br><span class="hljs-comment">// 填充都一样，但是要是填重复的键会覆盖之前的值</span><br><br></code></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>类似TArrays，不过迭代元素是TPair</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains来查询是否包含特定键</span><br><br><span class="hljs-comment">// Find，失败返回null</span><br><br><span class="hljs-comment">// FindOrAdd，不存在该键会新创建一个元素</span><br><br><span class="hljs-comment">// FindRef，没找到会返回默认值，不会创建新元素</span><br><br>FString&amp; Ref7 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// Ref7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;</span><br><span class="hljs-comment">// ]</span><br>FString&amp; Ref8 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// Ref8     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br>FString Val7 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">7</span>);<br>FString Val6 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// Val7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// Val6     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// FindKey，按值查找</span><br></code></pre></td></tr></table></figure><h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除对应键的元素</span><br>FruitMap.<span class="hljs-built_in">Remove</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// FindAndRemoveChecked，移除元素并返回该值</span><br>FString Removed7 = FruitMap.<span class="hljs-built_in">FindAndRemoveChecked</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// RemoveAndCopyValue 函数的作用与 Remove 相似，不同点是会将已移除元素的值复制到引用参数</span><br>FString Removed;<br><span class="hljs-type">bool</span> bFound2 = FruitMap.<span class="hljs-built_in">RemoveAndCopyValue</span>(<span class="hljs-number">2</span>, Removed);<br><br><span class="hljs-comment">// Empty和Reset，清空</span><br></code></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KeySort或者ValueSort</span><br>FruitMap.<span class="hljs-built_in">KeySort</span>([](int32 A, int32 B) &#123;<br>    <span class="hljs-keyword">return</span> A &gt; B; <span class="hljs-comment">// sort keys in reverse</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h3><p>有复制和移动语义</p><h3 id="Slack-1"><a href="#Slack-1" class="headerlink" title="Slack"></a>Slack</h3><h3 id="KeyFuncs"><a href="#KeyFuncs" class="headerlink" title="KeyFuncs"></a>KeyFuncs</h3><h2 id="TSet"><a href="#TSet" class="headerlink" title="TSet"></a>TSet</h2><h1 id="UE4回调"><a href="#UE4回调" class="headerlink" title="UE4回调"></a>UE4回调</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/">委托 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate - 知乎 (zhihu.com)</a></p><p>UE支持三种委托：单点委托，组播委托（事件），动态委托</p><h3 id="单点委托"><a href="#单点委托" class="headerlink" title="单点委托"></a>单点委托</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><h3 id="动态委托"><a href="#动态委托" class="headerlink" title="动态委托"></a>动态委托</h3><h1 id="UE4对象函数"><a href="#UE4对象函数" class="headerlink" title="UE4对象函数"></a>UE4对象函数</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Functions/">UFunctions | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h1 id="UE4引用"><a href="#UE4引用" class="headerlink" title="UE4引用"></a>UE4引用</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/ReferencingAssets/">引用资源 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/ReferenceAssets/">引用 Actor | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnLhvL7EdoiVzOhE8P2cjTCh">UE引用类型说明 - 飞书云文档 (feishu.cn)</a></p><p>引用分为两种，硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载；软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。</p><p>一种是通过UPROPERTY</p><p><strong>直接属性引用</strong></p><p>通过设置变量的UPROPERTY直接在编辑器设置对应资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** construction start sound stinger */</span><br><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Building)<br><br>USoundCue* ConstructionStartStinger;<br></code></pre></td></tr></table></figure><p><strong>构造时引用</strong></p><p>构造时加载对应资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/** gray health bar texture */</span><br><br><span class="hljs-constructor">UPROPERTY()</span><br><br><span class="hljs-keyword">class</span> UTexture2D* BarFillTexture;<br><br>AStrategyHUD::<span class="hljs-constructor">AStrategyHUD(<span class="hljs-params">const</span> FObjectInitializer&amp; ObjectInitializer)</span> :<br>    <span class="hljs-constructor">Super(ObjectInitializer)</span><br>&#123;<br>    static ConstructorHelpers::FObjectFinder&lt;UTexture2D&gt; <span class="hljs-constructor">BarFillObj(TEXT(<span class="hljs-string">&quot;/Game/UI/HUD/BarFill&quot;</span>)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>BarFillTexture = BarFillObj.Object;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>一种是用字符串来引用，如果UObject已经加载就用FindObject&lt;&gt;()，没有加载就使用LoadObject&lt;&gt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AFunctionalTest* TestToRun = <span class="hljs-built_in">FindObject</span>&lt;AFunctionalTest&gt;(TestsOuter, *TestName);<br>GridTexture = <span class="hljs-built_in">LoadObject</span>&lt;UTexture2D&gt;(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/EngineMaterials/DefaultWhiteGrid.DefaultWhiteGrid&quot;</span>), <span class="hljs-literal">NULL</span>, LOAD_None, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h1 id="UE4FName"><a href="#UE4FName" class="headerlink" title="UE4FName"></a>UE4FName</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/">FName | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p>在 <strong>内容浏览器</strong> 中为新资源命名时，变更动态材质实例中的参数或访问骨骼网格体中的一块骨骼时需要使用 <strong>FNames</strong> 。 FName 通过一个轻型系统使用字符串。在此系统中，特定字符串即使会被重复使用，在数据表中也只存储一次。</p><p>FNames 不区分大小写。它们为不可变，无法被操作。FNames 的存储系统和静态特性决定了通过键进行 FNames 的查找和访问速度较快。 FName 子系统的另一个功能是使用散列表为 FName 转换提供快速字符串。</p><p>FNames 不区分大小写，作为索引组合存储在唯一字符串和实例编号的表格中。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName TestName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Test&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FMame到FString</span><br>TestString = TestName.<span class="hljs-built_in">ToSring</span>();<br><br><span class="hljs-comment">// FName到FText</span><br>TestText = FText::<span class="hljs-built_in">FromName</span>(TestName);<br><br><span class="hljs-comment">// Fstring和FText到Fname都不可靠，因为FName不区分大小写</span><br><br><span class="hljs-comment">// FString到FName</span><br>TestName = <span class="hljs-built_in">FName</span>(*TextString);<br><br><span class="hljs-comment">// FText无法直接到FName</span><br></code></pre></td></tr></table></figure><p>对比是否相同直接比较索引的数值，不用执行字符串的对比</p><h1 id="TS和Lua有什么区别"><a href="#TS和Lua有什么区别" class="headerlink" title="TS和Lua有什么区别"></a>TS和Lua有什么区别</h1><h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><p>优点：</p><p>1.静态类型系统</p><ul><li><p>在编译时进行类型检查</p></li><li><p>可以提前发现潜在错误</p></li><li><p>提供更好的代码提示和自动完成</p></li></ul><p>2.面向对象特性</p><ul><li><p>支持类、接口、泛型等现代OOP特性</p></li><li><p>继承和多态的实现更加完整</p></li></ul><p>3.JavaScript生态系统</p><ul><li><p>可以直接使用JavaScript的所有库和框架</p></li><li><p>与现代前端开发工具链完美集成</p></li><li><p>庞大的npm生态系统</p></li></ul><p>4.工具支持</p><ul><li><p>优秀的IDE支持（VS Code等）</p></li><li><p>强大的重构工具</p></li><li><p>详细的文档和类型定义</p></li></ul><p>缺点：</p><p>1.编译开销</p><ul><li><p>需要编译成JavaScript才能运行</p></li><li><p>构建过程可能较慢</p></li></ul><p>2.学习曲线</p><ul><li><p>类型系统较复杂</p></li><li><p>需要理解装饰器、泛型等概念</p></li></ul><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>1.轻量级</p><ul><li><p>解释器小巧（约200KB）</p></li><li><p>启动快速，内存占用少</p></li><li><p>易于嵌入其他程序</p></li></ul><p>2.性能</p><ul><li><p>LuaJIT提供极高的执行效率</p></li><li><p>垃圾回收效率高</p></li></ul><p>3.简单易学</p><ul><li><p>语法简洁清晰</p></li><li><p>核心概念少</p></li><li><p>学习曲线平缓</p></li></ul><p>4.嵌入性</p><ul><li><p>广泛用于游戏开发</p></li><li><p>适合作为脚本语言嵌入应用</p></li><li><p>容易与C&#x2F;C++集成</p></li></ul><p>缺点：</p><p>1.标准库较小</p><ul><li><p>内置功能相对有限</p></li><li><p>需要依赖第三方库实现复杂功能</p></li></ul><p>2.生态系统</p><ul><li><p>相比现代语言，生态系统较小</p></li><li><p>工具链不如主流语言完善</p></li></ul><p>3.面向对象支持</p><ul><li><p>没有原生的类支持</p></li><li><p>需要通过元表模拟OOP特性</p></li></ul><h1 id="不同类型变量"><a href="#不同类型变量" class="headerlink" title="不同类型变量"></a>不同类型变量</h1><p>值类型（按值传递）：</p><p>number</p><p>string</p><p>boolean</p><p>undefined</p><p>null</p><p>symbol</p><p>引用类型（按引用传递）：</p><p>Object</p><p>Array</p><p>Function</p><p>Date</p><p>RegExp</p><p>Map</p><p>Set</p><p>类实例</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-Lua的闭包</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/358423900">构建Lua解释器Part11：Upvalue - Manistein的文章 - 知乎</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-number">10</span>  <span class="hljs-comment">-- x是一个局部变量</span><br>    <br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment">-- x在这里就是一个upvalue</span><br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">return</span> inner<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> fn = outer()<br>fn()  <span class="hljs-comment">-- 输出10</span><br></code></pre></td></tr></table></figure><ol><li><p>x 是 outer 函数的局部变量，inner 函数引用了 x</p></li><li><p>x 对于 inner 来说就是一个 upvalue</p></li><li><p>Lua 会特殊处理这个 x，使其在 outer 函数结束后仍然存活</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-unity多线程原理相关</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity协程（Coroutine）原理详解"><a href="#Unity协程（Coroutine）原理详解" class="headerlink" title="Unity协程（Coroutine）原理详解"></a>Unity协程（Coroutine）原理详解</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>协程本质上是一个迭代器（Iterator），它利用了C#的迭代器模式和yield关键字。它不是真正的多线程，而是一种特殊的程序执行方式。</p><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><p>1.暂停和恢复</p><ul><li><p>当遇到yield语句时，协程会保存当前的执行状态</p></li><li><p>将控制权返回给Unity的主循环</p></li><li><p>在适当的时机恢复执行</p></li></ul><p>2.状态机</p><ul><li><p>编译器会将协程方法转换为一个状态机</p></li><li><p>每个yield语句对应一个状态</p></li><li><p>恢复执行时从上次的状态继续</p></li></ul><h2 id="2-执行时机"><a href="#2-执行时机" class="headerlink" title="2. 执行时机"></a>2. 执行时机</h2><p>Unity的执行循环：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Update循环：<br><span class="hljs-number">1.</span> Input Events<br><span class="hljs-number">2.</span> Update()<br><span class="hljs-number">3.</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> 的协程<br><span class="hljs-number">4.</span> <span class="hljs-function">Late <span class="hljs-title">Update</span>()</span><br><span class="hljs-function">5. 渲染</span><br></code></pre></td></tr></table></figure><p>不同yield指令的执行时机：</p><ul><li><p>yield return null - 下一帧Update之前</p></li><li><p>yield return new WaitForFixedUpdate() - 下一次物理更新时</p></li><li><p>yield return new WaitForEndOfFrame() - 当前帧渲染完成后</p></li><li><p>yield return new WaitForSeconds() - 基于Time.time计时</p></li></ul><h2 id="3-内部实现机制"><a href="#3-内部实现机制" class="headerlink" title="3. 内部实现机制"></a>3. 内部实现机制</h2><h3 id="状态机转换"><a href="#状态机转换" class="headerlink" title="状态机转换"></a>状态机转换</h3><p>当你写一个协程时：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">MyCoroutine</span>()</span> <br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会这样转换成类似的状态机</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-title">MyCoroutine</span>&gt;<span class="hljs-title">d__1</span> : <span class="hljs-title">IEnumerator</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">object</span> current;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MyCoroutine&gt;d__1(<span class="hljs-built_in">int</span> state) <br>    &#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> <br>    &#123;<br>        <span class="hljs-keyword">switch</span> (state) <br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>                current = <span class="hljs-keyword">new</span> WaitForSeconds(<span class="hljs-number">1f</span>);<br>                state = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>                state = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-literal">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current <br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> current; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h2><h3 id="协程的内存分配："><a href="#协程的内存分配：" class="headerlink" title="协程的内存分配："></a>协程的内存分配：</h3><p>1.状态机对象</p><ul><li><p>每次启动协程时创建</p></li><li><p>包含局部变量和执行状态</p></li></ul><p>2.YieldInstruction对象</p><ul><li><p>每个yield return语句可能创建新对象</p></li><li><p>可以通过缓存减少分配</p></li></ul><h3 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h3><p>1.创建：StartCoroutine调用时</p><p>2.运行：Unity主循环中调度</p><p>3.销毁：</p><ul><li><p>协程完成时</p></li><li><p>手动停止时</p></li><li><p>MonoBehaviour禁用时</p></li></ul><h2 id="5-调度机制"><a href="#5-调度机制" class="headerlink" title="5. 调度机制"></a>5. 调度机制</h2><p>Unity的协程调度器：</p><p>1.维护一个活动协程列表</p><p>2.每帧检查需要执行的协程</p><p>3.根据YieldInstruction类型决定执行时机</p><p>4.调用MoveNext()推进协程状态</p><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><p>1.Update前的协程</p><p>2.Update</p><p>3.Update后的协程</p><p>4.LateUpdate</p><p>5.帧结束时的协程</p><h2 id="6-限制和注意事项"><a href="#6-限制和注意事项" class="headerlink" title="6. 限制和注意事项"></a>6. 限制和注意事项</h2><h3 id="技术限制："><a href="#技术限制：" class="headerlink" title="技术限制："></a>技术限制：</h3><p>1.单线程执行</p><ul><li><p>所有协程在主线程运行</p></li><li><p>不能进行真正的并行处理</p></li></ul><p>2.状态保存</p><ul><li><p>只能保存基本的执行状态</p></li><li><p>不保存完整的调用栈</p></li></ul><p>3.异常处理</p><ul><li><p>try-catch块跨越yield语句时可能失效</p></li><li><p>需要特殊的错误处理机制</p></li></ul><h3 id="性能考虑："><a href="#性能考虑：" class="headerlink" title="性能考虑："></a>性能考虑：</h3><p>1.内存开销</p><ul><li><p>每个活动协程占用内存</p></li><li><p>yield指令可能产生垃圾回收</p></li></ul><p>2.CPU开销</p><ul><li><p>协程调度有额外开销</p></li><li><p>过多活动协程会影响性能</p></li></ul><h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>1.适合用协程的情况：</p><ul><li><p>需要随时间推移的操作</p></li><li><p>等待特定条件</p></li><li><p>分帧执行大量工作</p></li></ul><p>2.不适合用协程的情况：</p><ul><li><p>CPU密集型计算</p></li><li><p>需要真正并行的操作</p></li><li><p>关键性能代码</p></li></ul><h3 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h3><p>1.重用YieldInstruction对象</p><p>2.适当分批处理</p><p>3.及时清理不需要的协程</p><p>4.避免过多嵌套</p><p>理解协程的这些原理，可以帮助我们更好地使用它，避免常见陷阱，并在适当的场景选择它作为解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动作游戏的方方面面</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>动作游戏系统设计</p><p>镜头选型，运动系统，输入模块，战斗能力。</p><h1 id="战斗系统？"><a href="#战斗系统？" class="headerlink" title="战斗系统？"></a>战斗系统？</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>好的攻击方式应该兼具优点和缺点，比如范围大那么久伤害低，伤害高但是攻速慢，或者需要某些特定的资源，或者具有冷却时间</p><p>攻速其实是动画的帧动画</p><p>前摇，判定和后摇</p><p>动画取消</p><p>范围：吸附的范围</p><p>不同的按键组合是不同的攻击方式，当然也可以是和位置不同而变化，比如背刺之类的。</p><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><p>一定顺序，准确时机可以打出不同的连招</p><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><p>防御或者闪避</p><p>弹反和招架：有可能过于强大，让整个游戏都变成了等待</p><p>可以增加弹反惩罚，或者限制弹反次数，或者降低弹反收益：比如只是单纯地给一点子弹时间。</p><p>当然你也要防止你的玩家完全不防御，防止让他一直压制敌人，比如给怪加体力条，体力条没了才能僵直，或者让他面对很多个怪物。</p><p>好的动作游戏，应该鼓励玩家在攻击和防守之间积极地变换。</p><h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><p>敌人的进攻应该有明显的提示，比如画面之类的。</p><p>并且最好不要设计成单一武器才能杀死的敌人 </p><p>如何鼓励玩家进攻多样而不是复读？</p><p>连击有特殊动画，或者直接设计连击分数（比如鬼泣或者猎天使魔女），还有受伤掉分</p><p>如果程序检测到玩家复读某一招，可以相对应地用表现得不一样，这些可以给玩家他适应了你的打法一样（街霸的ai也有类似的感觉，可以学习）</p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>巨大的前摇+飞速的打击动作+判定帧短暂的暂停+后摇缓慢的回复</p><p>刀光特效</p><p>震动屏幕</p><p>爽快的音效</p><h1 id="打击感-1"><a href="#打击感-1" class="headerlink" title="打击感"></a>打击感</h1><p><a href="https://www.bilibili.com/video/BV1g741157RC/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【暖风游戏厅】打击感是如何炼成的</a> </p><p>攻击角色击中被击角色的瞬间，游戏给玩家的反馈所形成的的体验。</p><p>打击感是击中的瞬间，手感是玩家输入的瞬间</p><p>被击动作、特效、静止帧、音效和振动</p><h2 id="被击动作"><a href="#被击动作" class="headerlink" title="被击动作"></a>被击动作</h2><p>首先是攻击动作和被击动作要匹配，方向和力度。</p><p>被击动作需要播放地够快。</p><p>如果是一个很大的boss，可以考虑做局部肢体的抖动。对骨骼施加物理力，然后和动作进行融合，这样做不会让被击方停止动作，一举两得。</p><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><p>最重要的功能是告诉玩家自己的攻击击中了，必须及时，准确和明显。</p><p>两种比较常见的，爆炸和飙血。前者是拳脚或者钝器（街霸），后者是利器（血缘）</p><h2 id="静止帧"><a href="#静止帧" class="headerlink" title="静止帧"></a>静止帧</h2><p>用来模拟现实打击中的顿滞感，拳头和钝器会慢一点，利器会快一点。也和敌人属性有关，比如穿了厚重的铠甲就会慢一点，破衣服就快一点。</p><p>全局或者局部</p><p>全局是整个游戏都暂停，局部是只用双方暂停。</p><p>战神利用了ik（反向动力学）来制作静止帧，斧子在击中敌人的一瞬间会卡肉，然后手臂会继续运动，直到一定程度才会完成打击动作。</p><h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><p>依旧是合适和及时，不同属性不同力度要对应。</p><h2 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h2><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>打击感是一瞬间的信息和力度，要专注这一瞬间的反馈。</p><p>命中</p><p>信息：信息要准确，丰富有层次</p><p>强度：强度要有对比，要有层次和疏密，最重要的是符合直觉</p><p>连招开启的卡肉，就像街霸里的确认一样，用来告诉你你可以开始爽快的连招了</p><p>第一法则：“0延迟”的即时反馈 </p><p>第二法则：制造预期，让玩家有所期待 </p><p>第三法则：符合预期，回应玩家的期待 </p><p>第四法则：简洁：明了清晰，弱化不必要的 </p><p>第五法则：夸张：强化重要的 </p><p>第六法则：回味：让玩家有时间和机会回味，延长令玩家愉悦的感觉 </p><p>第七法则：拟真：真实感的模拟（如果你不知道从什么地方开始，那么就向大自然和实际生活学习）</p><h1 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h1><p>重点是解决一下三个问题：</p><p><strong>如何让玩家探索战胜敌人的方式？</strong></p><p>敌人的形象设计；攻击提示；仇恨范围；攻击欲望；连招系统；战斗策略；指令输入；能力限制一级敌我对等程度；对峙突围能力……</p><p><strong>如何让玩家不断磨练自己的技术</strong></p><p>角色的成长策略；获胜的条件；游戏综合速度；不同情绪切换；基础物理法则；战场结构；纵向层次；角色能力提升曲线与自我技术革新……</p><p><strong>如何让玩家不会轻易放弃？</strong></p><p>游戏的核心挑战；次要挑战；游戏整体难度；死亡机制与死亡惩罚；角色的容错率；玩家的学习曲线；玩家操纵角色的综合能力……</p><h1 id="难度曲线"><a href="#难度曲线" class="headerlink" title="难度曲线"></a>难度曲线</h1><p>确保每一种类型的玩家都有自己的乐趣所在，初学者，玩家和大师</p><h1 id="进阶循环"><a href="#进阶循环" class="headerlink" title="进阶循环"></a>进阶循环</h1><h1 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h1><p><strong>Camera</strong></p><p>第三人称、第一人称、越肩（战神）、俯视角、横版</p><p><strong>Character</strong></p><p>移动方式和相机要相关，越肩就是要固定方向，第三人称的话可以转头，但是也可以锁定怪物</p><p><strong>Control</strong></p><h1 id="动作切换系统"><a href="#动作切换系统" class="headerlink" title="动作切换系统"></a>动作切换系统</h1><p><a href="https://zhuanlan.zhihu.com/p/663335854">动作游戏中的动作切换系统这么做就对了 - 猴与花果山的文章 - 知乎</a></p><h1 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Frame</span>&#123;<br><span class="hljs-keyword">public</span> frameId:<span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">public</span> clips:Array&lt;Clip&gt;; <span class="hljs-comment">//每一帧依然会是多个clip</span><br><span class="hljs-keyword">public</span> hitBox:Array&lt;Rect&gt;;<span class="hljs-comment">//碰撞框，动作游戏会有进攻、挨揍、防御等碰撞框，当然很可能都是空数组，比如角色死了的时候</span><br><br><span class="hljs-comment">//在这一帧，哪些frameId的动作可以成为下一帧cancel掉这个动作</span><br><span class="hljs-comment">//比如街霸的重拳接升龙，他不是等重拳全放完了，然后升龙从头来叫重拳接升龙</span><br><span class="hljs-comment">//而是从重拳的第x帧之后，直接切换到升龙的第y帧开始继续</span><br><span class="hljs-keyword">public</span> cancelableAction:Array&lt;<span class="hljs-built_in">string</span>&gt;; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="连招系统代码设计"><a href="#连招系统代码设计" class="headerlink" title="连招系统代码设计"></a>连招系统代码设计</h1><p><a href="https://www.zhihu.com/question/26760255/answer/56856767">游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 白井功名的回答 - 知乎</a></p><p><strong>1，在无法把握全部动作的前提下，把握好人物每个动作衔接过程中的着力点</strong></p><p><strong>2，适当地通过特效、光影等弥补动作上可能存在的不足</strong></p><p><strong>3，嗯之前忘了说，但是也许是最重要的一点：在做连招的过程中保持与美术的沟通，单个动作方面可能他是专家但连招的整体还是需要你们共同完成</strong></p><p>游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 猴与花果山的回答 - 知乎<br><a href="https://www.zhihu.com/question/26760255/answer/57075589">https://www.zhihu.com/question/26760255/answer/57075589</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-Lua高性能编程</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h1><p>在代码运行前，Lua会把源码预编译成一种中间码，类似于Java的虚拟机。这种格式然后会通过C的解释器进行解释，整个过程其实就是通过一个while循环，里面有很多的switch…case语句，一个case对应一条指令来解析。</p><p>自Lua 5.0之后，Lua采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多250个寄存器，因为栈的长度是用8个比特表示的。</p><p>有了这么多的寄存器，Lua的预编译器能把所有的local变量储存在其中。这就使得Lua在获取local变量时其效率十分的高。</p><h2 id="使用local引用global变量"><a href="#使用local引用global变量" class="headerlink" title="使用local引用global变量"></a>使用local引用global变量</h2><p>Lua对本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">局部变量</a>的访问是一个O(1)的操作（等价于一个数组地址+偏移），而global变量的获取需要一次<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=hash%E6%9F%A5%E6%89%BE&zhida_source=entity">hash查找</a>。local比global快很多（特别是在计算比较简单时，hash查找的开销反而是大头），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了本地local变量以外，upvalue的访问也比global快很多（访问上一层upvalue，等价于一次间接跳转之后再访问上一层函数的局部变量，基本还是一个O(1)的开销），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="使用local缓存table查找结果"><a href="#使用local缓存table查找结果" class="headerlink" title="使用local缓存table查找结果"></a>使用local缓存table查找结果</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="3R原则"><a href="#3R原则" class="headerlink" title="3R原则"></a>3R原则</h1><h2 id="Reducing"><a href="#Reducing" class="headerlink" title="Reducing"></a>Reducing</h2><p>避免创建新对象和节约内存</p><h3 id="把table变成数组"><a href="#把table变成数组" class="headerlink" title="把table变成数组"></a>把table变成数组</h3><h3 id="把常量对象的创建放在循环的外面"><a href="#把常量对象的创建放在循环的外面" class="headerlink" title="把常量对象的创建放在循环的外面"></a>把常量对象的创建放在循环的外面</h3><p>xxxxxxxxxx void Awake(){    objects &#x3D; new List<Transform>();}​void CreateObject(){    Transform t &#x3D; Instantiatie(prefab);    t.loactionPosition &#x3D; Random.insideUnitSphere * 5f;    t.locationRotation &#x3D; Random.rotation;    t.localScale &#x3D; Vector3.one * Random.Range(0.1f, 1f);    objects.Add(t);}c#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125; <span class="hljs-comment">--unnecessary redeclare</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span> <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">--这里每次循环会创建一个匿名函数对象</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">local</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fun2) <span class="hljs-comment">--重用循环外定义的func2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Reusing"><a href="#Reusing" class="headerlink" title="Reusing"></a>Reusing</h2><h3 id="复用对象"><a href="#复用对象" class="headerlink" title="复用对象"></a>复用对象</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123; year = i, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;) <span class="hljs-comment">--每次循环创建一个表</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> aux = &#123; year = <span class="hljs-literal">nil</span>, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    aux.year = i <span class="hljs-comment">-- 重用循环外定义的aux</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(aux)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Recycling"><a href="#Recycling" class="headerlink" title="Recycling"></a>Recycling</h2><h3 id="避免GC对象的创建"><a href="#避免GC对象的创建" class="headerlink" title="避免GC对象的创建"></a>避免GC对象的创建</h3><p>string有intenalize管理的开销，table需要开辟内存，lua中所有的function都是闭包，创建开销也不低，此外它们都会增加gc的开销。</p><h3 id="传参时避免构造table"><a href="#传参时避免构造table" class="headerlink" title="传参时避免构造table"></a>传参时避免构造table</h3><p>参数的数量不多时，尽量用独立的变量传递参数，而非构造一个table。</p><h2 id="宿主语言接口调用"><a href="#宿主语言接口调用" class="headerlink" title="宿主语言接口调用"></a>宿主语言接口调用</h2><p>尽量在lua内部完成计算，调用宿主语言接口会带来明显的上下文切换开销，如果不是一个复杂的计算过程，不值的浪费这个开销。</p><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n的整数键，其他的所有键都储存在哈希部分中。</p><p>哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。</p><p>当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。</p><h2 id="创建table时初始化数据"><a href="#创建table时初始化数据" class="headerlink" title="创建table时初始化数据"></a>创建table时初始化数据</h2><p>为了减少不必要的内存开销，table在创建时不会分配任何额外内存，早期几个元素的插入都必然导致rehash操作，这个特性对小table的创建影响特别显著，创建时一并指定初始化数据可以避免rehash的开销。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>t[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>t[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br> <br><span class="hljs-comment">-- good: 200% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="高效的遍历"><a href="#高效的遍历" class="headerlink" title="高效的遍历*"></a>高效的遍历*</h2><p>paris和iparis有函数调用的开销，因此效率不高。在性能敏感的场合，最好缓存table的size，然后使用for loop。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- pairs: 3.078 (217%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">--- ipairs: 3.344 (236%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,x do: 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,#atable do 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,atable_length do: 1.562 (110%)</span><br><span class="hljs-keyword">local</span> length = #a<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,length <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的插入"><a href="#高效的插入" class="headerlink" title="高效的插入*"></a>高效的插入*</h2><p>table.insert有函数调用的开销，因此性能不高。在性能敏感的场合，最好缓存table的size，然后指定下标赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table.insert: 1.250 (727%)</span><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    tinsert(a,i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[i]: 0.172 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[i]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[#a+1]=x: 0.453 (263%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[count++]=x: 0.203 (118%)</span><br><span class="hljs-keyword">local</span> count = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    d[count]=i<br>    count=count+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的unpack"><a href="#高效的unpack" class="headerlink" title="高效的unpack*"></a>高效的unpack*</h2><p>性能敏感的场合不要使用unpack，选择手动展开。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- with [ ]: 0.485 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>],a[<span class="hljs-number">4</span>] )<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- unpack(): 1.093 (225%)</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">unpack</span>(a) )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="array或者hash"><a href="#array或者hash" class="headerlink" title="array或者hash*"></a><a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=array&zhida_source=entity">array</a>或者hash*</h2><p>table有array和hash两部分存储，一般来讲array的存储开销要比hash小一些，访问速度也比hash查找要快，可能的话尽量选array。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 使用hash，内存开销最大 400%</span><br>polyline = &#123;<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">18.3</span>&#125;,<br>  &#123;x= <span class="hljs-number">15.0</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>&#125;  <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 使用数组，内存开销降低 250%</span><br>polyline = &#123;<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">98.5</span> &#125;,<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">18.3</span> &#125;,<br>  &#123; <span class="hljs-number">15.0</span>, <span class="hljs-number">98.5</span> &#125;,<br>  ...<br>&#125; <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 还可以进一步减少table本身的内存开销，只3个table 100%</span><br>polyline = &#123;<br>  x = &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">10.3</span>, <span class="hljs-number">15.0</span>, ... &#125;,<br>  y = &#123; <span class="hljs-number">98.5</span>, <span class="hljs-number">18.3</span>, <span class="hljs-number">98.5</span>, ... &#125;<br>&#125; <span class="hljs-comment">--(tables used: 3)</span><br></code></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。</p><p>所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为Lua需要去查找比较一遍。</p><p>第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变得十分高效。例如在Perl中，$x &#x3D; $y，会将$y的buffer整个的复制到$x的buffer中，当字符串很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。</p><p>但是只保存引用会降低在字符串连接时的速度。在Perl中，$s &#x3D; $s . ‘x’和$s .&#x3D; ‘x’的效率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插入到$x的buffer末尾。</p><p>由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。</p><h2 id="缓存字符串"><a href="#缓存字符串" class="headerlink" title="缓存字符串"></a>缓存字符串</h2><p>避免在运行时构造字符串，尽量缓存那些常量字符串。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>大字符串的拼接，使用table.concat。</p><p>在lua中可以用table来模拟buffer</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">30000</span> <span class="hljs-keyword">do</span><br>    t[#t+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">end</span><br>s = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="语言之外的东西"><a href="#语言之外的东西" class="headerlink" title="语言之外的东西"></a>语言之外的东西</h1><p>使用<a href="http://luajit.org/">LuaJIT</a>，LuaJIT可以使你在不修改代码的情况下获得平均约5倍的加速。查看LuaJIT在<a href="http://luajit.org/performance_x86.html">x86&#x2F;x64下的性能提升比</a>。</p><p>第二、将瓶颈部分用C&#x2F;C++来写。因为Lua和C的天生近亲关系，使得Lua和C可以混合编程。但是C和Lua之间的通讯会抵消掉一部分C带来的优势。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于蓝图的多人游戏玩法设计</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18Y41187vo/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2021]与众乐乐 - 基于蓝图的多人游戏玩法设计 | Epic Games 何骞</a> </p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221120244763.png"></p><p>复制Replication</p>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UE蓝图开发最佳实践</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1oG411M7Y6/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2022]蓝图开发最佳实践 | Epic 何骞</a> </p><h1 id="命名相关"><a href="#命名相关" class="headerlink" title="命名相关"></a>命名相关</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000001964.png"></p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000142710.png"></p><p>减少冗余信息</p><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000236767.png"></p><h1 id="蓝图如何保持整洁"><a href="#蓝图如何保持整洁" class="headerlink" title="蓝图如何保持整洁"></a>蓝图如何保持整洁</h1><h2 id="避免过长的蓝图逻辑，屏幕长度有限"><a href="#避免过长的蓝图逻辑，屏幕长度有限" class="headerlink" title="避免过长的蓝图逻辑，屏幕长度有限"></a>避免过长的蓝图逻辑，屏幕长度有限</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000410021.png"></p><h2 id="事件左对齐"><a href="#事件左对齐" class="headerlink" title="事件左对齐"></a>事件左对齐</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000501706.png"></p><p>保证更改逻辑的时候不会改错</p><h2 id="通过Re-route来减少连线"><a href="#通过Re-route来减少连线" class="headerlink" title="通过Re-route来减少连线"></a>通过Re-route来减少连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000527244.png"></p><h2 id="避免错乱事件连线"><a href="#避免错乱事件连线" class="headerlink" title="避免错乱事件连线"></a>避免错乱事件连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000700985.png"></p><p>不要想到一个事件就立马create出来</p><h2 id="重用Getter或者Pure节点"><a href="#重用Getter或者Pure节点" class="headerlink" title="重用Getter或者Pure节点"></a>重用Getter或者Pure节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000813646.png"></p><h2 id="清晰的返回节点"><a href="#清晰的返回节点" class="headerlink" title="清晰的返回节点"></a>清晰的返回节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000841491.png"></p><p>越复杂的函数为什么return，为什么early return需要写清楚</p><h2 id="Select节点"><a href="#Select节点" class="headerlink" title="Select节点"></a>Select节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000918576.png"></p><p>Text替代String</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000954247.png"></p><h1 id="蓝图注释规则"><a href="#蓝图注释规则" class="headerlink" title="蓝图注释规则"></a>蓝图注释规则</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001053596.png"></p><h2 id="分不同的颜色，规则不一样"><a href="#分不同的颜色，规则不一样" class="headerlink" title="分不同的颜色，规则不一样"></a>分不同的颜色，规则不一样</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001141232.png"></p><h2 id="注释的细节"><a href="#注释的细节" class="headerlink" title="注释的细节"></a>注释的细节</h2><p><strong>每个事件都编写注释</strong></p><p><strong>Sequence的每一段都写注释</strong></p><p>把长的拆分成sequence也可以做</p><p><strong>为复杂的逻辑写注释</strong></p><p><strong>为复杂的函数返回写注释</strong></p><h1 id="如何创建稳固更新的生产线？"><a href="#如何创建稳固更新的生产线？" class="headerlink" title="如何创建稳固更新的生产线？"></a>如何创建稳固更新的生产线？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001347062.png"></p><p>不是一开始就设计好，而是在项目进行到一定阶段在解耦。</p><p>不要复制黏贴，而是作为抽离成function</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>每次冷启动，可以通过log（Unreal Inside）来观察哪里加载的久。</p><p>以及每次添加新节点的时间</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>减少不必要的Cast，特别是复杂蓝图类的cast</strong>。</p><p><strong>用Gameplay Tag和blueprint Interface</strong></p><p><strong>活用命名空间</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002004041.png"></p><p>可以规定某个蓝图这是哪种玩法会用到的，这样就可以减少加载</p><p><strong>减少Hard Reference</strong></p><p>因为每个hard Reference都会加载在内存里面，会影响包体大小，考虑用Tag或者Soft Reference来替换</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002514037.png"></p><p>一个比较好的方式是，脚本语言不去改蓝图function的实现，然后划分好哪些变量会修改，这样也可以作为一个新的category来分类</p><h2 id="蓝图审核"><a href="#蓝图审核" class="headerlink" title="蓝图审核"></a>蓝图审核</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002854518.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002937518.png"></p><p>可以持续更新一个Best Practice文档</p><h1 id="编辑器拓展"><a href="#编辑器拓展" class="headerlink" title="编辑器拓展"></a>编辑器拓展</h1><p>Assest Action Utility（这里没太听懂，到时候学习一下）</p><h1 id="如何平衡蓝图和C-？"><a href="#如何平衡蓝图和C-？" class="headerlink" title="如何平衡蓝图和C++？"></a>如何平衡蓝图和C++？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221003705495.png"></p><p><strong>不用过早优化</strong></p><p>因为变化可能很快</p><p><strong>有安全性问题的时候可以考虑转</strong></p><p>比如拿的很多信息不是在本地，而是要通过服务器来request，这种可能放在C++核心类比较好</p><p><strong>直接重定向</strong></p><p>在C++里面写一个<strong>MigrateProperty</strong>这样一个函数，可以把哪些变量，CDO准确的转化过来</p>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-垃圾回收</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>也是采用标记清除的方式，会从根出发，标记所有</p><h2 id="根节点是什么？"><a href="#根节点是什么？" class="headerlink" title="根节点是什么？"></a>根节点是什么？</h2><p><strong>1. 静态字段</strong></p><p><strong>2. MonoBehaviour实例</strong></p><p><strong>3. ScriptableObject实例</strong></p><p><strong>4. 场景中的GameObject</strong></p><p><strong>5. 全局引用</strong></p><p><strong>6. 资源引用</strong></p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，主要分为以下几步：</p><ul><li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；</li><li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。</li><li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。</li></ul><p>堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。</p><h2 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h2><p>当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ul><li>GC会检查堆内存上的每个存储变量；</li><li>对每个变量会检测其引用是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为可回收；</li><li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li></ul><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h2 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h2><p>主要有三个操作会触发垃圾回收：</p><ul><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ul><h2 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a><strong>降低GC的影响的方法</strong></h2><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>基于此，我们可以采用三种策略：</p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。</li><li>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响</li></ul><h2 id="降低GC的具体方法"><a href="#降低GC的具体方法" class="headerlink" title="降低GC的具体方法"></a>降低GC的具体方法</h2><h3 id="减少内存垃圾"><a href="#减少内存垃圾" class="headerlink" title="减少内存垃圾"></a>减少内存垃圾</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>比如循环不要每次都创建新的数组，而是提前创建好</p><h4 id="不要在频分调用的函数里面使用堆内存分配"><a href="#不要在频分调用的函数里面使用堆内存分配" class="headerlink" title="不要在频分调用的函数里面使用堆内存分配"></a>不要在频分调用的函数里面使用堆内存分配</h4><p>比如tick和update里面不要分配内存，而是在之前就创建好，或者通过定时器或者脏标记的方法来改进</p><h4 id="减少链表"><a href="#减少链表" class="headerlink" title="减少链表"></a>减少链表</h4><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>减少内存的释放和创建次数</p><h3 id="造成不必要内存的分配的情况"><a href="#造成不必要内存的分配的情况" class="headerlink" title="造成不必要内存的分配的情况"></a>造成不必要内存的分配的情况</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在c#里面字符串不是值类型而是引用，而且值无法改变，所以改变值会直接创建一个新的值</p><p>　1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p><p>　　2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。</p><p>　　3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>比如说迭代器会产生新的数组（可以通过缓存来解决），调用GameObject.name 或者 GameObject.tag也会有内存垃圾，因为会犯乎一个字符串</p><h4 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h4><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。最好避免。</p><p>比如这种</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> cost = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">string</span> displayString = String.Format(<span class="hljs-string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost);<br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>6.5之前的版本会因为迭代器有内存垃圾</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>比如把对象里面的string拆出来，这样就不用频繁地在GC里面类型检查</p><h3 id="定时执行GC"><a href="#定时执行GC" class="headerlink" title="定时执行GC"></a>定时执行GC</h3><p>比如过场的时候主动调用GC操作</p><h1 id="UE"><a href="#UE" class="headerlink" title="UE"></a>UE</h1><p>也是标记清除</p><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p><a href="https://zhuanlan.zhihu.com/p/133939450">Lua GC机制分析与理解-上 - 小破孩不会编程序的文章 - 知乎</a></p><h2 id="gc的思想"><a href="#gc的思想" class="headerlink" title="gc的思想"></a>gc的思想</h2><p>会遍历所有对象，标记颜色，那些不可达的就是需要gc的对象，又分为双色和三色，双色就是不能中断，三色可以中断，但是实现复杂，</p><h2 id="何时会触发gc？"><a href="#何时会触发gc？" class="headerlink" title="何时会触发gc？"></a>何时会触发gc？</h2><p>分为两种，一种是自动触发</p><p>在以下代码中，使用 luaC_checkGC 检查 gc 阈值 GCdebt ，当 GCdebt 大于0 时，执行 gc<br>1、创建新数据时 string, thread, userdata, table, closure<br>3、语法解析时<br>4、错误发生时<br>5、字符串拼接时 concat<br>6、栈增长时</p><p>一种是手动触发</p><p>使用 lua API：<br>collectgarbage “step”<br>collectgarbage “collect”</p><h2 id="lua-怎么判定数据可达？"><a href="#lua-怎么判定数据可达？" class="headerlink" title="lua 怎么判定数据可达？"></a>lua 怎么判定数据可达？</h2><p>从 GC根集合（root set） 可访问的对象：<br>gc root set包含三部分：<br>1、主协程 g-&gt;mainthread，其栈记录了当前用到的所有对象<br>2、注册表 g-&gt;l_registry，包含了全局table(_G)，记录了全局变量和全局模块，还包括已加载的模块表 package.loaded<br>3、全局元表 g-&gt;mt，每种数据类型各一个，预留9个，暂时只有table和string的实现，效果如io模块的f:read()和 string模块的s:len()</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>程序是无法推断哪些东西是需要回收的，比如说在数组里的元素，虽然我们不用他了，但是数组还在引用，那么lua就无法自动回收它，这时候就需要弱引用表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p><p>1、导致引用计数+1的情况</p><p>对象被创建，例如a&#x3D;23</p><p>对象被引用，例如b&#x3D;a</p><p>对象被作为参数，传入到一个函数中，例如func(a)</p><p>对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>2、导致引用计数-1的情况</p><p>对象的别名被显式销毁，例如del a</p><p>对象的别名被赋予新的对象，例如a&#x3D;24</p><p>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</p><p>对象所在的容器被销毁，或从容器中删除对象</p><h2 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h2><p>针对循环引用这个问题，比如有两个对象互相引用了对方，当外界没有对他们有任何引用，也就是说他们各自的引用计数都只有1的时候，如果可以识别出这个循环引用，把它们属于循环的计数减掉的话，就可以看到他们的真实引用计数了。基于这样一种考虑，有一种方法，比如从对象A出发，沿着引用寻找到对象B，把对象B的引用计数减去1；然后沿着B对A的引用回到A，把A的引用计数减1，这样就可以把这层循环引用关系给去掉了。</p><p>不过这么做还有一个考虑不周的地方。假如A对B的引用是单向的， 在到达B之前我不知道B是否也引用了A，这样子先给B减1的话就会使得B称为不可达的对象了。为了解决这个问题，python中常常把内存块一分为二，将一部分用于保存真的引用计数，另一部分拿来做为一个引用计数的副本，在这个副本上做一些实验。比如在副本中维护两张链表，一张里面放不可被回收的对象合集，另一张里面放被标记为可以被回收（计数经过上面所说的操作减为0）的对象，然后再到后者中找一些被前者表中一些对象直接或间接单向引用的对象，把这些移动到前面的表里面。这样就可以让不应该被回收的对象不会被回收，应该被回收的对象都被回收了。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h2><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环境的编程中，对于变量在内存中的创建&#x2F;销毁，总有频繁和不那么频繁的。比如任何程序中总有生命周期是全局的、部分的变量。<br>Python将所有的对象分为0，1，2三代；<br>所有的新建对象都是0代对象；<br>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p><p>他们gc的频率不同，这样可以提高性能</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - allen的文章 - 知乎</a></p><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>如果要自己写一个内存泄漏，可以考虑在new和malloc里面记录内存。</p><p>调试可以用数据断点来操作。</p><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><h2 id="避免内存碎片"><a href="#避免内存碎片" class="headerlink" title="避免内存碎片"></a>避免内存碎片</h2><ol><li>使用内存池（Memory Pool）</li></ol><p>预先分配一大块内存，并在其中管理小块内存的分配和释放。这样可以减少频繁的动态内存分配和释放带来的碎片。</p><p>内存池可以根据对象的大小进行分区，确保相同大小的对象使用相同的内存块。</p><ol start="2"><li>对象重用：</li></ol><p>尽量重用对象，避免频繁的创建和销毁。可以使用对象池（Object Pool）来管理可重用的对象。</p><p>对象池可以在游戏中常用的对象（如子弹、敌人等）中使用，减少内存分配和释放的次数。</p><ol start="3"><li>合理的内存分配策略：</li></ol><p>使用合适的内存分配器，选择适合应用场景的分配策略（如分配器的对齐方式、分配大小等）。</p><p>避免频繁的小块内存分配，尽量使用较大的内存块进行分配。</p><ol start="4"><li>合并空闲块：</li></ol><p>在释放内存时，检查相邻的空闲块并合并它们，以减少外部碎片。</p><p>许多内存分配器会自动处理合并空闲块的逻辑。</p><ol start="5"><li>使用智能指针：</li></ol><p>在 C++ 中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）来管理内存，减少内存泄漏和碎片的可能性。</p><h2 id="解决内存碎片"><a href="#解决内存碎片" class="headerlink" title="解决内存碎片"></a>解决内存碎片</h2><ol><li>内存整理（Compaction）：</li></ol><p>在某些情况下，可以通过内存整理来解决外部碎片。内存整理的过程是将活动对象移动到内存的一端，释放出连续的空闲内存块。</p><p>这种方法在实时系统中可能不适用，因为它可能导致停顿。</p><ol start="2"><li>使用更高效的内存分配器：</li></ol><p>如果发现当前的内存分配器导致了严重的内存碎片，可以考虑使用其他内存分配器（如 jemalloc、tcmalloc 等），这些分配器在处理碎片方面通常更高效。</p><ol start="3"><li>监控和分析内存使用：</li></ol><p>使用内存分析工具（如 Valgrind、Visual Studio 的内存分析工具等）监控内存使用情况，识别和解决内存碎片问题。</p><p>定期检查和分析内存使用情况，及时发现和解决潜在的内存碎片问题。</p><ol start="4"><li>重启应用程序：</li></ol><p>在某些情况下，重启应用程序可以清除内存碎片，尤其是在长时间运行的应用程序中。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-UE相关</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="UE最基础的五个类是什么"><a href="#UE最基础的五个类是什么" class="headerlink" title="UE最基础的五个类是什么"></a>UE最基础的五个类是什么</h1><ol><li>GameMode是整个关卡的控制器，用来编写整个关卡的<a href="https://zhida.zhihu.com/search?content_id=212792905&content_type=Article&match_order=1&q=%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&zhida_source=entity">业务逻辑</a>；</li><li>GameState是整个关卡的状态，用来存储整个关卡的游戏数据；</li><li>DefaultPawn是玩家角色，若是角色扮演类游戏则就是在游戏场景中看到的角色实体；</li><li>PlayerController是玩家的控制器，用来编写和玩家相关的控制逻辑；</li><li>PlayerState是玩家的状态，用来存储和玩家相关的状态数据。</li></ol><h1 id="FName和FString"><a href="#FName和FString" class="headerlink" title="FName和FString"></a>FName和FString</h1><p>① <strong>FName：</strong>着重于表示<strong>名称</strong>，<strong>不区分大小写</strong>，<strong>不可更改</strong>，引擎中的资源名称都是FName类型，通过一个轻型系统重复使用字符串，FName创建时会根据内容创建一个<a href="https://zhida.zhihu.com/search?content_id=178876897&content_type=Article&match_order=1&q=Hash%E5%80%BC&zhida_source=entity">Hash值</a>，且同样的内容只会存储一次。通过Hash值在进行FName的查找和访问时速度较快，而在比较的时，也不需要比较字符串内容，直接比较Hash值来区分不同FName字符串。</p><p>另外两种字符串<strong>到FName的转换</strong>（特别注意的是，<strong>FText不能直接转换到FName</strong>，可<strong>先转换为FString</strong>，再转换为FName）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br> <br><span class="hljs-comment">// FString 转 FName：不可靠，丢失大小写信息</span><br>FName name1 = <span class="hljs-built_in">FName</span>(*str);<br><br>FString strFromTxt = txt.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 先转 FString，再转 FName：不可靠，丢失大小写信息，丢失本地化信息可能导致语言转换的潜在风险</span><br>FName name2 = <span class="hljs-built_in">FName</span>(*strFromTxt);<br></code></pre></td></tr></table></figure><p>② <strong>FString：</strong>最接近std::string，着重在于<strong>字符串的操作</strong>，提供了大量对字符串的操作接口，是<strong>三者中唯一可修改的字符串类型</strong>，也正因如此，FString对比其它两种字符串来说<strong>消耗更高</strong>，<strong>性能更低</strong>。</p><p>另外两种字符串<strong>到FString的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br><br><span class="hljs-comment">// FName 转 FString：可靠</span><br>FString str1 = name.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 转 FString：不可靠，丢失本地化信息可能导致语言转换的潜在风险</span><br>FString str2 = txt.<span class="hljs-built_in">ToString</span>();<br></code></pre></td></tr></table></figure><p>③ <strong>FText：</strong>着重在于<strong>显示与本地化</strong>，显示可理解玩家能直接看到的信息，本地化即多语言的处理，<strong>不可更改</strong>。相较于另外两种类型，FText会更加的臃肿，但提供了优秀的本地化功能。</p><p>另外两种字符串<strong>到FText的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br><br><span class="hljs-comment">// FString 转 FText：可靠</span><br>FText txt1 = FText::<span class="hljs-built_in">FromString</span>(str);<br><span class="hljs-comment">// FName 转 FText：可靠</span><br>FText txt2 = FText::<span class="hljs-built_in">FromName</span>(name);<br></code></pre></td></tr></table></figure><h1 id="软引用和硬引用"><a href="#软引用和硬引用" class="headerlink" title="软引用和硬引用"></a>软引用和硬引用</h1><p>加载的步骤</p><h1 id="Actor如何实现一个借口类"><a href="#Actor如何实现一个借口类" class="headerlink" title="Actor如何实现一个借口类?"></a>Actor如何实现一个借口类?</h1><h1 id="UE4反射机制"><a href="#UE4反射机制" class="headerlink" title="UE4反射机制"></a>UE4反射机制</h1><p>UHT</p><p><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a></p><p><a href="https://blog.csdn.net/duan19920101/article/details/127557454">C++反射机制</a></p><h1 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/v2-49e75fce0ea89e5dced9f3f8994fb6ce_1440w.jpg" alt="img"></p><p>作者：一勾大师<br>链接：<a href="https://zhuanlan.zhihu.com/p/308217207">https://zhuanlan.zhihu.com/p/308217207</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>UE4中创建Actor的方法主要有如下几种：<strong>从磁盘加载</strong>，<strong>Play In Editor（简称PIE）</strong>，<strong>SpawnActor动态生成</strong>和<strong>延迟生成。</strong>下面对不同形式的actor加载进行介绍</p><p><strong>从磁盘加载</strong></p><p>已位于关卡中的 Actor 使用此路径，如 LoadMap 发生时、或 AddToWorld（从流关卡或子关卡）被调用时，一般是提前搭好的场景中资源的加载方式。</p><ol><li>包&#x2F;关卡中的 Actor 从磁盘中进行加载。</li><li><strong>PostLoad</strong> - 在<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%BA%8F%E5%88%97%E5%8C%96&zhida_source=entity">序列化</a> Actor 从磁盘加载完成后被调用。在此处可执行自定义版本化和修复操作。PostLoad 与 <strong>PostActorCreated</strong> 互斥。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="Play-in-Editor"><a href="#Play-in-Editor" class="headerlink" title="Play in Editor"></a><strong>Play in Editor</strong></h2><p>Play in Editor 路径与 Load from Disk 十分相似，然而 Actor 却并非从磁盘中加载，而是从编辑器中复制而来，一般是在Debug时资源的加载方式。</p><ol><li><strong>PostDuplicate</strong> 被调用。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h2><p>这是生成（实例）Actor 时的路径。在实际工程中一般是通过SpawnActor等函数加载的资源</p><ol><li><strong>SpawnActor</strong> 被调用。</li><li><strong>PostSpawnInitialize</strong></li><li><strong>PostActorCreated</strong> - 创建后即被生成的 Actor 调用，构建函数类行为在此发生。PostActorCreated 与 PostLoad 互斥。</li><li><strong>ExecuteConstruction</strong>：</li></ol><ul><li><strong>OnConstruction</strong> - Actor 的构建。蓝图 Actor 的组件在此处创建，蓝图变量在此处初始化</li></ul><p>5.<strong>PostActorConstruction</strong>：</p><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>6.<strong>OnActorSpawned</strong> 在 UWorld 上播放。</p><p>7.<strong>BeginPlay</strong> 被调用。</p><h2 id="延迟生成"><a href="#延迟生成" class="headerlink" title="延迟生成"></a><strong>延迟生成</strong></h2><p>将任意属性设为”Expose on Spawn”即可延迟 Actor 的生成。</p><ol><li><strong>SpawnActorDeferred</strong> - 生成程序化 Actor，在蓝图构建脚本之前进行额外设置。</li><li>SpawnActor 中的所有操作发生；PostActorCreated 之后发生以下操作：</li></ol><ul><li>通过一个有效但不完整的 Actor 实例设置&#x2F;调用多个”<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0&zhida_source=entity">初始化函数</a>“。</li><li><strong>FinishSpawningActor</strong> -调用后对 Actor 进行最终化，在 Spawn Actor 行中选取 ExecuteConstruction。</li></ul><p><strong>生命周期的结束</strong></p><p>尽管生成方式有比较大的区别，上述几种生成方法的结束流程却都一样。</p><p><strong>Destroy</strong> - 游戏在 Actor 需要被移除时手动调用，但游戏进程仍在继续。Actor 被标记为等待销毁并从关卡的 Actor 阵列中移除。</p><p><strong>EndPlay</strong> - 在数个地方调用，保证 Actor 的生命走向终点。在游戏过程中，如包含流关卡的 Actor 被卸载，Destroy 将发射此项和关卡过渡。调用 EndPlay 的全部情形：</p><ul><li>对 Destroy 显式调用。</li><li>Play in Editor 终结。</li><li>关卡过渡（无缝行程或加载地图）。 包含 Actor 的流关卡被卸载。</li><li>Actor 的生命期已过。</li><li>应用程序关闭（全部 Actor 被销毁）。</li></ul><p>无论这些情形出现的方式如何，Actor 都将被标记为 RF_PendingKill，因此在下个垃圾回收周期中它将被解除分配。此外，可以考虑使用更整洁的 <code>FWeakObjectPtr&lt;AActor&gt;</code> 代替手动检查”等待销毁”。</p><p><strong>OnDestroy</strong> - 这是对 Destroy 的旧有反应。也许应该将这里的所有内容移到 EndPlay，因为它被关卡过渡和其他游戏清理函数调用。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><p>一个对象被标记待销毁的一段时间后，垃圾回收会将其从内存中实际移除，释放其使用的资源。</p><p>在对象的销毁过程中，以下函数将被调用：</p><ol><li><strong>BeginDestroy</strong> - 对象可利用此机会释放内存并处理其他<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&zhida_source=entity">多线程</a>资源（即为图像线程代理对象）。与销毁相关的大多数游戏性功能理应在 <code>EndPlay</code> 中更早地被处理。</li><li><strong>IsReadyForFinishDestroy</strong> - 垃圾回收过程将调用此函数，以确定对象是否可被永久解除分配。返回 <code>false</code>，此函数即可延迟对象的实际销毁，直到下一个垃圾回收过程。</li><li><strong>FinishDestroy</strong> - 最后对象将被销毁，这是释放内部数据结构的另一个机会。这是<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE&zhida_source=entity">内存释放</a>前的最后一次调用。</li></ol><h1 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zhuanlan.zhihu.com/p/149392857">UFUNCTION&#x2F;UPROPERTY&#x2F;UCLASS</a></p><p> 反射系统是可以选择加入的。你需要给暴露给反射系统的类型或属性添加注解，这样Unreal Header Tool (UHT)就会在编译工程的时候利用那些信息生成特定的代码。</p><p><strong>标记</strong></p><p>为了标记一个头文件包含反射类型，需要在文件顶部添加一个特殊的include文件。该文件必须放在#include的最后，这让UHT知道它需要考虑这个文件，并且在反射系统的实现里也是需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileName.generated.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>你现在可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()来在头文件中注解不同的类型以及成员变量。每一个宏都会出现在类型或者成员变量的前面，并且可以包含额外的修饰符关键字。</p><p>C++是没法直接通过函数名来调用的，因为存的都是地址，但是在蓝图里面可以，这就用到了反射机制</p><h2 id="常用的有哪些"><a href="#常用的有哪些" class="headerlink" title="常用的有哪些"></a>常用的有哪些</h2><p><a href="https://blog.csdn.net/ttod/article/details/136396379">简述UE中的UFUNCTION宏和UPROPERTY宏常用属性</a></p><p>UFunction</p><table><thead><tr><th><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></th><th>在蓝图编辑工具中显示时指定函数的类别。使用 | 运算符定义嵌套类别。</th></tr></thead><tbody><tr><td><code>Client</code></td><td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>CustomThunk</code></td><td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td></tr><tr><td><code>Exec</code></td><td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td></tr><tr><td><code>NetMulticast</code></td><td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td></tr><tr><td><code>Reliable</code></td><td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>SealedEvent</code></td><td>无法在子类中覆盖此函数。<code>SealedEvent</code>关键词只能用于事件。对于非事件函数，请将它们声明为<code>static</code>或<code>final</code>，以密封它们。</td></tr><tr><td><code>ServiceRequest</code></td><td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>ServiceResponse</code></td><td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>Server</code></td><td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>Unreliable</code></td><td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>WithValidation</code></td><td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td></tr></tbody></table><p>UProperty</p><table><thead><tr><th><code>AdvancedDisplay</code></th><th>属性将被放置在其出现的任意面板的高级（下拉）部分中。</th></tr></thead><tbody><tr><td><code>AssetRegistrySearchable</code></td><td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td></tr><tr><td><code>BlueprintAssignable</code></td><td>只能与组播委托共用。公开属性在蓝图中指定。</td></tr><tr><td><code>BlueprintAuthorityOnly</code></td><td>此属性必须为一个组播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td></tr><tr><td><code>BlueprintCallable</code></td><td>仅用于组播委托。应公开属性在蓝图代码中调用。</td></tr><tr><td><code>BlueprintGetter=GetterFunctionName</code></td><td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>BlueprintReadOnly</code></td><td>此属性可由蓝图读取，但不能被修改。此说明符与 <code>BlueprintReadWrite</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintReadWrite</code></td><td>可从蓝图读取或写入此属性。此说明符与 <code>BlueprintReadOnly</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintSetter=SetterFunctionName</code></td><td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td></tr><tr><td><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></td><td>指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td></tr><tr><td><code>Config</code></td><td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>DuplicateTransient</code></td><td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td></tr><tr><td><code>EditAnywhere</code></td><td>说明此属性可通过属性窗口在原型和实例上进行编辑。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditDefaultsOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditFixedSize</code></td><td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td></tr><tr><td><code>EditInline</code></td><td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td></tr><tr><td><code>EditInstanceOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>Export</code></td><td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td></tr><tr><td><code>GlobalConfig</code></td><td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>Instanced</code></td><td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td></tr><tr><td><code>Interp</code></td><td>说明值可随时间由Sequencer中的一个轨道驱动。</td></tr><tr><td><code>Localized</code></td><td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td></tr><tr><td><code>Native</code></td><td>属性为本地：C++代码负责对其进行序列化并公开到<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-object-handling?application_version=4.27#garbagecollection">垃圾回收</a>。</td></tr><tr><td><code>NoClear</code></td><td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td></tr><tr><td><code>NoExport</code></td><td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td></tr><tr><td><code>NonPIEDuplicateTransient</code></td><td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td></tr><tr><td><code>NonTransactional</code></td><td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td></tr><tr><td><code>NotReplicated</code></td><td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td></tr><tr><td><code>Replicated</code></td><td>属性应随网络进行复制。</td></tr><tr><td><code>ReplicatedUsing=FunctionName</code></td><td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td></tr><tr><td><code>RepRetry</code></td><td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td></tr><tr><td><code>SaveGame</code></td><td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td></tr><tr><td><code>SerializeText</code></td><td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td></tr><tr><td><code>SkipSerialization</code></td><td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>SimpleDisplay</code></td><td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开“高级”部分即可见。</td></tr><tr><td><code>TextExportTransient</code></td><td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>Transient</code></td><td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td></tr><tr><td><code>VisibleAnywhere</code></td><td>说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</td></tr><tr><td><code>VisibleDefaultsOnly</code></td><td>说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr><tr><td><code>VisibleInstanceOnly</code></td><td>说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr></tbody></table><h1 id="PUERTS"><a href="#PUERTS" class="headerlink" title="PUERTS"></a>PUERTS</h1><p><strong>puerts的本质</strong></p><p>puerts的本质是：</p><ul><li>在（UE）引擎提供了JavaScript虚拟机环境</li><li>让TypeScript&#x2F;JavaScript能够和引擎交互，或者说能调用C++或者蓝图API，也能被C++或者蓝图调用到</li></ul><p>js虚拟机实现了js语言，但js语言本身基本什么都干不了，它能做的事情取决于宿主环境给它添加的api，比如浏览器在js环境添加了dom操作api，于是浏览器里的js可以编写动态页面的逻辑，比如nodejs添加异步网络（io）api，于是nodejs里的js能用来编写web服务器。</p><p>puerts里js的宿主环境是游戏引擎，又添加了哪些api呢？</p><p>首先，puerts默认导入了<strong>所有</strong>反射api。换句话在UE蓝图里能调用的引擎API，在Typescript&#x2F;JavaScript环境都可以调用，如果用Typescript，正确引入了声明文件到工程中，这些api会有提示。</p><p>其次对于非反射api，手工封装成反射后蓝图也能访问，这点在typescript同样适用，而且puerts还额外支持《基于模板的静态绑定》，按文档声明一下在typescript即可调用。</p><p>在puerts里，要实现一项游戏编程任务，先想下这任务在C++或者蓝图里如何实现，然后在typescript调用同样的api去实现。</p><p>puerts并未重定义引擎，只是定义了ts和引擎相互调用的规则。puerts的demo也倾向于演示这些规则，而不是做一个游戏。</p><h1 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h1><p><a href="https://zhuanlan.zhihu.com/p/434028533">【UE5】给Landscape加一点料-地形篇（零）-前前言 - 徐凯鸣的文章 - 知乎</a></p><p><a href="https://www.youtube.com/watch?v=MRNFcywkUSA&list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3&index=3">Procedural Landmass Generation Youtube</a></p><p>地形编辑</p><p>Houdini</p><h1 id="自定义编辑器FAssetEditorToolkit"><a href="#自定义编辑器FAssetEditorToolkit" class="headerlink" title="自定义编辑器FAssetEditorToolkit"></a>自定义编辑器FAssetEditorToolkit</h1><h3 id="3-1-InitCustomAssetEditor方法："><a href="#3-1-InitCustomAssetEditor方法：" class="headerlink" title="3.1 InitCustomAssetEditor方法："></a><strong>3.1 InitCustomAssetEditor方法：</strong></h3><p>在此方法中，主要分为两个内容：<br><strong>① 初始化编辑器布局，可以使用以下步骤：</strong></p><ol><li>通过创建适当类的实例并设置其属性来定义自定义 FLayout、菜单和工具栏。</li><li>自定义 Slate 窗口现在将绑定到 TabManager，并使用自定义 FLayout、菜单和工具栏显示资产编辑器。</li></ol><p><strong>② 调用父类方法InitAssetEditor将自定义 Slate 窗口绑定到 TabManager。</strong></p><h3 id="3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法："><a href="#3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法：" class="headerlink" title="3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法："></a>3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法：</h3><p>+ 我们首先需要知道，Tab(SDockTab)是引擎定义的一个控件类，每一个Tab都是可以被关闭或打开的SWidget.Tab类型的窗口右上角包含一个关闭按钮。窗口内则可以包含自定义显示的各种Slate内容。</p><p>+ 我们打开编辑器时，就会根据Layout布局加载对应的Tab控件，并显示其中的内容，即Tab装入的子控件(Child Slate)。</p><p>+ 在此方法中，最重要的是调用TabManager对象，TabManager类主要用于管理编辑器中的布局，创建Tab对象。在类中我们需要定义一个FName类型的TabID变量，用于在该方法中指示一个Slate窗口。我们需要通过调用TabManager的方法RegisterTabSpawner绑定TabID和Slate，用于后续定义Slate控件的显示。</p><h3 id="3-3-SpawnTab-CustomWidget方法"><a href="#3-3-SpawnTab-CustomWidget方法" class="headerlink" title="3.3 SpawnTab_CustomWidget方法"></a>3.3 SpawnTab_CustomWidget方法</h3><p>在此方法中，将会创建并返回一个SWidget实例。<br>而RegistorTabSpawner方法通过调用TabManager的接口，将该Slate控件实例注册，与TabID进行绑定，并能够在InitCustomAssetEditor方法中添加到布局Flayout中被显示出来。<br>我们不仅可以创建简单的Slate控件（如SButton、IDetailsViews）,也可以创建较为复杂的窗口，如SEditorViewport(3D预览窗口)、SGraphEditor(可以连接复杂自定义的节点<a href="https://zhida.zhihu.com/search?content_id=222180537&content_type=Article&match_order=1&q=%E5%9B%BE%E8%A1%A8%E7%B3%BB%E7%BB%9F&zhida_source=entity">图表系统</a>)等内容，并将其添加到我们的自定义编辑器中。<br>在本文实例中，我在该方法中创建了一个最简单的Slate类SButton。</p><h1 id="模拟云"><a href="#模拟云" class="headerlink" title="模拟云"></a>模拟云</h1><p>Worley Noise</p><p>在空间中随机随便放点，然后计算最近的点的距离，为了连续，把这个的点放八个地方</p><h1 id="虚幻渲染编程"><a href="#虚幻渲染编程" class="headerlink" title="虚幻渲染编程"></a>虚幻渲染编程</h1><p><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻4渲染编程专题概述及目录 - YivanLee的文章 - 知乎</a></p><h1 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h1><p><a href="https://zhuanlan.zhihu.com/p/486808688">【Unreal】虚幻GAS系统快速入门 - LunarMaxim的文章 - 知乎</a></p><p><a href="https://github.com/DriedMachine/GASDocumentation5.3_CN">GAS Document中文翻译</a></p><h2 id="包括什么东西"><a href="#包括什么东西" class="headerlink" title="包括什么东西"></a>包括什么东西</h2><p>GAS主要包含以下内容：</p><ul><li>Who:ASC(Ability System Component) 主要组件，由C++编写，代码里有很多方法是蓝图未实现的。</li><li>How:GA(Gameplay Abilities) 角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI</li><li>What:AS(Attribute Set) 角色身上<strong>可以用float表示的属性</strong>，如生命值、体力值、魔力值等，有BaseValue和CurrentValue，方便回滚</li><li>Change:GE(Gameplay Effects) 用于<strong>修改属性</strong>，如增加50移动速度10s；还能配合GA实现更多玩法</li><li>Visual:GC(Gameplay Cues) 播放特效、音效等</li><li>If:Tag:用来分类，底层是FName，用.来分隔</li><li>Async：Task：如果想要异步的做一些东西，比如做完技能播一个蒙太奇，可以用这个来搞</li><li>Send：Event:ASC之间通信</li></ul><h2 id="做冷却"><a href="#做冷却" class="headerlink" title="做冷却"></a>做冷却</h2><p>角色在启动的时候可以保存一个specAbility，然后拿一个他的handle。</p><p>比如我想实现一个技能的冷却，其实就是做一个GE，然后这个GE启动的时候挂上在人物身上挂一个cooldown的tag，这个tag是有一个duration的，然后释放技能的时候加一个条件，有这个tag的时候无法释放，在ASC上面有一个Activation Blocked Tags，在里面加上刚刚搞的那个tag</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://zhuanlan.zhihu.com/p/463272214">【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南 - 水曜日鸡的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/38881269">《Exploring in UE4》多线程机制详解[原理分析] - Jerish的文章 - 知乎</a></p><h2 id="FRunnable"><a href="#FRunnable" class="headerlink" title="FRunnable"></a>FRunnable</h2><p>创建一个继承自FRunnable的类，把这个类要执行的任务分发给其他线程去执行。</p><p><img src="https://picx.zhimg.com/v2-21dde7f72b7b87f9133b60ab9190e5b5_r.jpg" alt="img"></p><h2 id="AsyncTask系统"><a href="#AsyncTask系统" class="headerlink" title="AsyncTask系统"></a>AsyncTask系统</h2><h2 id="TaskGraph系统"><a href="#TaskGraph系统" class="headerlink" title="TaskGraph系统"></a>TaskGraph系统</h2><p>Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个<a href="https://zhida.zhihu.com/search?content_id=7702163&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&zhida_source=entity">多线程任务</a>，指定各个任务之间的依赖关系，按照该关系来依次处理任务。具体的实现方式网上也有很多案例，这里先给出UE4Wiki的教程链接：</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>《Exploring in UE4》关于网络同步的理解与思考[概念理解] - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34721113">https://zhuanlan.zhihu.com/p/34721113</a></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>要将一个函数声明为 RPC，您只需将 <code>Server</code>、<code>Client</code> 或 <code>NetMulticast</code> 关键字添加到 <code>UFUNCTION</code> 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UFUNCTION</span>( Client )<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientRPCFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>《Exploring in UE4》RootMotion详解【原理分析】 - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/74554876">https://zhuanlan.zhihu.com/p/74554876</a></p><h1 id="DS-专用服务器"><a href="#DS-专用服务器" class="headerlink" title="DS 专用服务器"></a>DS 专用服务器</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/networking-overview-for-unreal-engine#%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">网络概述官方文档</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://www.bilibili.com/video/BV1mP4y1R7UR/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【[UOD2022]虚幻DS的机遇与挑战 | 晶核 刘豪</a> </p><p>NetworkPrediction</p><h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241220222047918.png" alt="image-20241220222047918"></p><p>等级低只同步自己</p><p>把宠物，npc全放在逻辑服，不用同步</p><p>大世界网格小，副本网格范围大</p><p>摄像机背后的actor同步频率低</p><p>不移动的时候降低同步频率</p><p>把不需要同步的属性清理掉。</p><p>使用pushModel，手动标记哪些属性需要更新，这样就不需要同步所有的信息</p><h3 id="物理计算优化"><a href="#物理计算优化" class="headerlink" title="物理计算优化"></a>物理计算优化</h3><p>服务器剔除角色身上所有的装饰器组件</p><p>服务器关闭动画计算，只有业务需要具体坐标时才计算。</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="如何关闭滚动条的显示？"><a href="#如何关闭滚动条的显示？" class="headerlink" title="如何关闭滚动条的显示？"></a>如何关闭滚动条的显示？</h3><p>调用方法<strong>SetScrollBarVisibility</strong>。参数是<a href="https://link.zhihu.com/?target=https://docs.unrealengine.com/en-US/API/Runtime/UMG/Components/ESlateVisibility/index.html">ESlateVisiblity</a>，设成<strong>Collapsed</strong>即可。</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>试玩的一些推箱子游戏记录</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>记录试玩的一些推箱子的idea，希望自己以后也能做出这种puzzle</p><h1 id="箱子联动"><a href="#箱子联动" class="headerlink" title="箱子联动"></a>箱子联动</h1><p>两个双重箱子会联动，并且推墙也会联动</p><p><a href="https://moonsoup.itch.io/sea-snake-safari">https://moonsoup.itch.io/sea-snake-safari</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121116554.png" alt="image-20241117121116554"></p><h1 id="组合箱子"><a href="#组合箱子" class="headerlink" title="组合箱子"></a>组合箱子</h1><p>需要通过拼接箱子的四个边来解谜，而且还能进入箱子里面来实现一些很有意思的操作</p><p><a href="https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09">https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121232954.png" alt="image-20241117121232954"></p><h1 id="推箱子点亮房间"><a href="#推箱子点亮房间" class="headerlink" title="推箱子点亮房间"></a>推箱子点亮房间</h1><p><a href="https://theconspiracy.itch.io/single-screen-scream">https://theconspiracy.itch.io/single-screen-scream</a></p><p>是一个迷宫类的游戏，把箱子推到对应的上面会点亮某个房间的地图，你需要自己画一下这个地图的结构，并且来搞</p><p>代码点评：他的代码太粗暴，每一个level都写了对应的操作，或许这个不太适合用这个编辑器来做，直接用引擎来写会更加简洁，不过创意不错</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121317837.png" alt="image-20241117121317837"></p><h1 id="改变关卡然后再推箱子"><a href="#改变关卡然后再推箱子" class="headerlink" title="改变关卡然后再推箱子"></a>改变关卡然后再推箱子</h1><h2 id="任意的位置"><a href="#任意的位置" class="headerlink" title="任意的位置"></a>任意的位置</h2><p><a href="https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3">https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3</a></p><p>需要先规定步数把关卡的墙壁消除，然后再推箱子，这个引擎竟然还可以这样有先后顺序，非常神奇啊，等等研究一下是怎么搞的， 相当牛逼啊</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117124647189.png" alt="image-20241117124647189"></p><h2 id="变身成铲子来改变，位置是有限的"><a href="#变身成铲子来改变，位置是有限的" class="headerlink" title="变身成铲子来改变，位置是有限的"></a>变身成铲子来改变，位置是有限的</h2><p><a href="https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea">https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea</a></p><p>这个需要捡起铲子来改变地形，会有不同，和自由的不太一样，设计思路也不太一样</p><p>他这个代码也很简单，因为他的规则集很统一，写的很好这个代码，三百行就搞定了</p><p>还讲了个小故事，不赖</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118232458914.png" alt="image-20241118232458914"></p><h2 id="场景中的物体也可以自己编辑"><a href="#场景中的物体也可以自己编辑" class="headerlink" title="场景中的物体也可以自己编辑"></a>场景中的物体也可以自己编辑</h2><p><a href="https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0">https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0</a></p><p>比如这一关是如何把这个小点搞出来</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118235755770.png" alt="image-20241118235755770"></p><h2 id="推箱子本身会改变路"><a href="#推箱子本身会改变路" class="headerlink" title="推箱子本身会改变路"></a>推箱子本身会改变路</h2><p><a href="https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab">https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab</a></p><p>箱子本身是一条以自身为中心的十字路，推箱子会改变主人公能走的位置，要通过这个推完成目标</p><p>关卡有点少，只有四关</p><p>一边推一边思考路的过程还是挺有趣的，要考虑的东西有点意思</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085156436.png" alt="image-20241119085156436"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119083807340.png" alt="image-20241119083807340"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084051277.png" alt="image-20241119084051277"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084505536.png" alt="image-20241119084505536"></p><h1 id="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"><a href="#改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径" class="headerlink" title="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"></a>改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径</h1><p><a href="https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337">https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337</a></p><p>会变成像素的数字，这个是可以走的路，蛮有意思</p><p>如果你吃的一瞬间路变没了，你也会死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119100230326.png" alt="image-20241119100230326"></p><h1 id="会连接在一起的箱子，而且中间的线也会挡住东西"><a href="#会连接在一起的箱子，而且中间的线也会挡住东西" class="headerlink" title="会连接在一起的箱子，而且中间的线也会挡住东西"></a>会连接在一起的箱子，而且中间的线也会挡住东西</h1><p>有点拓扑结构的意思</p><p><a href="https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0">https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117155008183.png" alt="image-20241117155008183"></p><h1 id="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"><a href="#推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物" class="headerlink" title="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"></a>推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物</h1><p><a href="https://notaninart.itch.io/pushing-u">https://notaninart.itch.io/pushing-u</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117163406595.png" alt="image-20241117163406595"></p><h1 id="箱子连接，但是本身自己也可以变成箱子，也可以解冻"><a href="#箱子连接，但是本身自己也可以变成箱子，也可以解冻" class="headerlink" title="箱子连接，但是本身自己也可以变成箱子，也可以解冻"></a>箱子连接，但是本身自己也可以变成箱子，也可以解冻</h1><p><a href="https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29">https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29</a></p><p>非常巧妙，自己可以被冰冻变成箱子，也可以解冻，很地狱笑话，被冰冻才能上飞机，太幽默了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118155250549.png" alt="image-20241118155250549"></p><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h1><p><a href="https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259">https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259</a></p><p>推动国际象棋的棋子，目标是走到对面的皇后位置，不能走到能被吃的位置，但是可以推动棋子可以把推动的棋子给杀了。</p><p>感觉可以做一个中国象棋版的来尝试复刻一下</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117221156115.png" alt="image-20241117221156115"></p><h1 id="有步数限制的推箱子"><a href="#有步数限制的推箱子" class="headerlink" title="有步数限制的推箱子"></a>有步数限制的推箱子</h1><p><a href="https://galactical.itch.io/at-the-hedges-of-time">https://galactical.itch.io/at-the-hedges-of-time</a></p><p>很好理解，也很简单的创意，一个trick的点是箱子不会随着自己回退</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118145646564.png" alt="image-20241118145646564"></p><h1 id="箱子本身是一个能和周围互动的装置"><a href="#箱子本身是一个能和周围互动的装置" class="headerlink" title="箱子本身是一个能和周围互动的装置"></a>箱子本身是一个能和周围互动的装置</h1><p><a href="https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5">https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5</a></p><p>按下开关之后箱子会动，会把自己往什么某个方向推，碰撞体积也会发生改变，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118171505291.png" alt="image-20241118171505291"></p><p>其实有些关设计的挺有意思的，因为你需要反复来回来利用本身他之后弹开的位置来占住那个开关，然后再去推，这样其实有一种联动的感觉，后面感觉会有那种一下联动好几个然后按顺序搞的感觉，感觉很有意思</p><h1 id="保龄球推箱子"><a href="#保龄球推箱子" class="headerlink" title="保龄球推箱子"></a>保龄球推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9">https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9</a></p><p>推的目标箱子推一次会一直往前滚，所以需要用生成的反射东西来组装好路径来搞，设计的比较简单，但是还是挺有意思的，和我们做的反射光的游戏甚至有点像，他里面有一分为二，还有生成东西的道具</p><p>但是他的关卡太简单了，不够多</p><p>而且他这个能推很多次，如果做成只推一次，会好很多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118201017238.png" alt="image-20241118201017238"></p><p>他的还有一个机制是遇到已经放好的花朵会导致提前停下，或许就是因为这一点所以他没有做一击通关，这样难度会很高</p><h1 id="不能自己往上的推箱子"><a href="#不能自己往上的推箱子" class="headerlink" title="不能自己往上的推箱子"></a>不能自己往上的推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb">https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb</a></p><p>因为主角是一个落叶，所以做了往上方向的限制，只能通过喷泉来往上，这种限制也蛮有意思的。但是可以同时推多个箱子，也要利用这个。</p><p>还有一个机制，在水里的话就可以往上推，可以借助水的浮力，比如这一关就是这样</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118234135382.png" alt="image-20241118234135382"></p><h1 id="推箱子和一笔画？"><a href="#推箱子和一笔画？" class="headerlink" title="推箱子和一笔画？"></a>推箱子和一笔画？</h1><p><a href="https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729">https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729</a></p><p>规则很简单，往某个地方推会朝那个方向生成一个箱子，目标是把所有的红色都占满</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085545410.png" alt="image-20241119085545410"></p><h1 id="箱子的状态会被改变（火）"><a href="#箱子的状态会被改变（火）" class="headerlink" title="箱子的状态会被改变（火）"></a>箱子的状态会被改变（火）</h1><p><a href="https://rosden.itch.io/theflames">https://rosden.itch.io/theflames</a></p><p>被火烧了会有几个状态，中间有四步移动的机会，这时候不会完全变成灰烬，还可以被推，可以用来填补空洞；之后会变成灰烬，不能被推动，也不会挡路（第一关就是教你这个，不挡路）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119092837131.png" alt="image-20241119092837131"></p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的独立游戏作品合集</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="完美世界GameJam"><a href="#完美世界GameJam" class="headerlink" title="完美世界GameJam"></a>完美世界GameJam</h1><p>开发日期：2024.3.15</p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a></p><p>一个关于骰子的肉鸽游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"></a></p><h1 id="2024CigaGamejam"><a href="#2024CigaGamejam" class="headerlink" title="2024CigaGamejam"></a>2024CigaGamejam</h1><p>主题：有限与无限</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">试玩连接</a></p><p>一个关于1v3的不对成派对游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"></a></p><h1 id="2024下半年Booom"><a href="#2024下半年Booom" class="headerlink" title="2024下半年Booom"></a>2024下半年Booom</h1><p>主题：change_,not change _</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">试玩连接</a></p><p>一个类似卡坦岛的生存游戏，美术不错</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"></a></p><h1 id="2024TapTapGameJam"><a href="#2024TapTapGameJam" class="headerlink" title="2024TapTapGameJam"></a>2024TapTapGameJam</h1><p>主题：light</p><p>开发日期：2024.10.25-11.1</p><p><a href="https://rorschachandbat.itch.io/lightpuzzle">试玩连接</a></p><p>一个关于光线解密的游戏，尝试着用ai+godot开发，完成度不错，关卡设计的很有意思</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>落井下食开发日志</title>
    <link href="/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p class="note note-primary">为了避免危险，你需要派遣伙伴们去合适的地方，它们会帮助你，□□食物，应对晚上的客人。 夜晚来临时，客人们会依次到来，你只需要提供它们需要的食物，它们就会满意的离开。</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png" alt="img"></a></p><h1 id="Luban导表工具"><a href="#Luban导表工具" class="headerlink" title="Luban导表工具"></a>Luban导表工具</h1><p>这次的项目需要填数据的地方非常多，有了上次做肉鸽小游戏的教训，决定搜寻一下有无更加好用的导表工具，最终找到了luban工具，算是比较方便好用的实现方案。</p><p><a href="https://github.com/focus-creative-games/luban">官方链接</a></p><p>作为一个需要大量配表的游戏，最理想的情况是，策划端只需要用excel就可以搞定，程序端也不需要编写处理db的代码，导表工具会自动生成相应的代码。</p><p>具体的例子直接看文档大概能看的明白，当然也有一些实现的非常草率的地方，</p><p>1.无法动态修改数据，就只能重新创建一个一模一样的结构体，因为他自己生成的结构式是read only的，无法实现修改，感觉这个也是可以细想怎么优雅实现的。</p><p>2.没有加数据校验功能，后期策划在编写的时候会出现填错的情况。</p><p>3.excel表无法实现比较复杂的数据结构。</p><h1 id="JKFrame"><a href="#JKFrame" class="headerlink" title="JKFrame"></a>JKFrame</h1><p><a href="http://www.yfjoker.com/JKFrame/">JKFrame使用手册</a></p><p>本次09老师使用了JKFrame作为编程框架，使用起来比较方便，相当于多了一些库，直接用事件系统和ui系统都很方便，以后也可以多用这个框架尝试。</p><h1 id="六边形地图设计"><a href="#六边形地图设计" class="headerlink" title="六边形地图设计"></a>六边形地图设计</h1><p>六边形地图不能直接用二维坐标来表示，并且因为本次项目不需要动态生成，所以就直接在ui上硬编码了整个地图，感觉更加正常的做法是用tilemap，但是因为时间紧迫所以全部都用ui来做了，之后这里可以研究一下如何更优雅的实现这种六边形地图。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png" alt="坐标参考"></a></p><p>坐标参考</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png" alt="demo图"></a></p><p>demo图</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png" alt="最后的成品"></a></p><p>最后的成品</p><p><a href="https://www.redblobgames.com/grids/hexagons/">六边形地图理论基础</a></p><p><a href="https://indienova.com/u/npc233/blogread/11298">六边形地图坐标距离计算（直接看结论版）</a></p><p>计算距离，像这样的坐标体系，有x,y,z三个维度，x,y,z的和始终是0，我们称之为cube坐标，距离计算公式是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br><br>TS<br>diatance=<span class="hljs-built_in">max</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))<br><br>TS<br>func <span class="hljs-built_in">posDistance</span>(pos1,pos2):<br>    <span class="hljs-selector-tag">var</span> cubePos1=<span class="hljs-built_in">getCubePosFromPos</span>(pos1)<br>    <span class="hljs-selector-tag">var</span> cubePos2=<span class="hljs-built_in">getCubePosFromPos</span>(pos2)<br>    <span class="hljs-selector-tag">var</span> distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br>    return distance<br><br>CPP<br></code></pre></td></tr></table></figure><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这次项目作为一个ui游戏，简单的使用了MV框架，前期实现整体游戏循环的过程很快，到后面开始拼ui的时候其实有很大的沟通失误，缺少一个统筹规划工作量的人，来预估这个完成的时间。我自己心目中的完成时间点和实际的完全不一样，比如说地图，到了最后几天才分配给我做，我本以为是第二个周末就能完成的事情，我觉得09花了太多的时间来重构代码，并且重构之后也没经过测试，这个风险非常大，我个人认为应该先保证所有功能都完备了再进行重构的工作，不然卡在这里也无法进行下一步的推进。</p><p>其实这又是一个沟通问题，如果没有一个责任人站出来，那么我就会倾向于摆烂，并且祈祷或者默认其他人能完成，这就导致了我们最后ui和玩法上还有很多bug没修完，如果倒数第二个周末就有人站出来规划好预计的时间，或许最后交上去的结果会好很多。</p><h2 id="测试以及策划功能优先级问题"><a href="#测试以及策划功能优先级问题" class="headerlink" title="测试以及策划功能优先级问题"></a>测试以及策划功能优先级问题</h2><p>再来讲讲测试的问题，理想的情况是做完一个功能就马上有人来验收，并且这个人是知道所有的功能细节，这样是效率最高的测试方法，所以要么是程序自测，要么是策划验收，如果再找一个测试来验收就还需要和他沟通具体的细节。</p><p>但是中期出现的问题是，队伍策划需要干的事情实在<strong>太多了</strong>，既要设计玩法，还要调整数值，还要设计ui，还要验收功能。但是这些事情我认为应该是有优先级的，应该是要保证完成游戏完整性而服务，也就是设计ui和验收功能为更优先，因为这些都是会影响其他人的工作流的，一旦这个地方卡住了，其他人就要<strong>等待这里完成</strong>，会陷入到无事可干，并且必须要完成好最终确定的游戏，才能开始跑游戏测试数值。</p><p>而关于数值设计，既然我们已经分离开了数据和玩法，大可之后再根据测试的反馈来更改数值，数值设计应该也是需要有一套<strong>方法论</strong>的，这个是需要思考学习的。</p><h2 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h2><p>在前期的设计阶段，我总是觉得已有的玩法过于简单，能够一眼望穿，所以提出了很多想要增加策略性的建议，比如增加道具种类，地图增加走格子玩法，白天从三个动物变成牌组的形式，但其实最后做下来，看玩家的反馈已经足够复杂。我开始意识到我走入了一个非常大的误区，作为开发者，对于自己的游戏当然足够熟悉，所以总是会觉得过于简单，而失去了站在旁观者来审视游戏复杂度的能力，很容易把游戏玩法膨胀得很难。当然，这也和我前面提到的<strong>快速测试并且验证思路</strong>有关，总是因为我们没有快速验证的过程，所以会让我有这种恐慌。</p><h2 id="主题和音乐和美术"><a href="#主题和音乐和美术" class="headerlink" title="主题和音乐和美术"></a>主题和音乐和美术</h2><p>这次游戏的另一个教训是有关于游戏的其他方面，我总是太过于在于游戏机制的设计，但是忽略了其他人看中的部分，比如主题、美术和音乐的统一性，ui设计的合理性，还是提到的一点，每个人对于jam最终作品的想象不一样，我所追求的是一个好玩的东西。但是可能其他人更愿意的是一个完整的作品，一个从机制到主题到美术音乐统一并且完整的作品，那就必然牺牲一部分有趣度的考量，而</p><p>这点以后要改进的是，和别人一开始就要沟通清楚<strong>自己的愿景</strong>，这样才能共同朝着一个方向努力。</p><h1 id="获得的一些灵感"><a href="#获得的一些灵感" class="headerlink" title="获得的一些灵感"></a>获得的一些灵感</h1><p><strong>西西弗斯</strong><br>糯米团子，做一个自动放置小游戏，不过是翻山，讽刺一下西西弗这个意象。</p><p><strong>todolist直接改的模拟经营</strong><br>模拟经营，但是像babaisyou一样，目标是可以根据自己的东西来拖动的，比如需要10个肉直接变成需要10个草。</p><p><strong>放置挂机+自走棋</strong></p><p>白天放置挂机拿资源，晚上自走棋战斗，更加纯粹简单的快乐。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次作品的完整性还是相当高的，作为一个三周的作品美术音乐音效玩法都非常融洽，给自己朋友家人试玩也是相当开心，作为自己第一个完整度这么高的作品也是相当开心了。真的相当感谢队友们的付出，队友们都非常给力，性格也相当nice，沟通起来都非常舒服，感谢队友的配合，学到了很多，希望以后能再次合作。</p><h1 id="还需要研究的问题"><a href="#还需要研究的问题" class="headerlink" title="还需要研究的问题"></a>还需要研究的问题</h1><p>1.六边形地图如何优雅实现</p><p>2.导表的问题</p><p>3.学习数值设计方法论</p><p>4.如何导网页端游戏</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png" alt="image-20240901211645122"></a></p><p>image-20240901211645122</p><p>游戏玩法是1v3的不平衡对抗，每局游戏开始前每个人都会随机到一个关于自身能力的一个buff和一个debuff（比如跳跃次数增加和奔跑速度变慢），人类方的</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>这次比赛的主题是limited and limitless，所以我一开始想的是，给玩家可以自由调控自己的任何能力值，比如奔跑速度，跳跃高度，跳跃次数，冲刺距离……但是你加了一方面的buff，就要选择另一个其他的debuff，然后设计一系列的关卡，看你如何通过你的搭配来最快的过关。这个核心规则比较简单但是变化也相当多，不过被否定了，理由是1.在这种现场试玩做这种一次性的解密游戏很容易让游戏失去游戏性，因为别人看一次就知道怎么玩了，2.可能没有那么多时间来设计关卡。所以他们最后还是决定做一个party game。</p><h1 id="Corgi引擎"><a href="#Corgi引擎" class="headerlink" title="Corgi引擎"></a>Corgi引擎</h1><p><a href="https://corgi-engine-docs.moremountains.com/">corgi引擎文档</a></p><p>先说下corigi引擎的优点，有非常多已经实现的平台跳跃功能，包括丰富的平台，以及人物不同的能力（飞翔，滑翔背包，冲刺），这些都是以</p><h1 id="编码思路和组件思维"><a href="#编码思路和组件思维" class="headerlink" title="编码思路和组件思维"></a>编码思路和组件思维</h1><h1 id="水面shader"><a href="#水面shader" class="headerlink" title="水面shader"></a>水面shader</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png" alt="一开始的效果"></a></p><p>一开始的效果</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png" alt="加了水面shader的效果"></a></p><p>加了水面shader的效果</p><p>一开始的加一个镜面反射和流动水的效果，就好看许多</p><h1 id="测试暴露的问题"><a href="#测试暴露的问题" class="headerlink" title="测试暴露的问题"></a>测试暴露的问题</h1><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>最理想的情况是策划来进行这个关卡的设计，但因为这次的策划是一个比较新手的人，到了最后也没能成功下载unity，并且也没有任何设计关卡的经验，所以只能由我自己来拼一个关卡了。</p><p>我的设计思路是观看我最喜欢的partygame，move or die的一些地图，然后再摆出目前能实现的平台：长条，斜坡，弹跳蘑菇，下落方块，（和mod里面差的也就是一个传送门）当然corgi里面还实现了很多其他平台效果但是都因为我们缺少美术就没有做了，根据</p><h2 id="跳跃手感"><a href="#跳跃手感" class="headerlink" title="跳跃手感"></a>跳跃手感</h2><p>作为一个平台跳跃，跳跃手感是至关重要的，一个很重要的标准是，就算没有任何的关卡，没有任何的剧情，你只需要操控着你的角色跑一下挑一下，如果你觉得很畅快那就是一个好的手感，</p><p>关于手感有许多很好的视频，</p><p><a href="https://www.bilibili.com/video/BV1M441197sr/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【游戏制作工具箱】《蔚蓝》的手感为何迷人？</a></p><p><a href="https://www.bilibili.com/video/BV15C411r7Ju/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【GMTK|中英字幕】马里奥跳跃的秘密</a></p><p>事实上corgi游戏里面已经对跳跃的参数给了很多自由的参数，比如</p><h2 id="试玩的插曲"><a href="#试玩的插曲" class="headerlink" title="试玩的插曲"></a>试玩的插曲</h2><p>线下试玩非常有趣，遇到了一个非常精通平台跳跃的玩家，蔚蓝打通c面的那种，我和他1v1打了许久，一开始我想着让一下他，不要打消他的热情，但是再玩了几把之后我发现是他是真的很强，所以索性放开了跟他玩，但是他还是偶尔能赢，不过由于某些关卡设计和机制设计，让他随机到了只能跳一次就基本赢不了，所以我索性在给他开放了冲刺的功能，让他</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>corgi引擎</p><h2 id="体量"><a href="#体量" class="headerlink" title="体量"></a>体量</h2><p>人手还是不够，这次光是画好人物和boss就已经差不多了，关卡的布置只能自己来搞了，所以做的不是特别好。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计问题也有很多，比如一开始说到的只能四个人玩，导致在现场体验的时候很难凑到四个人，这点还是致命伤啊。</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"></a></p><p>首先简单介绍一下游戏玩法，你和boss会轮流骰两个骰子，你需要选择是分开触发骰子还是合成触发，比如扔到4和6，你可以选择触发4扇区和6扇区，也可以选择只触发10扇区，每个扇区的牌有主动效果和被动效果，自己回合触发的是主动效果，boss回合触发的被动效果，当然每个回合还可以买牌，所以是一个需要你控制概率的肉鸽游戏。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"></a></p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a>(温馨提示，此版本未经过任何的数值调整，平衡和体验都及其不成熟)</p><h1 id="灵感和讨论过程"><a href="#灵感和讨论过程" class="headerlink" title="灵感和讨论过程"></a>灵感和讨论过程</h1><p>本次gamejam的主题是做你想做的游戏，并且也不要求你做出一个可玩的游戏，你做出关于游戏的ppt就能算完成。由此可见完美这次压根就不是想做一个jam，而是抱着一种想要偷你点子给公司赚钱的目的，所以我们索性就做一个自己想玩的游戏算了。</p><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h1 id="技能设计"><a href="#技能设计" class="headerlink" title="技能设计"></a>技能设计</h1><h1 id="dotween"><a href="#dotween" class="headerlink" title="dotween"></a>dotween</h1><h1 id="桌游转电子游戏的痛点和思考"><a href="#桌游转电子游戏的痛点和思考" class="headerlink" title="桌游转电子游戏的痛点和思考"></a>桌游转电子游戏的痛点和思考</h1><p>桌游的乐趣和电子游戏的乐趣非常难转换，桌游的乐趣在于与人互动，虽然也有很多自闭刷分的游戏，但是也是要与人交互的，他要求人与人之间是平等的决策思路，而单机游戏如果简单的转换成打boss，那就会变得很不一样，相当难转换，这就是为什么很多桌游的机制不能用在电子游戏上来，当然这个是一个值得持续思考的问题。</p><h1 id="题外话和八卦"><a href="#题外话和八卦" class="headerlink" title="题外话和八卦"></a>题外话和八卦</h1><p>非常可笑的是，做完jam的第二周，我就被通知优化了，真是唏嘘啊。</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>鸣潮体验报告</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h1><p>经过这一个月的体验，优点和缺点都挺明显的，一度也非常上头，优点就是战斗机制，动作，以及声骸系统比较有趣，缺点就是有一些玩法的手感和设计体验可以改进，以下是一些具体的讲述。</p><h1 id="战斗"><a href="#战斗" class="headerlink" title="战斗"></a>战斗</h1><h2 id="动作系统设计"><a href="#动作系统设计" class="headerlink" title="动作系统设计"></a>动作系统设计</h2><p>战斗的深度还是比较丰富的，有闪避，拼刀，普攻，重击，声骸技能，小技能，大招，换人技能，绳索，跳跃，而且基本所有动作都可以取消，这就给动作系统延伸了很多深度，给了玩家很多进阶技巧的可能，比如跳跃：比如各种换人使用声骸技能无限上天或者一路冲过去不落地，这都是非常有意思的技巧，我觉得官方甚至可以在大地图上放一些只能通过这些特殊技巧才能到达的地点，然后放一些小奖励，作为彩蛋来奖励掌握了这些深度技巧的玩家，类似马里奥奥德赛会在一个非常难跳上去的地方放一堆金币。</p><p>又比如战斗的时候卡延奏技能来打破怪物的拼刀圈，这是非常爽的，有一瞬间打出高伤害的快感。</p><h2 id="战斗模式"><a href="#战斗模式" class="headerlink" title="战斗模式"></a>战斗模式</h2><p>不同的模式侧重点不一样，比如深塔要求速通，可能连招拉怪就比较固定，讲究效率；全息挑战有一种魂类的感觉，一板一眼不能乱吃一招；肉鸽要求策略搭配，随机的快乐。这些战斗模式可以满足不同玩家的需求，</p><h3 id="深塔挑战"><a href="#深塔挑战" class="headerlink" title="深塔挑战"></a>深塔挑战</h3><p>限时挑战</p><h3 id="大boss挑战"><a href="#大boss挑战" class="headerlink" title="大boss挑战"></a>大boss挑战</h3><p>这个主要是通过增加数值来增加玩家的失误惩罚，但是血太厚了也有点无力感，毕竟也有限时的要求，感觉可以把限时给去掉，让人有刮死的可能</p><h3 id="肉鸽"><a href="#肉鸽" class="headerlink" title="肉鸽"></a>肉鸽</h3><p>我非常喜欢肉鸽模式，套路成型之后非常有一种割草的爽感，其中的乌龟套盾流更是相当的爽，只要能拿到满血加攻击力暴击这个buff就能无脑割草。</p><p>目前的肉鸽模式中，有两个build的方向，一个是凑词条来解锁开局带的声骸的技能上限，一个是选buff来产生combo，个人认为前者build起来后比较爽， 无论是化身无冠者战斗还是乌龟套盾都很快乐，但是后者的buff有点过于平淡普通了，大多是简单的加伤害暴击这些数值上的buff，非常简单粗暴，希望接下来可以出一些机制上的buff，这样可以加深肉鸽的策略深度。</p><p>还有一点的话是否可以开启无尽模式，让大家来多爽一下构建好的build。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>游戏整体的开图比较偏向于强引导，前期的各种boss都是通过支线任务引导见面的，支线任务有些太套路化了， 每次结束都是打一个新的boss，毫无新鲜感，而且这也破坏了玩家自主探索地图的过程。</p><p>另外一个破坏探索感的点是，打开地图可以直接看到所有的塔和传送点，或许这是因为出于剧情和难度考虑，不过对于我来说，因为地图上的传送点完全可以在地图上预览到，这就完全失去了开图的乐趣。并且也让地图设计的动线流程，引导全部失去了作用。</p><p>我的开图体验就是标一个还没开的点，然后直直的跑过去，途中如果有正好的宝箱会开一下，但是不会在意其他东西，然后面对着全部打开的地图，就失去了逛街的欲望；或许是不是可以让玩家自己选择游戏模式，可以把未知的传送点和塔设置为隐藏，这样或许能达到我一开始玩塞尔达的那种体验，追着高高的塔去探索，只知道一个大致的方向，然后中途被各种有趣的东西吸引，结果越走越远，越走越分叉，当然这也要求地图上的东西足够有趣，</p><h1 id="任务-amp-剧情"><a href="#任务-amp-剧情" class="headerlink" title="任务&amp;剧情"></a>任务&amp;剧情</h1><p>我觉得加了直接跳过有点破坏体验，中间有很多支线任务我都是直接全部跳过剧情，然后前往下一个点按一下f，或者打一下怪，游戏变成了一个大大的to-do list，并且显示十分枯燥，真就变成了一只在斯金纳箱的小白鼠，一直不停的跳过跳过只为了最后的奖励。</p><p>所以我觉得加剧情梗概或者快进是一个非常重要的功能，既能让玩家感受到剧情也能减负。或者可以考虑做一个galgame里面常见的历史对话，让玩家可以自己读跳过的对话。</p><h1 id="养成玩法"><a href="#养成玩法" class="headerlink" title="养成玩法"></a>养成玩法</h1><p>能养成的丰富度还是有的，人物等级，人物命座，武器等级，人物技能，声骸等级，声骸初始属性，声骸升级词条；其中声骸相关的是刷的重点，不过声骸的刷要从能稳定出金才开始，也就是大概数据坞18级（记不太清了），所以前三十级升声骸比较亏，因为无法把别的词条转移。</p><p>除了声骸是赌博玩法之外其他都是看得见的积累，这一点相对来说比较没那么坑，但是后续的数值养成是否会深度不够？不过这个方面我也不太懂。</p><h1 id="解谜和小玩法"><a href="#解谜和小玩法" class="headerlink" title="解谜和小玩法"></a>解谜和小玩法</h1><h2 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h2><p>这个玩法比较有趣，一笔画，其实可以借鉴一下the witness或者mini metro这些一笔画游戏，可以把这个趣味性做的更有深度。</p><h2 id="2d玩法"><a href="#2d玩法" class="headerlink" title="2d玩法"></a>2d玩法</h2><p>凌阳任务有一段转变成2d的玩法，这一段挺有意思，但是跳跃和冲刺的手感有点打磨不够好，跳起来感觉轻飘飘的，冲刺的速度没有明显加速，似乎是直接把3d里面的跳跃和冲刺参数直接拿过来，而且似乎没有土狼时间，所以导致跑起来手感很奇怪。</p><p>我觉得2d玩法挺有意思的，一开始3d转2d的时候非常有意思，之后如果有想法可以多做一些这种关卡和解谜，参考fez和马里奥奥德赛。</p><h2 id="找金币跑酷"><a href="#找金币跑酷" class="headerlink" title="找金币跑酷"></a>找金币跑酷</h2><p>每次遇到这个玩法我都无法收集完全部的金币，体验比较差，能否能在玩法开始前拉一个远镜头，告诉玩家大概得路线是怎样的，或者对于一些比较长的路线做一个预览图，告诉玩家路线。可以参考马里奥奥德赛里面的金币收集小玩法，还有一个</p><h2 id="声骸玩法"><a href="#声骸玩法" class="headerlink" title="声骸玩法"></a>声骸玩法</h2><p>变身成声骸跑酷还是比较有意思的，很有马里奥奥德赛里面附身变身的快乐，不过做的玩法有好有坏，以下是简单点评。</p><h3 id="蝴蝶"><a href="#蝴蝶" class="headerlink" title="蝴蝶"></a>蝴蝶</h3><p>这个玩法在电脑上体验一开始上手有点反逻辑，因为从wasd控制方向直接变成了鼠标完全控制方向，键盘仅仅用于加减速，而且某些移动靶想要完美通过的接口确实比较难。不过这个思路是挺有趣的，相对的变身成河豚跑酷就好很多。</p><h3 id="河豚"><a href="#河豚" class="headerlink" title="河豚"></a>河豚</h3><p>这个操作感就好一点，并且喷水加速的感觉很有奥德赛里面的变身成墨鱼喷水加速飞天的感觉，所以玩起来很快乐。</p><h3 id="鸟追逐战"><a href="#鸟追逐战" class="headerlink" title="鸟追逐战"></a>鸟追逐战</h3><p>一开始知道支线能变身鸟飞来作战非常期待，但是实际玩起来有点失望， 因为不用自己控制方法，只需要点击左键攻击和放大招就完事了，少了一点操纵感，如果未来还要类似的可以考虑增加玩家的操作维度。</p><h3 id="蜥蜴烧荆棘"><a href="#蜥蜴烧荆棘" class="headerlink" title="蜥蜴烧荆棘"></a>蜥蜴烧荆棘</h3><p>我记得一开始遇到一个荆棘挡路的时候，下意识地用了蜥蜴喷火的声骸技能，结果真的烧起来了，这个一开始见到还是比较经验的，颇有塞尔达点火射箭然后解谜过关的感觉，但是后面很多次我想继续重复这个知识，结果只能用旁边的爆炸球来解决眼前的荆棘，这个体验有点不好。</p><h3 id="未来可能"><a href="#未来可能" class="headerlink" title="未来可能"></a>未来可能</h3><p>未来是否有可能在大世界里加入更多声骸玩法，类似帕鲁，或者奥德赛这样直接变身声骸赶路，或者做一些特定解谜，然后把跑酷玩法手感优化。</p><h3 id="3d限时跑酷"><a href="#3d限时跑酷" class="headerlink" title="3d限时跑酷"></a>3d限时跑酷</h3><h2 id="音游"><a href="#音游" class="headerlink" title="音游"></a>音游</h2><p>手机上体验有一个反直觉的点，我一开始以为可以直接按中间的下落界面来操作，类似节奏大师，但是结果只有右下角的按钮才能响应操作，很奇怪，期待之后能做出更多音游玩法。</p><h2 id="控物填满拼图"><a href="#控物填满拼图" class="headerlink" title="控物填满拼图"></a>控物填满拼图</h2><p>这个玩法不太行， 主要是因为控物的操作太复杂了，首先这不是一个一眼能看出的谜题，所以就需要比较多的试错，传统的拼图puzzle一般是直接用鼠标拖动，这样试错起来就很简单，但是大世界里面采用控物来拼图，不仅要求对准，而且旋转和放下的操作也很缓慢，所以就很容易让人很暴躁，可以考虑简化操作。这个玩法的两个，打通光路和拼石头都比较体验不好。</p><p>其实控物这个操作还是挺有意思，但是操作感太差了，我一开始下意识以为能像王国之泪那样调整远近啊，旋转啊这样，但是其实并没有做到，希望未来可以改进，或许可以加入更多相关的解谜玩法。</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UE引擎LGUI框架记录</title>
    <link href="/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/"/>
    <url>/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>注册事件的写法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在EventDefine.ts里添加对应的枚举和interface</span><br><br><span class="hljs-title class_">GuideGroupOpening</span>, <span class="hljs-comment">//引导组打开</span><br>    <br>[<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideFocusNeedUiTabView</span>]: <span class="hljs-function">(<span class="hljs-params">stepInfo: GuideStepInfo, focusConf: GuideFocusNew</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>        <br><span class="hljs-comment">// 在对应的Controller的OnAddEvents和OnRemoveEvents添加</span><br>        <br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Add</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Remove</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><br><br><span class="hljs-comment">// 在对应的Model代码添加触发器</span><br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Emit</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Owner</span>!.<span class="hljs-property">Id</span>, isPreExecute);<br></code></pre></td></tr></table></figure><h1 id="LGUI在TS中的绑定写法"><a href="#LGUI在TS中的绑定写法" class="headerlink" title="LGUI在TS中的绑定写法"></a>LGUI在TS中的绑定写法</h1><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>prefab会有一个LGUIComponentsRegistry组件，定义了引用的顺序，例如：</p><p><img src="C:\Users\jiangliyong\AppData\Roaming\Typora\typora-user-images\image-20240619141651430.png" alt="image-20240619141651430"></p><p>然后在OnRegisterComponen方法里面按照熟悉绑定即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">ButtonMask</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextName</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextureBg</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UITexture</span>],<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p><a href="https://kurogame.feishu.cn/wiki/LR2lwhGmci2wxGk0ISPcCp9Enwf">‌⁠‬‌‬‬‬﻿‬﻿‌‌‍‌‬﻿﻿‬⁠‍﻿LGUI设计说明文档 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcn93vYNH8Hduj3SAJaSPuG8f">‌﻿﻿‍⁠⁠‬‬﻿‬﻿‍‬‬‌‍﻿‌‌‌Ts Ui框架说明 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/JicQw8apsiUMXukKIhacLdNInYf">‌⁠‌‬﻿‬‍﻿‌⁠‍‌⁠﻿⁠﻿‌‌⁠‌⁠‌‌‍‬‍‌﻿业务UI框架重构 - 飞书云文档 (feishu.cn)</a></p><p>一些关键的基类：ComponentAction（所有UI类和UIBehavior类的共同最终基类，实现了一套带状态的生命周期调度和可重载接口）、UIPanelBase（提供给小UI，即界面中的格子、小界面等继承，拥有丰富的UI相关操作能力）、UIViewBase（提供给界面继承，它本身也继承自UIPanelBase，在其上扩展了动画、场景、事件、读取UI配置表的能力），继承关系ComponentAction-&gt;UIPanelBase-&gt;UIViewBase</p><p>UiPanelBase.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">ComponentRegisterInfos</span>: <span class="hljs-title class_">TComponentsRegisterInfo</span>[] = [];<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">BtnBindInfo</span>: <span class="hljs-title class_">TBtnBindInfo</span>[] = []; <span class="hljs-comment">//所有按钮绑定事件的定义</span><br><br><span class="hljs-comment">// 重写OnRegisterComponent方法</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CgTextureBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CaptionText</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnAuto</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIItem</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnHide</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        ];<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>生命周期函数（带Async是异步版本）</p><p>OnRegisterComponent：绑定具体界面定义的enum里面的控件。</p><p>OnAddEventListener：添加ui事件监听，按钮啥的</p><p>控件相关的api在UIItem.d.ts里面</p><p>比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetButton</span>(<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>)!.<span class="hljs-property">RootUIComp</span>.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="预制体中组件的显示与隐藏"><a href="#预制体中组件的显示与隐藏" class="headerlink" title="预制体中组件的显示与隐藏"></a>预制体中组件的显示与隐藏</h1><p>SetUIActive</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetItem</span>(<span class="hljs-title class_">ETutorialsPopupComponents</span>.<span class="hljs-property">PnlBottom</span>)!.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="UI动画调用"><a href="#UI动画调用" class="headerlink" title="UI动画调用"></a>UI动画调用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelSequencePlayer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">RootItem</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Start&#x27;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Loop&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="游戏中LGUI层级结构"><a href="#游戏中LGUI层级结构" class="headerlink" title="游戏中LGUI层级结构"></a>游戏中LGUI层级结构</h1><p><a href="https://kurogame.feishu.cn/wiki/wikcntd0SV4OAJV1fG3Md9LxpHV">‌‍‍‌⁠‌﻿⁠‌﻿‬⁠﻿⁠‍‬⁠‌‌‌‍﻿‌‍‌⁠﻿UI层级节点描述文档，包含容器逻辑实现规则 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnNqg8wjO5u8dNApZbfzoJMe">屏幕空间UI层级说明 - 飞书云文档 (feishu.cn)</a></p><h2 id="Hud层"><a href="#Hud层" class="headerlink" title="Hud层"></a>Hud层</h2><p>交互和剧情界面旁白</p><h2 id="Normal层"><a href="#Normal层" class="headerlink" title="Normal层"></a>Normal层</h2><p>常规系统界面，只显示最表面的界面</p><h2 id="NormalMask层"><a href="#NormalMask层" class="headerlink" title="NormalMask层"></a>NormalMask层</h2><p>Normal层的点击阻挡遮罩</p><h2 id="Pop层"><a href="#Pop层" class="headerlink" title="Pop层"></a>Pop层</h2><p>可交互弹窗</p><h2 id="Float层"><a href="#Float层" class="headerlink" title="Float层"></a>Float层</h2><p>飘字和提示</p><h2 id="NetWork层"><a href="#NetWork层" class="headerlink" title="NetWork层"></a>NetWork层</h2><p>网络提示相关的ui</p><h2 id="Mark层"><a href="#Mark层" class="headerlink" title="Mark层"></a>Mark层</h2><p>以上所有层的点击阻挡遮罩</p><h2 id="Pool层"><a href="#Pool层" class="headerlink" title="Pool层"></a>Pool层</h2><p>对象池界面，优化性能使用</p><h1 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h1><p>使用AudioSystem</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">const LOOP_DIGITAL_SCREEN = <span class="hljs-string">&#x27;play_ui_digital_screen&#x27;</span><span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.PostEvent(LOOP_DIGITAL_SCREEN)<span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.ExecuteAction(LOOP_DIGITAL_SCREEN, UE.EAudioActionType.Stop)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="修改某一个组件的具体参数"><a href="#修改某一个组件的具体参数" class="headerlink" title="修改某一个组件的具体参数"></a>修改某一个组件的具体参数</h1><p>使用SetCustomMaterialScalarParameter，这里要用到FName</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> factor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-title class_">FName</span>(<span class="hljs-string">&#x27;factor&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetCustomMaterialScalarParameter</span>(<br>            factor,<br>            <span class="hljs-title class_">ModelManager</span>.<span class="hljs-property">DigitalScreenModel</span>?.<span class="hljs-property">TextFactor</span> ?? <span class="hljs-number">0.2</span>,<br>        );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏杂货铺</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-Unity相关</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/20201004160417460.png"></p><p><strong>1、静态构造函数</strong><br>当程序集被加载的时候就被调用了，如果你的unity处于编辑状态时，此时你保存一个脚本（从而迫使重新编译），静态构造函数会立即被调用，因为unity加载了DLL。并且它将不会再次运行，永远只会执行一次，unity运行时，是不会再次执行了！在一个已部署的游戏上，这个构造器将会在unity加载过程的早期被调用！</p><p><strong>2、Awake</strong><br>只会被调用一次，在Start方法之前被调用！ 主要用于字段值的初始化工作，禁用脚本，创建游戏对象，或者 Resources.Load(Prefab) 对象</p><p><strong>3、Start</strong><br>只执行一次，在Awake方法执行结束后执行，但在Update方法执行前执行， 主要用于程序UI的初始化操作，比如获取游戏对象或者组件</p><p><strong>4、Update</strong><br>每一帧执行的，监听用户输入，播放动画，当机器忙或者性能差的时候，他会停止执行，会产生停顿的感觉，例如一个人本来在1米的位置，突然到了5米的位置上，产生了跳帧，而下面的FixedUpdate方法则相反！会一米一米的去执行！（自己调试发现，Update是先于OnGUI执行的，且执行一次Update之后，会执行两次OnGUI）</p><p><strong>5、FixedUpdate</strong><br>不管当前机器忙不忙，都会保证每一帧执行一次！避免跳帧！固定更新。固定更新常用于移动模型等操作。</p><p><strong>6、LateUpdate</strong><br>先执行Update，然后才去执行lateUpdate(Update方法执行完，必定接着执行LateUpdate，而Update和FixedUpdate方法的执行顺序不确定，而且有时候FIxedUpdate执行了多帧，而Update却只执行了一帧，这就是因为跳帧的缘故造成的（取决于你的机器性能）！)，如果现在有100个脚本，分别有100个 Update()函数，其中只有一个LateUpdate，那么在同一帧中，等待100个Update()执行完后，才执行这一个LateUpdate()。</p><p><strong>7、OnGUI</strong><br>在这里面进行GUI的绘制，且GUI是每帧擦除重绘的！仅仅只是绘制！没有生命周期的概念！所有关于绘制GUI的代码，都要直接或者间接地写到OnGUI方法中！</p><p><strong>8、OnDestroy</strong><br>当前脚本销毁时调用</p><p><strong>9、OnEnable</strong><br>脚本可用时被调用、如果脚本是不可用的，将不会被调用！</p><p><strong>11、OnDisable</strong><br>如果脚本被设置为不可用将会被执行，程序结束时可用的脚本也会执行一次这个方法</p><p>OnEnable 和 OnDisable 只受脚本的可用状态的影响（enabled）,而 OnBecameVisible 和 OnBecameInvisible 是受对象是否可见的影响！即使脚本设置为不可用，OnBecameVisible 和 OnBecameInvisible 也会被执行，主要是看对象是否在场景中显示了！</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ugui"><a href="#ugui" class="headerlink" title="ugui"></a>ugui</h2><h3 id="rebatch和rebuild"><a href="#rebatch和rebuild" class="headerlink" title="rebatch和rebuild"></a>rebatch和rebuild</h3><p><a href="https://zhuanlan.zhihu.com/p/266997416">Unity UI 优化学习总结 - 天欲雪的文章 - 知乎</a></p><p><strong>Canvas</strong>（画布），和名字一样，是 UI 绘制的地方，Unity 的渲染系统用其来提供一个可绘制的分层几何。负责将ui几何合批成适合的网格，提交绘制命令给 Unity 的图形系统，这整个过程叫做 <strong>rebatch</strong> 或者 <strong>batch build</strong>。当 Canvas 其子节点下包含 Canvas Renderer 的节点需要进行 rebatch 的时候，就会被标记为脏。</p><p>Graphic 与 Layout 都依赖于 CanvasUpdateRegistry 类。它会定位 Graphic 与 Layout 是否需要更新并加入更新队列，在所在 Canvas 的 willRenderCanvases 事件被触发时对队列中的对象执行真正的更新。</p><h2 id="图集有什么用，适用场景。"><a href="#图集有什么用，适用场景。" class="headerlink" title="图集有什么用，适用场景。"></a>图集有什么用，适用场景。</h2><p>定义<br>图集是将很多零碎的2D小图整合成一张大图，方便unity渲染合批，降低渲染消耗。</p><p>优势<br>1.UI的合批处理，减少DrawCall</p><p>多张图片需要多次DrawCall，合并成一张大图只需要调用一次DrawCall</p><p>2.减少对内存的占用</p><p>OpenGL每张贴图都需要设置为2的N次方才能使用，假设有宽高分别为100x100、10x10的两张图片，如果不合成大贴图，那么就需要分别使用128x128和16x16的图片，会浪费一部分内存空间。</p><p>如果是使用一张大图的话，就可以将两张图片打到128x128的图集，进而减少内存的占用。</p><p>3.提升效率</p><p>图片尺寸为2的次幂时，GPU处理起来会快很多，小图不可能做不到每张图都是2的次幂的，但打成一张大图就可以。<br><a href="https://blog.csdn.net/z2014z/article/details/119654256">https://blog.csdn.net/z2014z/article/details/119654256</a></p><h2 id="屏幕自适应方案"><a href="#屏幕自适应方案" class="headerlink" title="屏幕自适应方案"></a>屏幕自适应方案</h2><p>canvas scaler</p><p>锚点</p><h1 id="批处理和drawcall"><a href="#批处理和drawcall" class="headerlink" title="批处理和drawcall"></a>批处理和drawcall</h1><p><a href="https://zhuanlan.zhihu.com/p/432223843">Unity渲染优化的4种批处理：静态批处理，动态批处理，SRP Batcher 与 GPU Instancing - acnestis的文章 - 知乎</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f5b8402d281543a9debe941f9762889a_r.jpg" alt="img"></p><h1 id="常用的Unity-Atrribute"><a href="#常用的Unity-Atrribute" class="headerlink" title="常用的Unity Atrribute"></a>常用的Unity Atrribute</h1><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>unity脚本生命周期函数。</p><p>Lerp作用</p><p>欧拉角计算，Quaternio.Euler。</p><p>常用的Unity Atrribute</p><p>如何判断是否碰到了场景中的物体？</p><p>Coroutine有什么用，优缺点</p><p>发生碰撞的必要条件。</p><p>ugui如何保证分辨率改变ui大小不变。</p><p>C#List底层数据结构，增加和删除时间复杂度。</p><p>结构体和类的区别。</p><p>引用类型和值类型分别有哪些。</p><p>装箱和拆箱是什么，为什么不要频繁适用?</p><p>简单用代码实现一个单例模式。</p><p>观察模式读代码写结构，用在哪里？</p><p>频繁地对字符串进行分割，写一个代码。（就是分数比如说100000，分成100,000这样）</p><p>分批手段和适用场景。</p><h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>渲染管线就是一系列处理数据的过程</p><h2 id="应用程序阶段"><a href="#应用程序阶段" class="headerlink" title="应用程序阶段"></a>应用程序阶段</h2><p>Unity会知道要渲染哪些模型，还有光源相机的信息也会输入进去，然后就会进行剔除，使用AABB包围盒，只要有一个顶点在摄像机的可视范围里面，就不会剔除，然后把这些输入进GPU里面。</p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><p>这个阶段是可以编程写shader的阶段，主要是把空间中的网格顶点编程屏幕上的网格顶点。顶点着色器，对每一个顶点都进行操作，可以简单的传递到下一个阶段，也可以做一些几何变换或者光源颜色相关的变换。</p><p>细分着色器，几何着色器，图元装配</p><p><img src="https://pic4.zhimg.com/v2-470a9d8b774085665f07fae572cc933f_1440w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-游戏相关的一些知识</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h1><p><a href="https://www.cnblogs.com/indream/p/3602348.html">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a></p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h2><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-cc979056c26b13f1e63233776fa9e8ad_720w.webp" alt="img"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f49989545904a5b8f3338ab64806450e_720w.webp" alt="img"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-88c91a4203fe50c44ed366de25ee577d_720w.webp" alt="img"></p><h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><p>一种比较简单计算并且比较自然的曲线的方式，利用插值的方式</p><p>博客教程：<a href="https://www.cnblogs.com/msxh/p/6270468.html">https://www.cnblogs.com/msxh/p/6270468.html</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/798142-20170114161306385-735353264.jpg" alt="img"></p><h1 id="游戏AI"><a href="#游戏AI" class="headerlink" title="游戏AI"></a>游戏AI</h1><p>比较常见的有状态机，行为树，效用系统，目标导向</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h2><p>一个比较简单的改进方案是分层状态机，比如把巡逻的都放在一个大的巡逻里面</p><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h2><p>行为树是树型结构的，每个节点都代表了一个行为，每个行为都可以有子行为。</p><p>所有行为都有一个先决条件，就是产生的这些行为的条件。</p><p>整个算法先从树的根部开始，然后开始检查每一个先决条件。树的每一层只可以执行一个行为，所以当一个行为正在执行，它的兄弟节点都不会被检查，但是它们的子节点还是要检查的。相反如果一个行为的先决条件当前并不满足，则跳过判断它的子节点，继续判断它的兄弟节点。一个树全部检查完毕之后，决定执行优先级最大的，然后再依次执行每个动作。</p><p>不同于状态机，行为树是无状态的，不需要记下之前执行的行为，只是判断行为该不该执行。</p><p>行为树的节点之间是不相关的，删除或增加节点，对其他节点都无影响。所以，可扩展性也是行为树的一个优势。另外还可以为决策树添加灵活性与随机性，父节点可以随机决定是否检查子节点。</p><ul><li>序列（Sequence）节点：顺序执行所有子节点返回成功，如果某个子节点失败返回失败。</li><li>循环（Loop）节点：循环执行子节点到指定次数后返回成功，如果循环次数为-1，则无限循环。</li><li>条件（Condition）节点：根据条件的比较结果，返回成功或失败。</li><li>动作（Action）节点：根据动作结果返回成功，失败，或运行。</li><li>等待（Wait）节点：当指定的时间过去后返回成功。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-c4b17080b7a4f12e765fc52edbfbdd4f_720w.webp" alt="img"></p><h2 id="效用系统"><a href="#效用系统" class="headerlink" title="效用系统"></a><strong>效用系统</strong></h2><p>所以有些情况，只是做这些布尔判断是不合适的，会遗漏很多情况，判断也不妥当。比如：我们可能需要同时考虑与敌人的距离、有多少弹药、饥饿程度、HP值，等等。这些判断条件能映射出许多动作，比我们单一的判断做不做这个动作要好很多。utility-based system，基于效用的系统，会根据权重、比率、队列和许多需要考虑的事项来做出最优选择，使AI比普通的行为树更有头脑。根据上面的例子，使用效用系统我们的AI可以做出我们想要的动作，并根据当前情况做出不同强度的动作，使AI真实、更具可能性，也不再是只有一个正确的选择了。决策树就是对AI说，“只是你将要做的一个行为”，效用系统就是对AI说：“这些是你可能要做的行为”</p><h2 id="目标导向型"><a href="#目标导向型" class="headerlink" title="目标导向型"></a><strong>目标导向型</strong></h2><p>GOAP来源于STRIPS方法，这两种都是让AI创造他们自己的方法去解决问题，我们提供给它一系列可能的动作作为对这个世界的描述，和每个动作使用的先决条件，和行动带来的影响。AI拥有一个初始状态和他需要达到的目标。有一组目标，AI可以通过优先级或当前状态选择一个。计划系统决定一个动作序列来满足当前目标，计划出一个像路径一样的能最简单达到目标状态的动作序列。</p><p>GOAP是一个反向链接搜索，从要实现的目标开始，找到什么动作能实现目标，在寻找刚才动作的先决条件，一直往前推，知道达到你的当前（初始）状态。这种反向链接搜索替代了启发式的前向链接搜索。</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p><a href="https://blog.codingnow.com/2018/08/lockstep.html">lockstep 网络游戏同步方案-云风blog</a></p><p><a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/164686867">细谈网络同步在游戏历史中的发展变化（中） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下） - 网易游戏雷火事业群的文章 - 知乎</a></p><h2 id="帧同步如何要实现什么东西"><a href="#帧同步如何要实现什么东西" class="headerlink" title="帧同步如何要实现什么东西"></a>帧同步如何要实现什么东西</h2><h3 id="确定性的数学和物理运算框架"><a href="#确定性的数学和物理运算框架" class="headerlink" title="确定性的数学和物理运算框架"></a>确定性的数学和物理运算框架</h3><p>计算逻辑采用定点数</p><p>逻辑层表现层分离，表现层可以浮点数</p><h3 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h3><p>UDP加冗余包来保证可靠性</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><h3 id="比赛回放"><a href="#比赛回放" class="headerlink" title="比赛回放"></a>比赛回放</h3><h3 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h3><h1 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><h3 id="描述一下A-算法"><a href="#描述一下A-算法" class="headerlink" title="描述一下A*算法"></a>描述一下A*算法</h3><ol><li>把起点加入 open list 。</li><li>重复如下过程：</li></ol><p>a.         遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。</p><p>b.         把这个节点移到 close list 。</p><p>c.         对当前方格的 8 个相邻方格的每一个方格？</p><p>◆     如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。</p><p>◆     如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。</p><p>◆     如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。</p><p>d.    停止条件</p><p>◆     把终点加入到了 open list 中，此时路径已经找到了，或者</p><p>◆     查找终点失败，并且 open list 是空的，此时没有路径。</p><ol start="3"><li>保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。</li></ol><p>F &#x3D; G + H</p><p>这里，</p><p>G &#x3D; 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。</p><p>H &#x3D; 从指定的方格移动到终点 B 的估算成本。这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 ) 。</p><h3 id="openlist和closelist的作用？"><a href="#openlist和closelist的作用？" class="headerlink" title="openlist和closelist的作用？"></a>openlist和closelist的作用？</h3><p>openlist就是还要搜索的列表，相比于dfs的盲目搜索更加有效率，</p><p>closelist就是已经搜过的或者不可搜的节点，加速过程。</p><h1 id="红点系统"><a href="#红点系统" class="headerlink" title="红点系统"></a>红点系统</h1><p><a href="https://zhuanlan.zhihu.com/p/85978429">Unity手游实战：从0开始SLG——独立功能扩展（三）用树实现客户端红点系统 - 放牛的星星的文章 - 知乎</a></p><p>规划红点系统的时候，我们将整个系统分为独立的三个部分：结构层、驱动层和表现层。</p><p>结构层用来部署红点的层级结构，使用树结构。</p><p>驱动层是指，如何驱动这个树结构产生状态变化，以及状态变化之后如何将变化的行为通知到指定的表现层，在一定的程度上将数据和表现分离开。</p><p>表现层就专门承担表现的职责，比如有的红点就是一个单纯的红点，有的需要显示数字，有的可能是图标晃动，有的是显示new标签，有的是播放特效等等。这些都可以归属在表现层统一去管控。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="https://zhuanlan.zhihu.com/p/23821422">【游戏设计模式】之四 《游戏编程模式》全书内容提炼总结 - 毛星云的文章 - 知乎</a></p><p><a href="https://gpp.tkchu.me/architecture-performance-and-games.html">游戏设计模式</a></p><p>要结合项目中能用到的东西来记忆 </p><h2 id="一、常用GOF设计模式"><a href="#一、常用GOF设计模式" class="headerlink" title="一、常用GOF设计模式"></a>一、常用GOF设计模式</h2><h3 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式"></a>1.命令模式</h3><h3 id="2-享元模式"><a href="#2-享元模式" class="headerlink" title="2.享元模式"></a>2.享元模式</h3><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><h3 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5.单例模式"></a>5.单例模式</h3><h3 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6.状态模式"></a>6.状态模式</h3><h2 id="二、序列型模式"><a href="#二、序列型模式" class="headerlink" title="二、序列型模式"></a>二、序列型模式</h2><h3 id="7-双缓冲模式"><a href="#7-双缓冲模式" class="headerlink" title="7.双缓冲模式"></a>7.双缓冲模式</h3><h3 id="8-游戏循环"><a href="#8-游戏循环" class="headerlink" title="8.游戏循环"></a>8.游戏循环</h3><h3 id="9-更新方法"><a href="#9-更新方法" class="headerlink" title="9.更新方法"></a>9.更新方法</h3><h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><h3 id="10-字节码"><a href="#10-字节码" class="headerlink" title="10.字节码"></a>10.字节码</h3><h3 id="11-子类沙箱"><a href="#11-子类沙箱" class="headerlink" title="11.子类沙箱"></a>11.子类沙箱</h3><h3 id="12-类型对象"><a href="#12-类型对象" class="headerlink" title="12.类型对象"></a>12.类型对象</h3><h2 id="四、解耦型模式"><a href="#四、解耦型模式" class="headerlink" title="四、解耦型模式"></a>四、解耦型模式</h2><p>这个更加像是写代码的方法论。</p><h3 id="13-组件模式"><a href="#13-组件模式" class="headerlink" title="13.组件模式"></a>13.组件模式</h3><h3 id="14-事件队列"><a href="#14-事件队列" class="headerlink" title="14.事件队列"></a>14.事件队列</h3><h3 id="15-服务定位器"><a href="#15-服务定位器" class="headerlink" title="15.服务定位器"></a>15.服务定位器</h3><h2 id="五、优化型模式"><a href="#五、优化型模式" class="headerlink" title="五、优化型模式"></a>五、优化型模式</h2><p>这个可能更偏向于应用。</p><h3 id="16-数据局部性"><a href="#16-数据局部性" class="headerlink" title="16.数据局部性"></a>16.数据局部性</h3><h3 id="17-脏标识模式"><a href="#17-脏标识模式" class="headerlink" title="17.脏标识模式"></a>17.脏标识模式</h3><p>有一些更新很需要花时间的数据，每次循环的时候，加一个标志，如果没有改变就不tick这里。</p><h3 id="18-对象池模式"><a href="#18-对象池模式" class="headerlink" title="18.对象池模式"></a>18.对象池模式</h3><h3 id="19-空间分区"><a href="#19-空间分区" class="headerlink" title="19.空间分区"></a>19.空间分区</h3><h1 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h1><p>ORCA</p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-刷题语法和一些经典算法题思路</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><strong>分割分号</strong></p><p>  stringstream ss(s);</p><p>  while(getline(ss,t,’;’))</p><p><strong>正则</strong></p><p>​    string temp &#x3D; t.substr(1);</p><p>​    if(regex_match(temp, regex(“[0-9]*”))){</p><p>}</p><p><strong>cout输出格式</strong></p><p>  cout &lt;&lt; setiosflags(ios::fixed);</p><p>  cout.precision(2);   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_set&lt;&gt; ch;<br><span class="hljs-type">char</span> text;<br>ch.<span class="hljs-built_in">count</span>();<br>ch.<span class="hljs-built_in">erase</span>(text);<br>ch.<span class="hljs-built_in">insert</span>(text);<br><br><br>stack&lt;&gt; sk;<br>sk.<span class="hljs-built_in">pop</span>();<br>sk.<span class="hljs-built_in">top</span>();<br><br>queue&lt;&gt; qe;<br>qe.<span class="hljs-built_in">pop</span>();<br>qe.<span class="hljs-built_in">front</span>();<br><br><span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:nums)&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分割（Divide）</p><p>将数组递归地分成两半，直到每个子数组只包含一个元素</p><p>单个元素被认为是已排序的</p><p>合并（Merge）</p><p>将两个已排序的子数组合并成一个更大的有序数组</p><p>使用双指针法比较和合并</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">原始数组: [<span class="hljs-number">38</span>, <span class="hljs-number">27</span>, <span class="hljs-number">43</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">82</span>, <span class="hljs-number">10</span>]<br><br>分割过程：<br>[<span class="hljs-meta">38, 27, 43, 3, 9, 82, 10</span>]<br>↙                  ↘<br>[<span class="hljs-meta">38, 27, 43, 3</span>]    [<span class="hljs-number">9</span>, <span class="hljs-number">82</span>, <span class="hljs-number">10</span>]<br>↙        ↘         ↙     ↘<br>[<span class="hljs-meta">38, 27</span>]  [<span class="hljs-number">43</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">9</span>]  [<span class="hljs-number">82</span>, <span class="hljs-number">10</span>]<br>↙    ↘    ↙    ↘       ↙     ↘<br>[<span class="hljs-meta">38</span>] [<span class="hljs-number">27</span>] [<span class="hljs-number">43</span>] [<span class="hljs-number">3</span>]     [<span class="hljs-number">82</span>]  [<span class="hljs-number">10</span>]<br><br>合并过程：<br>[<span class="hljs-meta">27, 38</span>]  [<span class="hljs-number">3</span>, <span class="hljs-number">43</span>]  [<span class="hljs-number">9</span>]  [<span class="hljs-number">10</span>, <span class="hljs-number">82</span>]<br>   ↘        ↙         ↘     ↙<br>[<span class="hljs-meta">3, 27, 38, 43</span>]     [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">82</span>]<br>         ↘              ↙<br>    [<span class="hljs-meta">3, 9, 10, 27, 38, 43, 82</span>]<br></code></pre></td></tr></table></figure><p>时间复杂度</p><p>最好情况：O(n log n)</p><p>最坏情况：O(n log n)</p><p>平均情况：O(n log n)</p><p>空间复杂度</p><p>O(n) - 需要额外的临时数组</p><p>稳定性</p><p>稳定排序 - 相等元素的相对位置不变</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; ary, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = ary.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> m = ary[mid];<br>        <span class="hljs-keyword">if</span>(m==target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m&lt;target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><strong>快排</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span><span class="hljs-comment">//应用二分思想</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mid=a[(l+r)/<span class="hljs-number">2</span>];<span class="hljs-comment">//中间数</span><br>    <span class="hljs-type">int</span> i=l,j=r;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">while</span>(a[i]&lt;mid) i++;<span class="hljs-comment">//查找左半部分比中间数大的数</span><br>        <span class="hljs-keyword">while</span>(a[j]&gt;mid) j--;<span class="hljs-comment">//查找右半部分比中间数小的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;=j)<span class="hljs-comment">//如果有一组不满足排序条件（左小右大）的数</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//交换</span><br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(i&lt;=j);<span class="hljs-comment">//这里注意要有=</span><br>    <span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-built_in">qsort</span>(l,j);<span class="hljs-comment">//递归搜索左半部分</span><br>    <span class="hljs-keyword">if</span>(i&lt;r) <span class="hljs-built_in">qsort</span>(i,r);<span class="hljs-comment">//递归搜索右半部分</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="椭球公式"><a href="#椭球公式" class="headerlink" title="椭球公式"></a><strong>椭球公式</strong></h2><p>x2 &#x2F; a2+y2 &#x2F; b2+z2 &#x2F; c2&#x3D;1。</p><p>当x^2&#x2F;a^2+y^2&#x2F;b^2+z^2&#x2F;c^2&lt;1时　则点(x,y,z)在内部</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><strong>反转链表</strong></h2><h2 id="删除导数第N个数"><a href="#删除导数第N个数" class="headerlink" title="删除导数第N个数"></a><strong>删除导数第N个数</strong></h2><p>总体很简单，有两个特殊的需要注意，第一是只有一个数或者零个数，第二个是需要删除的是第一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!head || !head -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//判断是否只有一个数或者零个数</span><br>ListNode* first = head;<br>ListNode* second = head;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) second = second-&gt;next;<br><span class="hljs-keyword">if</span>(!second) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">//判断是否要删的是第一个数，因为你要是走完发现走到了尽头就说明倒数第N个数是开头，那么久直接返回head-&gt;next就行，用源代码会有bug</span><br></code></pre></td></tr></table></figure><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a><strong>高精度加法</strong></h2><p>一个很妙的不用判断进位并且前面0的处理方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n1&gt;=<span class="hljs-number">0</span> || n2&gt;=<span class="hljs-number">0</span> || jw)&#123;<br>    <span class="hljs-type">int</span> x = n1 &gt;= <span class="hljs-number">0</span> ? num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = n2 &gt;= <span class="hljs-number">0</span> ? num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="n变成1"><a href="#n变成1" class="headerlink" title="n变成1"></a><strong>n变成1</strong></h2><p>n如果是奇数就变成n-1或者n+1，如果是偶数就变成n&#x2F;2</p><p>用动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; dp;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) dp[i] = dp[i/<span class="hljs-number">2</span>] +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure><h2 id="寻找第k大"><a href="#寻找第k大" class="headerlink" title="寻找第k大"></a><strong>寻找第k大</strong></h2><p>（1）基于快排，每轮划分选择一个基准值，把比它小的数放在左边，大的放在右边，函数返回基准值的位置，如果该位置恰好是K，就说明了这是第K小的数，所以从0-基准值位置的数是序列中的前K小数。若返回基准值的位置小于或者大于K，再进行相应调整：如果返回的基准值大于k，在基准值左边序列查找，如果小于，在基准值右边进行查找。递归地进行快排，直到返回的结果&#x3D;K；时间复杂度为O(n)。</p><p>（2）基于堆排序，求前K个最小的数用最大顶堆，求前K个最大的数用最小顶堆。以最大顶堆为例，要维护一个大小为K的顶堆，就是先将K个数插入堆中，随后，对每一个数，与堆顶的最大元素比较，若该数比堆顶元素小，则替换掉堆顶元素，然后调整堆，若大于堆顶元素，则不管，那么将所有元素比较和插入后，该堆维护的就是最小的K个数。求前k小的数用最大顶堆的目的(原理）：这是一种局部淘汰的思想，尽量的把小的数都放在堆中，最后使得即使堆中最大的数，也比外界的所有数都小，就达到了目的。</p><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a><strong>洗牌算法</strong></h2><p>遍历1到n，生成一个随机数，然后把当前位置的和生成位置的交换，复杂度O（n）</p><h2 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h2><h2 id="图如何判断是否有环"><a href="#图如何判断是否有环" class="headerlink" title="图如何判断是否有环"></a>图如何判断是否有环</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>DFS方法的核心思想是：如果在DFS遍历过程中，遇到一个正在访问的节点，就说明存在环。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>不断删掉入度为0的顶点，删的时候记得减掉对应顶点的入度，加入能全部删完，就说明没有环，如果删不完，就说明肯定有环</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">示例图（有环）：<br><span class="hljs-number">0</span> → <span class="hljs-number">1</span> → <span class="hljs-number">2</span><br>    ↑   ↓<br>    └── <span class="hljs-number">3</span><br><br>每个顶点的初始入度：<br><span class="hljs-number">0</span>: <span class="hljs-number">0</span> (没有边指向<span class="hljs-number">0</span>)<br><span class="hljs-number">1</span>: <span class="hljs-number">2</span> (<span class="hljs-number">0</span>和<span class="hljs-number">3</span>指向<span class="hljs-number">1</span>)<br><span class="hljs-number">2</span>: <span class="hljs-number">1</span> (<span class="hljs-number">1</span>指向<span class="hljs-number">2</span>)<br><span class="hljs-number">3</span>: <span class="hljs-number">1</span> (<span class="hljs-number">2</span>指向<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-number">1.</span> 初始状态：<br>入度数组：[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>将入度为<span class="hljs-number">0</span>的顶点(<span class="hljs-number">0</span>)加入队列<br><br><span class="hljs-number">2.</span> 处理顶点<span class="hljs-number">0</span>：<br>- 访问<span class="hljs-number">0</span>，计数=<span class="hljs-number">1</span><br>- 减少其指向的顶点的入度：<br>  <span class="hljs-number">1</span>的入度减<span class="hljs-number">1</span>：[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>- 没有新的入度为<span class="hljs-number">0</span>的顶点<br><br><span class="hljs-number">3.</span> 队列为空，但是：<br>- 还有未访问的顶点(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>- 它们的入度都不为<span class="hljs-number">0</span><br>- 访问计数(<span class="hljs-number">1</span>) &lt; 顶点总数(<span class="hljs-number">4</span>)<br><br>结果：存在环！<br></code></pre></td></tr></table></figure><h2 id="抛硬币决定输赢"><a href="#抛硬币决定输赢" class="headerlink" title="抛硬币决定输赢"></a>抛硬币决定输赢</h2><p>谁先正面就赢，求先手赢的概率</p><p><strong>做法一</strong></p><p>无穷级数求和：sum(0-n) :[(1&#x2F;4)^ n * 1&#x2F;2]</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241226173453421.png" alt="image-20241226173453421"></p><p><strong>取巧</strong></p><p>设赢的概率是x，那么后者赢的概率是x*0.5，所以(x + 0.5x) &#x3D; 1</p><p>可以得到x &#x3D; 2&#x2F;3</p><h2 id="实现一个共享指针类"><a href="#实现一个共享指针类" class="headerlink" title="实现一个共享指针类"></a>实现一个共享指针类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedPtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* res;               <span class="hljs-comment">// 指向资源的原始指针</span><br>    <span class="hljs-type">int</span>* refCount;        <span class="hljs-comment">// 引用计数指针</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SharedPtr</span><span class="hljs-params">(T* ptr = <span class="hljs-literal">nullptr</span>)</span> : res(ptr), refCount(new int(<span class="hljs-number">1</span>)) &#123;</span><br>        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">nullptr</span>) &#123;<br>            *refCount = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">SharedPtr</span>(<span class="hljs-type">const</span> SharedPtr&lt;T&gt;&amp; other) : <span class="hljs-built_in">res</span>(other.res), <span class="hljs-built_in">refCount</span>(other.refCount) &#123;<br>        ++(*refCount);  <span class="hljs-comment">// 增加引用计数</span><br>    &#125;<br><br>    <span class="hljs-comment">// 赋值运算符</span><br>    SharedPtr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SharedPtr&lt;T&gt;&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;  <span class="hljs-comment">// 防止自我赋值</span><br>            <span class="hljs-comment">// 先减少原有引用计数</span><br>            <span class="hljs-keyword">if</span> (--(*refCount) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">delete</span> res;<br>                <span class="hljs-keyword">delete</span> refCount;<br>            &#125;<br><br>            <span class="hljs-comment">// 复制新的资源</span><br>            res = other.res;<br>            refCount = other.refCount;<br>            ++(*refCount);  <span class="hljs-comment">// 增加引用计数</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">SharedPtr</span>() &#123;<br>        <span class="hljs-keyword">if</span> (--(*refCount) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">delete</span> res;<br>            <span class="hljs-keyword">delete</span> refCount;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取底层资源</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 解引用操作符</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *res;<br>    &#125;<br><br>    <span class="hljs-comment">// 箭头操作符</span><br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回引用计数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *refCount;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_null</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res == <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource in use!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个SharedPtr指向Resource对象</span><br>    <span class="hljs-function">SharedPtr&lt;Resource&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Resource())</span></span>;  <span class="hljs-comment">// 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reference count after p creation: &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 拷贝构造，p2指向与p相同的资源</span><br>    SharedPtr&lt;Resource&gt; p2 = p;  <span class="hljs-comment">// 2</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reference count after p2 creation: &quot;</span> &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用共享的资源</span><br>    p-&gt;<span class="hljs-built_in">show</span>();<br>    p2-&gt;<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-comment">// 由于p2和p共享同一个资源，引用计数会在析构时自动减少</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 当p和p2超出作用域时，资源会被释放</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实现一个吃鸡空投算法"><a href="#实现一个吃鸡空投算法" class="headerlink" title="实现一个吃鸡空投算法"></a>实现一个吃鸡空投算法</h2><p>要求平均，概率均等，每个点都能去到</p><h3 id="如何均匀分布点？"><a href="#如何均匀分布点？" class="headerlink" title="如何均匀分布点？"></a>如何均匀分布点？</h3><p>为了保证点在整个圆形区域内<strong>均匀分布</strong>，我们必须确保面积上是均匀的，而不是在半径上直接均匀分布。这样做可以避免靠近圆心的地方密度过高，靠近边缘的地方密度过低。</p><h3 id="均匀分布的正确方法"><a href="#均匀分布的正确方法" class="headerlink" title="均匀分布的正确方法"></a>均匀分布的正确方法</h3><p>为了确保在圆内均匀分布，应该使用以下方法生成随机半径：</p><p>生成随机数 𝑢 在 0 到 1 之间。</p><p>计算实际半径 𝑟 为 根号u * radius。这样可以确保在圆内的每个区域都有相同的概率被选中。</p><h2 id="多叉树的直径"><a href="#多叉树的直径" class="headerlink" title="多叉树的直径"></a>多叉树的直径</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct Interval &#123;</span><br><span class="hljs-comment"> *int start;</span><br><span class="hljs-comment"> *int end;</span><br><span class="hljs-comment"> *Interval(int s, int e) : start(start), end(e) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 树的直径</span><br><span class="hljs-comment">     * @param n int整型 树的节点个数</span><br><span class="hljs-comment">     * @param Tree_edge Interval类vector 树的边</span><br><span class="hljs-comment">     * @param Edge_value int整型vector 边的权值</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(<span class="hljs-type">int</span> node, vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>        visited[node] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> max_depth = <span class="hljs-number">0</span>, max_depth2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; neighbor: graph[node])&#123;<br>            <span class="hljs-type">int</span> next_node = neighbor.first;<br>            <span class="hljs-type">int</span> weight = neighbor.second;<br><br>            <span class="hljs-keyword">if</span>(!visited[next_node])&#123;<br>                <span class="hljs-type">int</span> d = <span class="hljs-built_in">depth</span>(next_node, graph, visited) + weight;<br>                <span class="hljs-keyword">if</span>(d &gt; max_depth)&#123;<br>                    max_depth2 = max_depth;<br>                    max_depth = d;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d &gt; max_depth2)&#123;<br>                    max_depth2 = d;<br>                &#125;<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">max</span>(result, max_depth + max_depth2);<br>        <span class="hljs-keyword">return</span> max_depth;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;Interval&gt;&amp; Tree_edge, vector&lt;<span class="hljs-type">int</span>&gt;&amp; Edge_value)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;Tree_edge.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> u = Tree_edge[i].start;<br>            <span class="hljs-type">int</span> v = Tree_edge[i].end;<br>            <span class="hljs-type">int</span> weight = Edge_value[i];<br>            graph[u].<span class="hljs-built_in">emplace_back</span>(v, weight);<br>            graph[v].<span class="hljs-built_in">emplace_back</span>(u,weight);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">depth</span>(<span class="hljs-number">0</span>, graph, visited);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p>描述二叉树里面的路径被定义为:从该树的任意节点出发，经过父&#x3D;&gt;子或者子&#x3D;&gt;父的连接，达到任意节点的序列。<br>注意:<br>1.同一个节点在一条二叉树路径里中最多出现一次<br>2.一条路径至少包含一个节点，且不一定经过根节点</p><p>给定一个二叉树的根节点root，请你计算它的最大路径和</p><p>例如：<br>给出以下的二叉树，<br>输入{1,2,3}<br>用C++</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxSum = INT_MIN;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 递归计算左右子树的最大贡献值</span><br>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span><br>        <span class="hljs-type">int</span> leftGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> rightGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;right), <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 节点的最大路径和取决于该节点的值与该节点的左右子树的最大贡献值</span><br>        <span class="hljs-type">int</span> priceNewPath = node-&gt;val + leftGain + rightGain;<br>        <br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, priceNewPath);<br>        <br>        <span class="hljs-comment">// 返回节点的最大贡献值</span><br>        <span class="hljs-keyword">return</span> node-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightGain);<br>    &#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">maxGain</span>(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> maxSum = INT_MIN;<br>        stack&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt; st; <span class="hljs-comment">// 节点和访问次数</span><br>        unordered_map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; nodeGain; <span class="hljs-comment">// 存储节点的最大贡献值</span><br>        <br>        st.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br>        <br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [node, visitCount] = st.<span class="hljs-built_in">top</span>();<br>            <br>            <span class="hljs-keyword">if</span> (visitCount == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 第一次访问，将左子节点入栈</span><br>                st.<span class="hljs-built_in">top</span>().second++;<br>                <span class="hljs-keyword">if</span> (node-&gt;left) &#123;<br>                    st.<span class="hljs-built_in">push</span>(&#123;node-&gt;left, <span class="hljs-number">0</span>&#125;);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visitCount == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 第二次访问，将右子节点入栈</span><br>                st.<span class="hljs-built_in">top</span>().second++;<br>                <span class="hljs-keyword">if</span> (node-&gt;right) &#123;<br>                    st.<span class="hljs-built_in">push</span>(&#123;node-&gt;right, <span class="hljs-number">0</span>&#125;);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 第三次访问，计算当前节点的贡献值</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <br>                <span class="hljs-comment">// 获取左右子树的贡献值</span><br>                <span class="hljs-type">int</span> leftGain = node-&gt;left ? <span class="hljs-built_in">max</span>(nodeGain[node-&gt;left], <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> rightGain = node-&gt;right ? <span class="hljs-built_in">max</span>(nodeGain[node-&gt;right], <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>;<br>                <br>                <span class="hljs-comment">// 计算经过当前节点的最大路径和</span><br>                <span class="hljs-type">int</span> pathSum = node-&gt;val + leftGain + rightGain;<br>                maxSum = <span class="hljs-built_in">max</span>(maxSum, pathSum);<br>                <br>                <span class="hljs-comment">// 计算并存储当前节点的最大贡献值</span><br>                nodeGain[node] = node-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightGain);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经-计算机基础</title>
    <link href="/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h3><p><strong>值类型</strong>包括整数、浮点、枚举、结构体；<strong>引用类型</strong>包括指针、引用、动态数组、类对象的指针。前者在栈上分配，后者在堆上分配；前者自动内存管理，后者需要手动管理。</p><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销；</p><p>内联函数是⼀种特殊的函数，会进行类型检查；对编译器的⼀种请求，编译器有可能拒绝这种请求； </p><p>C++中inline编译限制：</p><ol><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数体不能过于庞⼤</li><li>内联函数声明必须在调⽤语句之前</li></ol><p><strong>和difine相比有什么优点？</strong></p><ol><li>类型安全</li><li>可以访问类成员</li><li>调试友好，可以设置断电</li><li>参数求值一次，比如下面这种用define可能会求值多次，造成错误。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;  <span class="hljs-comment">// x只被求值一次</span><br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">square</span>(a++);  <span class="hljs-comment">// 安全的行为</span><br></code></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li>修饰变量<br>修改了变量的作用域和生命周期，存储在静态区域。生命周期和程序相同，作用域分为全局变量和局部变量。局部变量仅在函数内可用，全局变量仅在当前源文件中可用。</li><li>修饰函数<br>表明函数的作用域仅在当前源文件中。</li><li>修饰成员变量<br>静态成员变量为全局类对象所共享，仅有一份拷贝。类中声明，类外定义和初始化。所有实例共享一份数据，不依赖类的实例存在，可以通过类名访问</li><li>修饰成员函数<br>静态成员函数为全局类对象所共享。没有this指针，仅能访问静态成员变量和函数，虚函数不能为静态成员函数。【虚函数运行时绑定，静态成员函数编译时绑定】</li></ol><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ol><li><p>修饰变量：变量声明，表明变量在此处引用，在其他源文件中定义。</p></li><li><p>修饰函数：表明函数在其他源文件中定义。</p></li><li><p>extern “C”：编译器用C的命名规范去编译函数，链接器用C的命名规范进行链接。因为C++支持函数重载，而C不支持。</p><p>例如，假设某个函数的原型为：void</p><p>foo( int x, int y);该函数被C编译器编译后在符号库中的名字为 _ foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</p></li></ol><h3 id="constexpr-和-const"><a href="#constexpr-和-const" class="headerlink" title="constexpr 和 const"></a>constexpr 和 const</h3><p>constexpr：告诉编译器我可以是编译期间可知的，尽情的优化我吧。</p><p>const：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p><p>修饰对象的时候两者之间最基本的区别是：</p><ul><li>const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。</li><li>constexpr是修饰一个常量表达式。但请注意constexpr不是修饰常量表达式的唯一途径。</li></ul><p>修饰函数的时候两者之间最基本的区别是：</p><ul><li>const只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。</li><li>constexpr可以用于含参和无参函数。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数：                                                        </li><li>1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素      (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了)                                                                       2.参数和返回值必须是字面值类</li></ul><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof计算的是在栈中分配的内存大小。</p><p>（1） sizeof不计算static变量占的内存；</p><p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p><p>（3） char型占1个字节，int占4个字节，short int占2个字节</p><p>long int占4个字节，float占4字节，double占8字节，string占4字节</p><p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p><p>（4） 数组的长度：</p><p>若指定了数组长度，则不看元素个数，总字节数&#x3D;数组长度*sizeof（元素类型）</p><p>若没有指定长度，则按实际元素个数类确定</p><p>Ps：若是字符数组，则应考虑末尾的空字符。</p><p>（5） 结构体对象的长度</p><p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p><p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）&#x3D;4</p><p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p><p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p><p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p><p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p><p><strong>为什么空类大小不是0？</strong></p><p>为了确保两个不同对象的地址不同，必须如此。</p><p>类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独⼀⽆⼆的地址。 </p><p>同样，空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有独⼀⽆⼆的地址了。 </p><p>所以，空类的sizeof为1，⽽不是0。</p><p><strong>为什么不计算函数的大小？</strong></p><p>函数代码存储在代码段</p><p>所有实例共享函数代码</p><p>sizeof只计算实例数据成员</p><p>虚函数只计算vptr大小</p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>不会计算字符串最末尾的’&#x2F;0’，sizeof会计算</p><h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack()"></a>#pragma pack()</h3><p>#pragma pack()不带参数时，可以取消之前自定义的字节对齐方式，恢复默认的自然对齐。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>int i &#x3D; (int)p; 等同于 int i &#x3D; static_cast<int>(p);</p><p>(int)p是C风格的强制类型转换</p><p>static_cast<int>(p)是C++的类型转换</p><p>对于指针到整数的转换，使用static_cast</p><p>各种类型转换：</p><p>const_cast：去除const属性</p><p>dynamic_cast：安全的向下转型</p><p>static_cast：编译时静态转换</p><p>reinterpret_cast：重新解释底层内存</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p> dynamic_cast 是 C++中的一个类型转换操作符，它主要用于处理多态类型的安全向下转换（<strong>也就是父类向子类转换</strong>）。 如果转换不合法，对于指针类型，dynamic_cast 会返回空指针 nullptr ； 对于<a href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B&zhida_source=entity">引用类型</a>，它会抛出 std::bda_cast 异常</p><blockquote><p>注意：dynamic_cast是在运行时检查，并且 使用dynamic_cast 转换时，涉及的类通常至少需要有一个虚函数（比如<a href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">虚析构函数</a>），这样编译器才能再运行时使用类型信息和执行转换。<br>另外在转换前，也得 Base* base &#x3D;new Derived1; 指向这个对象，不然会存在 和reinterpret_cast一样的问题</p></blockquote><h4 id="static-cast和dynamic-cast的区别"><a href="#static-cast和dynamic-cast的区别" class="headerlink" title="static_cast和dynamic_cast的区别"></a>static_cast和dynamic_cast的区别</h4><ol><li><strong>类型检查时机</strong> ：</li></ol><ul><li><code>static_cast</code>：在编译时进行类型检查。它根据转换语句中提供的信息（尖括号中的类型）进行转换，不执行运行时类型检查。</li><li><code>dynamic_cast</code>：在运行时进行类型检查。它通过检查对象的实际类型来确定转换是否安全。如果转换不安全，<code>dynamic_cast</code>会返回空指针（对于指针类型）或抛出<code>std::bad_cast</code>异常（对于引用类型）。</li></ul><ol><li><strong>安全性</strong> ：</li></ol><ul><li><code>static_cast</code>：不如<code>dynamic_cast</code>安全，因为它不进行运行时类型检查，可能会在类型不匹配的情况下导致未定义行为。例如，将一个子类对象强制转换为父类对象是安全的，但将一个父类对象强制转换为子类对象可能会导致错误。</li><li><code>dynamic_cast</code>：在类层次结构中用于安全的下行转换（从基类指针或引用转换为派生类指针或引用）。它依赖于虚函数表（vtable）来确保转换的安全性。如果基类没有虚函数，<code>dynamic_cast</code>将无法进行类型检查，从而无法保证转换的安全性。</li></ul><h3 id="funture和promise"><a href="#funture和promise" class="headerlink" title="funture和promise"></a>funture和promise</h3><h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h4><ul><li>**<code>std::promise</code>**：<ul><li>用于在一个线程中设置值或异常。</li><li>与 <code>std::future</code> 配对使用。</li></ul></li><li>**<code>std::future</code>**：<ul><li>用于在另一个线程中获取由 <code>std::promise</code> 设置的值或异常。</li></ul></li></ul><h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ol><li><strong>绑定关系</strong>：<ul><li>一个 <code>std::promise</code> 与一个 <code>std::future</code> 成对使用。</li><li>当通过 <code>std::promise</code> 设置值时，绑定的 <code>std::future</code> 可以访问该值。</li></ul></li><li><strong>线程间通信</strong>：<ul><li><code>std::promise</code> 通常由生产者线程持有，用于设置数据。</li><li><code>std::future</code> 通常由消费者线程持有，用于获取数据。</li></ul></li><li><strong>延迟获取</strong>：<ul><li>使用 <code>future.get()</code> 阻塞当前线程，直到 <code>promise</code> 提供值。</li></ul></li></ol><h4 id="3-通信方式"><a href="#3-通信方式" class="headerlink" title="3. 通信方式"></a>3. 通信方式</h4><ul><li><strong>传递值</strong>：通过 <code>promise.set_value()</code> 设置值，<code>future.get()</code> 获取值。</li><li><strong>传递异常</strong>：通过 <code>promise.set_exception()</code> 传递异常，<code>future.get()</code> 捕获异常。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用和指针的区别？从底层角度考虑"><a href="#引用和指针的区别？从底层角度考虑" class="headerlink" title="引用和指针的区别？从底层角度考虑"></a>引用和指针的区别？从底层角度考虑</h3><p>引用必须初始化，不能改变引用的指向，从汇编的角度来看，引用就是一个const指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="C-中的智能指针有哪些，各自有什么作用"><a href="#C-中的智能指针有哪些，各自有什么作用" class="headerlink" title="C++中的智能指针有哪些，各自有什么作用?"></a>C++中的智能指针有哪些，各自有什么作用?</h3><p><a href="http://t.csdnimg.cn/SaXIX">C++智能指针weak_ptr详解</a></p><p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：</p><p>（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p><p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p><p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><h3 id="shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"><a href="#shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？" class="headerlink" title="shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"></a>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？</h3><p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p><p>（2）具体实现：</p><p>1）构造函数：将指针指向该对象，引用计数置为1；</p><p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p><p>3）赋值运算符：&#x3D;号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p><h3 id="shareptr引用计数数据类型"><a href="#shareptr引用计数数据类型" class="headerlink" title="shareptr引用计数数据类型"></a>shareptr引用计数数据类型</h3><p>long</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><h3 id="静态多态和动态多态的区别？"><a href="#静态多态和动态多态的区别？" class="headerlink" title="静态多态和动态多态的区别？"></a>静态多态和动态多态的区别？</h3><p><strong>何为静态多态</strong>？</p><p>又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数。例如：函数重载，通过类成员运算符指定的运算。</p><p><strong>何为动态多态？</strong></p><p>动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。<br>动态多态是在虚函数的基础上实现的，而实现的条件有：<br>(1) 在类中声明为虚函数</p><p>(2) 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同（否则是函数重载的条件）</p><p>(3) 将子类对象的指针（或以引用形式）赋值给父类对象的指针（或引用），再用该指向父类对象的指针（或引用）调用虚函数<br>如此，便可以实现动态多态，程序会按照实际对象类型来选择要实行的函数具体时哪一个。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p><a href="https://zhuanlan.zhihu.com/p/688090551">C++11、C++14、C++17、C++20新特性总结 - cpp后端技术的文章 - 知乎</a></p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><h3 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h3><h3 id="函数模板的更改"><a href="#函数模板的更改" class="headerlink" title="函数模板的更改"></a>函数模板的更改</h3><p>支持默认参数</p><p>支持可变参数</p><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>新的std</p><p>tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>Lambda可以很方便的定义函数列表的个数，以及获取方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">[] 什么也不捕获，无法lambda函数体使用任何<br><br>[=] 按值的方式捕获所有变量<br><br>[&amp;] 按引用的方式捕获所有变量<br><br>[=, &amp;a] 除了变量a之外，按值的方式捕获所有局部变量，变量a使用引用的方式来捕获。这里可以按引用捕获多个，例如 [=, &amp;a, &amp;b,&amp;c]。这里注意，如果前面加了=，后面加的具体的参数必须以引用的方式来捕获，否则会报错。<br><br>[&amp;, a] 除了变量a之外，按引用的方式捕获所有局部变量，变量a使用值的方式来捕获。这里后面的参数也可以多个，例如 [&amp;, a, b, c]。这里注意，如果前面加了&amp;，后面加的具体的参数必须以值的方式来捕获。<br><br>[a, &amp;b] 以值的方式捕获a，引用的方式捕获b，也可以捕获多个。<br><br>[<span class="hljs-keyword">this</span>] 在成员函数中，也可以直接捕获<span class="hljs-keyword">this</span>指针，其实在成员函数中，[=]和[&amp;]也会捕获<span class="hljs-keyword">this</span>指针。<br></code></pre></td></tr></table></figure><p>如果想要修改外部变量，可以用mutable，但是也只是修改拷贝的那一份变量，真正外部不会修改</p><p><strong>本质</strong>是一个匿名函数对象，编译器会将其转换为一个带有operator()的类（重新实现了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; &#125;;<br><br><span class="hljs-comment">// 编译器实际生成的等价类（简化版）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompilerGeneratedName</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意如果引用捕获了局部变量，可能已经销毁了，所以最好值传递。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.简化代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 传统方式</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Comparator</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;<br>&#125;;<br><br><span class="hljs-comment">// Lambda方式</span><br>std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br>    [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;);<br></code></pre></td></tr></table></figure><p>2.即时定义和使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> threshold = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 直接在使用处定义过滤逻辑</span><br><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find_if</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(),<br>    [threshold](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n &gt; threshold; &#125;);<br></code></pre></td></tr></table></figure><p>3.状态封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHandler</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEvents</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> errorCount = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 封装局部状态</span><br>        <span class="hljs-keyword">auto</span> errorHandler = [&amp;errorCount](<span class="hljs-type">const</span> Error&amp; e) &#123;<br>            errorCount++;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Error #&quot;</span> &lt;&lt; errorCount &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">message</span>();<br>        &#125;;<br>        <br>        <span class="hljs-comment">// 使用errorHandler...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.某些复杂的匿名函数可能可读性可能比较低。</p><p>2.调试比较困难，没法断点。</p><p>3.性能开销，如果是值捕获可能造成不必要的拷贝。</p><h3 id="for循环的新方式"><a href="#for循环的新方式" class="headerlink" title="for循环的新方式"></a>for循环的新方式</h3><p>之前只能三段式，现在可以直接auto来for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> arc[] = <span class="hljs-string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;<br>    <span class="hljs-comment">//for循环遍历普通数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : arc) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span> &lt;&lt; endl;<br>    vector&lt;<span class="hljs-type">char</span>&gt;<span class="hljs-built_in">myvector</span>(arc, arc + <span class="hljs-number">23</span>);<br>    <span class="hljs-comment">//for循环遍历 vector 容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : myvector) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 2)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">6</span> + <span class="hljs-number">4</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 3)</span><br><span class="hljs-type">int</span> length = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> url[length];<span class="hljs-comment">//错误，length是变量</span><br></code></pre></td></tr></table></figure><p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><h4 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h4><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p><h4 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h4><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p><p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p><p>1.整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const最好只用来用作只读的作用，要注意只读不意味不可以修改，可以通过其他的来改</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是当外部函数返回内部函数时，内部函数随后在不同的范围内执行，内部函数继续保持对外部函数变量的访问，即使外部函数不再存在。</p><p>就比如一个function再套一个function</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> helloWorld = <span class="hljs-title function_">hello</span>();<br><br><span class="hljs-title function_">helloWorld</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>1.定义一个函数(outer)，该函数存在声明的局部变量(b)</p><p>2.该函数的返回值也是一个函数(inner)</p><p>3.返回的函数(inner)调用了该函数声明的局部变量(b)</p><p>4.该函数被调用(outer)</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a href="https://www.zhihu.com/question/23971699/answer/2358595798">c++虚函数的作用是什么？ - 心试的回答 - 知乎</a></p><p>每个子类会生成一个虚函数表，根据这个子类有无重写父类的虚函数，重写了会覆盖对应的内存空间</p><p>一个继承一个比较好理解，一个继承了多个可以看下面的图</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-04eed39e986d359dcdd32ac2b8c5e658_720w.webp"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-01056f4f051d715cc5de57314b0e9ba1_720w.webp"></p><p>每一个类会有一个虚函数表，然后这个类的多个对象都会共享这一张虚函数表，新创建的对象会保存虚函数指针。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p><strong>纯虚函数是指在基类中定义的没有实现的虚函数</strong>。使用纯虚函数可以使该函数只有函数原型，而没有具体的实现。注：这里的“&#x3D;0”表示该函数为纯虚函数。</p><p>纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。</p><p><strong>抽象类是包含纯虚函数的类</strong>，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。</p><h3 id="抽象函数和接口"><a href="#抽象函数和接口" class="headerlink" title="抽象函数和接口"></a>抽象函数和接口</h3><p><strong>抽象类的定义</strong></p><ol><li>最少具有一个<a href="https://zhida.zhihu.com/search?content_id=202138011&content_type=Article&match_order=1&q=%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity">纯虚函数</a>。</li><li>可以有实现的方法。</li><li>可以进行变量定义。</li></ol><p><strong>接口</strong></p><ol><li>所有的函数必须被声明为纯虚函数。</li><li>没有变量的声明。</li></ol><p>抽象类是能单继承，接口可以多重继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 抽象类：单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> AbstractShape &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接口：可以多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> IDrawable, <span class="hljs-keyword">public</span> IPrintable &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 实现 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>接口使用场景</strong>：</p><p>1.需要定义一组行为规范</p><p>2.需要多重继承</p><p>3.不需要共享实现代码</p><p>4.想要实现松耦合设计</p><p>5.依赖依赖注入</p><p><strong>抽象类使用场景</strong></p><p>1.需要在相关的类之间共享代码</p><p>2.需要访问共同的成员变量</p><p>3.需要提供默认实现单允许重写</p><p>4.需要维护状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接口示例：定义行为契约</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IRenderer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setResolution</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象类示例：提供基础功能</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRenderer</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-type">bool</span> isInitialized;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 共享实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        width = w;<br>        height = h;<br>        isInitialized = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInitialized</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isInitialized;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类必须实现的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 在实际项目中的选择</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenGLRenderer</span> : <span class="hljs-keyword">public</span> AbstractRenderer &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* OpenGL实现 */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectXRenderer</span> : <span class="hljs-keyword">public</span> AbstractRenderer &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* DirectX实现 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>比如说你想要写一个database的打印函数，可能会有多个不同的database和打印的对应关系，如果不用接口，就会导致直接在类里面硬编码依赖</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不好的做法：硬编码依赖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 直接在类内部创建依赖</span><br>    MySQLDatabase database;  <span class="hljs-comment">// 强耦合到具体的数据库实现</span><br>    FileLogger logger;       <span class="hljs-comment">// 强耦合到具体的日志实现</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>        logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Creating user: &quot;</span> + name);<br>        database.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;users&quot;</span>, name);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种难以测试，并且不能切换实现，而且代码耦合度高 ，所以可以用接口+构造函数注入的方式来解决</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1. 首先定义接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IDatabase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IDatabase</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; table, <span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ILogger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ILogger</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 2. 实现具体类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySQLDatabase</span> : <span class="hljs-keyword">public</span> IDatabase &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; table, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// MySQL实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> : <span class="hljs-keyword">public</span> ILogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 文件日志实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 3. 使用依赖注入</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    IDatabase&amp; database;<br>    ILogger&amp; logger;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 通过构造函数注入依赖</span><br>    <span class="hljs-built_in">UserService</span>(IDatabase&amp; db, ILogger&amp; log) <br>        : <span class="hljs-built_in">database</span>(db), <span class="hljs-built_in">logger</span>(log) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>        logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Creating user: &quot;</span> + name);<br>        database.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;users&quot;</span>, name);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不同的数据库实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PostgreSQLDatabase</span> : <span class="hljs-keyword">public</span> IDatabase &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; table, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// PostgreSQL实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MongoDatabase</span> : <span class="hljs-keyword">public</span> IDatabase &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; table, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// MongoDB实现</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 不同的日志实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> : <span class="hljs-keyword">public</span> ILogger &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; message &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 可以轻松切换实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">configureService</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 开发环境</span><br>    MongoDatabase devDb;<br>    ConsoleLogger devLogger;<br>    <span class="hljs-function">UserService <span class="hljs-title">devService</span><span class="hljs-params">(devDb, devLogger)</span></span>;<br><br>    <span class="hljs-comment">// 生产环境</span><br>    PostgreSQLDatabase prodDb;<br>    FileLogger prodLogger;<br>    <span class="hljs-function">UserService <span class="hljs-title">prodService</span><span class="hljs-params">(prodDb, prodLogger)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用智能指针的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;IDatabase&gt; database;<br>    std::shared_ptr&lt;ILogger&gt; logger;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UserService</span>(std::shared_ptr&lt;IDatabase&gt; db, <br>                std::shared_ptr&lt;ILogger&gt; log)<br>        : <span class="hljs-built_in">database</span>(std::<span class="hljs-built_in">move</span>(db))<br>        , <span class="hljs-built_in">logger</span>(std::<span class="hljs-built_in">move</span>(log)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span> </span>&#123;<br>        logger-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Creating user: &quot;</span> + name);<br>        database-&gt;<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;users&quot;</span>, name);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> db = std::<span class="hljs-built_in">make_shared</span>&lt;MySQLDatabase&gt;();<br>    <span class="hljs-keyword">auto</span> logger = std::<span class="hljs-built_in">make_shared</span>&lt;FileLogger&gt;();<br>    <span class="hljs-function">UserService <span class="hljs-title">service</span><span class="hljs-params">(db, logger)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哪些函数不能声明成虚函数？"><a href="#哪些函数不能声明成虚函数？" class="headerlink" title="哪些函数不能声明成虚函数？"></a>哪些函数不能声明成虚函数？</h3><p><strong>非成员函数</strong></p><p>非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？</p><p><strong>构造函数</strong></p><p>要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了。</p><p>友元函数</p><p><strong>静态成员函数</strong></p><p>静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上才可以的，两者一个是与实例相关，一个是与类相关。</p><p><strong>内联成员函数</strong></p><p>内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数。</p><h3 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h3><p>在Effective C++ 中，Scott Meyers在《条款07:为多态基类声明virtual析构函数》中提到，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没有被销毁。也就是说，如果派生类继承了父类的情况下，如果父类的析构函数不是虚函数，而在使用中用了多态的写法，就会导致没有调用到派生类的析构函数，导致资源没有释放，造成泄漏。</p><p>总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说<strong>虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的</strong>。<br> （1）<strong>如果父类的析构函数不加virtual关键字</strong><br> 当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。<br> （2）<strong>如果父类的析构函数加virtual关键字</strong><br> 当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。</p><h3 id="一个指向nullptr的类能调用虚函数吗？"><a href="#一个指向nullptr的类能调用虚函数吗？" class="headerlink" title="一个指向nullptr的类能调用虚函数吗？"></a>一个指向nullptr的类能调用虚函数吗？</h3><p>这种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f1&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f2&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> </span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;f4&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>A* pa = <span class="hljs-literal">NULL</span>;<br>pa-&gt;<span class="hljs-built_in">f1</span>();<span class="hljs-comment">//正常</span><br>pa-&gt;<span class="hljs-built_in">f2</span>();   <span class="hljs-comment">//正常</span><br>pa-&gt;<span class="hljs-built_in">f3</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>pa-&gt;<span class="hljs-built_in">f4</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不能，但是可以调用成员函数和static的成员函数（不能使用这个类的成员变量），因为成员函数地址已经确定了，和你的类其实是无关的，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">A *pa = <span class="hljs-literal">NULL</span>;<br>pa-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func(pa, 2);且pa==NULL</span><br>((A*)<span class="hljs-literal">NULL</span>)-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func( ((A*)NULL), 2);</span><br></code></pre></td></tr></table></figure><p>类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针，成员函数中对成员变量的访问都是转化成”this-&gt;数据成员”的方式。因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的this指针。而类的静态成员函数只能访问<a href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">静态成员变量</a>，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。<br>有了上面的分析，就可以解释为什么空对象指针对f1, f2的调用成功，对f3的调用不成功。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存空间有哪些分类？"><a href="#内存空间有哪些分类？" class="headerlink" title="内存空间有哪些分类？"></a>内存空间有哪些分类？</h3><p>（1）堆，使用malloc、free动态分配和释放空间，能分配较大的内存；</p><p>（2）栈，为函数的局部变量分配内存，能分配较小的内存；</p><p>（3）全局&#x2F;静态存储区，用于存储全局变量和静态变量；</p><p>（4）常量存储区，专门用来存放常量；</p><p>（5）自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。</p><h3 id="malloc和new有什么区别？"><a href="#malloc和new有什么区别？" class="headerlink" title="malloc和new有什么区别？"></a>malloc和new有什么区别？</h3><p>（1）new分配内存空间无需指定分配内存大小，malloc需要；</p><p>（2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；</p><p>（3）new是从自由存储区获得内存，malloc从堆中获取内存；</p><p>（4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220309220924444.png" alt="image-20220309220924444"></p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>直接用new是自动给你分配，但是要用placement new可以在已分配的内存里面创建对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">A* p=<span class="hljs-built_in">new</span> (ptr)A<br></code></pre></td></tr></table></figure><p>1）用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。如本例就是在栈上生成一个对象。</p><p>（2）使用语句A* p&#x3D;new (mem) A;定位生成对象时，指针p和数组名mem指向同一片存储区。所以，与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。</p><p>（3）使用语句A *p&#x3D;new (mem) A;定位生成对象时，会自动调用类A的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&zhida_source=entity">构造函数</a>，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">析构函数</a>，如本例中的p-&gt;~A()。</p><p>（4）如果有这样一个场景，我们需要大量的申请一块类似的内存空间，然后又释放掉，比如在在一个server中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合c++的内存管理要求，没有什么错误，但是仔细想想很不合理，为什么我们每个请求都要重新申请一块内存呢，要知道每一次内从的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言)，极端情况下，如果当前系统中有大量的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87&zhida_source=entity">内存碎片</a>，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=2&q=placement+new&zhida_source=entity">placement new</a>来<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1&zhida_source=entity">构造对象</a>，那么就会在我们指定的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=3&q=%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4&zhida_source=entity">内存空间</a>中构造对象。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><ol><li><p>默认构造函数（Default Constructor）：没有参数的构造函数。如果在类中没有定义构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时进行默认的初始化操作。</p></li><li><p>参数化构造函数（Parameterized Constructor）：带有参数的构造函数。参数化构造函数可以接受不同的参数，并根据参数的值来初始化对象的数据成员。</p></li><li><p>拷贝构造函数：使用一个对象初始化另一个对象。拷贝构造函数的参数为同类对象的引用。它将被复制的对象的数据成员值复制给新创建的对象。</p></li><li><p>移动构造函数（Move Constructor）：C++11引入的特性，用于实现对象的移动语义。移动构造函数通过接管另一个对象的资源而避免进行深拷贝，提高了性能。</p></li></ol><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>传入右值，直接浅拷贝，右值用std::move来生成</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="stl底层实现"><a href="#stl底层实现" class="headerlink" title="stl底层实现"></a><strong>stl底层实现</strong></h3><p>vector：数组</p><p>Dequeue（双端队列）：二维数组</p><p>List：环状双向链表</p><p>set（集合）：平衡的红黑树</p><p>multiset：红黑树</p><p>map：平衡二叉树</p><p>unordered_map：散列表（哈希表）</p><p><strong>而C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表。</strong></p><h3 id="哈希表原理"><a href="#哈希表原理" class="headerlink" title="哈希表原理"></a>哈希表原理</h3><p>首先是哈希函数，就是把一个长的二级制数据转换成一个短的二进制数据的函数；然后就是解决哈希冲突的方法，常见的有开放寻址法和链表法，前者是通过探测并占用下一个可用的存储位置，后者是在冲突的位置用链表记录多个值。</p><h3 id="哈希函数原理"><a href="#哈希函数原理" class="headerlink" title="哈希函数原理"></a>哈希函数原理</h3><p>哈希函数的目标是将任意长度的输入数据转换为固定长度的输出值，同时要尽量避免冲突。下面介绍几种常见的哈希函数实现方法：</p><h4 id="除法散列"><a href="#除法散列" class="headerlink" title="除法散列"></a>除法散列</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DivisionHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> tableSize; <span class="hljs-comment">// 哈希表大小（最好是质数）</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DivisionHash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span> <br>    &#123;<br>        tableSize = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Hash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key</span>)</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.Abs(key) % tableSize;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 字符串的哈希</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">HashString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span> <br>    &#123;      <br>        <span class="hljs-built_in">int</span> hash = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> str) <br>        &#123;<br>              hash = (hash * <span class="hljs-number">31</span> + c) % tableSize;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.Abs(hash);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MultiplicationHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> tableSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> A = <span class="hljs-number">0.6180339887</span>; <span class="hljs-comment">// 黄金分割比例</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiplicationHash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span> <br>    &#123;<br>        tableSize = size;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Hash</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> key</span>)</span> <br>    &#123;<br>        <span class="hljs-built_in">double</span> temp = key * A;<br>        <span class="hljs-built_in">double</span> fractional = temp - Math.Floor(temp); <span class="hljs-comment">// 取小数部分</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)(tableSize * fractional);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringHash</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> BASE = <span class="hljs-number">31</span>; <span class="hljs-comment">// 基数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MOD = <span class="hljs-number">1000000007</span>; <span class="hljs-comment">// 大质数</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">ComputeHash</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span> <br>    &#123;<br>        <span class="hljs-built_in">long</span> hash = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">long</span> power = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> str) <br>        &#123;<br>            hash = (hash + (c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>) * power) % MOD;<br>            power = (power * BASE) % MOD;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> hash;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p><strong>拼接原理</strong></p><ol><li>计算拼接后字符串的总长度。</li><li>分配足够的内存以存储新字符串。</li><li>将原字符串和要拼接的字符串的内容复制到新分配的内存中。</li><li>释放原字符串的内存（如果需要）。</li></ol><p><strong>大量字符串如何优化</strong></p><p>当需要拼接大量字符串（例如一万个字符串）时，可以采取以下优化策略：</p><p>预分配内存：</p><p>使用 std::string::reserve 方法预分配足够的内存，以避免在拼接过程中多次分配内存。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string result;<br>result.<span class="hljs-built_in">reserve</span>(total_length); <span class="hljs-comment">// total_length 是所有字符串的总长度</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用 std::ostringstream：</li></ol><p>使用 std::ostringstream 来拼接字符串。ostringstream 是一个输出流，可以高效地处理字符串拼接，避免多次内存分配。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;std::string&gt; strings = &#123;<span class="hljs-comment">/* 一万个字符串 */</span>&#125;;<br>std::ostringstream oss;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; str : strings) &#123;<br>    oss &lt;&lt; str; <span class="hljs-comment">// 使用流操作符拼接</span><br>&#125;<br><br>std::string result = oss.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 获取最终拼接的字符串</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用 std::string::append：</li></ol><p>如果不使用 ostringstream，可以使用 std::string::append 方法，它在某些情况下比 operator+ 更高效。</p><ol start="4"><li>避免不必要的拼接：</li></ol><p>在拼接字符串时，尽量避免在循环中进行不必要的拼接操作。可以先将所有字符串存储在一个容器中，然后一次性拼接。</p><h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>有三种类型</p><p>模板实际上分为三类：</p><p>类型模板参数（类型模板）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><p>非类型模板参数（常量模板）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> Size&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><p>模板模板参数（模板的模板参数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="类型模板参数（通用游戏对象）"><a href="#类型模板参数（通用游戏对象）" class="headerlink" title="类型模板参数（通用游戏对象）"></a>类型模板参数（通用游戏对象）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameObject</span> &#123;<br>    T position;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(T delta)</span> </span>&#123;<br>        position += delta;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 可以用于不同类型的位置表示</span><br>GameObject&lt;Vector2&gt; player;<br>GameObject&lt;Vector3&gt; enemy3D;<br></code></pre></td></tr></table></figure><h3 id="非类型模板参数（固定大小游戏数组）"><a href="#非类型模板参数（固定大小游戏数组）" class="headerlink" title="非类型模板参数（固定大小游戏数组）"></a>非类型模板参数（固定大小游戏数组）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> MaxUnits = <span class="hljs-number">100</span>&gt;<br><span class="hljs-keyword">class</span> ArmyManager &#123;<br>    Unit units[MaxUnits];<br>    <span class="hljs-type">int</span> currentUnitCount = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 编译期确定最大单位数</span><br>ArmyManager&lt;<span class="hljs-number">50</span>&gt; smallArmy;<br>ArmyManager&lt;<span class="hljs-number">200</span>&gt; largeArmy;<br></code></pre></td></tr></table></figure><h3 id="模板模板参数（容器策略）"><a href="#模板模板参数（容器策略）" class="headerlink" title="模板模板参数（容器策略）"></a>模板模板参数（容器策略）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inventory</span> &#123;<br>    Container&lt;T&gt; items;<br>&#125;;<br><br><span class="hljs-comment">// 可以使用不同容器</span><br>Inventory&lt;Weapon, vector&gt; playerWeapons;<br>Inventory&lt;Weapon, list&gt; backupWeapons;<br></code></pre></td></tr></table></figure><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>（1）预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件；包括展开宏定义，处理条件编译指令，包含头文件</p><p>（2）编译阶段将预编译文件编译，删除注释，生成汇编文件（编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码)；</p><p>（3）汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件）（汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）；</p><p>（4）链接阶段，将多个目标文件和所需要的库连接成可执行文件（.exe文件）</p><h3 id="＃include-lt-file-h-gt-与-＃include-“file-h”的区别？"><a href="#＃include-lt-file-h-gt-与-＃include-“file-h”的区别？" class="headerlink" title="＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？"></a>＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？</h3><p>前者从标准库查找寻找和引用file.h，后者从当前路径寻找和引用</p><h3 id="main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>main函数执行之前会执行什么？执行之后还能执行代码吗？</h3><p>（1）全局对象的构造函数会在main函数之前执行；</p><p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p><p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。</p><p>比如全局变量的初始化，就不是由main函数引起的</p><p>举例： class A{};</p><p>A a; &#x2F;&#x2F;a的构造函数限执行</p><p>int main() {}</p><h3 id="动态库和静态库优缺点"><a href="#动态库和静态库优缺点" class="headerlink" title="动态库和静态库优缺点"></a>动态库和静态库优缺点</h3><p><strong>静态库</strong></p><p><strong>优点</strong></p><ol><li>代码装载速度快，执行速度比动态链接库略快</li><li>只需要开发者有lib就行，不需要考虑用户电脑上有无lib。</li></ol><p><strong>缺点</strong></p><p>生成的体积较大，包含相同的公共代码，造成浪费</p><p><strong>动态库</strong></p><p><strong>优点</strong></p><ol><li>节省内存</li><li>dll和exe独立，更换dll就可以改变函数内容，提高可维护性和可拓展性</li><li>不同编程语言只要按照函数调用约定可以用同一个dll</li><li>耦合度小，开发过程独立</li></ol><p><strong>缺点</strong></p><p>用户电脑里面需要有dll</p><h1 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h1><h2 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h2><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>在C#中，unsafe 关键字用于标识包含不安全代码块的上下文，允许直接使用指针和执行不安全的操作。</p><p>优点：</p><ol><li><p>更高的性能： 使用指针直接操作内存可以提高性能，特别是在处理大量数据或需要高效访问内存的场景下。</p></li><li><p>与非托管代码交互： 允许与非托管代码进行更直接的交互，例如调用 Windows API 或者使用一些底层的系统功能。</p></li><li><p>灵活性： 可以执行一些 C# 中无法直接实现的操作，如访问特定的内存地址或进行底层的位操作。</p></li></ol><p>缺点：</p><ol><li><p>安全性风险： 使用 unsafe 可能导致程序出现潜在的安全漏洞，因为绕过了 C# 的类型安全检查和边界检查。</p></li><li><p>可读性下降： 使用指针和不安全的操作会增加代码的复杂性，并且降低代码的可读性和可维护性。</p></li><li><p>难以调试： 不安全的代码可能更难调试和定位错误，因为涉及到直接操作内存的技术细节。</p></li></ol><h3 id="const和readonly有什么区别？"><a href="#const和readonly有什么区别？" class="headerlink" title="const和readonly有什么区别？"></a>const和readonly有什么区别？</h3><p>都可以标识一个常量。主要有以下区别：<br>1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值;<br>2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段<br>3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。<br>4、const默认是静态的；而readonly如果设置成静态需要显示声明<br>5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。</p><h2 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h2><p>要用到特性就必须要用反射，比如说你要序列化一个类，如果直接写接口来实现，你不知道这个类有哪些属性，而且还要写很多不同的接口，但是用反射可以很优雅地实现，如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Serialize</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>&#123;<br>     <span class="hljs-keyword">var</span> res = obj<br>         .GetType()<br>         .GetProperties(BindingFlag.Public | BindingFlags.Instance)<br>         .Where(pi =&gt;<br>                &#123;<br>                    <span class="hljs-keyword">var</span> attr = pi.GetCustomAttribute&lt;BrowsableAtrribute&gt;();<br>                    <span class="hljs-keyword">if</span>(attr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> attr.Browable;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;)<br>         .Select(pi =&gt; <span class="hljs-keyword">new</span>&#123;Key = pi.Name, Value = pi.GetValue(obj)&#125;)<br>         .Select(o =&gt; <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;o.Key&#125;</span> : <span class="hljs-subst">&#123;o.Value&#125;</span>&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Join(Environment.NewLine, res);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    [<span class="hljs-meta">Browsable(false)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><h2 id="引用类型和值类型-1"><a href="#引用类型和值类型-1" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h2><p>C#中定义的值类型包括原类型（Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举(enum)、结构(struct)，引用类型包括：类、数组、接口、委托、字符串等，引用型是在堆中分配内存，初始化为null，引用型是需要GARBAGE COLLECTION来回收内存的，值型不用，超出了作用范围，系统就会自动释放！</p><h2 id="结构体和类区别"><a href="#结构体和类区别" class="headerlink" title="结构体和类区别"></a>结构体和类区别</h2><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="死锁需要的条件"><a href="#死锁需要的条件" class="headerlink" title="死锁需要的条件"></a>死锁需要的条件</h2><ol><li><strong>互斥条件</strong> ：资源是独占的，即同一时间只能被一个进程使用。如果资源正在被一个进程使用，其他请求该资源的进程必须等待，直到资源被释放。</li><li><strong>请求与保持条件</strong> ：一个进程在已经持有一个资源的情况下，又请求新的资源，但新的资源已经被其他进程占用，因此请求的进程被阻塞，并且保持已    获得的资源不放。</li><li><strong>不可剥夺条件</strong> ：进程已经获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由进程自己释放。</li><li><strong>循环等待条件</strong> ：存在一个进程等待队列，其中每个进程都在等待下一个进程持有的资源，形成一个循环等待链。</li></ol><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="多个进程共享同一个库"><a href="#多个进程共享同一个库" class="headerlink" title="多个进程共享同一个库"></a>多个进程共享同一个库</h3><p>当多个进程加载同一个共享库时，操作系统会采用以下策略：</p><p>代码段（Text Section）</p><p>共享库的代码段会被映射到不同进程的虚拟地址空间中</p><p>实际上，代码段在物理内存中只有一份拷贝</p><p>多个进程共享这同一份物理内存，达到节省内存的目的</p><p>数据段（Data Section）</p><p>每个进程会获得共享库数据段的独立副本</p><p>这确保了进程间数据的隔离性</p><p>包括：</p><p>全局变量</p><p>静态变量</p><h3 id="线程和进程和协程"><a href="#线程和进程和协程" class="headerlink" title="线程和进程和协程"></a>线程和进程和协程</h3><p><a href="https://zhuanlan.zhihu.com/p/279383752">Unity协程的原理与应用 - 宇亓的文章 - 知乎</a></p><p>（1）进程是运行时的程序，是系统进行资源分配和调度的基本单位，它实现了系统的并发；</p><p>（2）线程是进程的子单位，也称为轻量级进程，它是CPU进行分配和调度的基本单位，也是独立运行的基本单位，它实现了进程内部的并发；</p><p>（3）一个程序至少拥有一个进程，一个进程至少拥有一个线程，线程依赖于进程而存在；</p><p>（4）进程拥有独立的内存空间，而线程是共享进程的内存空间的，自己不占用资源；</p><p>（5）线程的优势：线程之间的信息共享和通讯比较方便，不需要资源的切换等.</p><p>每一个进程都独立拥有自己的指令和数据，所以称为资源分配的基本单位。其中数据又分布在内存的不同区域，我们在C语言课程中学习过内存四区的概念，一个运行中的进程所占有的内存大体可以分为四个区域：栈区、堆区、数据区、代码区。其中代码区存储指令，另外三个区存储数据。</p><p>线程是处理器调度和执行的基本单位，一个线程往往和一个函数调用栈绑定，一个进程有多个线程，每个线程拥有自己的函数调用栈，同时共用进程的堆区，数据区，代码区。操作系统会不停地在不同线程之间切换来营造出一个并行的效果，这个策略称为时间片轮转法。</p><p>那么协程在其中又处于什么地位呢？ <strong>一切用户自己实现的，类似于线程的轮子，都可以称之为是协程。</strong></p><h3 id="线程的独占资源和共享资源"><a href="#线程的独占资源和共享资源" class="headerlink" title="线程的独占资源和共享资源"></a>线程的独占资源和共享资源</h3><p><strong>独占资源</strong></p><ol><li>线程就是函数的运行，所以运行时候的信息都是独占的，包括返回值，局部变量，寄存器信息等，每个进程有自己独占的栈区。</li><li>每个线程有自己独立的线程id，独立的调度优先级和错误返回码。</li></ol><p><strong>共享资源</strong></p><ol><li>共享进程的代码区</li><li>共享进程的数据区，即全局变量和静态变量。</li><li>共享进程的堆区。</li><li>动态链接库。</li><li>文件，打开的文件信息。</li><li>共享当前工作目录，以及用户id和组id。</li></ol><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>“线程安全”也不是指线程的安全，而是指内存的安全，在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。</p><p><strong>如何避免</strong>？</p><p>私有化内存</p><p>栈内存</p><h3 id="使用多进程与多线程的区别？"><a href="#使用多进程与多线程的区别？" class="headerlink" title="使用多进程与多线程的区别？"></a>使用多进程与多线程的区别？</h3><p>（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。</p><p>（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；</p><p>（3）线程产生的速度快，线程间通信快、切换快；</p><p>（4）线程的资源利用率比较好；</p><p>（5）线程使用公共变量或者资源时需要同步机制。</p><h3 id="操作系统如何保证每个进程都有独立的空间？"><a href="#操作系统如何保证每个进程都有独立的空间？" class="headerlink" title="操作系统如何保证每个进程都有独立的空间？"></a>操作系统如何保证每个进程都有独立的空间？</h3><p>通过虚拟内存来实现，</p><p>首先是虚拟内存分页，</p><p>然后是页表映射，给每个进程维护一个页表，记录了虚拟地址和物理地址的映射关系</p><p>之后是内存保护，操作系统会给分配的进程页表有一些额外的标志，用于控制进程对内存的访问权限。</p><p>之后是上下文切换，<strong>当操作系统切换到一个新的进程时，它会保存当前进程的页表以及其他的上下文信息，并加载下一个进程的页表</strong>。这样，每个进程在运行时拥有自己独立的虚拟地址空间，与其他进程的内存空间相隔离。</p><p>通过虚拟内存机制，操作系统能够为每个进程提供独立的内存空间，<strong>无论是代码、数据还是堆栈，每个进程都认为自己独占系统的整个内存空间</strong>。这种内存隔离保证了每个进程的数据安全和保密性，并且允许操作系统有效地管理和保护进城间的内存使用</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p><a href="https://zhuanlan.zhihu.com/p/461063930">线程同步的几种方式 - TOMOCAT的文章 - 知乎</a></p><p>同步指的是按一定的顺序依次执行</p><p><strong>互斥锁</strong></p><p><strong>读写锁</strong></p><p><strong>条件变量</strong></p><p><strong>信号量</strong></p><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3><p>（1）TCP是传输控制协议，UDP是用户数据报协议；</p><p>（2）TCP是面向连接的，可靠的数据传输协议，它要通过三次握手来建立连接，UDP是无连接的，不可靠的数据传输协议，采取尽力而为的策略，不保证接收方一定能收到正确的数据；</p><p>（3）TCP面向的是字节流，UDP面向的是数据报；</p><p>（4）TCP只支持点对点，UDP支持一对一，一对多和多对多；</p><p>（5）TCP有拥塞控制机制，UDP没有。</p><h3 id="tcp三次握手的过程"><a href="#tcp三次握手的过程" class="headerlink" title="tcp三次握手的过程"></a>tcp三次握手的过程</h3><p>三次握手的本质是确认通信双方收发数据的能力</p><p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</strong></p><p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</strong></p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次<strong>，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</strong></p><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="https为什么更加安全？"><a href="#https为什么更加安全？" class="headerlink" title="https为什么更加安全？"></a>https为什么更加安全？</h3><p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理 - 顾伊凡 YGY的文章 - 知乎</a></p><p>http是明文传输，对称加密虽然性能好但有密钥泄漏的风险，非对称加密（2组公钥+2私钥双向传输）安全但性能低下，因此考虑用非对称加密来传输对称加密所需的密钥，然后进行对称加密，但是为了防止非对称过程产生的中间人攻击，需要对服务器公钥和服务器身份进行配对的数字认证，然后引入了CA数字签名+数字证书验证的方式！</p><p>https基本采用以下流程，即非对称+对称</p><ol><li><p>某网站拥有用于非对称加密的公钥A、私钥A’。</p></li><li><p>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</p></li><li><p>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</p></li><li><p>服务器拿到后用私钥A’解密得到密钥X。</p></li><li><p>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</p></li></ol><p>但是可能会遭受中间人攻击，即在传输过程中把明文的公钥替换，那么如何保证浏览器收到的公钥就是服务器的公钥？所以就需要CA证书，CA证书本身也需要加密生成一个签名来保证没有被掉包。</p><p>而且也不用每次传输都传输密钥，服务器会为每个浏览器（或<a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2243789231%22%7D">客户端</a>软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p><h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>（1）应用程序阶段，该阶段主要是在软件层面上执行的一些工作，包括空间加速算法、视锥剔除、碰撞检测、动画物理模拟等。大体逻辑是：执行视锥剔除，查询出可能需要绘制的图元并生成渲染数据，设置渲染状态和绑定各种Shader参数，调用DrawCall，进入到下一个阶段，GPU渲染管线。</p><p>（2）几何阶段，包含顶点着色、投影变换、裁剪和屏幕映射阶段。</p><p>a. 顶点处理阶段：这个阶段会执行<strong>顶点变换</strong>和<strong>顶点着色</strong>的工作。通过模型矩阵、观察矩阵和投影矩阵(也就是MVP矩阵)计算出顶点在裁剪空间下的位置(clip space)，以便后续阶段转化为标准化设备坐标系(NDC)下的位置。也可能会计算出顶点的法线(需要有法线变换矩阵)和纹理坐标等。同时，在这个阶段也可能会进行顶点的着色计算，如平面着色 (Flat Shading)和高洛德着色 (Gouraud Shading)都是在顶点着色器中进行着色计算。因为这个阶段是完全可控制的，因此执行什么样的操作由程序员来决定。（此外，在顶点处理阶段的末尾，还有一些可选的阶段，包括曲面细分(tessellation)、几何着色(geometry shading)和流输出(stream output)，此处不详细描述）</p><p>b. 裁剪阶段：简单来说就是两次裁剪的粒度不同，前者是在物体对象层面的，一般对对象的包围盒做剔除，剔除掉不在视锥体内的物体，NDC裁剪是在三角形层面做的，裁剪掉不在屏幕内的像素。</p><p>c. 屏幕映射阶段：主要目的是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p><p>（3）光栅化阶段，包含三角形设置和三角形遍历阶段。</p><p>a. 三角形设置(图元装配)，计算出三角形的一些重要数据(如三条边的方程、深度值等)以供三角形遍历阶段使用，这些数据同样可用于各种着色数据的插值。</p><p>b. 三角形遍历，找到哪些像素被三角形所覆盖，并对这些像素的属性值进行插值。通过判断像素的中心采样点是否被三角形覆盖来决定该像素是否要生成片段。通过三角形三个顶点的属性数据，插值得到每个像素的属性值。此外透视校正插值也在这个阶段执行。</p><p>这两个阶段是完全硬件控制的，不可进行任何操作。</p><p>（4）<strong>像素处理阶段</strong>，包括像素着色和测试合并。</p><p>a. 像素着色，进行光照计算和阴影处理，决定屏幕像素的最终颜色。各种复杂的着色模型、光照计算都是在这个阶段完成。</p><p>b. 测试合并，包括各种测试和混合操作，如裁剪测试、透明测试、模板测试、深度测试以及色彩混合等。经过了测试合并阶段，并存到帧缓冲的像素值，才是最终呈现在屏幕上的图像。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>面经：<a href="https://zhuanlan.zhihu.com/p/417640759">https://zhuanlan.zhihu.com/p/417640759</a></p><p>设计模式：<a href="https://zhuanlan.zhihu.com/p/23821422">https://zhuanlan.zhihu.com/p/23821422</a></p><p>C++面经：<a href="https://github.com/huihut/interview?tab=readme-ov-file">https://github.com/huihut/interview?tab=readme-ov-file</a></p><p><a href="https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file">https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file</a></p>]]></content>
    
    
    <categories>
      
      <category>找工作</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《妙趣横生的游戏制作之旅》读书笔记</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%8A%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%97%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%8A%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%97%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、构思——制作想法"><a href="#一、构思——制作想法" class="headerlink" title="一、构思——制作想法"></a>一、构思——制作想法</h1><h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1.如何开始"></a>1.如何开始</h2><p>作者介绍了三种方法：头脑风暴、调研和原型</p><h2 id="2-头脑风暴"><a href="#2-头脑风暴" class="headerlink" title="2.头脑风暴"></a>2.头脑风暴</h2><p>头脑风暴最好有一些基本规则，比如：</p><p>设定时间限制；注重数量而不是质量；一次只有一人发言；让一个人来协调大家；让每个人都能发言；把一切都写下来；欢迎奇怪的想法；多肯定别人的想法；不要深入讨论出现的想法。</p><p><strong>评估头脑风暴结果</strong></p><p>做表列出根据不同维度的指标打分，“最重要的是选出团队都能接受的方案。“</p><p><strong>一些其他的奇思妙想的方法</strong></p><p>思维导图：一直链接</p><p>自动化：放空大脑让自己在纸上随便写点画点东西。</p><p>剪贴法：拿一个笔记本随时记录自己的想法。</p><h2 id="3-调研"><a href="#3-调研" class="headerlink" title="3.调研"></a>3.调研</h2><p>互联网；图片；实地考察；访谈；影子观察法：这个挺有意思，观察一个人的一天，游戏测试也有用到。</p><h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p><strong>游戏原型不是游戏的演示</strong></p><p><strong>每一个原型都会为你的游戏探索一个或多个想法</strong></p><p>在构思阶段，可以尽可能多地制作原型，一个原型能验证一个有趣的想法就够了。</p><p>用每一个原型来回答一个问题，比如：“用鼠标控制钓鱼是否可行？“</p><h3 id="三种原型设计方式"><a href="#三种原型设计方式" class="headerlink" title="三种原型设计方式"></a>三种原型设计方式</h3><p><strong>趣味原型设计</strong></p><p>直接拿现成的玩具，或者干脆用动作来演示你想做的游戏是怎么玩的。</p><p><strong>实物原型设计</strong></p><p>做一个桌游，这里有一个孤星猎人的验证思路视频，很有意思，<a href="https://www.bilibili.com/video/BV1fw4m1R75K/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">可以看看</a></p><p>视频里也演示了实物的优势，就是迭代很快，可以验证想法的可行性。</p><p><strong>数字原型设计</strong></p><h1 id="二、预制作——通过制作进行设计"><a href="#二、预制作——通过制作进行设计" class="headerlink" title="二、预制作——通过制作进行设计"></a>二、预制作——通过制作进行设计</h1>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
      <tag>找工作</tag>
      
      <tag>游戏制作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【GDC讲座】万智牌的20个教训</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E4%B8%87%E6%99%BA%E7%89%8C%E7%9A%8420%E4%B8%AA%E6%95%99%E8%AE%AD/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E4%B8%87%E6%99%BA%E7%89%8C%E7%9A%8420%E4%B8%AA%E6%95%99%E8%AE%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-跟人性作对是自寻死路"><a href="#1-跟人性作对是自寻死路" class="headerlink" title="1.跟人性作对是自寻死路"></a>1.跟人性作对是自寻死路</h1><p>有一个机制是延缓，得等三回合才能攻击，但是万智牌的规则不允许等待之后立马攻击，所以改了很多次都无法改好，最后改成能立马攻击了，所以要为了你的玩家来调整游戏而不是相反。</p><h1 id="2-美感很重要"><a href="#2-美感很重要" class="headerlink" title="2.美感很重要"></a>2.美感很重要</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119153159053.png" alt="image-20240119153159053"></p><p>这张牌被吐槽了很多，既不是因为他的强度，他的受欢迎度，而是因为他的攻击力是7，生命是7，效果是花七点血摸七张牌，但是他的花费是八点水晶（哈哈哈哈）</p><p>平衡感，对称感，整体感，不要和人类感知作对。</p><h1 id="3-共鸣很重要"><a href="#3-共鸣很重要" class="headerlink" title="3.共鸣很重要"></a>3.共鸣很重要</h1><p>玩家是有一些预先的知识和概念的，所以设计师不是从无到有地设计，你需要基于这一基础制作出更丰富的情感体验</p><h1 id="4-借用常识"><a href="#4-借用常识" class="headerlink" title="4.借用常识"></a>4.借用常识</h1><p>用已经存在的知识作为游戏信息，可以让游戏更加容易上手。</p><p>把木马（借用了特洛伊木马的点子）改成狮子之后会让玩家困惑这张牌的作用。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119153954784.png" alt="image-20240119153954784"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119154004563.png" alt="image-20240119154004563"></p><p>下面是一个植物大战僵尸的例子，他的设计师在设计的时候，觉得塔防游戏如果放了塔就不能移动显得很不符合逻辑，为什么这里其他地方需要帮忙他的士兵不能过去，所以他在想什么东西会更加符合直觉，于是他选择了植物，因为植物一旦放下就不能移动。然后怪物需要是一种不断靠近的生物，所以他选择了僵尸，看上去是为了幽默的两种组合其实也是经过思考的。</p><h1 id="5-不要错把“听起来有意思”当成真的“好玩”"><a href="#5-不要错把“听起来有意思”当成真的“好玩”" class="headerlink" title="5.不要错把“听起来有意思”当成真的“好玩”"></a>5.不要错把“听起来有意思”当成真的“好玩”</h1><p>理性觉得好玩不一定真的好玩</p><h1 id="6-理解你游戏希望唤醒的情感"><a href="#6-理解你游戏希望唤醒的情感" class="headerlink" title="6.理解你游戏希望唤醒的情感"></a>6.理解你游戏希望唤醒的情感</h1><p>为了让玩家感受到恐怖，设计了双面牌（比如一面是科学家一面是狼人），还有返场法术，亡语。</p><p>游戏的所有元素都要为了游戏的情感服务</p><h1 id="7-允许玩家有能力将游戏与自己联系起来"><a href="#7-允许玩家有能力将游戏与自己联系起来" class="headerlink" title="7.允许玩家有能力将游戏与自己联系起来"></a>7.允许玩家有能力将游戏与自己联系起来</h1><p>把基础枯燥的地卡的图片放大，每一张地卡都用不同的团，甚至用真实地形，这会让玩家很有参与感，让玩家对游戏产生更亲密的个人联系很重要，玩家越觉得游戏是为他们自己而设计的，他们就会越觉得游戏越棒。（熟悉感&#x3D;品质）</p><p>方法即使：多给玩家选择， 给他们不同资源，不同思路，不同表达方式，给他们选择和不选择的权利，让玩家觉得是他们自己做出的选择</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119160250626.png" alt="image-20240119160250626"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119160229907.png" alt="image-20240119160229907"></p><h1 id="8-细节是让玩家爱上你游戏的原因"><a href="#8-细节是让玩家爱上你游戏的原因" class="headerlink" title="8.细节是让玩家爱上你游戏的原因"></a>8.细节是让玩家爱上你游戏的原因</h1><p>玩家需要细节来和游戏产生羁绊</p><h1 id="9-要让玩家有拥有感"><a href="#9-要让玩家有拥有感" class="headerlink" title="9.要让玩家有拥有感"></a>9.要让玩家有拥有感</h1><p>受到玩家自制规则指挥赛的启发（就是一张传奇卡+99张同颜色卡），官方出了很多很多dlc，所以当玩家对某些细节产生好感之后，你需要给他们制作与众不同内容的能力，（电子游戏或许就是给他们打mod？），关键在于自定义，你要让他们实现与众不同的事，完成他们自己的创作（用自己构筑的卡组用了</p><h1 id="10-给玩家空间自己探索"><a href="#10-给玩家空间自己探索" class="headerlink" title="10.给玩家空间自己探索"></a>10.给玩家空间自己探索</h1><p>举了一个他们设计卡的时候没想到的联动（这种在炉石啊也很常见，这很有趣</p><p>不要给玩家灌输思想，让他们自己思考，因为人更关心自己发起的事情</p><h1 id="11-如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败"><a href="#11-如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败" class="headerlink" title="11.如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败"></a>11.如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119171325042.png" alt="image-20240119171325042"></p><p>别担心唤起负面情绪，多担心如恶化才能唤起一种强烈的感受</p><h1 id="12-别为了证明自己去设计"><a href="#12-别为了证明自己去设计" class="headerlink" title="12.别为了证明自己去设计"></a>12.别为了证明自己去设计</h1><p>做了一张两费的英雄卡（planeswalkers），做成两费是因为已经做过了三费四费五费的，所以想尝试一张两费的， 但是玩家觉得太垃圾了，因为强度太低，他们喜欢英雄卡是因为通常很强，但是两费的限制让他不能太强。</p><p>做游戏不是为了自己开心或是证明自己的能力，而是为了好玩，为了玩家。</p><h1 id="13-让好玩的玩法同样也是赢得游戏的正确策略"><a href="#13-让好玩的玩法同样也是赢得游戏的正确策略" class="headerlink" title="13.让好玩的玩法同样也是赢得游戏的正确策略"></a>13.让好玩的玩法同样也是赢得游戏的正确策略</h1><p>万智牌加入过一种搞笑机制，Gocha（大意就是做了某些事就可以拿回这张卡，类似不要做挑战），这样会让游戏变得很沉闷，因为玩家想要赢的话就最好什么都不要做，不要笑不要说话之类的，所以体验会很糟糕。</p><h1 id="14-不要担心用简单粗暴的手段"><a href="#14-不要担心用简单粗暴的手段" class="headerlink" title="14.不要担心用简单粗暴的手段"></a>14.不要担心用简单粗暴的手段</h1><h1 id="15-为目标用户设计内容"><a href="#15-为目标用户设计内容" class="headerlink" title="15.为目标用户设计内容"></a>15.为目标用户设计内容</h1><p>弄清用户的需求，做游戏里的宜家</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119173137436.png" alt="image-20240119173137436"></p><p>一张卡有投硬币的机制（能带来兴奋），也很平衡，但是两者都想讨好的结果就是大家都不喜欢。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119173302969.png" alt="image-20240119173302969"></p><h1 id="16-宁可尝试打破常规，也不要墨守成规让玩家觉得无聊"><a href="#16-宁可尝试打破常规，也不要墨守成规让玩家觉得无聊" class="headerlink" title="16.宁可尝试打破常规，也不要墨守成规让玩家觉得无聊"></a>16.宁可尝试打破常规，也不要墨守成规让玩家觉得无聊</h1><p>一开始设计饼干卡的时候除了自己和创始人没人喜欢，但是还是坚持下去了，结果大受欢迎</p><h1 id="17-你不需要做太多变动就可以改变全局"><a href="#17-你不需要做太多变动就可以改变全局" class="headerlink" title="17.你不需要做太多变动就可以改变全局"></a>17.你不需要做太多变动就可以改变全局</h1><p>由多色玩法引申而来，想要做一个另一个多色系列，如何做出不一样的感觉？改成双色的组合就大受欢迎</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119174256154.png" alt="image-20240119174256154"></p><h1 id="18-限制是创造力的温床"><a href="#18-限制是创造力的温床" class="headerlink" title="18.限制是创造力的温床"></a>18.限制是创造力的温床</h1><p>选择越多不一定创造力更强</p><h1 id="19-你的受众很擅长指出问题，但不擅长解决问题"><a href="#19-你的受众很擅长指出问题，但不擅长解决问题" class="headerlink" title="19.你的受众很擅长指出问题，但不擅长解决问题"></a>19.你的受众很擅长指出问题，但不擅长解决问题</h1><h1 id="20-所有经验教训都是相互关联的"><a href="#20-所有经验教训都是相互关联的" class="headerlink" title="20.所有经验教训都是相互关联的"></a>20.所有经验教训都是相互关联的</h1>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
      <tag>GDC讲座</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>出色的动作游戏是如何做出来的？</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%87%BA%E8%89%B2%E7%9A%84%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%87%BA%E8%89%B2%E7%9A%84%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="动作游戏的要素"><a href="#动作游戏的要素" class="headerlink" title="动作游戏的要素"></a>动作游戏的要素</h1><p>作者首先讲了六种让动作游戏变得好玩的要素。</p><h2 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h2><p>马里奥奥德赛有各种跳跃的方式，比如高跳，远跳，帽子跳，通过结合使用这些跳跃方式你可以去到一些不寻常的地方</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240111111207.png" alt="微信图片_20240111111207"></p><p>其他类似例子：麻布仔：大冒险 (2020) 时光之帽 (2017) 托尼·霍克的职业滑冰者 1 + 2 (2020)</p><h2 id="与环境交互"><a href="#与环境交互" class="headerlink" title="与环境交互"></a>与环境交互</h2><p>日落超速 (2014)，这款游戏只有简单的跑，加速，翻滚，但是这款游戏可以丰富地和环境交互，比如在遮阳棚弹跳，在电线上滑行，在杆上摇摆</p><p>其他类似的比如幽灵行者和奥日</p><h2 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h2><p>无路之旅：这款游戏可以用箭射击目标来获得短暂加速，你必须为射击充能，并在计量表完全充满时释放，这给游戏带来一种有节奏感的动作模式</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240111111211.png" alt="微信图片_20240111111211"></p><h2 id="动量"><a href="#动量" class="headerlink" title="动量"></a>动量</h2><p>泰坦陨落2：这个游戏简单的奔跑速度很慢，但是你可以通过滑铲跳，上墙，抓钩，甚至是手榴弹的方式来获得持续的动量来保证一个很大的速度，</p><p>其他类似：镜之边缘，不保持动量就无法完成挑战，crumble</p><h2 id="理解轨迹"><a href="#理解轨迹" class="headerlink" title="理解轨迹"></a>理解轨迹</h2><p>cyberhook：这是一款利用钩锁跑酷的游戏，他要求你理解轨迹。绳索的轨迹又重力和张力共同决定，为了最大限度的利用机制，我们必须在心中画出精准的摆荡弧线，一些滑翔机制的游戏也有同样的道理。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/da1e2b05f96686fe836a0c8ca475924.png" alt="da1e2b05f96686fe836a0c8ca475924"></p><h2 id="巧用物理"><a href="#巧用物理" class="headerlink" title="巧用物理"></a>巧用物理</h2><p>火箭联盟：你可以操作汽车做出一些非常难以想象的动作，比如飞越整个球场，倒挂金钩</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240111114026196.png" alt="image-20240111114026196"></p><p>这些元素可以混合使用，比如正当防卫，你可以打出钩锁，然后收缩获得动量，之后链接打开降落伞和滑翔翼</p><h1 id="为什么这些元素会显得好玩？"><a href="#为什么这些元素会显得好玩？" class="headerlink" title="为什么这些元素会显得好玩？"></a>为什么这些元素会显得好玩？</h1><h2 id="所有这些方法都允许真正的移动自由"><a href="#所有这些方法都允许真正的移动自由" class="headerlink" title="所有这些方法都允许真正的移动自由"></a>所有这些方法都允许真正的移动自由</h2><p>把墙壁和障碍变成了挑战而不是阻碍，增加了整个游戏的垂直感。</p><h2 id="允许模糊输入"><a href="#允许模糊输入" class="headerlink" title="允许模糊输入"></a>允许模糊输入</h2><p>对比塞尔达和apex的钩爪，自由度完全不一样，可操作度也自由的多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/db4855b33aedba57af2a6873e0c2a63.png" alt="db4855b33aedba57af2a6873e0c2a63"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/db16a1fc753793b1662520c163f95ea.png" alt="db16a1fc753793b1662520c163f95ea"></p><h2 id="允许你随着心流移动"><a href="#允许你随着心流移动" class="headerlink" title="允许你随着心流移动"></a>允许你随着心流移动</h2><p>当你的移动做得好，你可以完整的游玩整个关卡而不用减速或者停止</p><h2 id="这些高级的移动机制是对技巧的测试"><a href="#这些高级的移动机制是对技巧的测试" class="headerlink" title="这些高级的移动机制是对技巧的测试"></a>这些高级的移动机制是对技巧的测试</h2><p>链式移动：你需要理解如何连接</p><p>利用环境：你需要有一定的精度</p><p>时机不用多说</p><p>动量：你移动的越快就越难控制</p><p>轨迹要求你内化成自己的轨迹</p><p>基于物理的角色难以驾驭</p><h2 id="当你拥有这些技巧时，这些机制的使用会让你开心"><a href="#当你拥有这些技巧时，这些机制的使用会让你开心" class="headerlink" title="当你拥有这些技巧时，这些机制的使用会让你开心"></a>当你拥有这些技巧时，这些机制的使用会让你开心</h2><p>链式移动时，你仿佛在键盘上弹奏微小而快速的钢琴旋律；利用环境的时候你在不断地规划路线；抓住时机的正反馈非常大；不断获得更大的动量的时候让你既兴奋又害怕；</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023书影游总结</title>
    <link href="/%E9%9A%8F%E7%AC%94/2023%E4%B9%A6%E5%BD%B1%E6%B8%B8%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%9A%8F%E7%AC%94/2023%E4%B9%A6%E5%BD%B1%E6%B8%B8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/571fe6a36073b20ee5f54903b5968ab.jpg"></p><h2 id="我偏爱读诗的荒谬"><a href="#我偏爱读诗的荒谬" class="headerlink" title="我偏爱读诗的荒谬"></a>我偏爱读诗的荒谬</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s34075545.jpg" alt="我偏爱读诗的荒谬"></p><p>三十篇教你如何欣赏现代诗的文章，循序渐进，理解诗意是一个很困难的过程，这本小书或许可以带你走进现代诗的大门。</p><h2 id="小行星掉在下午"><a href="#小行星掉在下午" class="headerlink" title="小行星掉在下午"></a>小行星掉在下午</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s33531914.jpg" alt="小行星掉在下午"></p><p>今年读过的最有趣的短篇小说集，每一篇或多或少带有一点奇幻或者科幻的味道，但是读起来又很有现实意义，颇有一种村上的感觉。</p><p>最喜欢《工作狂》这一篇，对于工作和摸鱼的吐槽太有意思了；《使喂养人害怕的猫》也很好笑，夸张化的猫奴；《星际迷航》第一篇蛮有意思，瞎吹人员这个职业太黑色幽默了。</p><p>其他有意思的短篇小说有《平原上的摩西》，读起来有一种阿城的感觉；《回忆扑克牌》，这本集子的心理描写以及感情纠纷写的非常细腻，也挺好看；《如雪如山》，每一篇女主角都叫lili，比喻和文笔很舒服；《国王的游戏》，这本集子很多游戏和桌游的同人文，从熟悉的机制延申了很多有意思的故事。</p><h2 id="不方便，但很幸福"><a href="#不方便，但很幸福" class="headerlink" title="不方便，但很幸福"></a>不方便，但很幸福</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s33708031.jpg" alt="不方便，但很幸福"></p><p>深居山林的孤独生活，种菜捉鱼挖野菜，虽然日子过得紧巴巴的，但作者总是非常乐观，看得很开心的一本漫画。</p><p>今年我一直在b站，豆瓣小组看各种人的fire生活，比如银滩北海云南，每次上班上的不开心就想着找一个一年一千块房租的地方宅一年，每天运动运动，看看闲书，打打游戏，这种幻想是忍受目前工作的一些动力。</p><h2 id="just-for-fun"><a href="#just-for-fun" class="headerlink" title="just for fun"></a>just for fun</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s34464811.jpg" alt="只是为了好玩"></p><p>创造出linux和git的神人的自传，拥抱开源，专注，有热情，极具极客精神，非常令人敬佩。知乎有一个很有趣的帖子是，假如Llinus出生在中国会怎样，回答十分难绷，一个人的成功肯定是和家庭和环境都有关系的，linus幼儿园就抱着教授外公的电脑开始捣鼓程序了，本书后面也讲述他许多关于人生的看法，值得一读。</p><h2 id="一个女人的故事"><a href="#一个女人的故事" class="headerlink" title="一个女人的故事"></a>一个女人的故事</h2><blockquote><p>“我的母亲死了，于4月7日星期一，在蓬图瓦兹医院的老年病房。我失去了与我所来自的世界的最后一根纽带。”</p></blockquote><p>这本短短的自传体小说从母亲的去世开始写起，然后再从头开始回忆母亲的一生。尽管写得很克制了，但作者对母亲的爱太令人感同身受了，一个逐渐失去记忆的母亲，逐渐忘记和自己回忆的感觉太可怕了，仿佛随时有可能发生在自己身上一样。</p><p>今年读了很多讲家庭的书，大概是因为在北京待的时间太长了，有一种游子的哀伤，所以看这些总是很有感触。《夫之历》：一本描述父爱的漫画，看到父亲默默养自己留下来的狗的时候泪崩了；《明亮的夜晚》：三对母女的故事，横跨了数十年，和家人的关系或许是要用一生来学习的命题，读的过程中总想到一句歌词：“最心疼是，爱的太迟，有些心意，不可等某个日子…”；《秋园》：中国普通人的个人史，有一种听家里老人讲故事的感觉，苦难的日子真的多啊。</p><h2 id="象之首"><a href="#象之首" class="headerlink" title="象之首"></a>象之首</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s34632149.jpg" alt="エレファントヘッド"></p><blockquote><p>泄底剧透警告</p></blockquote><p>白井重新点燃了我对推理的热情，实在是太鬼才了，这本是我第一次读白井，核心设定是人格分类导致的物理相连的多元宇宙，非常有意思，故事篇剧情进展猪突猛进，各类鬼畜血腥元素砸过来，解答篇也是相当精彩，各种伏线的回收看的眼花缭乱，三个伪解答都看的很爽，既奉献了两个空间和时间的本格解答，也奉献了一个宇宙矛盾的变格解答，最后的真解答也让人叫绝。</p><p>之后又读了《名侦探的牺牲》，《彩虹牙刷》和《绝叫》，都各有特色，新的一年希望继续读各种有意思的诡计。（目前待读就有《X的悲剧》，《无人逝去》和《罗杰疑案》）</p><h1 id="影"><a href="#影" class="headerlink" title="影"></a>影</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/479ee89b5369ac9d561ca02b316453f.jpg"></p><p>今年还真是在电影院看了蛮多电影，八九月的时候每周都跑资料馆，今年的看过里面有四部都是短视频看的老片，嗯，我已经开始堕落成这种人了QAQ，不过我已经看淡了，很多老片确实看个情节就好了。</p><h2 id="恐怖分子"><a href="#恐怖分子" class="headerlink" title="恐怖分子"></a>恐怖分子</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2347245849.webp" alt="恐怖份子"></p><p>杨德昌实在是太厉害了，一开始多线叙事看的有点晕，最后交织到一起的时候看的真揪心，影片一点点地把毁掉男主的过程展示出来，最后开的那一枪仿佛射向了自己，伴随着蔡琴悠扬的歌声，结束的那么突然。</p><h2 id="情书"><a href="#情书" class="headerlink" title="情书"></a>情书</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2648230660.webp" alt="Love Letter"></p><p>嗯，确实是今年才第一次看这部片，资料馆的大屏幕体验相当好，中途看哭我两次，一次是爷爷拼死背着女树，一次是博子在雪山喊话男树，电影真的很美，女树的生活很令人羡慕啊，图书管理员的工作，能和家里人住在一起，自由自在的。</p><h2 id="火山挚恋"><a href="#火山挚恋" class="headerlink" title="火山挚恋"></a>火山挚恋</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2896531014.webp" alt="Fire of Love"></p><blockquote><p>看完情书的同一天晚上突发奇想去看的这部片，不得不说有一种很奇妙的冰火两重天的体验。</p></blockquote><p>电影是美的，许多火山的实拍镜头相当令人着迷，经历了漫长的地质时间，人类诞生两百万年之后，两个人诞生于同一时代同一地点，他们热爱着同一件事，热爱着彼此，推动了人类对于火山的认知。他们是追逐危险的疯子，是冒险家，是选择月亮的人，不顾一切地观察，拍摄，留下了这么多震撼到让我觉得不真实的记录。地球是有那么多的疑问，那样的绚烂，相比之下人类社会是如此的庸俗渺小，纪念他们短暂但是绚烂的一生。</p><h2 id="gamenight"><a href="#gamenight" class="headerlink" title="gamenight"></a>gamenight</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2514235105.webp" alt="Game Night"></p><p>在南京旅游晚上在民宿看的，可以说是送给桌游人的电影，开头桌游的蒙太奇接用桌游求婚的片段看得真开心。看到电影里男主和好朋友聚在家里玩桌游的画面，这简直就是我的人生理想！</p><h2 id="年会不要停"><a href="#年会不要停" class="headerlink" title="年会不要停"></a>年会不要停</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2901057189.webp" alt="年会不能停！"></p><p>2023年的最后一部电影，影片的节奏实在是太棒了，毫无尿点，辛辣地讽刺了职场的方方面面，裁员广进、pua、拉帮结派不干实事，白客这张上班脸看得人真心疼，结尾比较理想化，但是看的又爽又开心。</p><h1 id="游"><a href="#游" class="headerlink" title="游"></a>游</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240102105508.png"></p><p>今年的游戏开了很多坑，但是玩完的却不多，很多都中道崩殂了，比如逆转裁判，十三机兵，塞尔达……没办法，想玩的实在太多。</p><h2 id="马里奥奥德赛"><a href="#马里奥奥德赛" class="headerlink" title="马里奥奥德赛"></a>马里奥奥德赛</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s29543798.jpg" alt="超级马力欧 奥德赛 スーパーマリオ オデッセイ"></p><p>神作，游戏设计的标杆，任天堂真的太能藏东西了，用一个词来形容游玩的过程就是惊喜。总是在不断满足自己的好奇心，或许是拐角遇到月亮，或许是遇到一个特别的挑战，或许是变身成一个新生物，甚至是不小心条约失误掉落也能发现一个新世界，这种随时随地有新东西的感觉太棒了，这绝对是switch必玩的游戏！</p><h2 id="一堆派对游戏"><a href="#一堆派对游戏" class="headerlink" title="一堆派对游戏"></a>一堆派对游戏</h2><p>从国庆开始，在switch上玩了很多派对游戏，真是太欢乐了，录了许多条欢声笑语的视频，马派的合作划船相当累并且欢乐；马派的各种小游戏也是欢乐满满；马车8的道具赛相当刺激；12switch在动车餐车上通宵玩了一晚上，一个可以上限一百人的派对游戏，节目效果爆炸。</p><h2 id="街头霸王6"><a href="#街头霸王6" class="headerlink" title="街头霸王6"></a>街头霸王6</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/479ac5c9838f3a7802698666060085026308fcde.png"></p><p>去年玩的最久的游戏，作为一个格斗游戏小白，从零开始开始慢慢修炼的感觉非常好，感谢卡普空的现代模式，一键连招一键必杀让手残也有机会领略格斗游戏的魅力。</p><p>玩街霸是一种心态的磨炼，从一开始的只会抽奖打伤害，到后来的学习抓住对手的失误反击，再到一些套路和进攻的选择。</p><p>玩街霸你要接受自己的失误，接受失败，接受对面一直复读但是你又不知道如何应对，但是你不要把爽点放在胜利上，对局的每一次连段成功，每一次对策成功，都是非常令人振奋的。只要肯练习，肯学习，就一定会进步，这正是最强的正反馈。</p><h2 id="博德之门3"><a href="#博德之门3" class="headerlink" title="博德之门3"></a>博德之门3</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/%E5%85%A8%E5%AE%B6%E7%A6%8F.jpg" alt="全家福"></p><p>去年最沉迷的游戏，即使是加班的日子也每天九点启动打到凌晨一点，和好朋友探险的感觉真的太棒了，游戏的自由度和丰富度实在是太高了，每一个npc每一个剧情，再到不同的人物，装备，法术，一切东西你都可有自己的选择，拉瑞安扎扎实实地堆出了一个真实又有趣的世界，不过可惜的是还停留在第三章，希望有机会能玩完。</p><h2 id="怪兽远征"><a href="#怪兽远征" class="headerlink" title="怪兽远征"></a>怪兽远征</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/s33721384.jpg" alt="怪兽远征 A Monster&#39;s Expedition"></p><p>神中神，一年前沉迷了一段时间，今年终于顺畅地解完最后的几个小岛。太爽了，游戏是解密开放世界，很简单的推箱子机制，但是做到了极致，每一个小岛都像是在把玩一个孔明锁一样的小玩具，每次不断试错然后恍然大悟的尤里卡时刻让人非常上瘾，短木头，长木头，木筏，每一个谜题出现的新解法都能让你感慨设计的巧妙，遇到第一个木筏能推的时候直接震惊了，以及每一个一开始看起来不可能（比如死锁，换角度，双岛联动）的谜题但最后解出来的感觉真的太棒了。游戏的节奏感也把握的非常好，每次解完一个难关之后会有一些关于现代人类的吐槽，或者是一个一步式的谜题放松脑子。值得一提的是此游戏还有开放世界的感觉，你可以选择不同的道路探索，“以不同的眼光看旧路”，这种感觉太棒了，还有很多雪人没有收集，很多小岛没去……</p><h1 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h1><p>回看去年的目标，没完成的很多，日语没学，运动也没突破，好消息是开始做游戏demo了，而且闲书读的蛮多，但总是囫囵吞枣不求甚解，最近发现很多曾经看过的电影读过的书都想不起来细节了，新的一年多做总结慢慢来吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>东京贫困女子</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B8%9C%E4%BA%AC%E8%B4%AB%E5%9B%B0%E5%A5%B3%E5%AD%90/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%B8%9C%E4%BA%AC%E8%B4%AB%E5%9B%B0%E5%A5%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>提倡同薪同酬也好，实施住房扶持政策也罢，或者是实现男女平等也行，无论哪种形式，只要能将普通女性的可支配收入增加3万～5万日元，或者让她们的实际收入能和男性有相同程度的增长，从事风俗业的女性都会大幅减少。女性不断流入卖身世界的现状，现今不再是个人问题，而是已演变成一个国家的问题。</p><p>如今的社会是男性占优势地位，生活困苦的女性即使拒绝了通过风俗业从男性获得再分配的行为，也得不到任何好处，充其量就是转而选择长时间劳动，最后牺牲自己的健康。</p><p>看护行业和贫困问题采访得多了，就会渐渐看清国家的意图或意向。说实话，国家对除国家的行政公务员以外的职员，根本就不愿意支付酬金。他们知道自己正在让协助运营公共事业的国民和市民生活在贫困阶层，并且有意让这些劳动者的生活尽可能地接近贫困线。</p><p>从图书馆的图书管理员等临时职员、非常勤职员的情况和看护保险的制度设计就能非常明显地看出，国家和行政所追求的（针对不是公务员的劳动者）一定是“付最少的钱，达到最大的效果”。</p><p>我在采访福利行业和看护行业时，看到了深深依赖于雇用非正式化的公共事业中，太多令人绝望的现实。</p><p class="note note-primary">如果从工作上就有薪资不平等的情况，那么其他政策都是无稽之谈</p><p>在1999年和2004年，《劳动者派遣法》分别进行过修订，整个社会的雇用非正式化不断推进。其中，雇用的非正式化推进最快的就是地方自治体。由于小泉纯一郎政权时代的结构改革，给地方自治体的补助金被削减了，于是政府机构转而开始压缩雇用费用。他们将此前由公务员负责处理的业务交给了非正式职员，于是，官制穷忙族便诞生了。</p><p>女性首先成为了他们的目标，图书管理员、护工、保育士、窗口接待等工作一项一项改为非正式聘用制。不仅业务部门的职员的雇用被非正式化，从2000年代开始，幼儿园、看护机构，最近连图书馆都开始整个被外包给民间运营，而自治体支付的委托费用又十分低廉，这些行业都变成了严重低薪现象的温床。</p><p>谷村女士就职的这家图书馆是由自治体运营的。八成以上的图书管理员都是非正式聘用职员，只有两成左右是公务员。而非正式雇用的图书管理员，无一例外都拿着仿佛计算好的等于最低生活水平的收入，签订了有期限的雇用合同。</p><p class="note note-primary">日本派遣工真的难绷</p><p>一直生活在不安之中的谷村女士烦恼再三后做了一个决定——为了取得学艺员资格，她从4月起成了通信制大学的一名学生。一个因为公共机关的非正式雇用而烦恼的人，为了摆脱贫困却选择了去取得学艺员资格，这让我感到吃惊。然而这恰恰是大多数老实认真的贫困者的行为模式。想要取得医疗行政或看护类资格的人也属同类。</p><p>为了消除心中的不安，贫穷的人们不会去思考其中的原因，反而会着魔似的浏览那些印着各种职业资格的免费传单。然后，他们会为了取得那些难度较低的资格而开始学习。学习自然会花费一定的费用和时间，所以他们的生活会更加窘迫。可就算谷村女士学有所成，真的取得了学艺员的资格，能从事的也只有不存在生产行为的文化事业，她想要实现过上普通人生活的愿望，可能性依然很低。</p><p>她这样做不仅赚不回那些为了摆脱贫困而投入的时间和金钱，很可能招致相反的效果。最后增添更多烦恼，陷入恶性循环。被地方自治体非正式聘用，还在为了取得资格而学习的谷村女士，照这样下去，恐怕没有未来可言。</p><p class="note note-primary">有一个纪录片也讲过因学致贫，或者说穷人做什么都能难翻身</p><p>如果连一个有3个孩子的贫困家庭都得不到最低生活保障，那我们的社会保障制度还有什么意义呢？</p><p>最低生活保障是一种求生手段啊，在日本生活真是太容易了，哈哈。</p><p>听着村上女士的遭遇，我想起自己身边有一个熟人刚好在接受最低生活保障。他和孩子两个人组成了父子家庭，已经接受了10年以上的最低生活保障了。<br>虽说算不上有钱人，但他住在都内超繁华地段，有一辆高级车，时不时还能从他身边一个接一个的恋人手上拿点零花钱，总之一直过着逍遥自在的无业生活。偶尔见面，他总是赞叹最低生活保障制度是一项多么美好的制度。</p><p class="note note-primary">这一段有点不理解，真实性感觉不好说，可能只是个例</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明亮的夜晚</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%98%8E%E4%BA%AE%E7%9A%84%E5%A4%9C%E6%99%9A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我一度认为自己的优点就是善于忍耐。得益于这份忍耐，我取得了超出自己能力的成绩。为什么要忍耐到超过自己的限度呢？难道是认为应该证明自己的存在吗？是从什么时候开始，总感觉生活不是应该用来享受的，而是用以执行的呢？生活就像一个生存游戏面对着汗牛充栋、难且无趣的习题集搞题海术，制作纠错本、考试、得分、晋级。我不知道哪种生活方式才不需要证明自己的存在。在我看来，不被任何成绩证明的自己和没有价值的垃圾没什么两样。这一信条让我绝望，也让我一直都过分努力。那些认为自身存在本身就有意义和价值的人是没有必要证明自己的存在的，但我从一开始就不是那样的人。</p></blockquote><p class="note note-primary">这段自我怀疑的描写真贴切啊</p><blockquote><p>祖母的记忆中，自己从没收到过曾祖父送的任何一件小礼物。出来避难的时候，他也是睡在最好的地方，什么东西都不会让给女儿。</p><p>祖母穿着薄薄的外套冻得瑟瑟发抖，他都没想过脱下自己的外套给祖母。由于对曾祖父的这些行为太过熟悉，祖母甚至都感受不到生气。</p><p>祖母和南善的关系也因为这种熟悉才能维系。祖母无法把一个体贴的男人、在夫妻关系中不计得失的男人想象成自己的伴侣。比起期待和失望，祖母选择了放弃，因为这样做要容易得多。完全放弃了对丈夫的期待，彻底死心，于是这样的生活也变得可以忍受。</p><p>喜子有时会来信，祖母却几乎没有回过信。给喜子写信时，祖母会觉得哪里出了很大的问题。越是对自己诚实，就越难以承受那种心情。之前隐约感受到的那些情感和想法在写信的时候变得越发清晰，而这只会威胁到祖母的日常生活。</p><p>明淑奶奶寄来的信，祖母也没有回信。信里流露出的明淑奶奶的爱让祖母感到吃力。</p><p>因为读着明淑奶奶的信，就会知道，原来自己也是想要得到别人的爱的人；就要承认，原来自己也是非常热切地、急切地需要被爱的人。南善的话再刻薄也能忍受，但是读到明淑奶奶的信，祖母的心里总是很难受。是爱让祖母流泪了，是爱触动了连侮辱和伤害都无法撼动的祖母的心。</p></blockquote><p class="note note-primary">这个心里描写太细腻了，别人对自己的爱，会让自己怀疑现在过的生活太糟糕而难以忍受，哎</p><blockquote><p>姐姐和我骑着自行车下山。姐姐踩着踏板，我紧紧抱住她的背。姐姐身上散发出草莓泡泡糖的味道。好舒服、好平静的感觉，我已经不记得自己什么时候悲伤过，什么时候痛苦过。“不要走！”为了抓住这个瞬间，我大声叫起来.</p><p>“不要离开我，姐姐！”</p><p>接着，天空倒过来了，我看到吊在操场单杠上的中学时代的我。她总是想方设法地拖延回家的时间。我能像读纸上的宇一样读懂她的内心。现在她觉得，和她在一起的孩子们都以她为耻。她在跟自己说悄悄话：“我长得太丑了，没有人喜欢我。”</p><p>“不是那样的”正想告诉她的时候，有人把我拉到了后面。睁开眼，又是深夜了。</p><p>深夜的公共汽车上，我爱的人坐在我身边。二十二岁的我对他充满了 渴望，不知所措，但我知道他很快就会开口说要离开我。他终于开口了。“我知道，我知道。我就知道你会这样说。我知道，我知道。”他下了公共汽车，我还在这样说着，“我知道，我知道，你们最后都会离开我……”</p><p>我好想醒来。我按了下车铃，汽车却设有停下。我喊司机，用拳头拼命砸门，车还是不停。没有人看我。背后传来玄关门关上的声音。我知道那是丈夫离开我后关门的声——我以为只有你只有你不会离开我。我坐在地板上颤抖着了起来。</p><p>“智妍啊。”</p><p>这时，掉了两颗门牙的八岁的姐姐过来拍着我的背。</p><p>“智妍啊，智妍啊。</p><p>姐姐叫着我，世界越来越明亮。</p><p>太阳好像越来越大了。</p><p>我忘了刚才还在哭的事，对姐姐说：“太亮了，好刺眼。怎么这么亮呢？”</p><p>听我这样说，姐姐像是听到什么有趣的故事一样，在明亮的光线里大声笑起来。</p><p>“傻瓜。”</p><p>姐姐说。</p><p>“傻瓜，我从没离开过你。”</p></blockquote><p class="note note-primary">这一段的走马灯描写太好了，闪回人生中最痛苦的几个碎片，现实和虚幻交织，感染力太强了</p><blockquote><p>只听他的呼吸声，祖母就知道曾祖父要为此事责骂自己。对着卧病在床的祖母，曾祖父口若悬河地责怪起她来，嫌她无能，没能把丈夫留在熙岭。自己抓不住男人的心，现在被人抢走了，没什么好委屈的。</p><p>祖母闭着眼睛，忍受着他言语的鞭答。</p><p>“这句话你再说一遍。”</p><p>坐在一旁的曾祖母平静地说完，起身朝他走去。</p><p>你若敢再说第二遍，我就跟你拼命。再敢这样说英玉，就从我们眼前消失吧！</p><p>你算什么，敢这样跟我说话？要不是我你早就…</p><p>是，要不是你，我可能根本活不成。我并不是不知道这一点，所以我才能跟着你过了这么多年。你一直当我是来讨债的对吧？觉得是我欠你的。</p><p>当着自己丈夫的面你竟敢！</p><p>是我让你逃跑的吗？是我让你批弃自己的父母的吗？是我要和你结婚的吗？凭什么我一辈子都不能说个“不”字呢？我犯了什么罪？就因为我是白丁的女儿？那你不要管我就是了。我们英玉，我的命根子英玉也要成为你的出气筒，她这么难受你还要出言羞辱她。如果非要让我看到这一幕，当初还不如把我留在三川。不要和我拉上任何关系!</p></blockquote><p class="note note-primary">曾祖母真的解气啊</p><blockquote><p>虽然用眼睛看不到，但这个世界上一定有一个没有得到真心道歉的人们的国度。那里生活着这样的一群人- 想要的东西并不多，只希望得到真心的道歉，希望对方承认自己错误的人；凄然注视着对方，希望对方就算是装装样子，至少装作很抱歉的人；心如死灰地想着，如果对方从一开始就是可以道歉、不会让自己受到这种伤害的；再也无法像以前那样安然入睡的人；被别人质问 “为什么这么控制不住 自己的感情，一定要表露出来”的人；面对着无法得到任何人理解的高墙而束手无策的人；在众人畅谈的酒桌上像疯子一样放声大哭、让所有人惊慌失措的人。</p></blockquote><blockquote><p>那天的大海不再是祖母印象里熙岭的大海。既不是思念着明淑奶奶、新雨大婶和喜子，觉得自己好像被囚禁在照岭的年幼的祖母的大海，也不是抱着发烧的妈妈瑟瑟发抖地去找医院的途中看到的汹涌冷酷的大海。那一天祖母不需要看任何人的眼色，只是尽情地笑着，喊着。</p></blockquote><p class="note note-primary">又是一处对比描写，相当精彩</p><blockquote><p>我经常想起新雨大婶对金喜子博士说过的话—尽可能地走远一些。这句话指的绝不仅仅是物理上的距离，大婶一定是希望自己的女儿能去另一个维度的世界。她希望在自己所感受到的现实重力无法起作用的地方，女儿能够变得更加轻松，更加自由。我久久地思考着她的这份心意。</p></blockquote><p class="note note-primary">母爱啊/(ㄒoㄒ)/~~</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋园</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A7%8B%E5%9B%AD/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%A7%8B%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="自序-厨房里的写作"><a href="#自序-厨房里的写作" class="headerlink" title="自序 厨房里的写作"></a>自序 厨房里的写作</h1><p>标注(黄色) - 第 5 页·位置 34</p><p>然而，自从写作的念头浮现，就再也没法按压下去。洗净的青菜晾在篮子里，灶头炖着肉，在等汤滚沸的间隙，在抽油烟机的轰鸣声中，我随时坐下来，让手中的笔在稿纸上快速移动。在写完这本书之前，我总觉得有件事没完成，再不做怕是来不及了。</p><p>标注(黄色) - 第 6 页·位置 37</p><p>常常才写几行，泪水就模糊了眼睛。遥远的记忆被唤起，一些消失了的人与事纷至沓来，原本零星散乱、隐隐约约的回忆，在动笔之后互相串联，又唤醒和连接起更多的故事。我也感到奇怪：只要提起笔，过去那些日子就涌到笔尖，抢着要被诉说出来。我就像是用笔赶路，重新走了一遍长长的人生。</p><p>标注(黄色) - 第 6 页·位置 42</p><p>我一遍又一遍地重写这个故事，稿纸积累了厚厚一摞。出于好奇心，我称过它们的重量——足足八公斤。书写的过程，温暖了我心底深处的悲凉。</p><p>标注(黄色) - 第 6 页·位置 44</p><p>人到晚年，我却像一趟踏上征途的列车，一种前所未有的动力推着我轰隆轰隆向前赶去。我知道自己写出的故事如同一滴水，最终将汇入人类历史的长河。</p><h1 id="第一章-洛阳-南京"><a href="#第一章-洛阳-南京" class="headerlink" title="第一章 洛阳 南京"></a>第一章 洛阳 南京</h1><p>标注(黄色) - 第 19 页·位置 220</p><p>一九三七年深秋，一艘轮船停泊在汉口码头上等待靠岸。浓雾笼罩着宽阔的江面，看不到江水和天空，也看不到不远处的其他船只，天地之间只剩浓白的雾。远方，一小片浓雾深处闪烁着淡白的光亮，那是太阳在照耀，可灼热锐利的阳光亦穿不透浓雾。间或有汽笛鸣响，那声音孤单、凄清，如盲人般在雾中胡乱摸索、碰撞。</p><p>标注(黄色) - 第 20 页·位置 242</p><p>过吊桥时，年轻的秋园抱起子恒，迈着轻捷的步子走了过去。从前的生活，也远远地留在了吊桥那边。</p><h1 id="第二章-山起台"><a href="#第二章-山起台" class="headerlink" title="第二章 山起台"></a>第二章 山起台</h1><p>标注(黄色) - 第 27 页·位置 332</p><p>仁受当乡长期间，为了帮人买壮丁或救济穷人，有时连秋园的嫁妆、金银手饰也拿去变卖。本就不多的家当渐渐被贴得精光，他真正成了穷光蛋——穿在身上，吃在嘴里。</p><h1 id="第四章-黄泥冲"><a href="#第四章-黄泥冲" class="headerlink" title="第四章 黄泥冲"></a>第四章 黄泥冲</h1><p>标注(黄色) - 第 51 页·位置 650</p><p>仁受戴着眼镜，穿着长袍，走路笨拙，动作缓慢得像怕踩死蚂蚁一样，碰到人早早就露出谦和的微笑。他平时菜草不分、五谷不辨，完全是个书呆子，又有了五十岁，从头学种田谈何容易。事实证明，种田真不容易，起码没副强壮的身体就不行。不要说犁田、耙田这些技术活，仁受因有疝气痛，不能站久，一般的手脚功夫都做不了。</p><p>标注(黄色) - 第 67 页·位置 883</p><p>这次我可能会被枪毙。历届的乡长都枪毙了，保长也枪毙了几个。我死了，你们不要难过。我虽没做过迫害老百姓的事，但总是替国民政府做过事，罪有应得。国民党确实腐败，我深有体会。共产党看来是真为穷人、为百姓办事，现在穷苦人都分了田、分了房，人人都有饭吃、有衣穿。人民政府好，你们要听政府的话，千万不要做对不起政府的事。你们的妈妈跟着我冇享过一天福，我很对不起她，只有来世报答。我死了，她更可怜。你们要好好地孝敬妈妈，听妈妈的话。”</p><p>标注(黄色) - 第 77 页·位置 1027</p><p>听到狗叫声，杏梅母亲从灶屋里急急地走了出来。看到她们，她一边在围腰上使劲擦着手，一边小跑着来迎接，喊声“梁老师”，抓着秋园的手便往屋里走。无论是仁受被划成旧官吏、没收东西，还是满娭毑喋喋不休地咒骂，秋园从没哭过。她总是对细伢子们说：“我们不哭，懒得哭，哭也冇用。”可是此时此刻，秋园泪如泉涌，连忙用手去抹。</p><h1 id="第六章-跑"><a href="#第六章-跑" class="headerlink" title="第六章 跑"></a>第六章 跑</h1><p>标注(黄色) - 第 145 页·位置 1976</p><p>秋园哭道：“阳间有恶人，阴间有恶鬼，逃过一劫又一劫，不知我前世造了什么孽，今生今世要受这么多苦难！”</p><p>标注(黄色) - 第 146 页·位置 1985</p><p>这一年，秋园五十多岁。少年丧父，中年丧偶，晚年丧子，人生三大悲事都让她摊上了。</p><h1 id="代后记-解命运的谜"><a href="#代后记-解命运的谜" class="headerlink" title="代后记 解命运的谜"></a>代后记 解命运的谜</h1><p>标注(黄色) - 第 171 页·位置 2322</p><p>活着的理由，就是为了过那种不死不活的漫长日子做准备。”</p><p>标注(黄色) - 第 171 页·位置 2323</p><p>我见过非洲大草原上的牛羚横渡马拉河的情景。对牛羚来说，它们的命运就是渡过马拉河，河水会让它们一再跌倒，只要意志力稍微退却，可能连求生的意念都会放弃。</p><p>标注(黄色) - 第 171 页·位置 2325</p><p>外婆、妈妈这些被放逐到社会底层的人们，在命运面前显得如此渺小无力，仿佛随时会被揉碎。然而，人比自己想象的更加柔韧，她们永远不会被彻底毁掉。当之骅——我的妈妈——在晚年拿起笔回首自己的一生，真正的救赎方才开始。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长安的荔枝</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%95%BF%E5%AE%89%E7%9A%84%E8%8D%94%E6%9E%9D/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%95%BF%E5%AE%89%E7%9A%84%E8%8D%94%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote><p>杜甫把毛笔抢过去，不及研墨，直接蘸了酒水，唰唰写了起来。一会儿功夫，纸上便多了一首五言古诗：出门日已远，不受徒旅欺。骨肉恩岂断，男儿死无时。走马脱辔头，手中挑青丝。捷下万仞冈，俯身试搴旗。</p><p>杜甫把笔“啪”地一声甩开，直直看向李善德，眼神锐利如公孙大娘手中的剑器。“骨肉恩岂断，男儿死无时。既是退无可退，何不向前拼死一搏？”李善德读着这酒汁淋漓的诗句，握着纸卷的手腕，突地一抖，仿佛有什么东西在胸中漾开。</p></blockquote><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote><p>既然路上有人管吃住，上林署支给的所谓“驿使钱”与“出食钱”，其实是用不着。使职的妙处就在这里，它超脱诸司流程之外，符宝司不会跟上林署对账，上林署也没办法问户部虚实，三处彼此并不联通。</p></blockquote><blockquote><p>就算失败，我也想知道，自己倒在距离终点多远的地方。</p></blockquote><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><blockquote><p>在这一刻，他忘记了等待的贵妃，忘记了自己未知的命运，忘记了长安城市的香积贷，只想纵情歌舞，像当年一样跳一曲无忧无虑的胡旋舞。只见夜色之下，跃动的篝火旁边，一个胡子斑白的老头单脚旋转，状如陀螺，飘飘然如飞升一般。峒人们一边欢呼着，一边围在四周，像鸭子一样摆动身子，齐声高歌。歌声穿行于荔枝林间：</p></blockquote><blockquote><p>“石榴酒，葡萄浆，兰桂芳，茱萸香。愿君驻金鞍，暂此共年芳，愿君解罗襦，一醉同匡床。文君正新寡，结念在歌倡。昨宵绮帐迎韩寿，今朝罗袖引潘郎。莫吹羌笛惊邻里，不用琵琶喧洞房。且歌新夜曲，莫弄楚明光。此曲怨且艳，哀音断人肠。”</p></blockquote><blockquote><p>后来两人成婚，他还时时回味起那一天奔走在华山上的感觉。今日这荔枝的口感，竟和那时如此相似。怪不得圣人和贵妃也想吃新鲜荔枝，他们也许想重新找回两人初识时那种脸红心跳的感觉吧？</p></blockquote><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote><p>可光有想法还不成，具体到执行，至少涉及二十多个州县的短途供应，何处调冰，何处接应，如何屯冰，冰块消融速度是否赶得及等等，不尽早规划，根本来不及……灵感源源不断，毛笔勾画不断，李善德此时进入了一种道家所谓“入虚静”的奇妙状态，过往的经验与见识，融汇成一道大河，汪洋恣肆，奔腾咆哮。这一刻，他不是一个人在计算，陈子、刘徽、祖冲之、祖暅在这一刻魂魄附体。李善德的眼睛满布血丝，却丝毫不觉疲倦，恨不得撬开自己脑壳，一磕到底，把脑浆直接涂抹在纸卷之上。</p></blockquote><blockquote><p>李善德跟他约略讲了遭遇。鱼朝恩笑道：“别说大使你，就连圣人有时候要做点事，那一班孔目小吏都会夹缠不清，文山牍海砸将过来，包管叫你头晕脑胀。”</p><p>“正是如此！”李善德忙不迭地点头，他今天可算领教到了。</p><p>“他老人家为何跳出官序，额外设出使职差遣？还不是想发下一句话去，立刻有人痛痛快快去办成嘛。唉，堂堂大唐皇帝竟这么憋屈，我们这些做奴婢的，看了实在心疼啊。”鱼朝恩喟叹一声，用手里的白须拂子轻轻抹了下眼角。李善德赶紧劝慰几句，鱼朝恩复又振颜道：“我这个宫内副使的职责，正是内廷采买。岭南的新鲜荔枝，既然是圣人想要，那便是我份内的责任了。你放心好了，这件事我一定勾管到底。”</p></blockquote><blockquote><p>你若在呈上转运法之时，附上一份谢表，说明此事有岭南经略使着力推动、度支同仁大力支持、太府司、司农寺、尚食局助力良多，你猜鱼朝恩还敢不敢抢你的功 —— 良元兄呐，做官之道，其实就三句话：和光同尘，好处均沾，花花轿子众人齐抬。一个人吃独食，是吃不长久的。”</p></blockquote><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><blockquote><p>李善德接了牌子，又讨问手书，以方便给相关衙署行去文牒。杨国忠一怔，不由得哈哈大笑：“你拿了我的牌子，还要照章发牒，岂不坏了本相的名声？——流程，是弱者才要遵循的规矩。”</p><p>李善德唯唯诺诺，小心地把牌子收好。其实，杨国忠不给手书，还有一层深意。倘若李善德把事情办砸了，他只消收回银牌，两者之间便没任何关系，没有任何文书留迹，切割得清清楚楚。李善德想不到那么深，只觉得右相果然知人善用。他忽然想到一事，高兴地补充道：“这次转运，所费不赀。有岭南胡商苏谅愿意报效朝廷，国库不必支出一文，而大事可毕。”</p></blockquote><blockquote><p>李善德是做过冰政的人，很了解这个体系的秉性。每到夏日，上头说要一块冰，中间为求安全，会按十块来调拨。下头执行的人为了更安全，总得备出二十块才放心。层层加码，步步增量，至于是否会造成浪费，并没人关心。</p></blockquote><blockquote><p>所以右相要三十丛荔枝，到了都省就会增加到五十丛，转到经略府，就会变成一百丛，办事的人再打出些余量，至少也会截下两百丛。李善德无法苛责任何人，这与贪腐无关，也与地域无关，而是大唐长久以来的规则。</p></blockquote><blockquote><p>“你骗我！你骗我说给我带长安的酒，你骗我说没人会欺负我！你骗我说只砍十棵树！”阿僮似乎要把整个肺部撕来，浑身的血都涌上面颊，可随即又褪成苍白颜色。“我本以为你和他们不一样……”阿僮猛地推开李善德，一言不发地转头走开。她瘦弱的身形摇摇摆摆，像一棵无处遮蔽、被烈风摧残过的小草。</p></blockquote><blockquote><p>他痛苦地闭上眼睛，抖动缰绳，让马匹开始奔跑起来。可这样还不够，他拿起鞭子抽打着马屁股，不断加速，只盼着迅速逃离这一片荔枝林。可无论坐骑跑得有多快，李善德都无可避免地，在自己的良心上发现一处黑迹。在格眼簿子的图例里，赭点为色变，紫点为香变，朱点为味变。而墨点，则意味着荔枝发生褐变，流出汁水，彻底腐坏。</p></blockquote><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote><p>马匹是从驿站刚刚轮换的健马，皮毛鲜亮，四蹄带劲，跑起来鬃毛和尾巴齐齐飘扬。可它背上的那位骑士却软软趴在鞍子上，脸颊干瘪枯槁，全身都被尘土所覆盖，活像个毫无生命的土俑。一条右腿从马镫上垂下来，无力地来回啷当着。与其说这是活人，更像是捆在马革上的一具丧尸。</p></blockquote><blockquote><p>至于驿站附近的农户，他们在负担日常的租庸之外，突然要再服一期额外的白直徭役，没人愿意。没关系，那么只消缴纳两贯荔枝钱，便可免除这个劳役。“如此一来，国库、内帑两便，不劳一文而转运饶足，岂不是比你那个找商人报效的法子更好？”</p></blockquote><blockquote><p>“哼，只是个例罢了，又不是个个都逃。李善德，你到底想表达什么？”</p><p>“右相可知道。为了将这两坛新鲜荔枝送到长安城，在从化要砍毁多少成树？三十亩果园，两年全毁。一棵荔枝树要长二十年，只因为京城贵人们吃得一口鲜，便要受斧斤之斫。还有多少骑手奔劳涉险，多少牧监马匹横死，多少江河桨撸折断，又有多少人为之丧命？”</p><p>“右相适才说，不劳一文而转运饶足，下官以为大谬！天下钱粮皆有定数，不支于国库，不取于内帑，那么从何而来？只能从黄草驿馆、从化荔园榨取，从沿途附户身上征派。取之于民，用之于上，又谈何不劳一文？”</p><p>“你！你疯了！”杨国忠挥起月杆，狠狠砸在了李善德的头上，登时打出一条深深的血痕。</p><p>李善德不避不让，目光炯炯：“为相者，该当协理阴阳，权衡万事。荔枝与国家，不知相公心中到底是如何权衡，圣人心中，又觉得孰轻孰重？”月杆再次挥动，重重地砸在李善德的胸口。他仰面倒了下去，口中喷出一口血来。“滚！滚出去！”</p></blockquote><blockquote><p>我原本以为，把荔枝平安送到京城，从此仕途无量，应该会很开心。可我跑完这一路下来，却发现越接近成功，我的朋友就越少，内心就越愧疚。我本想和从前一样，苟且隐忍一下，也许很快就习惯了。可是我六月初一那天，靠在上好坊的残碑旁，看着那荔枝送进春明门时，发现自己竟一点都不高兴，只有满心的厌恶。那一刻，我忽然明悟了，有些冲动是苟且不了的，有些心思是藏不住的。”</p></blockquote><blockquote><p>“其实他去找杨国忠之前，跟我袒露过心声。这一次摊牌，一家人注定在长安城呆不下去。只要我反对，他便绝不会去跟右相摊牌。可这么多年老夫老妻了，我一眼就看出他内心的挣扎。他是真的痛苦，不是为了仕途，也不是为了家人，仅仅只是为了一个道理，却愁得头发全都白了。</p><p>二十多年了，他在长安为了生计奔走，其实并不开心。如果这么做能让他念头通达，那便做好了。我嫁的是他，又不是长安。”李夫人看向李善德的背影，嘴角露出少女般的羞涩，：“只要他肯背着我下山，无论是华山还是泰山，又有什么区别呢？”</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年终总结 桌游篇</title>
    <link href="/%E9%9A%8F%E7%AC%94/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%20%E6%A1%8C%E6%B8%B8%E7%AF%87/"/>
    <url>/%E9%9A%8F%E7%AC%94/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%20%E6%A1%8C%E6%B8%B8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="毛线"><a href="#毛线" class="headerlink" title="毛线"></a>毛线</h1><h2 id="scout"><a href="#scout" class="headerlink" title="scout"></a>scout</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/85fb34e40c190a13b0104fe5bab5967.jpg" alt="快要赢了的洋洋得意"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/d97561aa0793f242728c5bf5d01b3e1.jpg" alt="翻车的破防"><br>打牌游戏，简单的升级加了一个不能理牌但是可以强化卡组的设定，就变得十分有趣，这一年起码开了有七八次吧，每一次都是欢声笑语，这个游戏很容易最后一把翻车，上图就是一场我大意失荆州的搞笑画面。</p><h2 id="幻想国度"><a href="#幻想国度" class="headerlink" title="幻想国度"></a>幻想国度</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/ac134377b623e62c376335b9a594712.jpg"></p><p>玩法相当简单的卡牌游戏，一句话就能说完：抓一打一，最后比得分的多少。还有一款漫威换皮版也是这个机制，但是添加了一个反派堆所以我感觉没有原版那么好玩，只能说毛线非常看人，国庆和高中同学玩的时候非常上头，基本上每次玩我都要调侃一下，这么好玩的机制，我们来做个原神版，一定大卖（大雾）。</p><h2 id="the-crew（领航员）"><a href="#the-crew（领航员）" class="headerlink" title="the crew（领航员）"></a>the crew（领航员）</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/531047e924930296bac75869b139849.jpg"></p><p>其实我很喜欢吃墩这个机制，预测加打牌规划对我来说有很强的趣味性，既可以恶心人也可以精算，玩过非常多种竞争的吃墩游戏了，比如巫师牌，巫师牌极限版，盒中猫，tichu，否决权，但是领航员作为一款合作吃墩真的很有意思，每一关都有不同的机制，并且交流是有限制的，这就相当考验队友的默契程度，满分！</p><h2 id="瞎掰王"><a href="#瞎掰王" class="headerlink" title="瞎掰王"></a>瞎掰王</h2><p>这个可以算是年度毛线游戏了，详细的介绍可以看这个<a href="https://www.douban.com/note/850771070/">连接</a>，我还甚至还写了一个小程序来玩这个瞎猜游戏，直接用扑克牌就可以玩，相当有节目效果的一个嘴炮游戏，推的每个局都欢声笑语。</p><h2 id="猩猩相惜"><a href="#猩猩相惜" class="headerlink" title="猩猩相惜"></a>猩猩相惜</h2><p>这个游戏熟人局的效果爆炸，玩法就是轮流对三个问题暗自给出自己的答案，问题大概是一些三观题，比如你觉得是否自己是个坚强的人，答案在五个里面选择，觉得是，是，可能，不是，绝对不是。然后其他人来猜测回答者的答案，给出自己的答案，最后来判断大家的贴合程度，</p><p>p.s.这个游戏也可以用我的小程序来玩，回答就用扑克牌的1-5代替即可，相当好玩的语言毛线，大家快和好朋友试试吧~</p><h2 id="狼人真言"><a href="#狼人真言" class="headerlink" title="狼人真言"></a>狼人真言</h2><p>狼人杀和猜词机制完美的结合！第一次玩无感，时隔多年再次玩重新点燃了我对这款游戏的热爱，既有猜词的脑洞也有身份推理的紧张，因为先知不能暗示的太明显，狼人也不能捣乱的太明显，所以整个局面会非常混乱但又有趣，总之就是开多少次都不会腻的游戏。</p><h2 id="NANA"><a href="#NANA" class="headerlink" title="NANA"></a>NANA</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/6c64103d9f5ebf26116ace0c796e324.jpg" alt="扑克牌就可以diy"></p><p>又是一款记忆小游戏，规则很简单，要么翻某人的牌，要么在桌上的公共牌堆翻牌，谁先凑齐三组或者两组和或差为7或者一组7就能获胜。</p><p>这个游戏刚在北京玩的时候不太感冒，五一的时候和汤圆的朋友们一起玩相当的上头，整整开了两个小时，所以不得不在年度总结中提上一嘴了。</p><h2 id="签签入扣"><a href="#签签入扣" class="headerlink" title="签签入扣"></a>签签入扣</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/22d56d036bd43a3714b4b0c699b62cf.jpg" alt="22d56d036bd43a3714b4b0c699b62cf"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/72be64616afc84ec30ddc55adc56342.jpg" alt="72be64616afc84ec30ddc55adc56342"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/d985db468343d3a99832bd75c992b9c.jpg" alt="d985db468343d3a99832bd75c992b9c"></p><p>初次玩到这个游戏是两年前在一个桌游店和路人玩的，今年重新捞出这个游戏，开了好多好多次。和汤圆来北京复试的小区楼下玩</p><p>了，那天阳光很好；和北京桌游局在清华玩了，那天风很大，我们笑得很开心；回家和阿咩zzh，和我妈我弟开了一把，老妈竟然要求多玩几次，听到这句话的时候我真的又开心又感动。</p><p>不管什么游戏，只要能开起来，有互动性，能让大家开心，就是好游戏，强烈推荐这款动手的游戏！</p><h1 id="中策"><a href="#中策" class="headerlink" title="中策"></a>中策</h1><h2 id="nova-luna"><a href="#nova-luna" class="headerlink" title="nova luna"></a>nova luna</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/467b6f03dbb8381509e411b5d497b1c.jpg"></p><p>乌老师的拼图小游戏，打出combo的感觉相当爽，而且长得也好看，玩！</p><h2 id="太空基地"><a href="#太空基地" class="headerlink" title="太空基地"></a>太空基地</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/a6e8475281daefb8dda6f6ca11a5c66.jpg"></p><p>这个游戏线下开了一把之后就完全沉迷于在bga玩了，总共打了一百三十多把，虐过各种老外，也见识了各种套路，这个游戏好玩的地方在于刷分套路相当多，你可以走速推流，可以走换家流，可以走大大大流……当投资扔到自己重仓的区域的时候的爽感真是不可描述的，当然陈医经常说垃圾运气游戏哈哈哈。</p><p>附上一份大佬记录的套路图：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/3e9c61e5120d155e8cfaa4fc863f3b25_.png"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/b7fa3113e7527e41614bd40f9f4358f2_.png"></div></div></div><h2 id="诡镇奇谈"><a href="#诡镇奇谈" class="headerlink" title="诡镇奇谈"></a>诡镇奇谈</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/bc9bdac0a8080fdd402c91944036de3.jpg"><br>买了许久的诡镇奇谈终于开起来了！其实来我们基本不怎么玩美式，一是因为美式都太贵，二是很少玩合作类型的游戏，打了一个教学本和一个普通本，一开始直接不怕死地选择了困难难度，直接被虐的死去活来，升级卡组之后我们直接教邪神做人，我有预感这个游戏我们会开很久，出了八个扩展呢，慢慢玩！有一段话很喜欢，摘录如下：</p><blockquote><p>一个AHLCG玩家应该具备克苏鲁精神。就是作为一个普通人，在无情命运和残酷现实的压迫下，如何努力挣扎求生，打好自己的一手烂牌，最后坦然的面对不可名状的恐怖力量。<br>这个游戏的主基调就是残酷，这和让玩家开无双虐怪的游戏不同，玩家在游玩过程中不必刻意追求卡组强度，阵容搭配和完美结局,每个人不可能出生就是五边形战士，不可能在做出错误决定后让时间倒流，世界上也不存在完美结局。无所畏惧地向前，谱写自己独特的故事才是这个游戏的精髓。</p></blockquote><h1 id="重策"><a href="#重策" class="headerlink" title="重策"></a>重策</h1><h2 id="沙丘"><a href="#沙丘" class="headerlink" title="沙丘"></a>沙丘</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/6768c1ea0b2576a497c4354c36b0607.jpg" alt="五一回家前在kfc的最后一把沙丘"></p><p>工放dbg游戏，唯一的缺点就是阴谋牌和能力牌的收益方差实在太大（尤其是阴谋牌），所以有点过于看运气，于是陈医破防了说再也不开了哈哈哈。</p><h2 id="电力公司"><a href="#电力公司" class="headerlink" title="电力公司"></a>电力公司</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/4cce774e967d330906c7d2899abf750.jpg"></p><p>经典德式！印象中开了好多次，融合了抢点，拍卖，路径规划以及资源循环多种机制的扎实老德式，这个游戏最奇妙的一点是胜利条件不是看谁的电厂多或者是钱多资源多，而是终局结束那一回合的发电数量多少，相当有意思的设计，今年大概开了三四把，好玩。</p><h2 id="勃艮第城堡"><a href="#勃艮第城堡" class="headerlink" title="勃艮第城堡"></a>勃艮第城堡</h2><p>五一的时候去桌游店学会了，就深深地爱上了这款游戏，和太空基地一样，也是骰驱的策略游戏，不过勃艮第的可控性更强一点，这个游戏的精髓就在于你不可能每一样都做好，并且要做好抗风险能力，掌控运气的感觉，相当令人着迷。</p><p>这个游戏也是在bga上玩了好多把，很搞笑的一件事，一个大佬经常在群里分享勃艮第的胜利截图，然后配上一句险胜。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/6e21b6d7977360ef9ff905cdd96de58.jpg" alt="“险胜”"></p><h2 id="领国者"><a href="#领国者" class="headerlink" title="领国者"></a>领国者</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/40b76647337df332062c23ce9ecba82.jpg"></p><p>领国者，与其说是游戏不如说是宏观经济模拟器，完全可以用作教材的一个桌游，据说作者为了设计好这个桌游专门去修了政治学和经济学的硕士，佩服佩服。</p><p>游戏生动形象地刻画了每个阶层的生活轨迹：</p><p>劳动阶级好好打工，建立工会，保证自己的失业率不要过高，满足基本的生存需求并尽量使自己的民众富足，对剥削表达抗议、罢工、示威，参与议题，向共产主义靠近。</p><p>中产阶级中庸而立，左右逢源，需要平衡各方势力与各项政策，潜心发展。事业上既要有自给自足的小微产业，还要兢兢业业给资本主义和国企打工。力求最终过上自给自足的小资生活。</p><p>资本阶级则要努力扩大自己的产业，崇尚自由贸易，生产货物即可出口也可内需。扩大开放，降低赋税，降低人力成本，利润最大化永远是资本追逐的目标。</p><p>政府像一个束手无措的家长，施展各项政策，平衡各方势力，救济、补助、控制、影响，通过宏观的调控努力维持这国家这艘大船颤颤悠悠的前进。</p><p>游戏相当复杂，主要体现在不对称的差异化以及每轮面临茫茫多的选择与关联。相当于每个人都要学习自己的一套规则，意味着你换一个角色就是一套全新的玩法。开荒局的时候，读规setup就用了两小时，第一轮又打了两个小时，打了三轮直接掀桌了，期待某天能重新开完这个游戏。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>篇幅所限还有很多想推荐的就不写了：比如榴莲，眠羊时间，农场主玩了这么久桌游，也逐渐摸清了自己的喜好，喜欢那些有互动性能开起来的游戏，喜欢让大家都有参与感的游戏，喜欢能让大家欢声笑语的游戏拒绝。</p><p>翻着一张张桌游的照片，总能精准地回忆起每一次玩的场景，甚至是局势的走向，快乐的记忆总是这么的鲜明，因为玩桌游的时间总是那么宝贵，能一起玩桌游的同伴更是难得，再次感恩陪伴我这一整年的好朋友们。</p><p>其实公司也有桌游局，但是我基本不怎么去，或许我不是喜欢桌游，而是喜欢和好朋友们玩桌游，感谢每一个愿意听我讲规则，愿意学规则，愿意陪我村陪我破防的朋友们，明年我们继续快乐地桌游！！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>名侦探的牺牲读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%90%8D%E4%BE%A6%E6%8E%A2%E7%9A%84%E7%89%BA%E7%89%B2/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%90%8D%E4%BE%A6%E6%8E%A2%E7%9A%84%E7%89%BA%E7%89%B2/</url>
    
    <content type="html"><![CDATA[<hr><ul><li>若被人要求给养殖场出资十万，一般人不会突然掏钱。但是当被问及是出资一百万还是出资十万的时候，对方就会不可思议地感觉拿出十万也没什么大不了的。其实还有一个选项，那就是不出资，却隐没在两个选项中间无法看见。</li><li>“当信仰和现实发生抵触之时，信徒就会创造新的解释来解消抵触，通过进一步扩大活动来证明其正确性。从结果上看，信仰反倒得到了加强。如果要解释的话应该就是这么回事。</li><li>米勒派和塞德拉修女集团有一个共通点，那就是无论哪一边的信徒，都走投无路无法退缩。他们放弃了日常生活，抛弃私产，在世人异样的目光下等待语言化为现实的那一刻。事到如今再也无法回头的状况，令他们的信仰超越了现实。”</li><li>“起初就说过了，我是站在你们的立场上做的推理，在有奇迹的前提下查明凶手。也就是说，这是信教者的推理。但不巧的是，我并不相信你们的上帝，</li><li>比如看守富兰克林·帕尔泰坚信自己被切断的双腿已经恢复如初，但事实上只是固定着两根套着裤子的棍子，并没有长出脚。于是就产生出了自我感觉可以自由移动，但事实上没有轮椅就动弹不得的矛盾。为了让这一矛盾得到合理的解释，富兰克林便对轮椅萌生了强烈的依恋，誓言要与其长相厮守一直到死。干部们也给了他分配了不用腿的工作，看起来就是在配合他的解释。当然了，富兰克林和干部们都没有寻找解释的自觉。”</li><li>四年来，这个少年直面过去，思考的所有的可能性，自己则在空白的世界浪费了同样的时间，怎么可能和他平起平坐地交锋呢。</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大医读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%8C%BB/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A4%A7%E5%8C%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="上册"><a href="#上册" class="headerlink" title="上册"></a>上册</h1><ul><li>若要救人，非得红十字会前来营救；若要红十字前来营救，非得俄国人认可其身份；若要俄国人认可其身份，得先让大清加入万国红十字会……一群卑微平民的命运，在层层推动之下，竟奇妙地与国际局势牵连到了一块，这已完全超出了这个乡村少年的理解范围。</li><li>中国人所谓的活着，并不只是个人的追求与获得。”吴尚德在辽阳做了许多年医生，早洞悉了世情，“倘若这孩子现在抛弃父亲与乡亲离开，即使他还活着，他的灵魂也已经死了。</li><li>大大小小的事情，在地球每一个角落发生着。之前的旧因，正在落实为果；未来的果，此刻也正种下新因。因果涨落，缘数纠葛，无数人的抉择，汇聚成了一股不可抗拒的全球风暴。</li><li>姚英子忽然转过身来，背对着夕阳。飞旋飘散的乌黑长发，短暂地遮住了她精致的面孔，只有那一双清澈的眸子露在外面，映着半明半暗的云霞。最高明的画师，也调不出此时此刻她双眼中的颜色。</li><li>这一次因为皖北水灾，城里的行人明显变少，店铺也大部分上了门板，门口只留着一根拴驴桩子。其实敲敲门的话，店主全家多半还在，只是所有人都不举火烛，不发声响，像乌龟般缩在壳子里，巴望着灾难早点结束。</li><li>“凡大医治病，必当安神定志，无欲无求，先发大慈恻隐之心，誓愿普救含灵之苦。若有疾厄来求救者，不得问其贵贱贫富，长幼妍蚩，怨亲善友，华夷愚智，普同一等，皆如至亲之想，亦不得瞻前顾后，自虑吉凶，护惜身命。见彼苦恼，若己有之……如此可为苍生大医。”</li><li>张校长说过，她在广东搞医院时，发现农村的广大女性普遍思想蒙昧，满脑腐朽观念。与其跟她们说大道理，不如从最根本的活命权去启发。她们再愚昧，也希望能活下去，而想要活下去，不争取权利、不打破传统陋习是不可能的。</li></ul><h1 id="下册"><a href="#下册" class="headerlink" title="下册"></a>下册</h1><ul><li>这座寺庙就在徐家汇路北端，号称千年古刹，不过眼下的建筑是光绪七年（一八八一年）才重修完成的。寺前有一条英国人修的有轨电车道，可以直达外滩。孙希查了一下时刻表，下一班电车还有半个小时才来。他突然冒出一个古怪的念头：要不……我再去静安寺里求一个签？看看我抛下老方对不对。说来讽刺，人越是彷徨，往往越是迷信，他们会天真地寄希望于某种天启降临，将自己的抉择正当化。</li><li>原来……原来老方玩命似的打工赚钱，不是因为什么小气，而是因为他要养活整整一个村子的幸存者，要替父亲赎罪。霎时间，一幕幕景象浮现在孙希的脑海里：赶驴套车的方三响、收拾条凳的方三响、在食堂咸菜就米饭的方三响、一枚枚数着角洋的方三响。</li><li>盐谷忽然指了指自己胸口：“你知道吗？我的，是黑龙会的成员，北一辉先生的信徒。北先生常说，欲要日本革命，必先有中国革命的成功，然后推动整个亚洲天翻地覆，日本才有推展革命的土壤。所以我才以赤十字社成员的身份前来武昌，还有好多像我这样的日本人，以不同的身份参与到里面来。”</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绝叫读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%9D%E5%8F%AB/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%9D%E5%8F%AB/</url>
    
    <content type="html"><![CDATA[<hr><ul><li><p>结婚率下降，不婚族增加，再加上高龄化现象，社会构造的变化使得首都周边的卫星都市在不知不觉中转变为“孤独死之城”。这或许是意料中的结果，但负责善后的警察可头大了。</p></li><li><p>当时没有什么《两性工作平等法》，也没有内勤与外勤之分，许多女性都认为公司不过是另一种形式的联谊场所。至于以倒茶打杂为主的“工作”，也只是换个形式的新娘课程罢了。</p></li><li><p>如果真的幸福，根本不需要动不动就挂在嘴上；如果真的幸福，根本不会叹气，皮笑肉不笑的。她口中的“幸福”，隐藏着某种不安定的暗潮。</p></li><li><p>你的母亲、小纯的师长与同学，简直就是在共同创作一幅《小纯理想死亡图》。尽管小纯的成绩很好，却是个口无遮拦的讨厌鬼，不仅被霸凌，最后还赌气自杀——不，这不是他，他是聪明、前途一片光明的杰出人才，人缘极好，某日却出了车祸，英年早逝。</p></li><li><p>什么包容、社会福利，说得倒简单。秀才遇到兵，有理说不清。如果打打官腔敷衍了事，换来的就是当地住户的噩梦。怎么可以助纣为虐，叫无辜的邻居忍气吞声？真是岂有此理。</p></li><li><p>自行车是你唯一的交通工具，家乡就像狭小的金鱼缸，不论去哪里，你都无法摆脱这种窒息感。</p></li><li><p>说起来，凡人就是这么一回事。经历着酸甜苦辣，年复一年过着安稳的生活。</p></li><li><p>“没错。姐，你又不是自愿当爸爸和妈妈的小孩的，不是吗？我也是啊，相信爸爸和妈妈也是。就跟雨水只是从天上滴下来一样，没有人能选择自己生在哪里，而刚好生在同一个家庭的人就叫‘家人’，如此而已。”</p></li><li><p>不管山崎的外形多阴柔，他都是男性，离婚后可以马上再婚。</p></li><li><p>是铃木阳子的第二任丈夫河濑干男，根据车祸记录，撞死他的卡车司机叫新垣清彦。车祸发生七个月后，铃木阳子再婚，第三任新郎正是新垣清彦。车祸记录中备注的户籍一致，因此，司机跟新郎是同一人，而非同名同姓。新垣清彦与铃木阳子结婚后，依然逃不过被卡车撞死的命运。而撞死他的人，就是铃木阳子的第四任丈夫沼尻太一。也就是说，这些车祸的肇事者都与铃木阳子结婚，然后成为下一个被害人。她的最后一任丈夫沼尻太一死于八木德夫的车轮下，从户籍来看，这个人还活着。若将三起车祸记录对照来看，任谁都看得出案情不单纯，但三起车祸的事发地点为不同县市，分别由不同辖区的警员处理，导致至今没有任何人把这三起意外拿来比对。</p></li><li><p>我真是个超级大傻瓜。你觉得自己简直无药可救。那些原本深信地球是宇宙的中心，后来才发现地球竟然绕着太阳转的人，大概就是这种心境吧。</p></li><li><p>假结婚比一般人想象中简单多了。只凭区区一张健保卡，就能神不知鬼不觉地办理结婚手续，连当事者都不知情。</p></li><li><p>被大自然的力量玩弄于股掌带给你直觉上的恐惧，而想象自己被瓦砾压成肉酱则是精神上的恐惧。这两种恐惧使你的情绪异常亢奋。</p></li><li><p>不知是不是情绪太过亢奋的缘故，直到深夜你仍睡不着，而且觉得时间过得很慢，仿佛自己被全世界抛弃，独自品尝这孤单的夜晚。躺着躺着，你又开始觉得身体在摇摇晃晃，莫非身体还忘不了地震的感觉？你似乎看见日光灯在空中摆荡，墙壁在扭曲变形。世界并没有震动，而是你的世界受到了撼动。对，这里是我的世界，是独一无二、只属于我的世界。</p></li><li><p>“姐姐，你终于发现了。</p><p>”“是啊。”“其实，你大概很久以前就知道真相，只是现在才察觉。”</p><p>“小纯，你说得没错，一切都是自然现象。”</p><p>“是啊。”“无论是生死或是人心，一切都是冥冥中注定的，毫无道理可言。”</p><p>“是啊。”</p><p>“因此，没有一件事是我能做主的。如何诞生，如何生存，如何死亡，连一根头发落往何方，我都无法干涉。”</p><p>“是啊。”</p><p>“不仅无法做主，我也无法猜透。”</p><p>“面对世界上的任何事情，我们既无能又无知，因此，没有一件事情是有意义的。何谓美丑，何谓是非，都是人类擅自解读的，没有正确答案。”“是啊。”“换句话说……”你字斟句酌，寻找最贴切的字眼。如果世界上有神，假如他从天上看人间，大概是一条单行道吧。世界是自然现象的集合体，星球的运转轨迹早已注定，万事万物的结局也早已定案。没有分歧，没有选择，只是一条单行道，而人类就是在单行道上滚动的石头。</p><p>身为无知的人类，反而能逆转早已注定的命运。既然无法做主，无法预知任何结局，那就有无限的可能性。无知又无能为力，不就代表选哪个选项都没差别，因此选择范围无限大？“就是自由。”“是啊，姐姐，你是自由的。”自由。这就是你归纳出来的结论。人类这种自然现象的本质就是自由。人可以做任何事，也可以不做任何事。善恶好坏因果报应，都只是无意义的标签罢了。</p><p>“没错啊。姐姐，你很了解前因后果嘛。人不是通过战斗争取自由，而是人生来自由，所以才要战斗；人生来自由，所以才要活下去。姐姐，你能自由地活下去，自由死亡，自由战斗，自由放弃，所有的选项都在你面前，不必管法律与道德，想选什么就选什么。这是一个无法选择的世界，可是你拥有无限的选择。”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何完成你的第一个游戏</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="完成游戏"><a href="#完成游戏" class="headerlink" title="完成游戏"></a>完成游戏</h3><p><img src="http://www.derekyu.com/tumblr/finishgame01.jpg" alt="图片"></p><p>在我努力完成<a href="https://href.li/?http://spelunkyworld.com/">自己的游戏</a>时，我一直在思考如何完成项目。我注意到有很多才华横溢的开发者在完成游戏时遇到了困难。老实说，我在身后留下了一长串未完成的游戏……我想每个人都有这种情况。无论出于何种原因，并非每个项目都会成功。但是，如果您发现自己一直在退出具有很大潜力的游戏项目，那么可能值得退后一步并研究为什么会发生这种情况。</p><p>对于至少一款游戏、漫画书、电影等，我们都有过这样的感觉：“哎呀，我可以做得比这更好！这被高估了。” 但重要的是退后一步并意识到，嘿，他们投入了时间来完成一个项目，而我没有。这至少是他们可能比我更擅长的一件事，这可能就是他们得到我没有的认可的原因！如果您将完成视为一项技能，而不仅仅是过程中的一个步骤，那么您不仅可以承认这是您可以做得更好的事情，而且可以承认哪些习惯和思维过程会妨碍您。</p><p>我不相信有一种正确的方式来制作游戏。这是一项创造性的努力，所以没有什么硬性规定不能在某个时候被打破。但作为一个与其他游戏开发者讨论过这个问题的游戏开发者，我觉得我们在某些时候都会陷入一些心理陷阱，尤其是在我们刚开始的时候。意识到这些陷阱是完成某件事的重要第一步。（在你和我之间，编纂这些想法也是我掌握这些想法的部分方式！）</p><p>因此，事不宜迟，这里列出了完成游戏的 15 个技巧：</p><p><strong>1. 选择一个有潜力的想法</strong></p><p>**<img src="http://www.derekyu.com/tumblr/finishgame02.jpg" alt="图片"><br>**</p><p>我发现有三种类型的游戏能激起我的兴趣：我想制作的游戏、我想做的游戏和我擅长制作的游戏。</p><p><em>我想做</em>的游戏是过程本身看起来很有趣的游戏。也许这个机制看起来真的很有趣，或者也许有一个我真的想要动画的角色。</p><p><em>我想制作</em>的游戏是我对结果比达到目标更感兴趣的游戏。也许这是一个“无限制”的概念（“天啊，GTA 符合最终幻想符合星际争霸……”）或者只是一个实施起来不一定有趣的巧妙想法。</p><p><em>我擅长制作</em>的游戏是适合我的个性并且我有制作经验的游戏。也许有某种类型是你自然而然地被吸引的，并且你非常了解它的节奏和流程。</p><p>在我看来，最有潜力（至少要完成）的想法属于所有三个类别，并且也满足“我有时间和资源来实际制作”的要求。</p><p><strong>2.真正开始该死的游戏</strong></p><p>写下你的想法并不是开始该死的游戏。编写设计文档并不是开始该死的游戏。组建一个团队并不是开始该死的游戏。即使做图形或音乐也不是开始该死的游戏。“准备开始该死的游戏”与“开始该死的游戏”很容易混淆。请记住：该死的游戏可以玩，如果您没有创造可以玩的东西，那不是该死的游戏！</p><p>所以该死的，即使创建一个游戏引擎也不一定开始该死的游戏。这让我想到了下一个技巧……</p><p><strong>3. 如果不需要，不要使用自己的技术</strong></p><p>编写自己的引擎有利有弊。但是问问自己，你真的需要吗？你想做的事不可能用已经存在的东西去做，还是你会重新发明轮子？当然，如果您编写自己的引擎，您可以按照您喜欢的方式使其完美。但老实说，你多久会通过引擎进入游戏本身？您是否发现自己制作游戏引擎的频率高于制作游戏的频率？</p><p><a href="https://href.li/?http://www.yoyogames.com/make">我在Game Maker</a>中制作了 Spelunky 的原始版本，正是那个“完成”的游戏最终让我有机会在 Xbox 360 版本上工作。所以永远不要觉得游戏制作软件或其他简化工具在某种程度上是非法的。重要的是比赛。</p><p><strong>4. 原型</strong></p><p>这与＃2：原型首先与您可用的任何东西有关。有时你会立即发现这是一个坏主意。有时你会偶然发现一个更好的主意。无论哪种方式，在我真正开始做某事之前，我通常都很难弄清楚我想要做什么。所以做点什么吧！</p><p><strong>5. 确保核心机制是有趣的</strong></p><p>寻找有趣的核心机制。执行最基本的交互应该很有趣，因为这是玩家在玩游戏时会做的最多的事情。最终，您希望这个核心来推动您的发展。这将使您在以后必须删减部分游戏时更容易（#13）-您将始终拥有这个核心可以回退。</p><p>在进行原型设计时，您可能会发现一个比您最初认为的核心机制更有趣的机制 - 考虑将其作为新的核心机制！</p><p><strong>6. 选择好的合作伙伴（或尽可能独自工作）</strong></p><p><img src="http://www.derekyu.com/tumblr/finishgame02b.jpg" alt="图片"></p><p>找到一个好的游戏制作伙伴就像在很多方面约会。您可能认为最重要的是技能：“哦，酷，我是程序员，而这家伙是艺术家……让我们这样做吧！” 但是不，还有其他事情需要考虑，比如个性、经验、时机和共同利益。就像一段浪漫的关系一样，你不想处于一个你或另一个人都不那么专注的位置。用一些较小的项目互相测试一下，因为当一个关键人物在数月或数年的开发后退出时，这真的是毁灭性的。</p><p>完成项目的另一个好处是，您的合作伙伴会知道您的能力，并且会更自在地与您合作。很难说服任何有经验的人单独与你一起处理一个想法，考虑到很少有想法真正看到了曙光（以及在一些想法被执行之前很难看到它们的价值）。好的合作伙伴会希望看到您完成的游戏。所以完成他们！</p><p>或者，找到免费的图形和音乐在线使用，至少作为占位符（在 The Independent Gaming Source 我们举办了<a href="https://href.li/?http://www.derekyu.com/tigs/assemblee/">一场比赛</a>，其中创作了很多免费的艺术和音乐）。如果必须，请使用 ASCII。作为一名艺术家，我知道我更愿意为一个已经完成但缺少艺术的项目做出贡献。如果你需要一个编码器……考虑学习自己编码（如果我能做到，你也可以！）或者选择一些游戏制作软件（参见#3）。</p><p><strong>7. 研磨是正常的 - 将其纳入您的计划</strong></p><p>很多游戏制作都是乏味且毫无乐趣的。这不是玩，而是工作（这就是为什么当有人开玩笑说你“整天玩游戏”时，你应该让他们窒息）。在某些时候，你会突然意识到，当你计划你的项目和原型设计时，你从未想过这些东西——比如菜单、屏幕转换、保存和加载等等。我在想象我要创造的这个神奇的世界，或者我要试验的这个有趣的机制……我没想到我会花几周时间制作看起来不像垃圾的功能菜单！” 或者，你知道，有一些小剂量的东西很有趣，比如动画角色，当你意识到你已经为自己设置了 100 个不同的角色时，这会变成噩梦。</p><p>一旦你经历了几次，你就会意识到扩展你的项目是多么重要，这样你就不会在这个不可避免的泥潭中花费太多时间（“太多时间”是指在你退出之前需要多长时间). 你也会意识到很多无聊的东西是让游戏感觉完整的原因！例如，一个漂亮的标题屏幕可以让游戏感觉合法。</p><p><strong>8. 使用奖项、竞赛和其他活动作为真正的截止日期</strong></p><p>当 Alec 和我在<a href="https://href.li/?http://www.bit-blot.com/aquaria/">Aquaria</a>工作时，独立游戏节的提交截止日期迫使我们对所采取的方向做出艰难的决定，这也迫使我们更现实地看待我们的日程安排。如果我们没有那个最后期限，我不完全确定我们会完成！参加比赛非常棒，因为截止日期非常真实，而且奖励（认可、奖励、可能是金钱）非常真实。此外，他们可以为您提供一种与志同道合的人社区联系的方式。</p><p><em>链接：<a href="https://href.li/?http://igf.com/">独立游戏节</a>，<a href="https://href.li/?http://www.ludumdare.com/">Ludum Dare</a></em></p><p><strong>9. 向前推进</strong></p><p>感觉卡住了？向前推进。开始在下一个级别，下一个敌人，下一个任何东西上工作。它不仅有助于激励目的，而且您还想了解整个游戏将如何进行。就像写作一样——你不想一个接一个地读一遍，在继续之前确保每个句子都是完美的。把大纲画下来。</p><p><strong>10. 照顾好您的身心健康</strong></p><p>**<img src="http://www.derekyu.com/tumblr/finishgame03.jpg" alt="图片"><br>**</p><p>当您专注于完成比赛时，照顾自己可能会非常困难。但老实说，不睡觉、不锻炼或不正确饮食只会对你的游戏造成伤害。充其量，你正在阻止自己充分发挥自己的潜力，并让你更有可能退出。对你的项目有一些怀疑是很自然的，但抑郁或生病则不然。当您的身心感觉像垃圾时，您会多么不想为您的梦想项目工作，这真是令人惊讶！</p><p><strong>11.停止为重新开始找借口</strong></p><p>**<img src="http://www.derekyu.com/tumblr/finishgame04.jpg" alt="图片"><br>**</p><p><em>“我的代码一团糟。而且我已经学到了很多。如果我重新开始，我可以做得更好更快，然后比赛的其余部分也会更快！”</em></p><p>停止。不。在每款游戏的开发过程中的某些时候都是如此。你的代码总是一团糟。你会学到很多东西。它永远不会是完美的。如果你从头开始，当你再次到达这一点时，你会发现自己处于完全相同的境地。这样想是一个可怕的陷阱。</p><p>开个玩笑：一个人一生都在研究一个如此完美的游戏引擎，他所要做的就是按下一个按钮，完美的游戏就会诞生。其实，这不是什么玩笑，因为妙语是他永远不会完成它！不存在这样的引擎或游戏。</p><p>如果糟糕的组织真的让你慢下来，回去做一些手术，让你感觉更好。如果它有效但它有点hacky，那么勇敢并继续前进！</p><p><strong>12. 为下一场比赛保存它</strong></p><p>所以在开发的过程中，你有一个很棒的新想法，它会让每个人都大吃一惊，但你必须重做整个游戏来实现它？为下一场比赛保存它！正确的？希望这不会是你制作的最后一款游戏。把它留到下一个……但先完成这个！</p><p><strong>13. 剪裁。它。出去。</strong></p><p><img src="http://www.derekyu.com/tumblr/finishgame05.jpg" alt="图片"></p><p>哎呀，你的进度太落后了。你有所有这些想法，但它们会在你有机会实施其中一半之前殖民火星。哦，不幸的是你……但是等等！</p><p>嗯，这很棒，事实上！因为现在你被迫决定什么对你的游戏真正重要，以及你可以削减什么。事实是，如果我们都有无限的资源和无限的时间，我们都会做出同样的糟糕，曲折一切游戏，根本没有理由玩。是我们有限的资源和时间迫使我们制作紧凑的游戏，感觉它们有目的。</p><p>如果您一直在构建一些可证明很有趣的核心概念，请继续削减，直到您到达该核心的最边缘。其他一切可能只是你可以没有的绒毛。或者更糟的是，是绒毛阻止人们看到你游戏中最好的部分。</p><p><strong>14. 如果你退出了，缩小规模，而不是扩大规模</strong></p><p>好吧，有时是时候叫它退出了。也许你永远无法完成，而你所拥有的东西太大了，无法删除任何东西。也许你团队的其他成员已经退出了。我写这份清单的希望是帮助人们避免这种可能性，但是，嘿，也许你刚刚从这样的项目中走出来。有时……狗屎就发生了。</p><p>如果无法挽救它，至少要确保缩小下一个项目的规模。即使您的项目完成得越来越少，也很容易将您的目标设定得越来越高。“我的技能在进步！我正在从失败中吸取教训，”这是一个常见的借口。但我认为这就是为什么将完成作为一项技能也很重要的原因。</p><p>所以再往下，往下，往下，再往下，你甚至会发现它在你的下方。例如，与其从 4x 太空模拟跳到 4x 太空模拟 IN 3D，不如尝试制作一款专注于太空模拟的一个小元素的出色游戏。如果你做不到，试试小行星之类的东西。很有可能它最终仍然会是一场比你想象的更大的斗争（和&#x2F;或比你想象的更有趣）！</p><p><strong>15. 最后 10%</strong></p><p>他们说最后 10% 真的是 90%，这是有道理的。最终需要很长时间的细节。当然，也许你在一周内编写了一个称职的战斗系统……但是让它变得很棒并使它变得复杂（并且没有错误）……这些事情可能需要几个月的时间。诚实的事实是，在您到达真正的最后一圈之前，您可能会进行多次“最后一圈”冲刺。</p><p>如果这听起来令人沮丧，那不应该。虽然最后 10% 令人痛苦，但我也发现这是开发过程中非常令人满意的时刻。因为通常情况下，如果你一直在适当地度过你的时间，那么事情最终似乎真的会“聚集在一起”，将一堆杂乱无章的想法和内容变成甜蜜的游戏甘露是一种神奇的感觉。</p><p>这都是关于细节的。</p><p><strong>最后……释放！</strong></p><p><img src="http://www.derekyu.com/tumblr/finishgame06.jpg" alt="图片"></p><p>废话，你发布了一个游戏！恭喜，你刚刚升级了，很重要。好处包括：增加信心，能够完成项目的声誉，以及对游戏创作整个过程的理解！不过，最好的部分是你有一个不错的小游戏，我可以玩和享受！我确实喜欢玩游戏，几乎就像我喜欢制作它们一样。</p><p>不要再站在场边，朋友：你是一个游戏开发者。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOOM启示录</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/DOOM%E5%90%AF%E7%A4%BA%E5%BD%95/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/DOOM%E5%90%AF%E7%A4%BA%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li><p>作为年轻一代，卡马克和罗梅洛是“美国梦”的样板：他们是自我塑造的个体，他们用自己的 热情点燃了一种新的艺术形式、一种文化现象，并在商业上获得巨大成功。他们的经历使他 们成为叛逆的偶像，他们既是计算机黑客，同时也名列《财富》杂志（Fortune）评选的 500 佳企业管理者；他们被誉为游戏界的列侬（Lennon）和麦卡特尼（McCartney），尽管他们 更乐于被看做金属乐队（Metallica）。他们在少年时逃出他们各自破碎的家庭，制作出了历史上最有影响力的游戏，最终，也正是这些游戏，使得他们分道扬镳。而在接下来的几分钟 里，在作别多年之后，他们又要一起出现在玩家们的面前了。 </p></li><li><p>可以发现，卡马克的成功是因为技术，从卷轴技术到3d设计，他出色的完成了图形学游戏引擎的部分，然而游戏设计的部分，前者灵感来源于马里奥，后者做了一个经典2D游戏的3D版，这在当时是一个质一般的飞跃，然而如今想要有技术上的打动似乎很难，更要追求玩法和创意了。</p></li><li><p>死一般的寂静，没有人能接受这样的结果：这个游戏，这个在什里夫波特湖畔小屋里制造出无数欢声笑语的游戏，这个在麦迪逊陪伴他们度过一个个寒冷冬夜的游戏，就这么结束了？悲伤笼罩着房间的每一个角落。最终，罗梅洛开口对卡马克说道： “靠，那么好玩的游戏，就这么毁掉了？有什么办法能继续吗？ ”他其实知道这个问题的答案，卡马克是个实事求是的人，他的游戏也一样，他回答道： “没有，都结束了。 ”  </p></li><li><p>“你这份 Doom 圣经对我们完成这个游戏没有帮助， ”卡马克告诉汤姆， id 从来没有写过什么设计文档，为什么现在要开始写这玩意？ Doom 不需要背景故事，它是一个关于追逐和战斗的游戏，只要让玩家随时觉得紧张刺激就好，玩家不需要知道屏幕上正在发生的这一切都是为什么。卡马克建议汤姆不要再为那文档操心，而应该像罗梅洛一样来体验新的引擎， “我还在做各种技术尝试，但是，请先体验一下现有的东西，再去考虑我们究竟能用它来做什么。”他还建议汤姆去图书馆翻翻关于军事基地的书，找找灵感。</p></li><li><p>罗梅洛同意卡马克的建议，尽管他非常欣赏汤姆的文档，但一个由故事驱动的游戏显然不适合卡马克的引擎，在那个世界里没人会有空坐下来打牌， Doom 和《德军总部 3D》一样，也是个快节奏的杀戮游戏，只是， Doom 要比《德军总部 3D》更快，更血腥。汤姆彻底放弃了在游戏里加入情节的念头，而另有一段情节即将在现实中发生。类似卡马克对待程序那样的思想模式——创新、优化、挪开所有绊脚石——已在 id 短暂的历史里不断闪现：在游戏中，《基恩》因为《德军总部 3D》而被摒弃，地板和天花板因为性能而被去除，在生活中，艾尔、斯科特、甚至咪子，一一成为了这种模式的牺牲品。没有人知道谁会成为下一个。  </p></li><li><p>政客和卫道士们总是试图拯救下一代于水火之中，尽管他们不一定理解年轻人的文化，但这并不妨碍他们运用他们所把持的话语权和立法权。早在美国内战结束时，宗教领袖们就把艳情小说指为： “撒旦门下最能干的爪牙，它们毒害年轻人的心灵，以扩张它们邪恶的领地。 ”进入二十世纪后，电视和电影又成为了新的标靶，针对这些全新媒介的调查研究一连持续了几十年。五十年代，电视上的猫王（Elvis Aron Presley）只能出现上半身，《MAD》杂志的创办者威廉·盖恩斯（William Gaines）被国会传唤。七十年代，龙与地下城里的魔鬼与巫术被和撒旦崇拜（Satanism）联系到一起，尤其是在密歇根湖事件发生后，反对的声音更是一浪高过一浪。八十年代，重金属文艺工作者“犹大牧师”和“Ozzy Osbourne”被指控为教唆年轻听众自杀。九十年代，电子游戏成了新的“乐与怒”，也成了卫道士们心中更强烈、更无法抑制的痛。  </p></li><li><p>这种敌视心理可以上溯至三十年代，那时的弹球厅一贯被视做是地痞流氓聚集的地方。纽约市长 Fiorello La Guardia 为此颁布了禁令，直到七十年代中期方才解除。接着被取缔的就是《死亡飞车》，这款碾压屏幕上像素点的游戏一度成为报纸头条。八十年代初是电子娱乐业的黄金时代，它的总产值达到六十亿美元。随着电子游戏的日益普及，一些人心中的担心也开始疯长，他们觉得这些游戏对孩子们有潜在的不良影响。</p></li><li><p>1982 年，家庭－教师协会（PTA）发布了一份谴责街机游戏的声明： “遍地开花的电子游戏厅对经常光顾那里的年轻人是有害的，我们对此非常担心……初步调查表明，这些乌烟瘴气的场所大都集中在学校附近，许多游戏厅并不限制学生们在上课时间出入其中，这无疑是旷课和逃学的诱因。在这些几乎不受监管的场所，贩毒、吸毒、酗酒、赌博、帮派活动，以及其他不良行为得以孳生。 ”</p></li><li><p>一些城市，譬如德克萨斯州的麦斯奎特、伊利诺斯州的布拉得利、乔治亚州的斯乃尔维尔，开始限制或是取缔街机厅。 1982 年，布拉得利的市长看到“几百个青少年聚集在街机厅里抽大麻”，他随后得出结论： “孩子们把书费、午餐费，以及每一个能弄到的硬币都投进了那些花花绿绿的机器。 ”尽管美国最高法院驳回了麦斯奎特市试图取缔电子游戏的起诉，但其他国家，譬如马来西亚、新加坡、印度尼西亚，不光颁布了电子游戏的禁令，还强制关闭了街机厅。  </p></li><li><p>学校、企业、政府机关这些配备有计算机的地方现在都装上了调制解调器，也就是这些地方，有着许多懂得如何使用这些设备的人，他们无一例外被卷入了 Doom 狂潮。就在那个周末，大量的下载和玩家之间的对战导致因特网出现了前所未有的拥塞。玩家们争先恐后地连入美国在线。 “那天晚上就像是一场暴动， ”美国在线的游戏板块负责人德比·罗杰斯（ Debbie Rogers）回忆道： “要不是中间隔着电话线，我肯定都被这些疯狂的人们踩扁了。 ”</p></li><li><p>Doom 发布后几小时，卡内基梅隆大学（Carnegie-Mellon’s）的计算机系统管理员发布了一份在线通知： “自从今天 Doom 发布后，学校的网络就出现了异常情况，经过分析，我们认为是这款游戏导致了网络过载……校方请所有 Doom 玩家们不要进行对战，那样会给网络带来很大流量，我们校园网的负载已经接近极限。我们可能会强行断开进行 Doom 对战的机器。再重复一遍：玩 Doom 时切勿使用对战模式。 ”</p></li><li><p>英特尔（Intel）公司在发现网络异常后立刻禁止员工在公司运行 Doom。德克萨斯 A&amp;M 公司把网络服务器上的 Doom 全部删除。路易斯维尔大学的机房管理员为了解决 Doom 带来的困扰甚至专门写了个软件，他介绍说： “学生们为了玩这个游戏在机房外排起长队，于是我们写了一个小程序，它会遍历每一台机器，并删除之上的 Doom。  </p></li><li><p>他们注意到，《德军总部 3D》的模式制作是完全替换游戏本身的资源文件，譬如把纳粹的图片换成巴尼的图片，如果玩家想再换回到纳粹，就相当麻烦。于是，在 Doom 中，卡马克进一步抽象了引擎和数据文件之间的关系，他专门制作了一个资源管理子系统，把数据都放到所谓的 WAD 包中，这个名词是汤姆的点子，意为：数据都在哪？（Where’s All the Data?），从而，在每次主程序启动时，它载入的是一个包含了所有图片和音乐的 WAD 文件，这样，玩家就可以每次指定不同的 WAD 文件让引擎使用，而不必再像《德军总部 3D》那样麻烦地备份和恢复数据。</p></li><li><p>此外，卡马克还公布了 Doom 关卡编辑器和其他辅助工具的源代码，以便玩家们定制自己的游戏。这不光在游戏领域是个非常激进的做法，就任何形式的媒介而言，它都算得上前卫。这就像是涅槃乐队的唱片里附带了工具以便让你用自己的声音替换科特·科本（ Kurt Cobain），或是《洛奇》（Rocky）录像带允许你把费城的街景换成中世纪的日本。以前也有游戏发布过关卡编辑器，但还没有哪个公司的程序员——更不要说是老板本人——公开过如<br>此核心的技术。尽管卡马克暂时没有放出引擎本身的源代码，但他提供给玩家们的工具已足以让他们对游戏进行彻底修改。这不只是慷慨大方，这关乎世界观——这体现了自由主义里授权予民从而削弱垄断控制的思想。卡马克已不再是那个在堪萨斯城家中向往着黑客文化的孩子了，二十三岁的他现在是一个百万美元公司的所有者，他可以做任何他想做的事，他可以身体力行地去铸就黒客文化的辉煌。</p></li><li><p>“DeHackEd 可以彻底颠覆 Doom 的玩法， ”刘易斯在文档里写道： “譬如使火球隐形、使火箭弹的伤害增加到 2000 点、使怪物们漂浮在空中、使你那水深火热中的太空战士拥有无限弹药，它还可以在游戏里加入全新物品，譬如离子地雷、超级连发武器、极速火箭，这样你就可以设计出全新的死亡竞赛规则，而且你可以把这些改动都放到一个补丁文件里发给朋友，WAD 开发者们可以在关卡里加入新的怪物……一切的一切。 ”</p></li><li><p>这些黒客工具使游戏的“沉浸感”有了新的含义。 Doom 本身已使玩家沉浸于快节奏的三维世界，沉浸于可以互相对抗的死亡竞赛；而黒客工具则使他们沉浸于创作的乐趣，当玩家先勾画出整个世界的蓝图，然后设计出各种生命形态、并定义出这世界的物理规则时，他其实是在扮演上帝的角色。玩家们开始在因特网上互相免费交换自己创造的世界，这些因为死亡竞赛而离开课堂的玩家们现在找到了新的嗜好：创作。他们不分昼夜地忙碌，他们甚至赤膊上阵：泰勒大学的一些玩家定期举办“天体创作营”，在那期间，他们一个个都扒得精光坐在计算机面前。 Doom 不止是一个游戏，它是一种文化。  </p></li><li><p>罗梅洛自有解释：慢工出细活，他在每一个关卡上都花了大量的时间。但卡马克怀疑另有原因：罗梅洛失去了他的专注。除了那些访谈和死亡竞赛外，罗梅洛现在还是 Raven 公司下一个游戏的监制。他曾经告诉卡马克，他要把引擎的经济效益发挥到极致： “我们用这技术多做几个游戏吧，那样可以赚到更多的钱，把引擎授权给 Raven，他们很棒，他们肯定可以制作出精彩的游戏，然后我们来发行。 ”卡马克同意了，却毫不热心：要把公司做到多大才<br>算够？但罗梅洛不只是为了把公司做大，他还有其他动机——乐趣。罗梅洛热爱游戏，他活着就是为了玩游戏，而他现在找不到比 Doom 更好玩的游戏了，和 Raven 的合作将给他带来新的游戏。这天晚上，在卡马克的办公室里，罗梅洛向卡马克描绘了 id 的新生活：该是享受成功的时候了，不再有压榨模式，不再有加班熬夜， “不再有死亡进度。 ”他开心地说。</p></li><li><p>卡马克看着屏幕上闪烁的光标，一言不发。曾经有多少夜晚，罗梅洛就坐在他身边，和他一起完善引擎，和他一起调试排错，直到东方渐白；今夜，卡马克目送那印有“制作者”的背影消失在门口。  </p></li><li><p>而卡马克很快就意识到，他所面临的挑战远比他所预料的艰难。他的目标是创造因特网上的真三维世界，项目之初，他和往常一样收集和阅读了大量的研究资料，他花了几千美元购买书籍和论文，但所有这些都只是纸上谈兵的东西，还从未有过计算机程序可以模拟出一个交互的、实时的、快速的、真三维的游戏世界，要实现这样的虚拟体验，不光要耗尽他的才能，还要榨干当前 PC 机的性能。更糟的是，在这紧要关头，卡马克发现，他一直以来的战友，罗梅洛，不见了踪影。  </p></li><li><p>卡马克厌恶那种貌似先哲圣贤般的夸夸其谈，但如果你一定坚持，他也会聊聊他的想法。 “在信息时代，客观障碍已不复存在， ”他说： “所谓障碍都是主观上的。如果你想动手开发什么全新的技术，你不需要几百万美元的资金，你只需要在冰箱里放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。我们在地板上睡过，我们从河水中趟过。 ”</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何向混蛋解释你的游戏</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%90%91%E6%B7%B7%E8%9B%8B%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E5%90%91%E6%B7%B7%E8%9B%8B%E8%A7%A3%E9%87%8A%E4%BD%A0%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>解释你的游戏的第一个坏方法是根本不解释它。</strong>人们经常放出一些原始镜头或屏幕截图，让它自己说话。</p><p>问题是事实并非如此。如果您知道它说的是什么，它可能不言而喻，但您无法想象它对其他人来说意义不大。有时我们甚至无法判断您控制的是哪个<em>东西</em>。</p><p><strong>第二个错误是认为要解释你的游戏，你应该解释你的艺术意图。</strong></p><p>所以你可以将其描述为“关于损失的游戏”。</p><p>好的，但这他妈的是什么<em>意思？</em>据我所知，Off-Road Velociraptor Safari 可能是关于损失的。我认为瓷器店里的牛头怪确实是。</p><p>但是你的信息、你的主题和你的艺术意图并没有告诉我任何关于我如何玩这个游戏或者我可以在其中做些什么有趣或不同的事情。</p><p><strong>第三个错误是认为解释你的故事就解释了你的游戏。</strong>“暗日之民正受到远古诸神的威胁……”</p><p>除了创造“Darksun”这个词的人之外，没人在乎 Darksun 的人。我相信你的故事很好，我相信它对你的游戏很重要，但它不会用十个字来表达。如果你写的超过十个字，就没有人会看。</p><p><strong>错误四：</strong>说你的游戏很好，好像这会让我们相信它是好的。</p><p>从来没有人读过开发者将他们的游戏描述为“创新”并认为“哇，这听起来很创新。”</p><p>我们读过开发者将他们的游戏描述为创新和想法，“哇，它们听起来像一个工具。”</p><p>这些都是行不通的方法。那么你如何向像我这样不耐烦的混蛋解释一些微妙而酷的东西呢？</p><p>您必须以简单明了的语言非常快地切入要点。</p><p>事实上，你必须在大约三句话中说到四点，否则我们就停止阅读。</p><p><strong>第一点是告诉我们这是什么类型的游戏。</strong></p><p>您不必拘泥于传统类型，而是尝试使用能够反映您在游戏中实际所做的事情的词。也许它不是平台游戏，而是“2D 探索游戏”。</p><p><strong>第二点，在你说完第一句话之前，告诉我们它最酷的独特之处。</strong></p><p>你可以<em>彻底</em>总结。我们不需要知道它<em>是如何</em>工作的，但我们想知道它为什么酷。</p><p>我游戏中的主要机制很难用八个词来解释，但如果我说“你可以重新设计它的关卡来欺骗人们”，你就会明白了。</p><p><strong>第三点是给我们一些背景信息</strong>：我是谁，我在哪里，我想做什么？</p><p>情节永远不会用十个词来形容，但幻想可能。你是间谍？你是神吗？你在救小猫？你是猫神拯救间谍？所有这些都很酷。</p><p>到那时我们应该有一个概览，但它可能有点枯燥。<strong>所以第四点是给我们一个例子来说明它是如何发挥作用的。</strong></p><p>描述一个玩家可以体验到的典型游戏时刻，并说明您刚才告诉我们的最佳内容。</p><p>如果你说这是一个关于控制你的敌人的游戏，我很感兴趣。但如果你告诉我，我可以附身一个敌人，把他扔到一个朋友身上，然后在我变回自己的身体看着他们爆炸之前把他们俩都撞到地雷里——我就完蛋了。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我们可能不只是旁观者--《大空头》影评</title>
    <link href="/%E5%BD%B1%E8%AF%84/%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%97%81%E8%A7%82%E8%80%85--%E3%80%8A%E5%A4%A7%E7%A9%BA%E5%A4%B4%E3%80%8B%E5%BD%B1%E8%AF%84/"/>
    <url>/%E5%BD%B1%E8%AF%84/%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%97%81%E8%A7%82%E8%80%85--%E3%80%8A%E5%A4%A7%E7%A9%BA%E5%A4%B4%E3%80%8B%E5%BD%B1%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2283531871.webp" alt="The Big Short"></p><p>刚看电影的时候，被各种做空次级贷款浮动利率等名词弄的一头雾水，最后一步一步知道杠杆这么大的时候也确实给了我一种被华尔街黑心金融骗子用包装的名词欺骗的感觉。</p><p>影片用三组性格各异的主角并行讲述，一个是孤芳自傲的freek，宅男，不穿鞋，边听着摇滚乐边打着空气鼓边思考着数学模型，最先发现的泡沫的产生，义无反顾地在没有任何人相信的基础下选择了做空房地产。</p><p>一个是经验老道的基金管理人，有些神经质，对一切充满着愤怒，抱怨憎恶着充斥着欺骗和不公的金融系统，但又用工作麻痹着自己，在经过各种实地调查之后，逐渐发现整个金融系统是如此的不可靠。</p><p>一组是刚刚进入投资界的小年轻，他们偶然间看到了最空房地产的小册子，自以为抓住了绝佳的投机机会，满头热血地冲了进去。</p><p>他们的共同点是都或多或少地对反人性的金融系统产生质疑，最开始的一个震撼我的地方是，两个小年轻自以为聪明的做成了一笔大生意，手舞足蹈，这时候ben略带愤怒的训斥了他们，“你们刚才是在和美国经济对赌，也就是说要是我们对了，人们就会无家可归，人们会失去工作，人们会失去退休存款，人们会失去养老金，你们知道我最讨厌银行业什么吗？它把人变成了数字，这里有个数据我告诉你们，失业率没上升百分之一，就会四万人死亡，你们知道吗？”</p><p>从这里开始，整个影片的格调就变了，我仿佛从一个自以为很聪明的旁观者视角变成了灾难中的一员，从这三个赚的盆满钵满的幸运儿变成了那个租着房子的大叔，他刚刚搞定孩子的学校，按时交房租，却被告知自己的房东已经几个月没交贷款了，只能无助地离开。</p><p>其实现在又何尝不是呢，我们都以为自己会是旁观者，就是那个看穿一切的人，那很大概率我们只是普通人，那个为灾难埋单的一员。</p>]]></content>
    
    
    <categories>
      
      <category>影评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和衡水中学在一起的2557天</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%92%8C%E8%A1%A1%E6%B0%B4%E4%B8%AD%E5%AD%A6%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%842557%E5%A4%A9/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%92%8C%E8%A1%A1%E6%B0%B4%E4%B8%AD%E5%AD%A6%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%842557%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>晓宁最喜欢的是郭敬明和村上春树。这两者的共同点是提供一种幻想。读书让我俩产生一种匮乏感：生活恐怕不应当是眼前这样，至少土豆应当是削皮的。</p><p>我产生过一些疑虑。第一次集体大会，在辉煌的礼堂，全体起立喊口号。群情激昂之时，台上的老师问：你们的人生理想是什么？大声说出来！我没料到有这一环节，理想是多私密的东西啊。可是周围的人全都喊了起来：“清华！”“北大！”那一瞬间我感到疏离：为什么人生理想会是某一所大学呢？高考时才十八岁，人生不是有八十年吗？难道此后的人生都不作数吗？</p><p>几年之后，我才知道，原来不论我，郭靖宇，还是PPT男孩，都是“小镇做题家”“应试机器”“头脑死板的书呆子”。即便如此，我每次都很想问一问，你们也见过PPT做的蝴蝶翅膀吗？</p><p>衡中的假期很短，三周放一次，从前一天下午到第二天中午，时长约为20小时。我常常选择不回家，换上牛仔裤和T恤，洗个澡，偷偷搭上去城里的公交车（四十分钟一趟），在公交车上打开窗户吹湿头发，正大光明掏出MP3来听。为了避免错过末班车，在城里大概可以停留一两个小时，保留曲目是点上一桌子必胜客，撑到溢上喉咙，再买上两大包零食和一箱牛奶，漫无目的地走上半个钟头。有时候下雨，水泊和橱窗里倒映出我们的身影，道路呈现出一种坚硬的深蓝色，路上钉着的伸缩路障发亮，它们像一连串的眼睛一样一颗一颗盯着我们看。我们感觉从未如此自由，仿佛知晓一切，拥有一切。</p><p>如同从小到大成长的经历一样，我总会觉得前一阶段的痛苦是如此微不足道，甚至幼稚可笑。现在写下这些字，是想留给之后的自己。我想说，按照四维空间的理论，你和现在的我并非同一人，因此，请像体察旁人的痛苦一样体察现在的我吧，不要嘲笑，也不要轻而易举地认为是青春期问题的一种。我要说，此刻的痛苦是真实的。</p><p>刚读高三我还保留着周末读书的习惯，每次都是狼吞虎咽。可是有一次不小心在回家路上读完了一本恰克·帕拉尼克的书。接下来开学的整整一周，所有的情节、句子、主人公的动作，千方百计地钻到我脑子里。我感到恐惧，不敢再读书。情况好转了一些，有一段时间我几乎认为自己是“全心全意学习了”。我跟同桌总结道：我发现，走神、喝水、多花时间吃饭，这些都不可怕，逃课也不可怕。最可怕的就是读书，因为你会记住，还会回想。我同桌深以为然：最可怕的就是会一直想。</p><p>无法控制思想使我感到耻辱，只能在其他地方多下功夫，例如再把吃饭的时间压缩一分钟。有一次午饭的时候想吃泡面，开水倒进去，食堂的人几乎走光时，泡面还没有泡开。面汤是滚烫的，烫掉了一半舌苔；但面饼又是硬的，我几乎吞下去，方便面块在胃里翻滚时仍然保留着锋利棱角。我胃绞痛了整整一天。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对望的恒星</title>
    <link href="/%E4%B9%A6%E8%AF%84/%E5%AF%B9%E6%9C%9B%E7%9A%84%E6%81%92%E6%98%9F/"/>
    <url>/%E4%B9%A6%E8%AF%84/%E5%AF%B9%E6%9C%9B%E7%9A%84%E6%81%92%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<p>大刘的除了第一篇都看过，选的确实不错，前两篇大刘都是那种人类抗争外星人的戏码，一般般，中国太阳和山蛮有意思的，《山》真是点子文学的极致，中间这一篇都够写一篇小说了，主角前后的心态变化很有意思《中国太阳》少见的很有人文关怀；相较之下另外两位作家的软科幻占比更大，很多只是假借科幻来写一些其他东西。</p><p>先讲谢尔盖：《我的爸爸是抗生素》是反战，《如果您现在就下单》是讽刺那些盲目相信技术。我特别喜欢《买只猫吧》，讲了一个宅男在空间站和猫探讨爱情的故事，我特别喜欢这种末日或者孤独生存的戏码。</p><p>罗伯特的作品我特别喜欢《蜕去的外壳》这一篇，很有黑镜的感觉，探讨人和机器人的定义；《鹰舱已着陆》也很有意思，旁观者的角度冷静评判可笑的地球人；《手牌》这一篇点子很不错，但是很遗憾太短了，理论上来说基因决定命运这种事情可以写很多的，有一种赛博朋克的味道，但是很遗憾结束的太快了，而且结尾有些太仓促。</p>]]></content>
    
    
    <categories>
      
      <category>书评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>国王的游戏</title>
    <link href="/%E4%B9%A6%E8%AF%84/%E5%9B%BD%E7%8E%8B%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <url>/%E4%B9%A6%E8%AF%84/%E5%9B%BD%E7%8E%8B%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>就故事性和现实性来说我最喜欢塞洛西滨25，从一个决定平凡的人引出，然后一步一步地说出神奇的着相剂，对于寻找人生的月亮有一种神奇的解释，看的蛮上头；</p><p>和桌游相关的两篇：国王的游戏和A只是一个代号，没啥多大的意思，前者只是用了一点阿瓦隆的规则，后者没太看懂；</p><p>幻听音乐史蛮浪漫的，扫码听着读完的体验蛮好；</p><p>全语言透镜和赝人是蛮合格的短小的科幻故事，前者语言荒地的概念容易意思，后者是都市传说的感觉</p><p>明日方舟一看标题有点难绷，但其实和那个手游没啥关系，但是男主的性格的描写挺有意思，理解世界的方式很奇特，而且疫情非常有同感…不过最后结局有点好猜；</p><p>和平精英前面太无聊，最后是人机倒是有点惊喜。</p><p>这本集子给我带来的感受就是或许我也可以尝试写写桌游或者游戏的故事，不过我觉得有点不好把握度，很容易写成规则实录或者是同人作品，不太好利用游戏本身的内容来拓展出一个有意思的作品</p>]]></content>
    
    
    <categories>
      
      <category>书评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>overcook如何迫使你在游玩的过程中交流？</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/overcook%E5%A6%82%E4%BD%95%E8%BF%AB%E4%BD%BF%E4%BD%A0%E5%9C%A8%E6%B8%B8%E7%8E%A9%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BA%A4%E6%B5%81%EF%BC%9F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/overcook%E5%A6%82%E4%BD%95%E8%BF%AB%E4%BD%BF%E4%BD%A0%E5%9C%A8%E6%B8%B8%E7%8E%A9%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BA%A4%E6%B5%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>对称合作游戏</strong></p><p>不少合作游戏，多人玩的游戏难度会下降，比如合金装备，茶杯头，生化危机，但是联机的体验仿佛就是单机，因为两个主角的能力完全一样，体现合作只有在帮助队友复活或者一些简单的把他人推过墙壁这样的操作。</p><p><strong>三位一体</strong></p><p>类似三位一体，pico park这样的解密合作游戏，虽然非常不错，但是很容易陷入一控多的局面，某个比较聪明的玩家直接指挥其他人来游玩，其他玩家仿佛成了外置手，不过当然合作通关的体验很不错，这个在一些美式合作桌游中也很常见。</p><p><strong>启示录2</strong></p><p>给予玩家不同的能力，一个拿手电筒眩晕怪物一个开枪。</p><p><strong>保持通话不然就爆炸</strong></p><p>给予玩家不同的信息，不交流就无法通关。</p><p><strong>胡闹厨房</strong></p><p>因为人数是可变的，所以保证每个玩家都可以独立的完成做出一道菜，信息，能力都是一样的，但是通过关卡设计（隔断）和评分、效率要求，迫使玩家要沟通并且要做出分工。</p><p>但是完全的不对称合作很容易让玩家陷入单调的行为模式，甚至变得不需要沟通，但是overcook做了一些设计让你在游戏的过程中偏离你们最初的规划，变得非常混乱，比如<strong>计时器</strong>，迫使你离开工作岗位，别浪费时间，但可能是妨碍他人；<strong>灭火</strong>，迫使别人来收拾你的烂摊子；<strong>洗碗</strong>，这是一个不可预测的任务，所以没人会专门做，所以会打乱节奏，而且每次干净盘子用完，你们的生产流水线就会打乱，整个游戏的节奏就会变化；<strong>游戏关卡的阻碍</strong>，会动的菜板，风，老鼠，各种无法预测的东西会迫使你随即应变。</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计谜题的方式</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E8%B0%9C%E9%A2%98%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E8%B0%9C%E9%A2%98%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>随手记录翻译一下，原文链接如下：<a href="https://cwpat.me/misc/puzzle-level-idea-strategies/">https://cwpat.me/misc/puzzle-level-idea-strategies/</a></p><h2 id="谜题关卡创意策略"><a href="#谜题关卡创意策略" class="headerlink" title="谜题关卡创意策略"></a>谜题关卡创意策略</h2><p><a href="https://cwpat.me/about">帕特里克·特雷诺</a> 2022-07-14</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是为益智游戏设计更多关卡的策略列表。创意练习、灵感来源以及看待游戏系统的不同方式。其中许多策略在不同时期对我有帮助；我认为它们是我工具箱中有用的工具。随着时间的推移，我收集了这些策略，我认为写下这个列表可能对其他人有帮助！</p><p>感谢为本列表做出贡献的人员：Brett Taylor、clementsparrow、clickmazes、Corey Martin、Elyot Grant、Ethan Clark、icely、jackk、Joel Fox、Joseph Mansfield、knexator、Le Slo、marcosd、pancelor、ReflectivistFox、Toombler。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="找到交互并强制使用它"><a href="#找到交互并强制使用它" class="headerlink" title="找到交互并强制使用它"></a>找到交互并强制使用它</h3><p>围绕解决谜题所需的特定交互或动作构建谜题。就我个人而言，我经常使用这种方法。</p><h3 id="混合机制"><a href="#混合机制" class="headerlink" title="混合机制"></a>混合机制</h3><p>思考练习：假设所有机制都被邀请参加一个聚会。当机制A遇到机制B时会发生什么？他们会进行哪些对话？机制C 也会对这段对话感兴趣吗？:)</p><h3 id="枚举所有机制对"><a href="#枚举所有机制对" class="headerlink" title="枚举所有机制对"></a>枚举所有机制对</h3><p>列出所有机制对并对每个机制对进行集体讨论。</p><p><img src="https://img3.doubanio.com/view/note/l/public/p94849397.webp" alt="img"></p><p>来自 Brett Taylor 演讲《益智游戏魔法秘密》的 Linelight 机制电子表格。</p><h3 id="枚举动作序列"><a href="#枚举动作序列" class="headerlink" title="枚举动作序列"></a>枚举动作序列</h3><p>列出您的游戏具有的动作（对于本练习有用的“动作”的某些定义），然后列出这些动作的许多序列，并尝试使用这些序列作为解决方案来制作关卡。例如，如果您的操作是 A、B 和 C，请尝试创建一个级别，迫使您先执行 A，然后执行 B，再创建一个级别，先执行 B，然后再执行 A，再创建一个级别，强制执行 AAB、ABA、ABB 等。</p><h3 id="尝试极端"><a href="#尝试极端" class="headerlink" title="尝试极端"></a>尝试极端</h3><p>极端的布局可能很有趣，有时可能有一套全新的推论和定理。例如，几乎所有空间都是板条箱，几乎所有空间都是玩家，等等。</p><h3 id="尝试有趣的几何图形"><a href="#尝试有趣的几何图形" class="headerlink" title="尝试有趣的几何图形"></a>尝试有趣的几何图形</h3><p>尝试有趣的几何形状，例如只有 2 个单元格宽的关卡、对称关卡、非常大的关卡、没有墙壁的关卡等。</p><p><img src="https://img3.doubanio.com/view/note/l/public/p94849377.webp" alt="img"></p><p>帕特里克的帕拉盒子中的一个谜题，没有容易到达的朝北墙壁。</p><h3 id="在一个大关卡上玩耍"><a href="#在一个大关卡上玩耍" class="headerlink" title="在一个大关卡上玩耍"></a>在一个大关卡上玩耍</h3><p>制作一个大的游乐场关卡，里面有很多物体和结构，然后到处乱逛，看看你能在里面做什么。</p><h3 id="在关卡编辑器中随机放置对象-x2F-涂鸦"><a href="#在关卡编辑器中随机放置对象-x2F-涂鸦" class="headerlink" title="在关卡编辑器中随机放置对象&#x2F;涂鸦"></a>在关卡编辑器中随机放置对象&#x2F;涂鸦</h3><p>在关卡编辑器中涂鸦随机、混乱、异常和愚蠢的结构可以激发您原本不会想到的想法。这比听起来更有用！</p><h3 id="创建一个不可能的关卡，然后使其成为可能"><a href="#创建一个不可能的关卡，然后使其成为可能" class="headerlink" title="创建一个不可能的关卡，然后使其成为可能"></a>创建一个不可能的关卡，然后使其成为可能</h3><p>创建一个显然无法解决的关卡。然后，以此为起点，不断进行调整以使其成为可能，然后看看最终的结果。或者，想出一个漏洞来解决一个自相矛盾的情况，然后掩盖这个漏洞。</p><h3 id="创建一个不可能的关卡，然后尝试解决它"><a href="#创建一个不可能的关卡，然后尝试解决它" class="headerlink" title="创建一个不可能的关卡，然后尝试解决它"></a>创建一个不可能的关卡，然后尝试解决它</h3><p>创建一个显然无法解决的关卡。现在，无论如何都要尝试解决它。</p><h3 id="创建一个可能的关卡，然后让它变得不可能"><a href="#创建一个可能的关卡，然后让它变得不可能" class="headerlink" title="创建一个可能的关卡，然后让它变得不可能"></a>创建一个可能的关卡，然后让它变得不可能</h3><p>从可以解决的关卡开始，不断进行更改，直到不可能为止，然后撤消最后的更改。</p><h3 id="教一些你想让玩家学习的东西"><a href="#教一些你想让玩家学习的东西" class="headerlink" title="教一些你想让玩家学习的东西"></a>教一些你想让玩家学习的东西</h3><p>找到您希望玩家学习的内容，例如特定规则、边缘情况或技术，并制作一个教学这些内容的关卡。</p><h3 id="找到一个有趣的推论并强制执行它"><a href="#找到一个有趣的推论并强制执行它" class="headerlink" title="找到一个有趣的推论并强制执行它"></a>找到一个有趣的推论并强制执行它</h3><p>找到一个可以在特定设置中进行的有趣推论，并尝试围绕该推论作为关键构建一个谜题。</p><h3 id="正向设计链"><a href="#正向设计链" class="headerlink" title="正向设计链"></a>正向设计链</h3><p>遵循“正向设计”方法：从一张白纸开始，放置物体来创建一系列推论，以便玩家也遵循完全相同的推论序列。</p><p><img src="https://img3.doubanio.com/view/note/l/public/p94849352.webp" alt="img"></p><p>《见证者》中的一个谜题，需要进行一系列推论。</p><h3 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h3><p>建立一个具有一些不变量的设计，例如几何不变量、拓扑不变量、排序不变量，并围绕它构建一个谜题。</p><h3 id="突发现象和模式"><a href="#突发现象和模式" class="headerlink" title="突发现象和模式"></a>突发现象和模式</h3><p>看看你是否可以归纳或发现紧急现象或模式，例如奇偶性、循环、动作的可逆性、动作的等价性等。</p><h3 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h3><p>看看您是否可以使用游戏的对象来实现小工具和机制，例如单向隧道、一次性隧道、15 个拼图、二进制计数器、密码锁等。</p><p><img src="https://img1.doubanio.com/view/note/l/public/p94849350.webp" alt="img"></p><p>Jelly 中的一个谜题是 Sticky，它实现了弹子锁机制。</p><h3 id="谜题比喻"><a href="#谜题比喻" class="headerlink" title="谜题比喻"></a>谜题比喻</h3><p>看看你是否可以实现益智游戏中的其他常见益智比喻，例如两个冲突的任务、重新打开一扇门将早期的物体带到后面的区域等。</p><h3 id="从一个主题开始"><a href="#从一个主题开始" class="headerlink" title="从一个主题开始"></a>从一个主题开始</h3><p>几何或叙事“主题”可以成为关卡的良好前提。例如，关于使用大量 2x1 块的关卡、关于护送物体穿过许多障碍的关卡、关于 2 个角色互相帮助的关卡等。此外，根据游戏的不同，您可以尝试制作带有约束的谜题，布局或与设置或叙述相关的解决方案。</p><h3 id="追求一种感觉"><a href="#追求一种感觉" class="headerlink" title="追求一种感觉"></a>追求一种感觉</h3><p>制作一个让玩家感到强烈、幽闭恐惧、惊讶等的关卡。</p><h3 id="笑话"><a href="#笑话" class="headerlink" title="笑话"></a>笑话</h3><p>将机制发挥到逻辑的极端，找到一个滑稽的设置，建造一个鲁布·戈德堡机器，建造一些荒谬的东西，以不寻常或愚蠢的方式使用物体（例如，一个有用的物体现在是一个障碍，反之亦然），制作一个谜题看起来很难，但实际上很简单，等等。</p><h3 id="睁大眼睛留意“事情即将发生”的时刻"><a href="#睁大眼睛留意“事情即将发生”的时刻" class="headerlink" title="睁大眼睛留意“事情即将发生”的时刻"></a>睁大眼睛留意“事情即将发生”的时刻</h3><p>有时，游戏测试者有一个解决谜题的计划或理论，但由于某种原因而不太有效。作为一名开发人员，您可能会在制作谜题或观看人们玩游戏时想到这些失败的理论。“这可能是一个解决方案！” 尝试制作一个不同的谜题，让差点发生的事情真正发生！</p><p><img src="https://img2.doubanio.com/view/note/l/public/p94849351.webp" alt="img"></p><p>帕特里克的帕拉盒子中的一个谜题，是由于进一步探索从墙上拯救盒子的概念而产生的。</p><h3 id="澄清误解或强化定理"><a href="#澄清误解或强化定理" class="headerlink" title="澄清误解或强化定理"></a>澄清误解或强化定理</h3><p>关注最初的游戏测试者对规则的误解可以为谜题提供一个想法，以进一步澄清规则，或激发新的想法。同样，尝试制作一个谜题来加强对游戏测试者可能无法完全掌握的定理的理解，或探索定理的进一步应用。</p><h3 id="将替代解决方案转变为单独的级别"><a href="#将替代解决方案转变为单独的级别" class="headerlink" title="将替代解决方案转变为单独的级别"></a>将替代解决方案转变为单独的级别</h3><p>当您或游戏测试者找到谜题的替代解决方案时，您可能最终会编辑谜题以禁止它，但也可以考虑制作第二个谜题，其中该替代解决方案实际上是强制的！</p><h3 id="尝试其他游戏的关卡"><a href="#尝试其他游戏的关卡" class="headerlink" title="尝试其他游戏的关卡"></a>尝试其他游戏的关卡</h3><p>查看<a href="https://www.sokobanonline.com/play/web-archive/david-w-skinner/microban">Microban puzzle set</a>、原始推箱子或其他适用的游戏，并检查这些级别是否可以在您的游戏规则集中解决（可能会稍作更改），然后看看您最终会得到什么结果。（注意：如果你觉得灵感过于重合，请寻求许可并归功于他人。另外：不要抄袭内容，这不是这个策略的目的！）</p><p><img src="https://img9.doubanio.com/view/note/l/public/p94849354.webp" alt="img"></p><p>Microban 拼图套装的第 1 级，适用于帕特里克的 Parabox</p><h3 id="翻译谜题"><a href="#翻译谜题" class="headerlink" title="翻译谜题"></a>翻译谜题</h3><p>选择一款截然不同的游戏，并尝试将其中的一个谜题转化为您的游戏。例如，将 Portal 中的谜题转换为基于网格的推箱子游戏。尝试将方钉装入圆孔的过程既困难又混乱，最终可能会得到一些新的、无法识别的东西。</p><h3 id="将两个级别一分为二"><a href="#将两个级别一分为二" class="headerlink" title="将两个级别一分为二"></a>将两个级别一分为二</h3><p>拿两个已有的谜题，设计位于这两个谜题“之间”的谜题。例如，介于超级简单和超级复杂谜题之间的谜题，或者两者之间共享想法的谜题。</p><h3 id="将一个困难的谜题逆向设计成一个简单的谜题"><a href="#将一个困难的谜题逆向设计成一个简单的谜题" class="headerlink" title="将一个困难的谜题逆向设计成一个简单的谜题"></a>将一个困难的谜题逆向设计成一个简单的谜题</h3><p>使用简单的谜题作为起点，使用相同级别的几何形状制作困难的谜题和解决方案。这尤其适用于具有元谜题或多级目标的游戏。</p><h3 id="使用计算机生成或求解"><a href="#使用计算机生成或求解" class="headerlink" title="使用计算机生成或求解"></a>使用计算机生成或求解</h3><p>有些人使用程序根据启发法随机生成级别，然后从那里修改级别。有些人使用解谜程序来帮助改变和完善关卡。就我个人而言，我对这两种技术都不熟悉，而且我自己也没有找到任何资源来轻松尝试这两种技术，但我在这里将它们列出来是为了更全面。</p><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><h3 id="尝试和错误是过程的一部分"><a href="#尝试和错误是过程的一部分" class="headerlink" title="尝试和错误是过程的一部分"></a>尝试和错误是过程的一部分</h3><p>根据我的经验，许多谜题创意并没有具体化为实际的谜题，或者它们具体化为一个不太好的谜题。就我个人而言，我已经习惯了进行大量的挖掘，并拥有大量未使用的谜题草稿，而不会为此感到沮丧。但另一方面，有时一个想法可能会导致多个谜题，而不是一个谜题！你永远不会知道。:)</p><h3 id="迭代时研究变化"><a href="#迭代时研究变化" class="headerlink" title="迭代时研究变化"></a>迭代时研究变化</h3><p>在迭代谜题时，无论是在初始构建期间还是在完善谜题时，都要对谜题的潜在变化持开放态度，这些变化可能是他们自己的谜题，例如相关的想法、稍微不同的设置、强制执行相同约束的不同机制、较难的版本、较简单的版本、拼图的扭曲等等。</p><p><img src="https://img3.doubanio.com/view/note/l/public/p94849353.webp" alt="img"></p><p>Patrick’s Parabox 中的 4 个谜题是同一想法的变体</p><h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><h3 id="益智游戏魔法秘密-布雷特·泰勒"><a href="#益智游戏魔法秘密-布雷特·泰勒" class="headerlink" title="益智游戏魔法秘密 - 布雷特·泰勒"></a><a href="https://www.youtube.com/watch?v=B36_OL1ZXVM">益智游戏魔法秘密 - 布雷特·泰勒</a></h3><p>在这个 1 小时的演讲中，我了解到了其中一些策略，并且还对益智游戏设计的其他部分有很多见解。我强烈推荐它！</p><h3 id="30-节谜题设计课程，扩展导演剪辑版-Elyot-Grant"><a href="#30-节谜题设计课程，扩展导演剪辑版-Elyot-Grant" class="headerlink" title="30 节谜题设计课程，扩展导演剪辑版 - Elyot Grant"></a><a href="https://www.youtube.com/watch?v=oCHciE9CYfA">30 节谜题设计课程，扩展导演剪辑版 - Elyot Grant</a></h3><p>这个 3 小时的演讲充满了对谜题和益智游戏如何运作以及如何制作它们的深入见解。我也强烈推荐它！</p><h3 id="Thinky-益智游戏-Discord"><a href="#Thinky-益智游戏-Discord" class="headerlink" title="Thinky 益智游戏 Discord"></a><a href="https://discord.gg/9HqeAhXPeh">Thinky 益智游戏 Discord</a></h3><p>这个 Discord 服务器是讨论益智游戏和益智游戏开发的好地方！</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>村上t</title>
    <link href="/%E4%B9%A6%E8%AF%84/%E6%9D%91%E4%B8%8At/"/>
    <url>/%E4%B9%A6%E8%AF%84/%E6%9D%91%E4%B8%8At/</url>
    
    <content type="html"><![CDATA[<p>收集物品这件事，我其实并不是非常感兴趣，但在不经意间收集各种各样的物品，似 乎成了我人生的主题之一。多到永远听不完的LP唱片、今后恐怕不会重读的书本、杂乱 无章的剪报、短到放不进削笔器的铅笔头……总之，各类物品日益增多，以紧逼之势将我 包围。我就像忍不住救下乌龟的浦岛太郎，一面告诉自己做这些事毫无意义，一面又在某 种情绪的鼓动下，下意识地把物品们收集了起来。尽管那些短短的铅笔头，就是攒上几百根也派不上什么用场。</p><p><img src="https://img2.doubanio.com/view/thing_review/l/public/p9227173.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227186.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/thing_review/l/public/p9227172.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227175.webp" alt="img"></p><p>我当然也喜欢纯色T恤，平时生活中穿得最多的应该就是它了；其次常穿的，可能就 是纯色底只有艺术字的T恤。而且不能是一串有意义的句子，最好是那种生硬的单字，让 人看了满头问号，心想：“这到底是什么意思？”这类文字像图案一样，怎么也看不腻，信 息性更少，形状规整，也好搭配其他衣服。所以看到这类T恤，我经常冲动地买下来。</p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227174.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227176.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/thing_review/l/public/p9227177.webp" alt="img"></p><p>那一次，我在店里挑了几本看着挺有意思的书，抱着它们去付钱。没想到收银台的女店员问我：“莫非您就是村上？”我回答：“是的。”她说：“那真是太棒了。”当场让我在好几十本书上签了名，简直像即时签名大会一样，太狼狈了。这件T恤好像是那次店里送给我的礼物。哎，如果真能帮上书店一点忙，也算值了。（哈哈哈哈）</p><p><img src="https://img1.doubanio.com/view/thing_review/l/public/p9227178.webp" alt="img"></p><p>如今这个年代，若说有什么东西完整继承了三明治人的精神，恐怕就是推广T恤了。企业在T恤上印下自家的商标或信息，发给人们，人们穿着T恤走上大街。对企业来说，这相当于免费给自己做了宣传。T恤这东西不仅可以批量生产，而且价格低廉，不妨将其制作费用视为一笔廉价的广告支出。因此，如今的大街上处处可见“免费的三明治人”</p><p><img src="https://img1.doubanio.com/view/thing_review/l/public/p9227179.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/thing_review/l/public/p9227181.webp" alt="img"></p><p>虽说和所谓的“跑者兴奋”不尽相同，但游泳也有一个兴奋点，游到一定时长之后，自我感觉会越来越好，会 不自觉地想唱歌（我常唱的是《黄色潜水艇》，边吐泡泡边唱）。每当这时我就觉得，游泳给人带来的好心情，仅次于在天上飞。</p><p><img src="https://img1.doubanio.com/view/thing_review/l/public/p9227180.webp" alt="img"></p><p>最近想去看电影，但我家附近的影院放的都是漫威的原作改编的影片，其中不乏我个人难以理解的片子。不过既然片方如此孜孜不倦地拍摄，一拍就是一个系列，说明这类影片的需求还是很大的。这个世上的人们如此迫切地需要超级英雄吗？</p><p><img src="https://img2.doubanio.com/view/thing_review/l/public/p9227183.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/thing_review/l/public/p9227182.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227185.webp" alt="img"></p><p>说到T恤，就会想起夏天；而说起夏天，就会想到啤酒……对吧。不，也不必非得是夏天，在暖炉的明火前，坐进摇椅里，一面抚摸膝头的小猫脑袋，一面一小口一小口地喝下冰凉的啤酒，也是人生的一大幸事呢。</p><p>什么？你说既没有暖炉，也没有摇椅，还没有猫？那真是太可怜了。不过想想看，这三样东西我家也全都没有。连猫都没有。我只是在想象中觉得这样的场景一定很棒。想象力还是很重要的。（哈哈哈哈哈）</p><p><img src="https://img9.doubanio.com/view/thing_review/l/public/p9227184.webp" alt="img"></p><p>“因为有时会有着装要求。有一年夏天，出版社的老师请我在银座的吉兆吃饭，我到了餐厅门口，却被工作人员告知不能穿短裤入场。明明是人家请我来的，我要是进不去不就尴尬了吗（笑）。于是我说‘好的’，从包里拿出长裤，在吉兆的大门口套上。大伙儿都看呆了</p><p>收集也是一种游戏，是游戏就要有相应的规则。如果干什么都是掏钱就行，那就没意思了。收集T恤也是一样。看过的两百件里，能有一件看得上的，已经很不错了。集中精神一件件地看下来，肯定是要花时间的。不过，既然这是游戏，那就是要拼命地去看嘛</p><p>标准是有的。能穿的T恤和不能穿的T恤，我分得一清二楚。说白了，我就是不想惹人注意嘛，想尽可能低调地生活。平时不是要坐地铁、坐公交、走路出门、去书店、去Disk Union(22)吗？对我来说，如果太招眼，就会引来麻烦。所以能穿的衣服就比较有限。有不少T恤很棒，但我的话就是没办法穿。首先，有象征含义的T恤我就没法穿。穿上这类T恤，人们就会去解读嘛（笑）。一旦被人解读，就难办了。</p>]]></content>
    
    
    <categories>
      
      <category>书评</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工作一年之后</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E4%B9%8B%E5%90%8E/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E4%B9%8B%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<p>工作一年之后，感觉和大学生活没什么区别，无非就是从白天上课变成了上班，晚上依旧在自己的小房间里打游戏看番看电影看书。不用加班，不用应酬，领导也不pua不画饼，压力不大，工资还过得去，这么一看没什么可以抱怨的，但还是会不想上班，已经变成了上班摸鱼等着下班，工作日等着周末的循环了。</p><p>这么安逸的工作环境往好了说压力不大，往坏了说也没什么成就感，做的是我自己都不会玩的十几年的老mmo。端游确实不卷，节奏很慢，没什么动力提升自己了，人生失去了目标这种东西，之前还想着或许自己能开发点自己喜欢的游戏，但是一想到美术和创意自己一概没有，又想到还有那么多好玩的游戏和有趣的书电影可以去看，此消彼长，更没了努力的动力。不过话又说回来，觉得摆烂是一种罪过这种心态本身就有问题，就应该好好享受这种快乐的时光嘛。</p><p>这一年很感谢我的朋友们，每周陪我玩桌游，这一年大概玩了六七十个新桌游，相当的开心，这大概是我能坚持留在北京最重要的原因。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瞎掰王</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E7%9E%8E%E6%8E%B0%E7%8E%8B/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E7%9E%8E%E6%8E%B0%E7%8E%8B/</url>
    
    <content type="html"><![CDATA[<p>最近发现一个桌游，感觉非常有意思，大概规则是谁是卧底的逆转版，一个人作为猜题人，剩下的人分为一个老实人，其他的都是瞎掰王，全场只有老实人知道这个词的真正意思，然后就轮流开始解释这个词的意思，如果猜题人猜中了老实人就获胜。</p><p>感觉是一个非常有意思的语言毛线游戏，正好现在也在众筹，但是忍不了那么久发货所以就自己看了综艺爬了一些词，以及我自己想了一些词，比如小黄鸭效应，斯特普尼克情人，写了个脚本生成了图片准备玩。</p><p>也欢迎大家给我提供一些冷门，可以联想的有节目效果的词！</p><p>放个综艺连接吧：<a href="https://www.bilibili.com/video/BV17K4y1a7kf/?p=65&share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">https://www.bilibili.com/video/BV17K4y1a7kf/?p=65&amp;share_source=copy_web&amp;vd_source=5d07d04eb2516df147034367e7af6fd2</a></p><p>p.s. 也可以微信搜索美丽的随机小程序，词库更全</p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384861.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384858.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384859.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384860.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384865.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384862.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384863.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384866.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384867.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384868.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384869.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384870.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384871.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384872.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384873.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384875.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384876.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384877.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384878.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384879.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384880.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384881.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384882.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384883.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384884.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384885.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384886.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384887.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384888.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384889.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384890.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384891.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384892.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384893.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384894.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384895.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384896.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384897.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384898.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384899.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384900.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384901.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384902.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384903.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384904.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384905.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384906.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384907.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384908.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384909.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384910.webp" alt="img"></p><p><img src="https://img2.doubanio.com/view/note/l/public/p94384911.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384912.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384913.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384914.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384915.webp" alt="img"></p><p><img src="https://img9.doubanio.com/view/note/l/public/p94384916.webp" alt="img"></p><p><img src="https://img3.doubanio.com/view/note/l/public/p94384917.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384918.webp" alt="img"></p><p><img src="https://img1.doubanio.com/view/note/l/public/p94384919.webp" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ZOO笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ZOO%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ZOO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="小饰与阳子"><a href="#小饰与阳子" class="headerlink" title="小饰与阳子"></a>小饰与阳子</h1><ul><li>“这是我家的钥匙，以后再也不用编藉口了。我最喜欢阳子了，你随时想来就来哦。”我拼命地点头，这主意真是太美妙了。活到今天不知道有多少次，我后悔自己被生到这个世上。我爬上大厦的屋顶，攀上铁丝网，迎着强风一边流着鼻水一边犹豫要不要往下跳，想都没想过会有这样的一天降临我身上。那天之后，凡是碰到痛苦的事，我都会紧紧握住铃木奶奶给我的钥匙努力撑过去，简直就像三号碱性电池一样。这把钥匙给了我能量，让我有了生存意志。我每次都拿这钥匙当书签用，将它夹在书里面藏了起来。</li></ul><h1 id="七个房间"><a href="#七个房间" class="headerlink" title="七个房间"></a>七个房间</h1><ul><li>我走近水沟，将漂在脏水上流过来的她的手指头，轻轻地用双手捧了起来。那是她最后紧握着我的手的指头，已经失去温度，变成小小的碎片。</li><li>我的眼泪掉个不停。我的脖子上挂着十字架项链，手拿着那本写着向父母道歉文章的记事本。我的手腕上挂着姐姐的遗物——那只手表。因为不是防水的表，大概在我躲进水里的时候坏掉了吧，指针恰好指着傍晚六点，停止了走动。</li></ul><h1 id="远离的夫妇"><a href="#远离的夫妇" class="headerlink" title="远离的夫妇"></a>远离的夫妇</h1><ul><li>从他们两人的话语里我理解到，他们其中有一人死掉了。爸爸深信妈妈已经死了，误以为只剩他和我两人一起过生活；而相对地，妈妈则认为爸爸死了。难怪他们彼此无法看见对方，也听不到对方说话。能同时看见他们双方的人，只有我。</li><li>我不再处于他们两个的世界的重合处，不过是在渐行渐远的两个世界之间来来去去罢了。</li><li>“他好像看不见爸爸了。”妈妈快哭出来似的对男人说道，“他听得到我的声音，可是好像听不到他爸爸的……即使他爸爸牵他的手或摸他的头，他好像都没感觉。硬把他抱起来或是拉他的手臂，他就瞬间变得全身软绵绵的，像个面无表情的人偶一样。”</li></ul><h1 id="向阳之诗"><a href="#向阳之诗" class="headerlink" title="向阳之诗"></a>向阳之诗</h1><ul><li>他说，几乎所有的人类都死亡了。由于病菌突然覆满整个天空，受到感染的人无一幸免地都在两个月内死去。他在感染之前与伯父一道搬进这栋别墅，但伯父很快去世了，之后他便独自一人在此生活。他口中的伯父也死于病菌感染，尸体是他掩埋的，就埋在刚刚经过的小丘上。这么说来，那座白色十字架应该就是伯父的坟墓了。</li><li>不知从何时起，我前往水井的时候不再采取最短距离了。我会慢慢地走在蜿蜒的铺石小径上，小心不去踩到路旁的花草。以前我认为那很浪费时间与精力，如今却觉得一边欣赏四周，一边慢慢地走是乐事一桩。</li><li>“听着窗边的挂饰摇动发出的声响，我会忍不住想，如果自己是人类该有多好。”连风都能吹动挂饰创造出音乐，而我却无法制造出任何东西，这让我觉得很遗憾。我能在会话中使用富有诗意的说词或者编一些谎话，但我所能创造的东西却仅止于此。</li><li>停止运作很恐怖吗？我觉得在停止运作与感觉到恐怖之间，似乎还缺了一样什么东西，或许那就是我必须学习的课题吧。</li><li>我思考着自己死去时的状况。那不只是停止活动而已，那是和这整个世界的告别，也是和我自己的告别。就算我再怎么喜欢某样事物，最终一定会走到这一步。所以“死亡”是恐怖而悲哀的。愈是深爱着某样事物，死亡的意义便愈沉重，失落感也愈深刻。爱与死并不是两回事，它们是一体的两面。</li><li>“那种病菌造成的‘死亡’，会那么准时吗？”“……这个嘛，谁晓得呢。”他的回答听起来对这问题不甚感兴趣。我压抑着内心的紧张，试着继续问他：“……你之所以不替我取名字，其实就跟无法创造绘画或音乐一样，你也无法创造名字，对吧？”</li><li>“我也是以秒为单位，非常清楚自己死亡的时间。因为像我这样的被造物，存活时间是打从一开始就被设定好的。所以说，你也……”事实是，他根本没有被什么病菌感染吧！他是曾经看过其他人类用积木组装帆船，所以才组装得出来吧！在人类全部灭亡的世界里，只剩他独自存活至今。他凝视着我好一阵子，之后低下头去，白皙的脸庞蒙上了阴影。“抱歉，我骗了你……”</li><li>“但现在，我对你只有满满的感谢。如果不曾诞生到这个世界，我就无法看见小丘上辽阔的草原；如果当初你没有为我装上心，我就无法体会望向鸟巢时的愉悦，也不会因为咖啡的苦涩而皱眉了。能够这样一一地去碰触世界的光辉，是多么宝贵的事情啊！一想到这里，即使内心深处因为悲伤而淌着血，我都能够把那视为证明我活着的最最珍贵的证据……”</li></ul><h1 id="动物园"><a href="#动物园" class="headerlink" title="动物园"></a>动物园</h1><ul><li>照片和电影的差异，很类似俳句和小说的关系。不只俳句，短歌和诗也是如此，一般来说，它们的字数都远少于小说，那正是它们的特征，在一连串短短的文字中，撷取内心某个刹那的感动，将其封印。作者便是在体验这个世界之后，将其内心的感动以短短的文字描写出来。而小说的感动则是连续的。不但对于内心状态的描写是连续的，而且随着行数的增加，其形态也有所变化。根据小说内发生的种种事情，登场人物的心情并不会始终保持在同一状态。若从中单单抽出一段短文，那便是描写；然而若让短文接连下去，便是描写“变化”了。登场人物们的内心会从第一页变化到最后一页，最终成为不同的形貌，整个变化过程其实可用波状曲线来表示，而那正是故事的真面目。这其实是数学。将小说微分，便成了俳句或诗；将故事微分，便成了描写。而照片正是描写。它截取刹那的风景收入框框中，描写孩子正在哭泣的脸庞，其实很接近俳句或诗。虽然文字并不等同画面，但不论哪一方，都是抽出某个重要时刻让其停留在永恒的尝试。</li><li>这样一来，存放在计算机里的她的静止影像便按着号码顺序接连播放成了动画。一秒十二张，她的静止影像一张换过一张。这个功能原本是用来制作动画的。只要按下播放，就能看到她日渐腐化的过程。虫子们一齐涌上来覆满她的身躯，终于在饱餐一顿之后退散离去，看上去就像浪潮一样。</li><li>我的每句话都是台词，都是我的演技。在我的内心，其实一直思考着完全不同的事情。但是不这么持续演下去，太过痛苦的现实只会让我崩溃。也就是说，我只是一直装作不知道自己的事情。我忽略那一块，然后信誓旦旦地宣称要找出杀害她的凶手。不过我绝对不可能抓到凶手吧。因为，杀了她的人正是我。</li><li>“开车的人也是你啊。喂，这样行了吗？我的台词讲得够完美了吧？你每天都这么来一下，也真辛苦。一天到晚做一样的事情，不嫌烦吗？从开始陪你玩这个游戏到今天已经是第几个月了啊？虽然说你是常客，不好不配合你。”</li></ul><h1 id="把血液找出来！"><a href="#把血液找出来！" class="headerlink" title="把血液找出来！"></a>把血液找出来！</h1><ul><li>有一次我正在看报纸，不知道为什么四格漫画《暖洋洋小弟》[9]的最后一格整格被涂成了红色。究竟是哪个家伙恶作剧？这样不就不知道结局了吗？虽然这部漫画本来也谈不上有没有结局之类的。正当我气愤不已，才发现那是被我指尖流出的血染红的，原因是我养了一只土佐犬，那天早上忘了喂它，结果那家伙不知道什么时候把我的手当成狗食嚼了起来。还有一次我正准备洗澡，在脱衣间脱下内衣，发现不知为何内衣上头有一点一点红色的水珠图样，正想开骂“是谁买了品位这么差的衣服啊”，才察觉那点点水珠其实是我的血。我的背上被两、三个图钉刺伤了！看来是我午睡时睡相太差，滚来滚去滚到图钉上头去了。总是这样，等我发现的时候，才知道血一直流。就算钉子刺到皮肤，我也不会有感觉。有一次小脚趾头踢到衣柜的一角骨折，我甚至过了两天才发现。</li></ul><h1 id="寒冷森林中的小白屋"><a href="#寒冷森林中的小白屋" class="headerlink" title="寒冷森林中的小白屋"></a>寒冷森林中的小白屋</h1><ul><li>墙里的人们以复杂的姿势相互交缠。一个男人弯着手肘，紧邻着的人则配合他手肘的弯度扭曲着身体；一个直立于地面的少年以头部支撑着他上方的男女。人们手脚复杂交缠的模样，宛如大量的蛇被聚集到一处痛苦翻搅着，而我在他们的环伺之中抱膝入睡。寒冷的夜晚持续。</li></ul><h1 id="衣橱"><a href="#衣橱" class="headerlink" title="衣橱"></a>衣橱</h1><ul><li>“你把知道我秘密的龙司杀了，是想进一步惩罚我？”美纪追问。肯定。“打开看里面是谁吧。”冬美说。于是她缓缓地拉开门，下一秒钟便和全身大汗、透过衣橱缝隙一直瞪大眼窥视外头的我对上了视线。妹妹与妻子两人的脸上失去了血色，惨白得宛如死人。</li></ul><h1 id="神的咒语"><a href="#神的咒语" class="headerlink" title="神的咒语"></a>神的咒语</h1><ul><li><p>我的妈妈是个头脑很好的人。她从少女时代便开始读艰涩的书籍，后来上了有名的大学。她的个性很好，积极参与各种义工活动，深受当地居民喜爱。她总是抬头挺胸，站姿宛如冬季湖畔静静伫立的白鹤。在她不染一丝尘埃的明亮眼镜底下，是一对充满知性的眼眸。</p></li><li><p>要说她唯一的缺点，就是她分不清家猫和仙人掌。因为这样，前阵子她伸出两手将我们家养的猫一把抓起来种进花盆里，盖上土还浇了水；接着将仙人掌误以为是猫，抱起来在脸上磨蹭，弄得脸颊血肉模糊。</p></li><li><p>“你——将再也分不出猫跟仙人掌的差别——”</p></li><li><p>他想打电动就去电玩中心，不想念书就索性把铅笔折断。虽然代价是必须忍耐父母亲对他的失望，但我弟弟和也似乎原本就过着无所谓失望不失望的人生。但我不一样，为了让爸爸喜欢我，我用功念书，谈吐有礼，五育健全。别人谈到我都会说我是个清爽、开朗的好青年。然而那不过是外表的金色毛皮，里头包覆的其实是一团黏糊糊的红黑色块状物。</p></li><li><p>替家人和仙人掌准备早餐的人；为了不让报纸被风吹翻页而以没有指头的左手压着报纸的人；总觉得大家都不像人类，而像是会动的人偶。上学途中、搭电车时、检查我月票的人、坐在我旁边的人、在学校走廊上擦身而过的人，每个人都不像是生物，仿佛不具思考能力，愈来愈觉得大家都像撞球台上的球，一撞到球台边框便反弹回来似的，只是做出一连串既定的反应，我不禁怀疑他们只是有着巧夺天工的皮肤其实体内全是由人工零件组成的聚合物。</p></li><li><p>顺带提一件事，我在考虑单单把自己房里的那张书桌从上述条件里抽离。“你的所有感官将无法欺骗你的书桌。”也就是说，即使你过着与平常无异的每一天，唯有这张桌子是连接着现实世界的。你现在一定很后悔听这卷录音带吧？你或许又会想要忘掉这一切，又想回到听录音带之前的自己吧？若你现在的确这么想，那你不妨就再往桌上刻下一刀吧。这张桌子并不是你的幻觉。因此你听了这卷录音带之后抹消记忆的次数，将忠实地以刻痕的形式留在这张桌子上。现在，桌面的刻痕有几道了呢？</p></li><li><p>我坐在床边想象着。在这个被腐肉覆盖表层的世界，只有我一个人穿着制服去上学；为了表明我不会逃票，我对着无人的剪票口出示我的月票；我深信电车在摇晃，其实我只是沿着铁轨一路走去学校吧；我踩着地面上各式各样柔软的东西，静静地走进校门；为了讨所有人欢心，我露出虚假的笑容走进永远无人打扫的教室；我梦见教室里同学们吵吵闹闹的，而老师大吼要大家安静，实际上只是我一个人一直坐在死寂的教室里罢了。我的头发长了，眼神空洞，还是拼命装出笑脸，这样的我与其说是人类，更像是动物吧。</p></li></ul><h1 id="在即将坠落的飞机中"><a href="#在即将坠落的飞机中" class="headerlink" title="在即将坠落的飞机中"></a>在即将坠落的飞机中</h1><ul><li>“是吗。总之，我只规划了自己二十一岁之前的人生。”“结果世界并没有毁灭啊。这样说或许有点夸张，不过在那之后，我觉得接下来的日子都是余生了。”男人仿佛叹了口气般感慨良深地说。</li><li>“我还没搭上这班飞机就在想了，在诺斯特拉达姆士预言落空的1999年之后出生的孩子，究竟是怎么看待死亡的？他们和我们的生死观一定截然不同吧。1999年之前就懂事的我们，童年时期就算再怎么快乐，还是受到那个诅咒般的预言纠缠，心中总是有一丝阴影。即使是不相信世界会灭亡的孩子，心里某个角落里一定也存有“不过只怕万一……”的想法。但是在预言落空之后懂事的孩子一定不一样，他们压根没有机会思考世界灭亡或自身的死亡吧。”</li><li>从现在开始，大约一个半小时之后，这架飞机就会撞上 T 大的校舍。各位，请和我一起死吧，拜托你们了。考了五次 T 大都落榜的我，只有死路一条了 ……”</li><li>“这个嘛。不过如果是某本短篇故事集里特别收录的新增作品，或许就不会有这么称心如意的结果了。我想一定会坠机的，我们所有乘客都会品尝到坠落和逐渐逼近T大校舍时所带来令人发狂的恐怖啊。”</li><li>请让我的死法是如同睡着一般死去，那我就算结不了婚也无所谓。”</li><li>“我想让我老婆难堪，所以我要死在她娘家的玄关，这样她一开门就会看见我的尸体。她一定会大吃一惊，不知道该怎么办吧？然后一定会被附近的邻居冷眼对待。”“这计划也造成太多人的困扰了吧！”</li><li>“……原来如此，我晓得了，你和那个劫机犯是一伙的吧？你们的计谋是引起劫机骚动，然后在机舱内高价贩卖安乐死的药，对吧？”推销员笑了出来。“有必要为了诈欺而不惜杀人吗？”</li><li>“你在这种情况下还想杀价啊！只卖你一万圆的话，我是没办法安心成佛的啦！”“谁管你能不能成佛？我的生存意义就是杀价，每天在蔬菜店鱼店杀价杀价再杀价就是我唯一的乐趣。高丽菜被虫咬了个洞啦，鱼太瘦啦……跟老板挑三拣四让他算我便宜一点，这就是我一整天下来唯一好好和别人讲话的时间啊。”</li><li>我想，我跟这个人不像其他乘客那么害怕，或许是因为我们没有什么好失去的。</li><li>说完男孩子开始说明依据蔬菜切法的不同，酱菜的嚼劲和腌渍的时间都有所变化，还解释了腌酱菜时盐分的浓度。他说这些事情时的表情十分开朗。“当我独自一人在阴暗的家里默默地腌酱菜时，内心便觉得非常平静。我从小学时代就一直是这样了……”</li><li>“我赌了你会顺利让飞机坠落哦，所以请你务必加油，将所有人推下恐怖的深渊吧！”男孩很有精神地点了头。“我知道，我不会让你白白安乐死的。”“这两个人从刚刚就一直聊着相当恐怖的话啊……”</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如雪如山笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A6%82%E9%9B%AA%E5%A6%82%E5%B1%B1%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A6%82%E9%9B%AA%E5%A6%82%E5%B1%B1%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="我只想坐下"><a href="#我只想坐下" class="headerlink" title="我只想坐下"></a>我只想坐下</h1><ul><li>开车一小时之后，人们已经开始各为彼此的娱乐，聊天、打扑克、吃瓜子、看书报杂志、戴耳机听歌、织毛活儿，还有女人端着竹篾绷子绣花。车厢宛如一个狭隘与伧俗的移动展览馆，能听到所有热门的偏见、女演员的风月新闻……有些人只是呆坐，两眼半开半闭，沉浸在混沌中。立立也是呆坐者，她其实带了书，在行李箱里，但她不想拿，她预感到跟那个列车员“还没完”。雨将落未落，悬念像雨滴悬在半空，她只想把悬念当一颗话梅，尽情地咂吮，滋味无穷。</li><li>这里一点点的亲密，换到任何别的地方，都要惹起“耍流氓”的叫嚷和纠纷的。但这时候，少女的粉脸贴着大汉的发黑的脚心，妇人当着丈夫的面公然倚在别人大腿上。双人座上的夫妻情侣抱得像阴阳鱼，头顶着彼此肚子。为了一点点舒适和支撑力，有人腿架在桌板上，有人脚丫高举到壁板上，有人把脚趾塞到别人屁股底下。大部分睡脸上都有个黑乎乎的嘴窟窿，远一看，像不约而同的呼救。</li><li>车厢里的味道很浓，是“人”味儿，又不完全是，是十几吨人肉在钢铁胃口里消化过的气味。</li><li>对孩子来说，贫穷是一桩游戏。他们刚来到人生之中，就像旅行者初到某地，疮痍也被新鲜感美化成风景。即使一无所有之际，他们还有自己，肉体和五感都是玩具。</li><li>她模糊地笑一声，有点不悦，以及失望。这种以一辈子为主题的故事，聆听者即使出于道义和礼貌，也该给出一些沉痛的感慨，提这样半开玩笑的问题就过于轻佻了。</li><li>我是觉得，人生在世，哪可能什么都合心意？受了点挫折就伤心，就决裂，哪能决裂得过来？比如我吧 …… 他像激动了似的转过身，差点跟她脸挨脸。我本来打算念表演的，中戏、上戏、北影，都去考了，离家出走去考的。复试通知书都拿到了，但是怎么样呢？家里不同意，我爷我爸都是铁路局的，他们想要“铁三代”。我一提上电影学院，我妈就躺炕上不起，一躺一天，拿枕巾擦眼泪擤鼻涕，脸色煞白，跟活不了似的 —— 她有心脏病，室间隔缺损。我爸，跟我说着说着，就能一耳光扇过来。嗨，最后我老老实实干了客运，他们总算舒坦了。我呢，一天天熬得想卧轨。刷厕所有多恶心，你都想象不到，有人能把屎喷到墙上去，有人能拉出跟蹲坑平齐的一池子 …… 哎呀，对不起，不该跟你一个女孩子说这些。</li></ul><h1 id="地上的血"><a href="#地上的血" class="headerlink" title="地上的血"></a>地上的血</h1><ul><li>每次从工作的城市回乡，感觉既像要进考场考试，又像要面对一张等她批改评分的试卷。她草草朝母亲笑一下，就眨眨眼，把目光焦距打散。长久分离之后，猛见面的第一眼，最难受。母亲双手插在外套兜里，有点驼背，穿着浅紫上衣，灯芯绒白裤子。陌生感强迫她以评卷人的目光承认那是个瘦削的半老女人，美貌丰饶所剩无几。她低头推行李箱，把车票按在扫描桩上，咬牙熬过心中酸楚。</li><li>其实每次回家，都是从坐上火车那一刻开始的，像彩排，或模拟考，满车厢共享终点站的人也共享籍贯与口音，人们互相打招呼，打听居住地和出行事由，口音以彼此为酵母，痛快淋漓地膨胀。大部分乡音像不体面的内衣，在腰间皮筋上印一圈牌子拼音。在她工作的城市，人人都把口音藏得严实，像用漱口水和口香糖掩藏口气。</li><li>餐具也是成套的，酒杯里倒好了枸杞江米酒，乌木筷子斜放在白瓷筷架的凹陷中，油爆大虾、酱焖鲤鱼、蚝油生菜和炸藕盒都勾了芡，亮晶晶地在灯下等待赞美。不赞美简直没天理，她赞美得卖力极了，平均吃三口配一句夸，形式多样，包括嗯嗯点头感叹，包括真诚地询问做法。杨器还原成耐心称职的老师，款款讲解怎么选鱼选虾，怎么杀，怎么用汁腌。母亲负责做适当的插叙。他们把这顿饭吃成了一堂演出来的公开课，热烈愉悦得不真实。</li><li>他咳嗽着，转身叫服务员倒杯凉水过来。自始至终，他没有问她母亲，也没有问你在学校怎么样、谈没谈对象，这些家长的常规问题，他全部身心都被即将开始的新生活占满了。</li><li>这倒真有。跟你讲啊粒粒，我第二次和他出去看电影，看了一部美国片。片子演到一个地方，里面的人说了句话，那话挺平常的，可我觉得特别有意思，就笑了，听到旁边杨器也在笑。那句话，全影院的人都没笑，只有我跟他一起笑了出来。那时我就觉得，以后跟他过日子，应该过得下去，起码我们能笑到一起。也不知道我想得对不对？（什么电锯人）</li><li>因为我姑姑家那边的亲戚里，有个堂姐是天生“石女”，从小没有月经，长大了也不能生孩子。我第一次看到自己流血，松一口气，跟自己说，这下好了，我不是石女，我将来是能生小孩的。我从小喜欢小孩，尤其是小女孩，从小就盼着自己生一个。那么，你从小就在盼着我当来你的孩子啦？是啊。她们相视一笑，都感到对世界别无所求。</li><li>母亲还在说话。她感到母亲的两手握住她肩膀，轻轻摇晃。她想说，你不明白。我的血里有一半红色是你给的，我的血是你的血。这件事只属于我和你，只容许我和你。现在你把它毁了。当你给予的时候你不明白，现在你毁掉它的时候，仍然不明白。</li></ul><h1 id="泳客"><a href="#泳客" class="headerlink" title="泳客"></a>泳客</h1><ul><li>水像一种爱，让人松弛，有安全感的爱。那一刻的感觉真好，比猛灌一大口冰啤酒还好，比亲吻时舌头伸进一个可爱的嘴里还好。水给了浮力，也给了阻力——更像是爱了。在水里，挥手，踢腿，都是慢放的，快不起来。</li><li>上班一天结束，浑身说不出的不自在，好像那些盯着的目光，把她身上看得坑坑洼洼的，看得掉了皮，都露出底下电线了。埋进水里，让水抱着、保护着，她才觉得安全，身上开裂的地方、走风漏气的地方，慢慢闭合，重新变得光滑、平整。</li><li>她更喜欢憋一大口气，钻入水中，游向池底。一整池的水在头顶，仿佛一床无穷大的、透明的缎子被，肚皮贴住瓷砖釉面，就像钻进被底。被子遮天蔽日，把一切隔绝在外。四周安静极了，只能听见吐气的声音，珠子似的气泡摇曳而去。这时她不是王沥沥。她没有名字，没有学历简历工龄房租，没有重量和体脂率，没有欲望，也没有忧喜。她只有水，她变成水。她化为一匹水，一朵水，一粒水，是藏在水里的一棵水，是酹入水中的一樽水，是插进水里的一页水。</li><li>王沥沥觉得这沉默的情景让她的心脏在腔子里瑟缩着，缩成一颗红豆那么大。玲珑骰子安红豆。她是一咬牙把骰子掷出去了，屏息看它在空中滴溜溜打转，等它受一句神奇的话语的指挥，静止出一个点数。</li><li>她想，等将来某一天那个人回来游泳，一定要给她讲讲这一幕。无边雨线，像无数小小的爪子，叩击游泳馆的屋顶、天窗。大玻璃窗上不断流下细细的水流，竖着一道道的，犹如利爪留下的抓痕。</li></ul><h1 id="纪念日"><a href="#纪念日" class="headerlink" title="纪念日"></a>纪念日</h1><ul><li>孤独久了，会觉得人变得干瘪，渴望到这些地方出没一下，吸一下“人”的气息，但真待在人群里，又想要尽早逃开。似乎很快乐，其实不快乐，又不能说自己不快乐。</li><li>不是，大鸭梨的梨，糖炒栗子的栗。都是吃的。小范围内能听到这几句话的人都笑了，第五岳却说，这名字很风雅，是陶潜的诗：通子垂九龄，但觅梨与栗。</li><li>这个典栗栗自己当然知道，她通常不说，她不希望让人觉得她是个用诗命名的人，那样比较……不平常。但被别人道破的感觉还是很好的，她用含笑的目光向第五岳致意。另一边的编辑说，第老师，咱们下本书，我打算让小陶给设计封面。第五岳随便嗯一声，已经转过头去了，他抬手叫来服务员，要了碗米饭，捏着玻璃大转盘的边缘，把一坛红烧肉转到面前，用瓷勺把米饭的锥状尖端压平，从坛子里舀出两勺赭色汤汁，浇在米饭上，捣一捣，埋头香甜地吃起来。</li><li>从十二岁到三十二岁，她看男人的标准跟随老王而变化，老王在发育期蹿个子，瘦得一副骨架挑着皮，关节从皮里支棱出来，她就觉得皮包骨很好看；高考期间压力大，老王像充了气一样胖起来，她躺在他怀里时跟那些脂肪也相处融洽；后来老王迷恋健身，练出一肚皮巧克力块似的肌肉，她像背一首歌词一样，背下了他身上所有腱划。</li><li>现在唯一一次意外发生了，她没有把第五岳跟老王对比，那种对比，会像是跨物种的比较。第五岳具有引人注意的光彩，犹如海豚跃出水面时身上闪闪发亮的水光；老王身上想让人依偎过去的、粗粝的温暖，则像风沙里安详矗立的骆驼的毛发。拿海豚跟骆驼比个头，没有意义。</li><li>海、海风和海浪，像整整一种生活。一种坦荡、开阔、强悍、无所畏惧、容纳一切、藐视一切的生活。它属于那些敢于遗世独立的人。她胸中荡漾起一种浩渺的愁绪，她感到羞愧，感到自己配不上它们。比平庸更糟的，是以平庸为乐。</li><li>第五岳口中喷出苦涩的咖啡气息，他说，你知道我为什么剃光头发？说出来你可能会笑。我每次遇到中意的女人，都会把头发剃掉，然后让它慢慢重新长起来，就像结绳记事一样。以后我的头发长度，就是我遇到你的时间长度。</li><li>跟第五岳在一起时，栗栗不好意思拿出手机来拍东西，后来第五岳发现了，说，不要紧，你就照自己的喜好随意拍，我从来没笑话过非专业人士的照片。你用手机拍出来的，是你的视角，是你对世界的理解。总不能因为世上有了拉斐尔、伦勃朗，别人就不画画了吧？这段话通透宽容，让她颇为感动。她说，是，我估计伦勃朗家的小孩上幼儿园，也要画恐龙和蝙蝠侠的。</li><li>他们一向如此，把所有单独获得的见闻倾诉给对方，逐个细节讨论，然后就像一起经历了那件事。但现在她需要悄悄锁起一个抽屉，不让他翻动。这种罪恶感带来的刺痛也被藏进抽屉里，留待无人时拿出来，咂吮那新奇的苦味。</li><li>她挂断电话，静坐了一阵享受那种快感，她现在明白她一定要告诉某个人的原因，她要靠别人的惊诧羡慕来确认，冒这个险——后半辈子都受累于那个上锁抽屉的风险——是值得的。</li><li>她无法接受不修片的真实图景。真相、真正的第五岳和她真正的情感，突兀地显现出来。水像被什么魔法瞬间吸走了，河床底子露出来，还有河底的污物与骸骨。飞着的蝴蝶很美，你忍不住想去追它，然而一旦捏住蝴蝶翅膀，一切就毁了，你只能得到两根手指上糊涂一片的粉末和一只再也不美丽的虫子。所有跟第五岳相关的美好时刻和遐想，犹如蝴蝶翅膀上的粉一样脱落了。</li><li>——第五岳，你该剃头发了。把跟我有关的头发剃了吧。他的回复仍然没有文字，只有一张图，一张她在窗前梳理头发的照片。他们没再见过面。</li></ul><h1 id="春之盐"><a href="#春之盐" class="headerlink" title="春之盐"></a>春之盐</h1><ul><li>新生儿入主的头一个月像一百年。一百年的孤独。她与婴儿父亲分房间睡，因为人们认为他需要好睡眠，白天才能有精力工作。她跟别人躺在大卧室里，婴儿床放在一边。闹钟总像是刚歇过气，就又响起。婴儿以无声的霸权统治所有人，更用责任感和负罪感的长鞭来驱使她。</li><li>万一你不得不妥协，记得跟你丈夫签一份他要承担的义务的合同，条文列细一点。你也不要允许、不要容忍任何人插手这个过程，她们插进来就不会放弃干预，她们相信自己有资格掌管一切。不要用顺从巩固她们的相信，否则你就会一败涂地，什么都丢掉 …… 她滔滔不绝地朝人们越来越不好看的脸色演讲。我想伸手捂她的嘴，但我的手只顾上给自己堵眼泪，我跟她共享一副泪腺，我就是她。后来她笑了，一边笑一边拍着桌子，像给自己打拍子，她好久没笑了，这次，她笑得由衷极了。</li></ul><h1 id="雪山"><a href="#雪山" class="headerlink" title="雪山"></a>雪山</h1><ul><li>巫童也理解，每个人精神上都有一部分是充气的，像自行车胎、游泳圈，用一阵就需要往里打气。不同的人，要充进去的气体不一样。马闯需要人世里蓬勃的热气，巫童需要空房间里平静的冷气，没有高下之分。他们轮流陪伴，耐心地尽伴侣的职责。</li><li>那是她人生的黄金时代。都是琐事，都是平庸家常，单个拎出来也没意思，但远观是无尽水面上一片粼粼波光，她躺在船里，半梦半醒，金光在眼皮上跳，桨声轧轧，搴舟中流，操桨的是吴桐。</li><li>曾经那么亲近，可她现在竟不记得吴桐的长相。都是零星印象，像一张照片撕得太碎，风又刮走了一些，剩下的碎片，有的有一点鬓角，有的有半边眉毛，似乎什么都在，只是拼不出一张面貌了。</li><li>这话可能是从大人那听来的。当时她暗自愤慨，心想凭什么看扁我，我偏不“完”！当时赖有这些零星的残忍，跟小锉刀似的，慢慢把她心脏外边的死皮锉掉了。现在她明白，那人说得对，她的某一部分是真“完了”，不认账不行。她像是那年因罪获刑，被散弹枪打过，此后的年头，自己一次次做手术，把弹片一块块挖出来，但总难免有遗漏。弹片永远取不干净，总在阴雨天以绵绵的疼痛提醒她，有一条命、几十年和无数种人生的可能，从她手里滑脱了。不认账不行。她像是那年因罪获刑，被散弹枪打过，此后的年头，自己一次次做手术，把弹片一块块挖出来，但总难免有遗漏。弹片永远取不干净，总在阴雨天以绵绵的疼痛提醒她，有一条命、几十年和无数种人生的可能，从她手里滑脱了。</li></ul><h1 id="拜年"><a href="#拜年" class="headerlink" title="拜年"></a>拜年</h1><ul><li>曹啸东说，别总看那些低级的东西。他们挣的是下沉市场的钱，都是给那些三四线城市没受过良好教育的人看的，奶头乐。孙娟说，我看的是一个北大教育专家的号，不低级。曹啸东看她的目光近乎怜爱了。教育专家的视频，配那种笑出假声的音效？娟啊，教育就是耳濡目染。不爱看书是你的自由，我不judge你，也不勉强你，只希望你为了球球装一下。一切以孩子为重，咱不是说好的？孙娟说，行了行了我知道。哎呀，一个耳朵监听球球，一个耳朵监听我，厉害死你了。</li><li>打认识他，孙娟就发现，他是一堆走动的规矩。自从十七岁离开家乡白泥沟子村榆树大队，他像一个勤勉的登山者，十年如一日，用“规矩”和“品位”当作岩钉、绳子，一心一意攀向心目中“上等人”的峰顶。</li><li>大学二年级别的男生牙不刷脸不洗，打游戏，看日本女优片、看 NBA ，一天两顿泡面，他看的是 BBC 纪录片、 IMDB Top100 电影、网球比赛、高尔夫比赛、 F1 方程式赛车、美国职业骑牛大赛、威斯敏斯特全犬种大赛。他按营养书里的食谱调配三餐，拿学校食堂的甜豆腐花当餐后甜点，俨然在演一部落难贵族的电影。</li><li>要学的东西还太多，岩钉越打越密：学打网球，学喝咖啡，学鉴赏西洋油画，学跳华尔兹，学花袜子配牛津鞋，学标准普通话和英式英语……如果不是城里没有培训班，曹啸东很可能会去学打马球，查尔斯王子爱玩的那种。他个头一米八五，班长和体育老师常游说他加入篮球队，他的回答是不屑地微微一笑。读研时他买回蒸汽熨斗和熨衣板，跟个英国人似的，每天穿熨得一丝不苟的衬衣长裤去见导师。孙娟第一次跟他上床，发现他居然戴着箍在大腿上的衬衣夹子吊带（那玩意长得像女士吊袜带，用来拽住塞在裤子里的衬衣衣襟，令之不随上身动作乱窜），笑得满床打滚。</li><li>一旦确定孙娟将成为人生一部分，他的规则就像爬山虎的藤，一条条往她身上蔓延。听通俗歌曲没品位，得听山羊皮和齐柏林飞艇——“不能让灵魂吃垃圾食品”。烟熏妆、铁钉choker、长统靴，低级，要穿赫本那样的白衬衣、束腰伞裙、平底鞋。出去吃饭，供应拉条子、锅包肉、小鸡炖蘑菇的东北馆子，档次太低，要去就去西餐厅，或日料店。《神奈川冲浪里》的棉布帘底，厚瓷酒器如花瓶，斟出一小盅碧绿梅子酒。寿司摆在筏子似的长方碟里，筷子尖如长针，轻巧地啄起一块肉，在鸟屎大小的一坨上蘸蘸。摆在筏子似的长方碟里，筷子尖如长针，轻巧地啄起一块肉，在鸟屎大小的一坨上蘸蘸。</li><li>也是很久之后，孙娟才知道他没说实话，没完全说实话。他想要儿子，是想要一个小号的、克隆的自己，把自己从头养育一遍。</li><li>去年春节他们回老家，住了五天，不管曹啸东怎么努力营造一个精神真空舱，球球还是迅速学会了“啥”“咋啦”等刺耳的方言词，又在不知哪个亲戚家孩子手机上看了《熊出没》，并且没出息地迅速爱上，跟着那群孩子乱喊“熊大，你等等俺”</li><li>他惬意得像鼹鼠待在洞里，海豚待在海里。其余人都是访客，是聒噪的割草机，是闯入的潜水员。曹啸东心里泛起熟悉的酸楚，这人年纪跟他差不多，命运的手无意中哆嗦一下，悠然坐在这里的也可以是他。他慢慢走过来，笑道，听您跟高老师谈话特别有收获，您也是画家吧？</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假如我们的语言是威士忌读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%81%87%E5%A6%82%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A8%81%E5%A3%AB%E5%BF%8C/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%81%87%E5%A6%82%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%AD%E8%A8%80%E6%98%AF%E5%A8%81%E5%A3%AB%E5%BF%8C/</url>
    
    <content type="html"><![CDATA[<ul><li>我也作出了努力，争取把我在旅途中品尝到的各具特色的威士忌的风味、其令人意犹未尽的口感以及在那里认识的“沁入威士忌”的人们的印象完整地转换成文字形式。书诚然不足为道，但您读后（哪怕您滴酒不沾）若能产生“啊，是啊，真想一个人跑去远处什么地方，喝一口那里的美味威士忌”那样的心情，作为作者就喜出望外了。</li><li>不过一般说来，艾莱岛之所以声名远播，原因并不在于其隐士遁世一般的风土，也不在于飞禽走兽的数量和种类之多，而在于这里生产的威士忌的香醇，一如古巴以雪茄闻名、底特律以汽车闻名、阿纳海姆以迪斯尼乐园闻名。</li><li>刚喝的时候有一股强烈的土腥味儿，涩嘴刺舌。随后慢慢变得圆润，口感柔和起来。鲍摩尔正好介于二者之间，平衡得恰到好处，即所谓“分水岭”。但无论味道变得如何轻淡和柔润，那种“艾莱味”依然如烙印一般久留不去。</li><li>“我所以喜欢造威士忌，是因为这活计很浪漫。”吉姆说，“等我现在酿造的威士忌拿到世上的时候，有可能我已不在这个人世了，但那东西是我酿造的，你不认为这很妙？”</li><li>我于是照做。在饭店要了一盘生牡蛎加两杯纯麦芽威士忌，把威士忌满满地浇在壳中的牡蛎上面，直接放到嘴里。唔，实在好吃得不得了。牡蛎的海潮味和艾莱威士忌那海雾般独特的氤氲感在口中融为一体。不是哪一方靠近，也不是哪一方接受，简直就像传说中的崔斯坦与易梭德 (9)一样。然后我把壳中剩的汁液和威士忌一起“咕嘟”咽下。如此俨然举行仪式一般重复了六次。真可谓人间天堂！</li><li>我一般干喝一半。也许是天生小气的关系，总觉得好东西用水掺和了未免可惜，横竖得干喝掉一半，然后停顿一下，加水进去，将杯子绕着大圈摇晃。水在威士忌中缓缓旋转，清澈的水和动人的琥珀色液体描绘出了由比重差带来的流畅纹路，稍顷融为一体。那一瞬间甚是美妙。</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>可能性的艺术笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="序言-可能性的艺术：通过比较理解政治"><a href="#序言-可能性的艺术：通过比较理解政治" class="headerlink" title="序言 可能性的艺术：通过比较理解政治"></a>序言 可能性的艺术：通过比较理解政治</h1><ul><li><p>我并不知道世上还有什么“米兰达警告”，只觉得脑袋里“咯噔”一声，用我们今天的话来说，叫“三观碎了一地”——这个人是犯罪嫌疑人，居然还有“保持沉默的权利”？沉默居然还可以是一种权利？一个人做了错事，难道不应该老实交代吗？就算你没做错事，你交代清楚不就得了吗？但是，不，至少这个世界上有一部分人并不这样认为。他们认为让人自证其罪是不人道的，他们担心这种“坦白从宽”的观念会造成或者恶化刑讯逼供，他们认为在强大的国家权力机关和弱小的被逮捕的个体之间应该有一个作为缓冲力量的第三方，也就是律师。</p></li><li><p>commitment），使得民众获得了前所未有的财产安全感，产生了投资、生产、创新的动力，最终触发了工业革命。这种看法被称为“制度主义”，直到今天，还有很多经济学家都是制度主义者。</p></li><li><p>举个例子。菲律宾在1946年刚独立的时候，它的宪法和美国宪法非常像。原因是，在那之前，菲律宾是美国的殖民地，所以它的宪法是在美国的指导下制定的。但是，结果大家都知道，菲律宾后来的发展，无论是民主制度，还是经济发展，都不像是美国，离发达国家都很遥远。所以，同样的宪法，“淮南为橘，淮北为枳”。</p></li><li><p>所以，虽然政治非常重要，但是政治也是有限的。一个社科学者如果没有这种专业谦卑，就容易成为井底之蛙。理解政治，有时候恰恰要从政治之外着手。只有通过研究政治与其他因素的“化学反应”，我们才能真正理解世界政治的多样性。也正是因为“政治在社会中”，因为“淮南为橘，淮北为枳”，所以研究比较政治学的目的，不是为了寻找一个“放之四海而皆准”的政治配方，也不可能找到这样一个政治配方。</p></li><li><p>很遗憾地告诉大家，社会科学的思考，包括政治学的思考，没有一劳永逸的答案，没有那个 punchline 。社会科学的思考就像是开车，需要时刻警觉，时刻观察路况，并根据路况随时调整速度和方向。一刹那间的走神，就可能导致车毁人亡。这听上去的确很累，但也是唯一安全的做法。世界是复杂的，但又不是随机的，知识也应当如此。求知的道路，意味着永恒的疲倦以及偶尔的惊喜。</p></li></ul><h1 id="第一章-全球视野"><a href="#第一章-全球视野" class="headerlink" title="第一章 全球视野"></a>第一章 全球视野</h1><h2 id="政治比较的维度"><a href="#政治比较的维度" class="headerlink" title="政治比较的维度"></a>政治比较的维度</h2><ul><li>所以，衡量政治发展，应该是两个尺度，一个是衡量民主问责，一个是衡量国家能力，二者缺一不可。如果用一个比喻，或许可以说，国家能力是一个政治体系的发动机，而民主问责则是一个政治体系的方向盘。没有良好的发动机，一辆车根本跑不起来，方向再正确也没有用，它只能在原地打转，但是光有很厉害的发动机，一路狂奔，越跑越快，根本不听民众指路，最后也很有可能开到悬崖底下去。</li></ul><h2 id="和平的“爆发”：一个黄金时代？"><a href="#和平的“爆发”：一个黄金时代？" class="headerlink" title="和平的“爆发”：一个黄金时代？"></a>和平的“爆发”：一个黄金时代？</h2><ul><li><p>再来看另外一个指标，战争死亡人数。这方面，学者平克（StevenPinker）做出了最有影响力的研究。事实上，他专门写了一本书来告诉我们“世界正在变得更好”。这本书可能很多人都读过，叫《人性中的善良天使》——这可能也是21世纪最重要的书之一。大家可能听说过一个词，叫作“政治性抑郁”，这本书可以说专治各种“政治性抑郁”。反正每次翻这本书，我整个人就都变好了，连血糖、血脂都刷刷下降了。</p></li><li><p>你可能会说，啊，阿富汗已经这么惨了，居然以前更惨？是的，阿富汗人民以前真的更惨。我们之所以没有意识到这一点，很大程度上是因为人类天生更关注现实而不是历史，而且我们习惯于用理想而不是过去来衡量当下。</p></li><li><p>这些声音的初衷可能充满善意，但是，衡量现实不能仅仅以理想为尺度，而且要以历史为尺度，因为摧毁进步的不仅仅可能是所谓的保守势力，而且也可能是对完美乌托邦的迷恋。用英语中的一个常用句来说就是：不要让最好成为更好的敌人。</p></li></ul><h2 id="天下与我：国际格局的多米诺骨牌效应"><a href="#天下与我：国际格局的多米诺骨牌效应" class="headerlink" title="天下与我：国际格局的多米诺骨牌效应"></a>天下与我：国际格局的多米诺骨牌效应</h2><ul><li><p>霸权国家当然历史上常常有，自由国家在当今也不少见，但是信奉自由主义的国家同时是霸权国家，是历史上非常难得的组合。</p></li><li><p>美国不要再自作多情了，很多国家根本不想要西式的自由民主，他们想要的是民族自豪感，是宗教归属感，是文明的认同，你非要塞给人家你的自由主义，结果就是打打打，何苦要干这种吃力不讨好的事情？</p></li></ul><h2 id="全世界有产者联合起来？全球化的经济后果"><a href="#全世界有产者联合起来？全球化的经济后果" class="headerlink" title="全世界有产者联合起来？全球化的经济后果"></a>全世界有产者联合起来？全球化的经济后果</h2><ul><li><p>这个看法的逻辑是这样的：经济全球化虽然给跨国公司带来了巨额利润，给中国、印度这样的新兴市场带来了大发展，却牺牲了西方国家的蓝领工人，尤其是制造业工人。为什么？因为很多工作都跑到发展中国家去了，就算是留在发达国家的工作，工资也被压低了。这些被经济全球化抛弃的人一气之下动员起来，把右翼政治家选上了台。</p></li><li><p>所以，在美国蓝领工人眼里，他们花了一两百年斗争换来的工人权益——最低工资、最高工时、休假补助、医疗保障、集体谈判权……这些东西在全球化形成的连通器面前，突然变得没有意义了。全球化一个浪头就把他们打回了“丛林世界”。有研究显示，过去40年左右，美国蓝领阶层的真实工资水平，也就是扣除了通货膨胀之后的工资水平，没有变化。如果经济没有发展，那么真实工资不变也就认了，问题是，这恰恰是一个经济大发展的时代，只不过CEO们财富爆炸性增长，白领阶层也与有荣焉，只有蓝领工人成为“没有赶上火车的人”。还有研究发现，21世纪以来，教育水平低的白人男子，也就是白人蓝领阶层，是美国唯一自杀率在显著上升的群体。或许，只有放在全球化冲击的背景下，这个奇怪而令人悲伤的现象才能得到解释。</p></li><li><p>在很多中国人看来，这没有什么不公平的，政府在经济中保持重大角色，经济保持相当的国有成分，本来就是中国特色，这就是我们的经济模式，为什么一定要按你们的模式来下棋？</p></li><li><p>何以如此？根据罗德里克的说法，如果想要全球化和主权国家，就很难兼顾民众问责——问责政治捆住政府手脚，使政府很难大刀阔斧地行动，营造竞争性的投资环境；如果想要主权国家和民众问责，那老百姓可能就会选择关起门来，减少竞争压力，不搞全球化；如果想要全球化和问责制，那就得全球各国一起决定税率、工资水平、知识产权政策、汇率政策等，免得资本家到处寻找税收洼地、劳工权利洼地，但是，那样的话，就得放弃国家主权。因为哪一个都很难放弃，所以就构成了一个“三难困境”。</p></li></ul><h2 id="为什么瑞典也如此排外？全球化与文化反弹"><a href="#为什么瑞典也如此排外？全球化与文化反弹" class="headerlink" title="为什么瑞典也如此排外？全球化与文化反弹"></a>为什么瑞典也如此排外？全球化与文化反弹</h2><ul><li>毕竟，人不仅仅是理性的动物，也是认同的动物，他者越有可能吞没“我们”，就越需要强化甚至想象集体的“我们”来抵御他者。像塔利班这样的极端政权，干脆禁止西方音乐、电影，以这种方式来守卫他们心目中的伊斯兰文化。</li><li>正是因为这些原因，很多瑞典人慌了。他们发现，瑞典正在从一个“和谐社会”变成一个“二元社会”——两边的人说着不同的语言，穿着不同的衣服，信着不同的宗教，生活在不同的阶层。而且，由于不同族群的人口出生率不同，那个陌生的世界似乎会越来越大，而他们传统的世界似乎在缩小。根据皮尤中心的一个温和估算，2050年穆斯林将占瑞典人口的21%。30年后是21%，100年、200年后呢？应该说，一些瑞典人担心自己的传统文化被伊斯兰化也不完全是没有根据的。</li><li>有研究指出，“高税收、高福利”的经济模式之所以出现于北欧，一定程度上得益于它同质性的人口结构 —— 正是因为彼此文化、语言、宗教接近，才产生了深厚的社会信任，使得人们愿意交出很大一部分收入来扶助那些穷困潦倒者，一旦社会“二元化”，人们不再把彼此看作兄弟姐妹，他们还愿不愿意交同样高的税收、进行同样程度的财富转移，就变成一个问号了。</li></ul><h1 id="第二章-政治转型"><a href="#第二章-政治转型" class="headerlink" title="第二章 政治转型"></a>第二章 政治转型</h1><h2 id="“历史终结论”的终结？"><a href="#“历史终结论”的终结？" class="headerlink" title="“历史终结论”的终结？"></a>“历史终结论”的终结？</h2><ul><li>而民主政治作为一种“可重复博弈”，理论上本不必你死我活。但问题在于，由于威权体制下的文化遗产，转型国家中的很多政治力量，都愣是把一个“可重复游戏”玩成了“一次性游戏”。这次我赢了？太好了，我得把这次的胜利果实转化为永久的胜利果实，这就是袁世凯的做法。这次我输了？不可能，这不是真的，我要二次革命。这就是国民党的做法。于是，一个本可以是“风水轮流转”的故事，又变成了一个“你死我活”的故事。今天很多发展中国家的民主崩溃历程，尽管细节不同，逻辑却往往相似，它们往往都有自己的袁世凯和国民党，自己走向脱轨的辛亥革命。</li><li>过去两三百年，启蒙运动所创造的“主权在民”观念，像一匹巨大的马，把世界从走了几千年的既有道路上拽出来，往另一个方向拉去。起先可能举步维艰，因为任何新制度的启动都非常艰难，所以第一波、第二波民主化都更加缓慢、更加颠簸，但是，随着全球化的加速，随着观念传播的加速，尤其是随着早发民主国家的民主稳固，这匹马越跑越快，最终出现了壮观的第三波民主化浪潮。</li></ul><h2 id="法国往事：转型浪潮中的第一艘泰坦尼克号"><a href="#法国往事：转型浪潮中的第一艘泰坦尼克号" class="headerlink" title="法国往事：转型浪潮中的第一艘泰坦尼克号"></a>法国往事：转型浪潮中的第一艘泰坦尼克号</h2><ul><li>到了革命的高峰期，针对教会的“破四旧”轰轰烈烈地展开，教堂里的十字架被砸掉，含有圣徒名字的街名地名被更换，巴黎圣母院则干脆改名“理性殿堂”。可以说，革命自身成为一种新的宗教。</li><li>在任何国家，面对民众，恶都是很难被推销的。打压异己、剥夺自由是一种恶，直接推销它很难奏效，但是，当恶与善捆绑出现，人们却有可能为它慷慨解囊</li></ul><h2 id="印度：民主为什么“不管用”？"><a href="#印度：民主为什么“不管用”？" class="headerlink" title="印度：民主为什么“不管用”？"></a>印度：民主为什么“不管用”？</h2><ul><li>其实，很多国家历史上都有过类似的“职业世袭身份制”，像在英文世界里，叫Smith的就是铁匠出身，叫Miller的就是磨坊主出身。中国某些历史阶段也有过类似的制度安排，比如明朝就有军籍、匠籍、灶籍等职业身份。但是，在其他国家，随着社会流动性的增加，这种制度就慢慢瓦解了。可是在印度，这种“职业身份制”却非常顽固。为什么呢？因为它被写进了宗教文本，内嵌于印度教，被神圣化了，所以打破它格外困难。我读到过一个报道，说一个新德里大学教授去喝茶，服务员还是会问他：“你是什么种姓？”当他说出自己是达利特人时，对方告诉他：“那麻烦你喝完茶自己洗杯子。”所以，即使这个人已经身为教授了，在高种姓的人看来，你碰过的东西，我还是不能碰。</li></ul><h1 id="第三章-国家建构"><a href="#第三章-国家建构" class="headerlink" title="第三章 国家建构"></a>第三章 国家建构</h1><h2 id="什么是国家？从墨西哥的毒贩集团说起"><a href="#什么是国家？从墨西哥的毒贩集团说起" class="headerlink" title="什么是国家？从墨西哥的毒贩集团说起"></a>什么是国家？从墨西哥的毒贩集团说起</h2><ul><li>我们当代人，尤其是中国人，在一个相对稳定的国家体系中生活了很久，容易忘记这种艰难。事实是，人类花了几千年才慢慢实现了权力的相对集中，目前 200 个左右的国家数量就是这种“相对集中性”的体现，因为如果是停留在部落社会，那么这个数字就不会是 200 个，而可能是 2000 个甚至 20,000 个了。</li></ul><h2 id="国家能力从何而来？战争"><a href="#国家能力从何而来？战争" class="headerlink" title="国家能力从何而来？战争"></a>国家能力从何而来？战争</h2><ul><li>因此，一个悲剧性的历史观察是：国家建构就像是买房，残酷的暴力冲突则像是付款，你可以选择大额首付，也可以选择大额尾款，或者漫长的分期付款，但是你却无法逃避付款。当然，历史是历史，生活在资源越来越丰富、文明越来越进步的当代，我们仍然希望，对于抵达政治秩序，人类能找到比相互杀戮更聪明的方式。</li></ul><h2 id="美国：国家建构的另类道路"><a href="#美国：国家建构的另类道路" class="headerlink" title="美国：国家建构的另类道路"></a>美国：国家建构的另类道路</h2><ul><li><p>但是，其实，放在美国的“反国家主义”传统下，这一点或许又不是那么难以理解。毕竟，美国这个国家的优势从来不是国家能力，而是个体创造性和社会活力，是乔布斯和马斯克，是爱迪生和迈克尔 · 杰克逊。碰到需要政府集中力量办大事的时候，除非是极大的危机来临，它往往团结不起来，经常是特别迟缓和笨拙，不同层级和部门之间打来打去、互相拆台。可以说，美国这个国家，由于对国家权力的极度警觉，导致了一种“制度化的混乱”。</p></li><li><p>所以说，这个世界上，比悲惨更可怕的，是不为人知的悲惨。一旦有了信息的开放和流通，社会就有了推动变化的杠杆。</p></li><li><p>固然，罗斯福个人的理念，对于联邦政府的角色改变起到了一定的作用，但是，罗斯福政府之所以能够成立这么多机构，大刀阔斧地做这么多事，根本而言，是因为他背后有汹涌的民意。罗斯福新政有多受欢迎呢？这从 1936 年罗斯福竞选连任时的得票率就可以看出。当年的总统选举，罗斯福得到的选举人团票是 523 张，其对手只有可怜的 8 张。</p></li><li><p>从美国国家能力的巨变来看，我们发现了一条不同的国家建构道路，它的核心动力不是密集的战争或者发达的文官制，而是社会运动。一代又一代的美国人，通过街头的、媒体的、工会的、校园里的声音改变了政府的角色，改变了联邦和地方政府的关系，乃至改变了美国社会的“国家观”。</p></li></ul><h1 id="第四章-政治文化"><a href="#第四章-政治文化" class="headerlink" title="第四章 政治文化"></a>第四章 政治文化</h1><h2 id="韩国电影中的革命：观念的水位与制度的变迁"><a href="#韩国电影中的革命：观念的水位与制度的变迁" class="headerlink" title="韩国电影中的革命：观念的水位与制度的变迁"></a>韩国电影中的革命：观念的水位与制度的变迁</h2><ul><li>具体到韩国当年，学生们为什么要放弃大好前程去与威权政府抗争？最重要的原因，就是他们接受了那种把政治权利放在个人利益之上的价值体系。根据这种价值体系，“生命诚可贵，爱情价更高；若为自由故，两者皆可抛”。所以，你观察电影里那些示威者喊的口号，不是什么具体的利益诉求，至少主要不是具体的利益诉求，比如工资、养老金、物价、就业、住房，等等，而是什么？民主权利本身。</li><li>《辩护人》讲的就是这样一个故事，一个本来唯利是图的税务律师，因为一个朋友的儿子被刑讯逼供，最终走上了“反抗者”的道路。《出租车司机》里的那个司机，《1987》里那个清纯的女学生，《华丽的假期》里面的女护士……也都是本来完全不关心政治，但是，因为不堪忍受国家暴力而加入抗争。这些情况一而再再而三地出现让他们慢慢意识到，除非权力结构改变，这些不对是不能被系统纠正的</li><li>但是，到最后，我发现，这种源于道德直觉的正义感有种令人敬畏的天真。你会发现，当所有政治的泥沙沉淀、所有理论的波涛平息、所有流行的趋势过去，最终，这种无与伦比的天真还是会从水底浮现。它熠熠的光芒，还是会诱惑你向它伸</li></ul><h2 id="何为民主文化？泰国困局"><a href="#何为民主文化？泰国困局" class="headerlink" title="何为民主文化？泰国困局"></a>何为民主文化？泰国困局</h2><ul><li><p>从泰国当代极简史可以看出，我们可以批评泰国政治和社会中的种种问题，但是唯独不能批评泰国民众没有政治参与精神。2005—2015年这10年左右，泰国人民简直是无时无刻地在进行政治参与，黄衫军、红衫军，你方唱罢我登场，街头运动成为一个永不落幕的剧场。</p></li><li><p>问题恰恰出在泰国人太有政治参与精神了，让民主的街头逻辑碾压了民主的选票逻辑。没有边界感和节制感的政治参与，让泰国的民主每次都是刚刚被建立，就又被推翻。过度的政治热情、过高的政治要价、过于急迫的政治通牒以及“不达目的决不罢休”的战斗精神，每每让泰国的新生民主不堪重负，走向崩溃。</p></li></ul><h2 id="恶真的平庸吗？暴民考古学"><a href="#恶真的平庸吗？暴民考古学" class="headerlink" title="恶真的平庸吗？暴民考古学"></a>恶真的平庸吗？暴民考古学</h2><ul><li><p>角色 A ，只是负责登记犹太人的信息；角色 B ，只是依法没收了犹太人的财产；角色 C ，只是负责把犹太人送上火车；角色 D ，只是集中营的保安 …… 甚至，角色 Z ，可能什么也没有干，只是在这一切发生的时候，把头转了过去。但是，如果这些艾希曼们能够跳出自己的身份碎片、跳出“此时此刻”，从一个更高、更大的图景去看待自己的所作所为，他们会发现，是的，“我”，作为一个个体，的确没有杀人，但是“我们”，作为一个集体，却杀了无数人。</p></li><li><p>事实上，在我看过的所有纳粹历史记录中，几乎所有的纳粹分子都觉得自己很冤，在他们看来，我只是一万分之一，做了0.001%的恶，你们却把我当作100%的恶棍来审判，这也太不公平了。殊不知，他可能对每一个受害者的死只需要负0.001%的责任，但是他要对几百万个人的0.001%负责，即使从数学上来说，他手上所沾染的鲜血也是无数生命了。</p></li><li><p>在法庭辩护中，艾希曼不断强调自己只是个政策的执行者，却不谈论他如何把自己放到执行人的位置上去，这显然是避重就轻。这就像一个醉汉不断宣称，自己因为别人劝酒而喝醉了，却不提及是自己主动走到“别人的”酒席中去。艾希曼的恶，不仅仅是“平庸之恶”，而恰恰是“不甘平庸之恶”。</p></li></ul><h2 id="文明的冲突：一个过时的预言？"><a href="#文明的冲突：一个过时的预言？" class="headerlink" title="文明的冲突：一个过时的预言？"></a>文明的冲突：一个过时的预言？</h2><p>一种常见的否认政治文化差异的方式，就是以文化内部的多样性，去否认一个文化总体的价值倾向性。比如，如果我说，中国人倾向于有更强烈的民族主义观念，可能立刻有人会说，“我就认识谁谁谁，他完全没有民族主义观念”；或者如果我说，穆斯林世界对同性恋更缺乏宽容，可能立刻有人会说，“我就认识哪个哪个穆斯林，他们完全能够接受同性恋婚姻”。显然，我相信，每个文化内部都会有多元的声音，但是，我理解的文化差异，不是指每个文化铁板一块、万众一心，而是指在特定的历史时刻，每个文化圈的“平均观念水位”或者“中间观念水位”的位置不同。</p><ul><li><p>另一种否认政治文化差异的方式，是以每个文化内部的演进性，去否认一个文化在特定历史时刻的倾向性。比如，有一次，我和一个朋友说到巴基斯坦的“荣誉谋杀”。所谓“荣誉谋杀”，大家可能听说过，就是一个男性，因为他某个女性亲属做出什么“有伤风化”的事情，比如通奸、私奔，甚至仅仅因为穿着有点暴露，就直接把这个女人给杀了。讲到这个现象时，我表示很愤怒，我这个朋友的第一反应就是：基督教国家以前也非常歧视女性，中国不也是，等等。显然，基督教世界历史上有过烧女巫现象，中国古代也有过将通奸女性“浸猪笼淹死”的现象，这和今天巴基斯坦的“荣誉谋杀”相比，其残忍程度，简直是有过之而无不及。但是，当我们谈论文化差异的时候，我们是在谈论“特定的历史时刻”的差异，也就是在同一个时间的横切面里，不同文化是否存在着价值差异。毕竟，文化的冲突是发生在特定的历史时刻，400年前的英国人可能比今天的巴基斯坦人更加保守，但是他们不会相遇，会相遇的，是今天的巴基斯坦人和今天的英国人，所以特定历史时刻的文化落差很重要。</p></li><li><p>第三种否认政治文化差异的方式，是以“普世价值”去否认文化差异的存在。根据这种观点，世界上存在着普世的价值，因为“人同此心，心同此理”，大家都是人嘛。因此，我们能够观察到文化差异，“其实”仅仅是政治差异，无非是一些统治者以高压方式蒙蔽人心，一旦高压消失，“虚假观念”也会随之消失，普世价值自然就浮现出来了。</p></li><li><p>儒家文明圈呢？似乎也没有拧成一股绳。在2019年皮尤的民调中，[1]全球对中国的正面印象比例最低的，居然是日本——只有14%的日本人对中国印象正面，而85%选择了负面。其他邻国也好不到哪里去，韩国选择正面印象的为34%，印度为23%，印尼为36%……事实上，亚太地区对中国印象正面的比例，平均而言，比非洲、拉美甚至欧洲更低。可见，相似的历史、文化、传统，未必是同盟的保证。事实可能相反，距离有时候反而更产生美。</p></li><li><p>从这个角度来看，很难说中美目前的矛盾在多大程度上是“文明的冲突”，在多大程度上是利益的冲突、权力的冲突。比如华为和TikTok的争端，这里面“文明的冲突”成分可能很少。简单而言，就是两大强国在科技前沿、科技市场份额上的利益竞争。老实说，华为当年努力学习IBM的管理模式、TikTok体现的娱乐主义，这里面借鉴的，恰恰是当代西方文化的精神。如果不是因为利益竞争，美国应该为西方文明的传播而高兴才对。</p></li><li><p>这个案子具体谁对谁错，不是我们这次课要讨论的。值得关注的，是这场斗争中激烈的价值冲突。在支持同性恋者权利的一方看来，他们的平等权利被杰克给践踏了；在支持杰克的一方看来，他们的宗教和言论自由被州政府给侵犯了。一方要平等，一方要自由，这是典型的价值冲突。大家都知道，过去几年，这种冲突在美国愈演愈烈，从历史雕塑到变性人的称谓，从奥斯卡的获奖标准到教授们的言论尺度，处处都是文化战争的号角。</p></li></ul><h2 id="第五章-政治经济"><a href="#第五章-政治经济" class="headerlink" title="第五章 政治经济"></a>第五章 政治经济</h2><h2 id="智利：皮诺切特之后"><a href="#智利：皮诺切特之后" class="headerlink" title="智利：皮诺切特之后"></a>智利：皮诺切特之后</h2><ul><li>这些改革，有些或许有必要，有些则仅仅是对政治压力的妥协。无论是智利还是其他国家，恐怕都不能忘记一个历史教训：在现实世界中，选择往往不是在“更好”和“最好”之间，而是在“更糟”和“不那么糟糕”之间。环顾委内瑞拉、巴西、阿根廷的经济发展轨迹，我怀疑，如果自由经济模式在智利被连根拔起，在废墟中生长出来的，未必是</li></ul><h2 id="委内瑞拉：如何毁掉一个国家？"><a href="#委内瑞拉：如何毁掉一个国家？" class="headerlink" title="委内瑞拉：如何毁掉一个国家？"></a>委内瑞拉：如何毁掉一个国家？</h2><ul><li>大家想想看，一边是生产成本急剧地通货膨胀，一边是商品不让涨价，结果是什么？结果当然是商店关门大吉了。于是，委内瑞拉的短缺经济变得更加严重。我看相关报道的时候，有一个小细节印象很深，因为短缺经济造成人们到处排长队买东西，而政府觉得超市门口到处排长队太有损国家形象了，于是发明出各种办法限制排队，比如，只能在超市后门或者车库排队，或者人们按照身份证号码轮流出门排队，比如，身份证尾号是1，周一排队，尾号是2，周二排队，等等，可以说是各种荒诞不经。</li></ul><h2 id="新镀金时代？不平等的幽灵"><a href="#新镀金时代？不平等的幽灵" class="headerlink" title="新镀金时代？不平等的幽灵"></a>新镀金时代？不平等的幽灵</h2><ul><li><p>不过，说到不平等，其实最严重的既不是发生在美国，也不是发生在中国或者任何具体的国家，而是发生在一个更广阔的范围内——全球各国之间。这是一个极其重要却很容易被人忽略的视角，因为我们常常把国家作为思考的容器，而这个容器有时候对思维会构成障碍。这方面，经济学家米兰诺维奇（BrankoMilanovic）的研究令人印象深刻。根据他2011年发表的研究，美国最穷的5%的人口，和印度最富的5%的人口的收入重合，也就是说，印度最富的5%的人口，平均收入和美国最穷的5%的人口的平均收入差不多。喀麦隆顶部5%的人口，和德国最穷的5%的人口重合；英国最穷的人和津巴布韦最富的人，有8%的重合度；等等。所以说，富国的穷人对于本国的富人来说是不幸的，但是对于穷国的穷人来说，又是相当幸运的。</p></li><li><p>我一直相信天赋、才华在人群中大体而言是均匀分布的，但是，由于出生不平等、教育不平等，事实是，我们都知道，科学家、律师、艺术家从留守儿童中出现的比例要远远低于城市中产家庭。如此之多的才华、天赋、梦想，仅仅因为出生而被埋没，真的是细思极恐。</p></li><li><p>第一个背景知识是，不平等是什么经济水平上的不平等？不同经济基础上的不平等，其分量是很不同的。简单来说，穷得吃不起饭，和穷得去不起夏威夷度假，含义很不同。如果我的生活能维持小康，那么我其实不介意比尔·盖茨比我富有1000倍、1万倍、100万倍。但是，如果我食不果腹、衣不蔽体，那么，盖茨就算只比我富两倍，我也会感到义愤填膺。当年中国闹革命“打土豪、分田地”的时候，其实很多地主富农的财产，用我们今天的标准来看，也几乎是一贫如洗，但是这并不妨碍贫下中农对他们充满怨恨，原因就在这里。</p></li><li><p>第三个背景知识是社会流动性。如果贫富悬殊和阶层固化同时出现，那的确非常可怕。我们在北京的写字楼看到一个年轻保安，内心有不安，是因为我们知道，他现在的收入和技能，很难帮助他实现向上流动，我们知道他被“困住”了。但是，我们看到一个法学院的学生，哪怕他欠一屁股债，多半也不会感到同情，因为我们知道，他的贫困是暂时的。更形象地说，如果住在一楼的人和住在三楼的人在不停地交换位置，哪怕一楼和三楼的层高在不断拉长，这个越来越长的距离本身，其实没有那么可怕。</p></li></ul><h2 id="政治的可能与不可能"><a href="#政治的可能与不可能" class="headerlink" title="政治的可能与不可能"></a>政治的可能与不可能</h2><ul><li><p>is the art of the possible, the attainable-the art of the nextbest.”政治是可能性的艺术、可行性的艺术，是次优的艺术。这个完整说法，更清晰地呈现了它的“政治现实主义”指向。</p></li><li><p>大家也许会对我这种“不对称的”的说法有点困惑，为什么政治可能让社会变得非常糟糕，却未必会让生活变得非常美好？这是因为，在我看来，政治可能扼杀所有的社会关系和个人努力，但是它却不可能替代所有的社会关系和个人努力。什么意思呢？就是当政治非常糟糕的时候，比如一个极权政府掌控一切，它可以摧毁人们的生产积极性、自发的社会组织、家庭乃至人性，使所有人的生活变成一场噩梦。可是，另一方面，当政治非常好的时候，它也只是制定一个相对公平的游戏规则——我前面讲到过，一场球赛踢得精不精彩，公平的游戏规则只是一个必要条件，绝不是一个充分条件，因为球赛踢得精不精彩，除了游戏规则，还要取决于球员们技艺是否高超、配合是否默契。在这个意义上，好的政治注定只是美好生活的前一半，而后一半则取决于社会、市场、文化以及每个人的努力。这种不对称，就是我所理解的“政治现实主义”。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>烧纸读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%83%A7%E7%BA%B8/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%83%A7%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="为了大家的安全"><a href="#为了大家的安全" class="headerlink" title="为了大家的安全"></a>为了大家的安全</h1><ul><li>拔掉了似的露岀一片头皮，皮肤是久经太阳暴晒后的黑红色，粗糙到让人完全猜不出实际年龄。衣服好像穿了一辈子都没换过,破烂得不成样子,袖口磨得锂亮，早已看不出原来的颜色。还有身上散发的味道，有点像腌透的虾酱，又腥又骚，直冲京哲的鼻子,像是执着地提醒他到光州之前要跟这位老太婆坐在一起的事实。</li></ul><h1 id="火与灰"><a href="#火与灰" class="headerlink" title="火与灰"></a>火与灰</h1><ul><li>阴暗狭窄的市场小巷里拥挤着许多破旧的餐馆。刚一进去,排列整齐露出浑圆脚趾头的猪蹄，像刚洗了个澡一样白白净净地微笑着的怦猪头，还有油腻黑亮的牛肥肠映入我的眼帘。还有猪肉味、油炸食品刺鼻的食用油的味道，不断刺激着我空荡荡的胃,令我不得不努力抑制呕吐。</li><li>永生和复活。每每听到这种说辞时，我都无比愤怒。因为我实在无法接受居然用这种方式去解释和抚慰一个孩子的死亡。如果真能给一个三岁孩子的死准备永生和复活，那么为什么要放任他的死亡？难道，一个刚刚开始观察和学习这个世界的天真无邪的孩子,他的突然死亡还藏着某种法则和天意吗？但是妻子却固执地深陷其中，忽然间比迷信的人更加虔诚地出入过去从未去过的教堂，试图用赞美歌和祈祷来战胜痛苦。我不相信妻子能从中得到救赎，也不知道能使她摆脱痛苦的其他方法。过去的一年，即使在睡觉时我们也努力不触碰到对方，就好像一旦触碰到对方身体，痛苦也会传递给对方。她总是背过身去小声祈祷或是低声抽泣。而我只能努力假装什么也没有听到。</li><li>出租车在高架桥的桥墩间穿行，桥上行驶着电车。街道上正在平静地结束一天。头顶上电车怪叫着呼啸而过，公交车挤满了泥塑般面无表情的人，朝某个地方驶去。而我却像染上恶寒一样瑟瑟发抖。胸腔像被撕裂一样的疼痛和炙热的喜悦充满了我的体内。刚才我分明看到了，逐渐被夜幕吞噬的巨大混凝土桥墩之间，一个浑身燃烧着火焰的人。可是他没有坠落，而是穿透了死亡，正在上升。</li></ul><h1 id="祭奠"><a href="#祭奠" class="headerlink" title="祭奠"></a>祭奠</h1><ul><li>我们拥有自己的房子时，我已经升入高中了。我们在城郊市场里盘下一个小店面。我至今还记得石棉瓦屋顶的房子蒸腾着热气和恶臭，屋外还有永不停歇的喧闹声。扁长的建筑像大型养鸡场一样，被水泥板隔成一间一间，在这里，人们的生活跟集中饲养的家畜没什么两样。建筑物之间的道路上方被蓝色的塑料板遮住，所以连阳光也是蓝色的。这是令人非常憋闷的地方。母亲的缝纫店上面的阁楼就是我和弟弟的房间。石棉瓦屋顶矮得伸不宜腰，所以我只能穿着内裤一直躺着。到了夏天，阳光烤热了屋顶，阁楼就会变成汗蒸房，热得只穿内裤也会汗流泱背。尼龙炕板也会变得黏黏糊糊。躺在黏腻的汗水里，能听到附近店铺收音机的音乐声，还有母亲踩缝纫机的声音，而且每天准会听到一两次激烈的争吵，我一边拼命手淫，一边绝望地想：呵，这也算是活着么？这么活着也敢说是活着么？</li></ul><h1 id="烧纸"><a href="#烧纸" class="headerlink" title="烧纸"></a>烧纸</h1><ul><li>会道的人，嘴上总说什么都能干的家伙，一边给父母兄弟和自己的儿女惹祸，不让他们好好过日子，一边唱各种高调，要为了什么理想去死，其实都是些为了什么目的害死别人的家伙。用一句话说，你们就是赤色分子。”</li><li>腕表是妻子送给我的新婚礼物。虽然标着“瑞典制造”，但不知道是不是假货，从来没有准过，弄得我养成了经常对表的习惯。这腕表就像婚姻生活的某种象征，我一直无法摆脱这种令人不快的预感。</li></ul><h1 id="大雪纷飞的日子"><a href="#大雪纷飞的日子" class="headerlink" title="大雪纷飞的日子"></a>大雪纷飞的日子</h1><ul><li><p>“我实在是合不了格。中队长，我眼睛不好。”“配眼镜戴上不就行了吗？”“我得出去才能配眼镜，不是吗？ ”“想出去就通过考核，臭小子。”</p></li><li><p>”你说什么？”他明白自己首先越过了两个人之间那条看不见也不能触碰的危险的警戒线。这份醒悟反而让他说出了更多的话。于是两个人开始互戳对方的痛处，他们的武器就像一支两头尖利的长枪，尽管彼此都清楚刺向对方的同时自己也会流血，可他们却愈发疯狂地互相攻击之后才结束这场战斗。</p></li></ul><h1 id="一头有心事的骡子"><a href="#一头有心事的骡子" class="headerlink" title="一头有心事的骡子"></a>一头有心事的骡子</h1><ul><li>的堤坝来往几次，把垃圾倒在还未建成工厂的空地上。转眼间这些垃圾铺满田地，堆了一大片，让人不免怀疑这座城市或许是一头巨兽，每日都得换一次毛，又或是一位肠胃不好的老人，把吃进去的东西全给吐了出来。隶属于市政府清扫科的清洁工大杞，他的工作就是一天两次赶着骡子奔波在城里的各个角落，搜集清理这些垃圾。</li></ul><h1 id="战利品"><a href="#战利品" class="headerlink" title="战利品"></a>战利品</h1><ul><li>这事儿奇怪吧 , 还没疼的时候，我一直不知道这个叫肝的东西在我们身体里有啥用。肝疼的时候才知道肝的存在，就像阑尾疼的时候，才知道阑尾的存在。曰：存在即痛苦，痛苦即存在啊。</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网内人读书笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%86%85%E4%BA%BA/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BD%91%E5%86%85%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<hr><p>第七章</p><ul><li><p>然而，周绮蓁不晓得的是，尽管区辉的老板不用付钱，他也不希望保险公司赔偿巨款。因为这样会影响公司的“信用额”。只要赔偿个案成立，即便付款的是保险公司，也会令投保的企业信用额受损，往后保险公司便会要求该企业付更高的保险费。周绮蓁就是不明白这个道理，以为资方会替员工向保险公司争取最大补偿，殊不知对方是一丘之貉。</p></li><li><p>香港的荣景，就是建立在被牺牲的草根阶层之上。大企业剥削小企业，小企业剥削工人，在老板们眼中，商业利益比个别工人的家庭前途更重要，哪怕那丁点利润不过占这些老板们财产的万分之一。</p></li></ul><p>第九章</p><ul><li>“区小姐，”架着金边眼镜、西装笔挺的主任抬起头，直视着阿怡双眼，“我很同情您的处境，不过您知道目前有多少家庭在轮候公屋吗？我们不尽快处理每一个个案，那些家庭就只能继续住在更狭小、更不堪的房子里。您说我们‘不近人情’，那您无视那些苦等多年还未‘上楼’的大众，不就是‘自私自利’吗？”</li><li>“区小姐，您别看我好像高薪厚禄，其实我一样为每个月的房贷头痛。今天连死过人的私人楼宇也一样索价几百万，香港就是如此一个居住环境恶劣的城市。在这儿生活，我们只能逆来顺受，世事未必尽如人意，凡事别那么执着就好。”</li></ul><p>第三章</p><ul><li>“豪哥，那女学生上个月自杀死了，说不定她真的在地铁被侵袭，所以才会以死证明清白，这种死人财，赚了也损阴德啊。”马仔皱了皱眉。“马仔，你太嫩了。”阿豪摆出一副老气横秋的姿态，像说教似的，“世间财没有分什么积阴德或损阴德，钱就是钱，Money is money.就像股票市场，你趁高位卖出赚钱的股票，接货的投资者被套牢，账面亏一大笔，那你说算不算赚肮脏钱？如果你坚信因果报应，那你又怎么知道那女学生跳楼自杀，会不会也是报应？假如每件事也要衡量因果，那说不定你今天开发的程序，导致他日某个家庭发生悲剧，你又要负责吗？所以我说，钱能赚便去赚，只要不犯法、不会被控告便可以赚。花生讨论区还有成人征友版，一大票援交妹假征友真卖身，花生从这版面的点击数获取盈利，不就跟皮条没分别？但法律一天不禁止，他们就能理直气壮地赚钱啊！在这个城市里，唯有强者才能生存，我们不想成为被剥削的一群，就只有成为剥削他人的阶层，别天真地以为什么‘好人有好报’，这种想法已经过时。这是香港的法则，是资本主义、市场定律下的黄金法则。”</li><li>怎么吃碗面也这么龟毛——阿怡心里骂道。</li><li>一流黑客都精通这门技术，就是通过社交手腕获取系统的切入点，以交谈或伪装偷取账密，甚至是借他人之手完成侵入。”阿涅冷笑道，“因为天下间最容易击破的‘最弱一环’，就是‘人类’。电脑系统能随岁月发展得更完善，但人性弱点却永远无法改变。”</li></ul><p>第五章</p><ul><li>“她不会让自己——和学校——惹上如此大的麻烦。假如她真的跟你妹妹有什么血海深仇，她也不会利用网路抹黑制造舆论，因为这会连累她的工作。对她来说，她希望学生们都像工厂的原料，毫无个性地注入相同的模具复制成相同的人偶，再送进名为社会的机器里，成为不起眼的齿轮。因为她也视自己是这样的一枚齿轮罢了。”</li><li>事实上，她惊觉自己对那段日子的记忆近乎空白，每天公式化地起床、上班、回家跟家人吃饭、睡前读读小说、入睡。单调而重复的生活，就像纯粹将时间兑换成金钱，目的只为增加银行存款支撑家庭，过程毫不重要。</li><li>“人啊，就是一种既善忘又自私的动物。”阿涅语气平静，表情跟之前没两样，但阿怡隐约觉得他暂时卸下了面具，“寻求他人原谅，不过是一种利己主义的投影，因为得到对方的谅解，自己就可以洒脱地大步向前走了，但说到底，那不过是伪善。你觉得小雯不会原谅你嘛，那你就背负着这份愧疚，无时无刻记住你曾经亏待了一位好朋友，而且你永远无法补偿。你余下的人生永远无法摆脱这罪恶感，你可能会不时反省当年为什么没多走一步、多说一句话，后悔得心里绞痛，但你同时要记着，你有责任好好活着，因为你只有通过倾听自己的内心、做正确的决定，来消减心里的苦、赎自己的罪。这份沉重的愧疚会成为你的血肉，也会成为你是一个好人的证明。”阿怡和国泰惊讶于阿涅的话，但国泰很快收起愁容，用力地点头：“嗯，诚哥，我明白了，谢谢你。”</li><li>“区小姐，你没有经历过中学生活吗？你没感受过同侪之间的自我认同压力吗？这个年纪的孩子，有多少个可以不在乎他人眼光、我行我素地过活？当所有人都同意‘二加二等于五’时，你敢力排众议，冒着被他人排挤孤立而大声反对吗？假如郡主的姐妹们觉得郡主是个弱者，她肯定不到一天便会被贬为‘庶民’咧。国泰也好、郡主也好，全都挂着不同厚度的假面具，为了成为他人眼中的理想形象，他们都在勉强自己。本来成年人该告诉他们要有自信、由衷地做自己就好，可是我们这个病态社会只在乎教育能否制造出一批批服从权威、配合主流、具备相同学识与能力的机器人，而这些机器人又将下一代塑造成另一批机器人。”</li><li>“我不就跟你说过，你要学得自私一点，脸皮厚一点吗？”兄长曾对她说，“这个社会很残酷，示弱的人只会遭到无情的打击。那个姓区的绝对不是因为你做了什么才会死，假如被人骂两句便跳楼，那我们每天大概会看到成千上万个自杀者了。她会死，是因为她不够坚强，是因为她宁愿选择死亡去逃避承受这个荒谬社会的压力。”纵使这说法像歪理，杜紫渝还是好几次因为这些鬼话获得丁点救赎。</li></ul><p>第八章</p><ul><li>“你弄错了，区小姐，我不是‘逼’她自杀。强迫、威胁一个人自杀，其实跟谋杀没有分别。人类比其他生物高等，在于我们拥有自由意志，而且知道自己拥有自由意志。我们懂得逻辑推理，了解凡事有因必有果，要为自己的决定负责。我不会逼杜紫渝自杀，但我会制造出自杀的选项，放在她面前，让她选择。这样子对你来说，才是真正圆满的复仇。”</li><li>杜紫渝兄妹做过的事，小雯和国泰也做过，甚至该说杜紫渝所做的，不过是小雯他们种下的结果。假如阿怡自诩现在她对杜紫渝的作为是正确的话，那杜紫渝对小雯所做的一切也不见得错误。阿怡觉得自己踏上一个可憎的回圈，让这股仇恨延续下去。</li><li>“既然你明知杜紫渝背后有此般理由，为什么仍要替我复仇？是为了钱吗？我憎恨害死小雯的人，认定他们十恶不赦，但现在我不就成了我痛恨的对象？我跟他们有什么分别？”“分别是去年杜紫渝获救，而你妹妹死了。”阿涅冷冷的一句话，敲响阿怡心中的最后一根弦线。</li><li>“你会，但我不是针对你，世上所有人也会这样想。”阿涅以阿怡从没见过的严肃眼神瞧着对方，“人总不愿意承认自己是自私自利的生物。我们满嘴仁义道德，表面上容不下丁点恶念，可是一旦失去了余裕，就会祭出什么‘物竞天择’的理由，为自己所作所为开脱，这就是人性。更糟糕的是，人喜欢找借口，连承认自私的勇气也没有，自我催眠找个感觉良好的下台阶，说穿了不过是伪善。简单地问一句，你为什么要复仇？”“当然是为了替小雯讨回公道——”“什么‘为了妹妹’？这是‘你的复仇’。因为你承受着失去家人的痛苦，所以要找寻发泄怒火的对象，让自己得到解脱，别将责任推到妹妹身上，你复仇是‘为了自己’。你妹妹已经不在了，你凭什么代替她发言？你怎知道她想‘讨回公道’？将理由塞进不能作声的死者之口，你会不会太狡猾了？”</li><li>阿涅稍稍叹一口气，换回淡然的表情，“这样说可能惹你不高兴，但你跟我是同类。我们都钟爱孤独、享受孤独，相比起无聊的交际，我们更愿意将时间投放在我们认为‘必要’的事情上，就像你为了照顾家人放弃校园生活，宁愿花时间多看几本书而拒绝同事的邀约。我们可以无视世俗，我行我素。可是，你要知道你妹妹不是你，她会感受到朋辈压力，会在乎如何在群体里从俗地生存，模仿他人的样子，装作有共同兴趣。她大概也是因为这原因，才会答应跟国泰交往吧，没料到反而造成伤害了。</li><li>不过阿涅是一个有原则的人，他相信因果。阿涅平生最受不了的，是“正义”这两个字。这不是说他不分善恶，只是他了解到，比起单纯由善恶引起的冲突，世上更常见的是因为立场相异而勾起的纷争。在各种对抗之中，任何一方都打着“正义”的旗号，声称自己才是道理所在，即使用上卑污的手段，也美其名为“逼不得已”，以力量压倒对方，说穿了不过是胜者为王的丛林法则。阿涅对此更有深刻体会，他拥有金钱、地位、力量和才能，几乎能够为所欲为，能轻易成为他人眼中的“正义”化身，可是他知道随便以“正义”为名在他人身上施压，不过是一种霸凌。</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022</title>
    <link href="/%E9%9A%8F%E7%AC%94/2022%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%9A%8F%E7%AC%94/2022%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2022，时间概念及其混乱的一年，当我试图找寻一些记忆的时候，发现朋友圈总是断档了很多时期，仿佛在嘲笑我这些时光的虚度和无聊，痛苦的毕设，每周的汇报，失败的考研，匆忙的找工作。这样一想这一年也干了很多事了，一瞬间回想起来的都是美好的回忆，那些和朋友一起的桌游时光，几次旅行，居家一个月的快乐摸鱼。</p><p class="note note-danger">观前提示，本文及其漫长，结构散乱，夹杂了许多废话和主观印象，写了许久，中途很多次感觉到自己已经丧失了写作能力，不得已删了好多，但还是决定要写下去。仅仅是看过一遍就算了，留下的只会是好或不好的二极管印象，而逐渐丧失对于美好的感受</p><h1 id="考完研报复性观影期"><a href="#考完研报复性观影期" class="headerlink" title="考完研报复性观影期"></a>考完研报复性观影期</h1><h3 id="真探"><a href="#真探" class="headerlink" title="真探"></a>真探</h3><p class="note note-info">Touch darkness, and darkness touches you back</p><ul><li>及其精彩的一部剧，故事硬核连贯，探案不神棍，人物塑造也极其竞猜。Rust和Marty像硬币的正反面，一个孤高自傲，高智商低情商，满嘴哲学和形而上，活脱脱的一个反社会人格，而另一个家庭美满，处世圆滑，社交达人，他们之间的碰撞和合作非常的有意思。</li><li>本剧最末，一袭白衣的Rust在Marty的搀扶下蹒跚举步，并对Marty释怀地道出：“你知道，关于星空，你弄错了。以前，这个世界只有黑暗。要我说，是光明占了上风（You know, you’re looking at it wrong , the sky thing. Once there was only dark, If you ask me, the light is winning.）”。从这个画面中，我看到了基督下十字架的意象——Rust不止为世人受难，且多年来，以一个心结而自锁于十字架上，将己身放逐于深渊之侧、人世边缘。此刻，他终于得到了救赎，原谅了这个世界，与之和解，同时也开释了自己，撒手过往，步下架来。基督死去了，而Rust获得了重生，犹如基督的复活和再临人间。</li></ul><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2161543367.webp" alt="True Detective"></p><h2 id="集中性补荒木推荐的恐怖电影"><a href="#集中性补荒木推荐的恐怖电影" class="headerlink" title="集中性补荒木推荐的恐怖电影"></a>集中性补荒木推荐的恐怖电影</h2><h3 id="危情十日"><a href="#危情十日" class="headerlink" title="危情十日"></a>危情十日</h3><ul><li><p>狂热粉丝真的太恐怖了，女主的演技实在让人惊悚。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p1217959104.webp" alt="Misery"></p></li></ul><h3 id="迷雾"><a href="#迷雾" class="headerlink" title="迷雾"></a>迷雾</h3><ul><li><p>这部片完美地体现了美国的反智主义，宗教主义，个人的力量在集体面前显得不值一提。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p1970406441.webp" alt="The Mist"></p></li></ul><h3 id="魔女嘉莉"><a href="#魔女嘉莉" class="headerlink" title="魔女嘉莉"></a>魔女嘉莉</h3><h1 id="短暂但是快乐的寒假"><a href="#短暂但是快乐的寒假" class="headerlink" title="短暂但是快乐的寒假"></a>短暂但是快乐的寒假</h1><h2 id="高铁连看两部番"><a href="#高铁连看两部番" class="headerlink" title="高铁连看两部番"></a>高铁连看两部番</h2><p class="note note-primary">难以想象我是怎么在九个小时的高铁旅途中连看两部番的，似乎都是xyz推荐的，感恩</p><h3 id="平稳世代的韦驮天们"><a href="#平稳世代的韦驮天们" class="headerlink" title="平稳世代的韦驮天们"></a>平稳世代的韦驮天们</h3><ul><li>第一集就被画风和打斗流畅度吸引，世界观合理且有趣，智慧才是最大的武器，如同之前看过的寄生兽和亚人一般，看上去无敌的存在，也一定会有软弱的一面，这样的设定让我觉得非常好。</li><li>当然本片也相当的媚宅，有许多无意义的性羞辱场面，修女部分暂且不谈，很多桥段看的过于刻意，而且最后结束的也十分匆忙，正好在剧情最高潮的地方停止了，提出了问题却无力解决，有点太监的意思了。</li></ul><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2653060567.webp" alt="平穏世代の韋駄天達"></p><h3 id="odd-taxi"><a href="#odd-taxi" class="headerlink" title="odd taxi"></a>odd taxi</h3><ul><li>年代最强推理番，非常精彩的多线叙事，在短短13话中串起了许多有血有肉的人物，而且最后一集最所有人的连接和反转更是神中神，我这里不想剧透一丝的剧情，看就完事了。</li></ul><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/p2631090442.webp" alt="オッドタクシー"></p><h2 id="温泉"><a href="#温泉" class="headerlink" title="温泉"></a>温泉</h2><p>很奇妙，第一次和高中同学出去旅游竟然是和隔壁班的同学出去玩，和自己的高中同学反而有一种疏离感，倒也不是很陌生只不过总是遇不到一起，和他们认识是因为，初中同学的高一舍友一起打游戏，然后这人又拉了自己的高二同学，于是我们逐渐熟络了起来，纯罗汉局，泡温泉、打边炉、看恐怖片，打麻将玩桌游，真有趣。</p><h2 id="小谭局"><a href="#小谭局" class="headerlink" title="小谭局"></a>小谭局</h2><p>和小谭群经典阿宅聚会，租了个民宿打电动玩桌游，快乐的时光，颇有印象的派对游戏有这些：picopark move  or die 超级鸡马，节目效果拉满。</p><h1 id="失败的噩耗"><a href="#失败的噩耗" class="headerlink" title="失败的噩耗"></a>失败的噩耗</h1><p>这或许是我人生第一次我以为我会记住那个失败的时刻很久，但其实好像不是的，很长一段时间，但仅仅过了几个月，连具体的分数都回想不起来了，登陆研招网也显示无法查询，真正地随风飘散了。考研就是这样一个东西，其实早在考前的一个月就能知道你是否能够成功，考完的等待仿佛只是一场注定的死刑宣判。</p><h1 id="折磨的毕设"><a href="#折磨的毕设" class="headerlink" title="折磨的毕设"></a>折磨的毕设</h1><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><h3 id="大话设计模式"><a href="#大话设计模式" class="headerlink" title="大话设计模式"></a>大话设计模式</h3><h3 id="游戏引擎架构"><a href="#游戏引擎架构" class="headerlink" title="游戏引擎架构"></a>游戏引擎架构</h3><h2 id="找到工作后的安稳"><a href="#找到工作后的安稳" class="headerlink" title="找到工作后的安稳"></a>找到工作后的安稳</h2><h3 id="新蝙蝠侠"><a href="#新蝙蝠侠" class="headerlink" title="新蝙蝠侠"></a>新蝙蝠侠</h3><ul><li>这部片给我留下的最大印象，是进电影院之前就下起了雪，离场之后雪下的更大了，那已经是三月份了吧，还是第一次在北京的三月份看到这么大的雪，电影本身我只能说画面不错，剧情太无聊了。</li></ul><h3 id="偶然与想象"><a href="#偶然与想象" class="headerlink" title="偶然与想象"></a>偶然与想象</h3><h3 id="更衣人偶"><a href="#更衣人偶" class="headerlink" title="更衣人偶"></a>更衣人偶</h3><h2 id="联机看片"><a href="#联机看片" class="headerlink" title="联机看片"></a>联机看片</h2><p class="note note-info">这段时间每个周末都和朋友们腾讯会议联机看电影，仿佛回到了中学一起在教室看电影的时光，真是快乐啊</p><h3 id="花束版的恋爱"><a href="#花束版的恋爱" class="headerlink" title="花束版的恋爱"></a>花束版的恋爱</h3><ul><li>截止到目前为止这部片已经看了三遍了，第一遍看的时候非常气氛于男主的不作为，觉得就是因为他沉迷工作才导致分手；第二遍和朋友线上一起看，才觉得其实两个人都没有错，他们都以彼此的方式爱着对方，可是彼此都没有沟通，彼此认为自己是在为对方牺牲，其实还是没有做出爱对方的责任。第三遍是工作了之后再看，豆瓣上一个短评说的特别好：“靠消费主义维系的恋爱是抵抗不了资本主义秩序的。”，爱是很沉重的事情，而仅仅靠兴趣爱好维系只能成为同好，但是一起结伴走向人生的道路的决定是很难的。工作了之后越发能体会到这种沉重感，带着初心面对社会非常地艰难，于是我也经常自省自己的所作所为，希望自己能够不偏离。</li></ul><h3 id="big-nothing"><a href="#big-nothing" class="headerlink" title="big nothing"></a>big nothing</h3><ul><li>英式喜剧的代表，没有一句废话。</li></ul><h3 id="闻香识女人"><a href="#闻香识女人" class="headerlink" title="闻香识女人"></a>闻香识女人</h3><h2 id="肠胃炎"><a href="#肠胃炎" class="headerlink" title="肠胃炎"></a>肠胃炎</h2><p class="note note-info">在只能每天吃流食的日子里，电影成了唯一的寄托</p><h3 id="树先生"><a href="#树先生" class="headerlink" title="树先生"></a>树先生</h3><h3 id="幸福终点站"><a href="#幸福终点站" class="headerlink" title="幸福终点站"></a>幸福终点站</h3><ul><li>机场版我是传奇，04年的片子完全的诠释了美国梦的定义，是金子在哪里都会发光，然而现实总是比电影更残酷，原型待了十几年才得以回家，令人唏嘘。</li></ul><h2 id="毕设尾声"><a href="#毕设尾声" class="headerlink" title="毕设尾声"></a>毕设尾声</h2><h3 id="洛奇三部曲"><a href="#洛奇三部曲" class="headerlink" title="洛奇三部曲"></a>洛奇三部曲</h3><ul><li>不得不说洛奇开创了一种体育励志片这种模式，三部曲基本是按照同样的桥段进行的：先压抑、失落、失败的剧情整一个小时，然后嘴遁转折，然后开始放神曲gonna fly now加上训练蒙太奇，最后比赛胜利结尾。</li><li>幕后的故事其实更加动容，史泰龙在观看了查克.威普纳和阿里的比赛之后，写出了洛奇1的剧本，那场比赛查克就像洛奇一样，被击倒了无数次，还是艰难的站了起来。之后史泰龙跑了几十家家电影公司推销自己的剧本都失败了，但他还是一次一次地去尝试，最终把这个憨憨傻傻但是毅力惊人的洛奇带到银幕上与我们见面。</li><li>洛奇三部曲的名场面非常多，第一步的跑步训练聚集越来越多人，第二部病床上Adrian的win，第三部伴随着eye of tiger的开场蒙太奇，黑人老哥的“There is no tomorrow“，</li></ul><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p453792998.webp" alt="Rocky"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2053433277.webp" alt="Rocky II"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2199773386.webp" alt="Rocky III"></div></div></div><h3 id="一些韩国电影"><a href="#一些韩国电影" class="headerlink" title="一些韩国电影"></a>一些韩国电影</h3><p class="note note-primary">这段时间集中看了好几部韩国电影，如今回忆的时候，一直想的是在北京的出租屋里看的，想了许久还是不能找到任何在大学宿舍看这些电影的记忆。我一度怀疑是豆瓣的标记系统出了问题，这样的记忆错乱或许成了这一年的缩影，持续的长时间封控，间歇性的出来玩，让一切美好的回忆都堆在了一起</p><h4 id="辩护人-amp-出租车司机"><a href="#辩护人-amp-出租车司机" class="headerlink" title="辩护人&amp;出租车司机"></a>辩护人&amp;出租车司机</h4><ul><li>这两部片都可以或许可以放在一起讲，宋康昊那张大饼脸颇有喜感演技又贼好。《辩护人》讲的是这样一个故事，一个本来唯利是图的税务律师，因为一个朋友的儿子被刑讯逼供，最终走上了“反抗者”的道路。《出租车司机》里的那个司机也都是本来完全不关心政治，但是，因为不堪忍受国家暴力而加入抗争。这些情况一而再再而三地出现让他们慢慢意识到，除非权力结构改变，这些不对是不能被系统纠正的</li><li>韩国似乎特别喜欢拍自己的转型故事，这种沉重的政治片仿佛已经成为了他们的精神纪念碑，反抗从学生转向一个又一个普通的人，最后体制内的人也开始动摇，一步一步见证了韩国民主运动的扩散，每个民族都需要自己的神话，韩国人的民主抗争似乎成为了他们的民族神话。这种源于道德直觉的正义感有种令人敬畏的天真，你会发现，当所有政治的泥沙沉淀、所有理论的波涛平息、所有流行的趋势过去，最终，这种无与伦比的天真还是会从水底浮现。它熠熠的光芒，还是会诱惑你向它伸手。</li></ul><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2158166535.webp" alt="변호인"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/uq5QUIlT4inLH6jDVD5WM3YXMag.jpg" alt="image" style="zoom: 45%;" /></div></div></div><h4 id="杀人回忆"><a href="#杀人回忆" class="headerlink" title="杀人回忆"></a>杀人回忆</h4><ul><li>其实这部片也有一点韩国民主抗争的影子，双男主，从汉城来的精英警察象征着进步与文明，查案手法比乡下警察们，据说现实中的杀人犯还去电影院观看了这部片子，现在想起来本片最令人毛骨悚然的就是主角团在查明白凶手会在雨天电台播某首歌的时候动手，然后突然下起了雨，并且收音机里传来了那首歌，实在是太有压迫感了。</li></ul><h4 id="恐怖直播"><a href="#恐怖直播" class="headerlink" title="恐怖直播"></a>恐怖直播</h4><h4 id="熔炉"><a href="#熔炉" class="headerlink" title="熔炉"></a>熔炉</h4><p>这部片看的太难受了，虽然知道电影改变不了什么，但至少韩国人能拍出来，不是么？</p><h1 id="最后的暑假"><a href="#最后的暑假" class="headerlink" title="最后的暑假"></a>最后的暑假</h1><h2 id="汕头"><a href="#汕头" class="headerlink" title="汕头"></a>汕头</h2><p class="note note-primary">旅游不是在乎去了哪里，干了什么，而是和谁去</p><p>可以列入我人生最开心的旅游了，回想起来还是甚至会觉得悲伤，因为没准再也没如此的开心了。我们都不是那种打卡型的人，能够聚在一起就很开心，那几天我们白天出去逛逛，晚上疯狂桌游，从身份类到猜词，玩的嗓子都哑了；我们租车去看海，追日出，吃各种各样的本地美食，真幸福啊，真开心啊。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li>在飞机上太无聊所以用座位面前的小屏幕重看了一遍青春派，看完的感受和我高中的完全一致，太傻太假，随说外界评价已经是够真实，可是我还是看到了一种不真实，或许唯一讽刺的真实就是有北京户口的人这样随意玩闹也能上个好大学吧，早早地让我认识了社会的不公平。</li></ul><h2 id="剧"><a href="#剧" class="headerlink" title="剧"></a>剧</h2><h3 id="风骚律师1-6"><a href="#风骚律师1-6" class="headerlink" title="风骚律师1-6"></a>风骚律师1-6</h3><p>14年，125集，非常幸运我能一口气看完如此神剧，而不用经历这么多漫长的等待。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2218944919.webp" alt="Better Call Saul"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2305158254.webp" alt="Better Call Saul"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2442801582.webp" alt="Better Call Saul"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2526785183.webp" alt="Better Call Saul"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/p2580304539.webp" alt="Better Call Saul"></div><div class="group-image-wrap"><img src="https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2869521768.webp" alt="Better Call Saul"></div></div></div><h2 id="番"><a href="#番" class="headerlink" title="番"></a><strong>番</strong></h2><h3 id="lycoris"><a href="#lycoris" class="headerlink" title="lycoris"></a>lycoris</h3><ul><li>虽然结局有点粪但还是忍不住提一句，因为前期的各种戏份实在看得人很开心，哎，可惜了。</li></ul><h3 id="石之海"><a href="#石之海" class="headerlink" title="石之海"></a>石之海</h3><ul><li><p>作为前六部最强大的反派，神父的能力实在逆天</p></li><li><p>整个part3都在讲引力，讲命运，讲觉悟，神父希望创造一个人人知晓命运而能够做好觉悟的世界。三兄弟阻挡主角团的觉悟，维萨与佩拉的相遇，神父的一次次被逼上绝路…一切种种或许正如神父所说，最终的结果在他融合绿孩的那一刻就已经揭晓，命运会如同滚石一般发生，即使做出反抗也只不过是命运的安排。然而主角们还是选择相信勇气，相信神父口中不值一提的正义，他们怀揣着觉悟与黄金精神，将希望一次次传递。最终如同安波里奥最后所说，走在正义之路上才是命运！</p></li><li><p>长达数百年的恩怨终于结束，谢谢你荒木！我们新大陆见！</p></li></ul><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201815.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201825.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201828.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201833.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201835.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201838.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201840.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201843.jpg"></div><div class="group-image-wrap"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230107201845.jpg"></div></div></div><h3 id="灵能百分百"><a href="#灵能百分百" class="headerlink" title="灵能百分百"></a>灵能百分百</h3><h3 id="孤独摇滚"><a href="#孤独摇滚" class="headerlink" title="孤独摇滚"></a>孤独摇滚</h3><p class="note note-success">你的第一部轻音，又何必是轻音</p><p>如果非要给番剧排序的话我愿意把孤独摇滚列为我今年的年度第一番，能看得出制作组相当的用心，许多片段的表现力真的太爆炸了。</p><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><h3 id="放松"><a href="#放松" class="headerlink" title="放松"></a>放松</h3><h4 id="暗杀1905-12"><a href="#暗杀1905-12" class="headerlink" title="暗杀1905 12"></a>暗杀1905 12</h4><h4 id="沼泽怪物1和2"><a href="#沼泽怪物1和2" class="headerlink" title="沼泽怪物1和2"></a>沼泽怪物1和2</h4><p>个人感觉说比守望者好看一点过誉了，以为会是个连续的故事其实是短篇故事合集，故事连贯性和完整性还是守望者好太多了。</p><h3 id="陈浩基的小说"><a href="#陈浩基的小说" class="headerlink" title="陈浩基的小说"></a>陈浩基的小说</h3><h4 id="1367"><a href="#1367" class="headerlink" title="1367"></a>1367</h4><p>太绝了….港味十足，倒叙回环结构，每一个故事都引人入胜，最后的结局让人有一种宿命使然的感觉，真的是忍不住脱帽致敬。</p><h4 id="网内人"><a href="#网内人" class="headerlink" title="网内人"></a>网内人</h4><ul><li>一气呵成，非常流畅的阅读体验，陈浩基不愧是cs科班出身的，前半段的的探案的各种黑客知识很过瘾，后半段的复仇刻画出一个蝙蝠侠般的现代侠客形象，当然还是太理想了，略显脸谱化，剧情的走向稍显俗套。</li><li>爽过之后再来反思结局，有一种机械降神的味道，作者视图批判的东西太多了，校园暴力，资本逐利，到最后拯救无产阶级的是靠另一个充满善意的大资本家</li></ul><h3 id="村上的小短篇"><a href="#村上的小短篇" class="headerlink" title="村上的小短篇"></a>村上的小短篇</h3><h4 id="假如我们的语言是威士忌"><a href="#假如我们的语言是威士忌" class="headerlink" title="假如我们的语言是威士忌"></a>假如我们的语言是威士忌</h4><p>太短啦村上君，请原谅我还是没领悟到威士忌的魅力，不过还是有了想尝试一下的欲望，不过酒对我来说吸引力甚至比不上可乐，鼓吹的醇香味对我来说不如甜。不过真想去旅游啊，不是那种打卡式的，想像村上这样慢悠悠地在一个陌生的地方待上一两个月，真好啊</p><h4 id="遇到百分百的女孩"><a href="#遇到百分百的女孩" class="headerlink" title="遇到百分百的女孩"></a>遇到百分百的女孩</h4><p>一些很短的短篇合集，村上的语言很轻快，也没有什么厚重的主题，读起来就像是扯闲话一样，一种不用怎么过脑子的娱乐活动，毕竟这都是长篇剩下来的边角料，真是很好奇小说家们怎么有这么多故事呢？</p><h3 id="修行"><a href="#修行" class="headerlink" title="修行"></a>修行</h3><h4 id="好玩的好设计"><a href="#好玩的好设计" class="headerlink" title="好玩的好设计"></a>好玩的好设计</h4><p>一本关于桌游美学设计的书，但其实里面的大部分桌游玩法欠佳，只能说美术还不错，具体的<a href="https://rorschachandbat.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%A5%BD%E8%AE%BE%E8%AE%A1">读书笔记</a>可以点进链接。</p><h4 id="代码大全"><a href="#代码大全" class="headerlink" title="代码大全"></a>代码大全</h4><p>和重构配合着看非常有意思，代码大全教你如何写好代码，重构教你如何改烂代码。</p><h4 id="力量训练原理"><a href="#力量训练原理" class="headerlink" title="力量训练原理"></a>力量训练原理</h4><ul><li>为了让力量举训练取得更好的效果，超负荷原理要求我们不断尝试使用从没用过的重量进行训练，不断突破自己的能力极限。随着你变得越来越强壮，这个过程会变得越来越吓人。</li><li>比如你能负重200kg进行深蹲了，这时候光是放在深蹲架上的杠铃杆都会因为被挂上太多杠铃片而出现明显的变化，更别提你还要将他抗起来，如果你每周还要再此基础上多加10kg的重量，再联想一下这个周期的最后一周要完成的重量，你是不是在看到这个冷冰冰的杠铃时就已经开始头疼了？如果单单是看到训练计划就让你从生理上产生退意了，那么唯一的解决方法就是从心里接受它，接受计划的风险和你对计划的不适。坚强的心理素质对所有的运动都是必须的，而不是锦上添花。</li><li>执行训练计划的时候，有些人会故意回避提高训练难度，不定期地更改计划，给自己安排减载。他们只在感觉感觉好的时候苦练，还会降低辅助动作的容量，或者将超负荷的辅助动作换成低重量的简单动作。如果你对自己要求不高，这些想法也是合情合理的，但效果肯定不那么好。<br>如果你想超越自己，唯一的方法就是咬着牙把计划执行到位，不要多练，也不要少练。</li><li>健身先健脑，健身其实是非常需要技巧的，书中深入浅出地讲解了力量举的七大原理：专项性、超负荷、疲劳管理、刺激-恢复-适应、变式、阶段增益、个体差异，运用其中的前几个原理就能做出非常不错的力量举计划，比市面上绝大多数的教练都有用。</li></ul><h1 id="关于2023年"><a href="#关于2023年" class="headerlink" title="关于2023年"></a>关于2023年</h1><p class="note note-success">怕什么真理无穷，进一寸也有进一寸的欢喜</p><p>之前看了一个关于箱根驿传的纪录片，青山大学的主教练原晋十分令人动容，他原本只是一个电力公司的职员，因为受伤而停止了一直热爱的跑步运动，自己都嘲笑自己是“失败的上班族”。救世主和么一个人，用五年时间让青山大学拿到了箱根驿传预选赛的资格，又花费了六年时间让青山大学拿到了冠军，更是在之后的四年里蝉联五届冠军。</p><p>原晋做了一张10年的计划表，制定了10年后的目标，然后制定从现在往前半步能达到的目标，达到了这个半步之后，再想下一个半步，这样不断地半步地前进，定下目标，打成，收获快乐，不断重复，因为意识自己可以达成目标，学生们就会主动加入作战，就能形成自主思考，主动行动的思维模式。人还是需要一些理想的，不然太容易陷入短期的快乐。</p><p>稍微计算一下，2023年的空闲时间会有4640h（按照工作日8h，非工作日16h粗略计算得到），抛去吃饭出行刷奶头乐等一系列杂七杂八的时间，更加粗略地估计为四千小时，我真希望能有这么一个功能，在自己不断买书不断买游戏的过程弹窗一下，“很抱歉地提醒您，您今年的娱乐剩余时间已不足，请停止买书买游戏以及添加愿望单”</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p class="note note-info">2023年立志成为游戏库存清灰大师</p><p>taitanfall2：15h</p><p>the witness：27h</p><p>空洞：20h</p><p>baba is you：10h</p><p>命运石之门：30h</p><p>428，被封锁的涩谷：31h（</p><p>马里奥奥德赛：30h</p><p>塞尔达：100h</p><p>只狼：50</p><p>极乐迪斯科：20h</p><p>老头环：50h（玩了一段时间学习版终于打折了决定补票通关一周目）</p><p>心跳文学部：10h（</p><p>杀戮尖塔崩坠：32h（还剩下观者和dlc的四个新角色没玩）</p><p>evergarden：5h</p><p>gris：10h</p><p>in outer waters：3h</p><p>无人深空：50h</p><p>patrick paradox：20h</p><p>pipe push paradise：15h</p><p>脑航员2：30h</p><p>锈湖系列：4h</p><p>total：562h</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p class="note note-info">翻了一遍豆瓣top250和自己的想看，发现还有许多许多等待着我，真幸福</p><p>辛德勒的名单</p><p>末代皇帝</p><p>素媛</p><p>何以为家</p><p>哈尔的移动城堡</p><p>钢琴家</p><p>天空之城</p><p>死亡诗社</p><p>西西里的美丽传说</p><p>拯救大兵瑞恩</p><p>小鞋子</p><p>致命魔术</p><p>海豚湾</p><p>美国往事</p><p>超脱</p><p>狩猎</p><p>被嫌弃的松子的一生</p><p>7号房的礼物</p><p>入殓师</p><p>侧耳倾听</p><p>今敏的作品</p><p>告白</p><p>电锯惊魂</p><p>色戒</p><p>纵横四海</p><p>遗愿清单</p><p>宫崎骏的电影们</p><h2 id="书-1"><a href="#书-1" class="headerlink" title="书"></a>书</h2><p class="note note-info">目标是把双十一以及头脑发热下的一大堆电子书看完</p><p>战争与和平</p><p>卡拉马佐夫兄弟</p><p>钟型罩瓶</p><p>可能性的艺术</p><p>人性中的善良天使</p><p>克莱因壶</p><p>惶然录</p><p>始于极限</p><p>如雪如山</p><p>金阁寺</p><p>当我们不再理解世界</p><h2 id="修行-1"><a href="#修行-1" class="headerlink" title="修行"></a>修行</h2><p class="note note-danger">疼痛无法避免，磨难却可以选择</p><p>健身：三大项希望能突破450kg</p><p>跑步：虽然健身的体型不太适合跑步，不过还是希望能达到至少5min配速跑完5km，目前看来这是最难的一个目标</p><p>日语：N4就算成功</p><p>游戏：1.希望能用unity的corgi引擎做一个小的demo出来。2.多看gdc讲座以及书籍并且总结游戏设计方面的知识。3.学完<a href="https://space.bilibili.com/31898841">谌嘉诚</a>的虚幻4入门视频。</p><p>减重：该减脂了，希望能减个10kg</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【gdc讲座】如何增加游戏的宽容度</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E6%B8%B8%E6%88%8F%E7%9A%84%E5%AE%BD%E5%AE%B9%E5%BA%A6/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E5%A6%82%E4%BD%95%E5%A2%9E%E5%8A%A0%E6%B8%B8%E6%88%8F%E7%9A%84%E5%AE%BD%E5%AE%B9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>如何增加游戏的宽容度</p><p>意识到玩家的操作室不连贯的，所以要设置宽容度</p><p>土狼跳</p><p>将can_jump从布尔值变成一个计时器，超过0.1s还是可以跳</p><p>包裹跳</p><p>跳跃比钩爪距离强，所以设置一下跳跃钩爪可以更长</p><p>玩家不仅会操作晚还有看操作早</p><p>预指令</p><p>在落地前0.2s按跳都可以跳，而且不止跳跃，使用道具也可以</p><p>要求过于精确就会导致操作不灵敏</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216000852595.png" alt="image-20221216000852595"></p><p>玩家还可能按错键，比如一直按住下会打开下落模式，但是包裹跳的时候玩家需要按住下，这时候可能错误地进入下落模式。</p><p><strong>Input Rest（输入重置）</strong></p><p>这时候会加一些限制：1.跳起来的时候关闭下落模式。2.只有在地上的时候才能打开下落模式。这个方法叫</p><p><strong>Input Speedbump</strong></p><p>把一些容易误操作的按键，比如重置关卡改成长按才生效。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【gdc讲座】解密游戏的30堂课</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%B0%9C%E6%B8%B8%E6%88%8F%E7%9A%8430%E5%A0%82%E8%AF%BE/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E8%AE%BE%E8%AE%A1%E8%A7%A3%E8%B0%9C%E6%B8%B8%E6%88%8F%E7%9A%8430%E5%A0%82%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p>本文为Elyot Grant的gdc讲座笔记，不得不说实在是太爽了，感谢up的翻译，整个三个小时的讲座就是一次又一次的尤里卡时刻，让我异常敬佩Elyot深厚的谜题知识，学到了非常多，非常有用这些谜题知识创造一些东西的欲望，小说或者游戏或者就是单纯的分享这些有趣的谜题。</p><p>电子游戏擅长用心流创造游戏，传统谜题设计师擅长设计Eureka时刻</p><h2 id="1-什么是Eureka-Moment？"><a href="#1-什么是Eureka-Moment？" class="headerlink" title="1.什么是Eureka Moment？"></a>1.什么是Eureka Moment？</h2><p>尤里卡时刻是一种突然的、愉悦的、流畅的，自信的领悟。</p><p>比如在传送门游戏中学会了出入传送门动量是守恒的，</p><p>谜题：任何隐藏着尤里卡时刻的东西</p><h2 id="2-谜题与幽默是同构的"><a href="#2-谜题与幽默是同构的" class="headerlink" title="2.谜题与幽默是同构的"></a>2.谜题与幽默是同构的</h2><p>尤里卡时刻的心理学特征：积极印象，高度多巴胺，整正反馈记忆形成，减少压力，增强毅力</p><h2 id="3-最大限度提高Sparkle"><a href="#3-最大限度提高Sparkle" class="headerlink" title="3.最大限度提高Sparkle"></a>3.最大限度提高Sparkle</h2><p>Sparkle是指尤里卡时刻的强度，来源于填字游戏的一个概念</p><p>谜底的生动性和谜面的巧妙性 </p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216153805072.png"></p><p>你可能不是直接想出来的，而是通过交叉得到的这个词，然后你就会有一种哦原来cover是这个意思的尤里卡时刻。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216153947780.png"></p><p>有个网站可以查每个单词的谜面：<a href="https://www.xwordinfo.com/Finder">https://www.xwordinfo.com/Finder</a></p><h2 id="4-避免无意义的谜题"><a href="#4-避免无意义的谜题" class="headerlink" title="4.避免无意义的谜题"></a>4.避免无意义的谜题</h2><p>Crosswordese：指那些经常在填字游戏中出现，但在日常生活中不怎么用得到的词，比如只有几个字母的以元音开头结尾的词，或者纯辅音的缩写，事实上每个填字游戏或多或少用到几个crosswordese，才能把填字游戏组合起来，但用多了就会拉低谜题的质量。</p><p><strong>一些不太好的设计词语</strong></p><p>Green Paint：无意义的词语组合</p><p>Rewaters：不太能算个词</p><p>Natick：两个难以猜出的词语相交</p><p>Aldi：这是一个主要在美国东部的连锁超市，所以不太适合把这种词放在填字游戏中</p><h2 id="5-惊喜是Sparkle的重要源泉"><a href="#5-惊喜是Sparkle的重要源泉" class="headerlink" title="5.惊喜是Sparkle的重要源泉"></a>5.惊喜是Sparkle的重要源泉</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216160813814.png"></p><p>最不可能的走法（后走出去让兵生成后）才能在三步之内将死黑棋</p><h2 id="6-有趣的事实是惊喜的源泉"><a href="#6-有趣的事实是惊喜的源泉" class="headerlink" title="6.有趣的事实是惊喜的源泉"></a>6.有趣的事实是惊喜的源泉</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216161531958.png"></p><h2 id="7-尤里卡时刻并不是自豪"><a href="#7-尤里卡时刻并不是自豪" class="headerlink" title="7.尤里卡时刻并不是自豪"></a>7.尤里卡时刻并不是自豪</h2><p>Fiero：克服艰难挑战的情绪，这和尤里卡时刻是两个垂直的维度，尤里卡时刻更加注重让玩家发现有趣的东西，Eureka甚至不需要自己体验就可以云到这种感受，但是Fiero则要自己面对那种苦难然后体验成功的快乐。</p><p>任何游戏都可以带来Fiero的体验，但是只有谜题能带来Eureka时刻。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216162605597.png"></p><p>下面来分析两个木块游戏，左边你无法通过硬塞解出来，你需要认真地思考关于空间，学习一些组合数学，空间填色问题的知识才能发现这是具有唯一解的，但是右边仅仅是一个打法时间的玩具，他只是把方块放在盒子里面，会让人感到消遣，但它没有揭示任何关于宇宙自然的事实。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216163412636.png"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216163915973.png"></p><h2 id="8-不同解密者所寻求的解密体验是不尽相同的"><a href="#8-不同解密者所寻求的解密体验是不尽相同的" class="headerlink" title="8.不同解密者所寻求的解密体验是不尽相同的"></a>8.不同解密者所寻求的解密体验是不尽相同的</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216164139078.png"></p><p>题海式的体验（重复已经发现的尤里卡时刻，随着自己的思绪游荡）：一本数独书</p><p>缓慢沉思式的体验：九连环、205分钟方块、报纸谜题</p><h2 id="9-尤里卡是可以分享的"><a href="#9-尤里卡是可以分享的" class="headerlink" title="9.尤里卡是可以分享的"></a>9.尤里卡是可以分享的</h2><h2 id="10-创造很多尤里卡时刻"><a href="#10-创造很多尤里卡时刻" class="headerlink" title="10.创造很多尤里卡时刻"></a>10.创造很多尤里卡时刻</h2><p>去玩密室逃脱吧！</p><h2 id="11-创造一个有收获的结局"><a href="#11-创造一个有收获的结局" class="headerlink" title="11.创造一个有收获的结局"></a>11.创造一个有收获的结局</h2><p>比如Picross（数织游戏，规则很简单，比如第一行的4 1 就代表这一行有一个连续4格和一个连续1格），玩家在玩的过程中会好奇最终能拼出一个什么图像。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216165258790.png"></p><p>天体游戏：把每一个点用区域分割同时这个点需要变成这个区域的对称点</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216165557123.png"></p><p>你甚至可以用一个生成器来生成Tentai Show谜题：<a href="https://erikdemaine.org/fonts/spiralgalaxies/">https://erikdemaine.org/fonts/spiralgalaxies/</a></p><p>p.s. 逛这个网站本身就很有乐趣啊，可以做各种谜题了：<a href="https://erikdemaine.org/fonts/">https://erikdemaine.org/fonts/</a></p><p>提炼步骤：最后的答案是一个新的谜题。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216171404877.png"></p><h2 id="12-藏入一些秘密和惊喜"><a href="#12-藏入一些秘密和惊喜" class="headerlink" title="12.藏入一些秘密和惊喜"></a>12.藏入一些秘密和惊喜</h2><p>藏彩蛋，因为这是有可能被错过的，所以你发现并解开的时候会更加惊喜。</p><h2 id="13-困惑是惊喜的前兆"><a href="#13-困惑是惊喜的前兆" class="headerlink" title="13.困惑是惊喜的前兆"></a>13.困惑是惊喜的前兆</h2><p>Aporia：一种困惑的状态，解密者觉得这不可能，但其实是有些事情你没有在注意到，会让你产生一个想法：一个有趣的诀窍是存在的，它预示了一个大的尤里卡时刻将要到来。当玩家处于Aporia时刻，他会有很强的激励感，而一旦他解出来了，就会很想和别人分享，并为之兴奋。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216173136032.png"></p><h2 id="14-建立与解密者之间的信任"><a href="#14-建立与解密者之间的信任" class="headerlink" title="14.建立与解密者之间的信任"></a>14.建立与解密者之间的信任</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216180312448.png"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216180328467.png"></p><p>这种情况只要遇到一次你就会对剩下的部分都失去信心，所以有时候直接告诉玩家你已经可以有了解决这个谜题的所有条件，比较有效（Superland）</p><p>还有一些时候可以引入Squres dealing的概念，即引入一些为了让玩家感到公平而遵守的惯例，比如一个钥匙对应一把锁，没有不给提示的同字母异构词这种。</p><p>避免使用拙劣的把戏：一个好迷题有“啊哈”时刻，一个坏谜题有“啊？真的吗？”时刻</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20221216184745402.png"></p><p>比如给提示在黑暗中跳跃，但是你不仅要保证你给了提示，还要保证玩家没看到提示的时候无法到达这个地方.</p><h2 id="15-当心不透明性"><a href="#15-当心不透明性" class="headerlink" title="15.当心不透明性"></a>15.当心不透明性</h2><p>谜题中没有向玩家解释的部分，目标、规则、能力、交互或结果，由于不透明性会让玩家觉得疑惑.</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216201115490.png"></p><h2 id="16-让玩家容易尝试"><a href="#16-让玩家容易尝试" class="headerlink" title="16.让玩家容易尝试"></a>16.让玩家容易尝试</h2><p>不要让尝试过程挫败感太强:初见新机制的存档点，失败后漫长的失败动画和嘲讽，这些都会让人很挫败。</p><h2 id="17-让解密者走在正确的道路上"><a href="#17-让解密者走在正确的道路上" class="headerlink" title="17.让解密者走在正确的道路上"></a>17.让解密者走在正确的道路上</h2><p>比如填字游戏的每个字母都可以被检查，这样可以让玩家确认自己方向是正确的。</p><p><strong>转移注意力的种类</strong></p><p>装饰（一种本身不必要与谜题无关的装饰物，却又足够突出明显以至于会被理解为与谜题相关）、干扰项、假谜题和幽灵谜题、混淆和误导、兔子足迹（错误的谜题解法，但却没法被证明不可行），兔子足迹是最让人沮丧的， 因为新手不擅长猜测什么是可行的，只有在放弃之后才会改变方向。</p><p><strong>让相关性和显著性相匹配</strong></p><h2 id="18-追求系统与规则的深度"><a href="#18-追求系统与规则的深度" class="headerlink" title="18.追求系统与规则的深度"></a>18.追求系统与规则的深度</h2><p>系统的好处：玩家会有概念模型，知识可以服用，一致性与深度，涌现的惊喜，更好的尤里卡时刻，降低内容创造成本（设计一个谜题的实例比设计一整套规则更简单）</p><p>再开始重复同样的技巧之前，你能创造多少个谜题？</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216221930513.png"></p><p>加入新的组件，或者采用混合体和变体。</p><p><strong>增加容量的常见方法</strong>：改变集合结构或拓扑结构，增加新约束条件，增加新线索类型，融合两种谜题类型，撒谎线索、密码线索、偏置1</p><p><strong>深度从何而来</strong>：天然内在的深度（围棋），人为构造，规则间的互动</p><p><strong>常见的谜题惯用手法</strong>：连通性、路径问题；装箱问题和覆盖问题（骨牌谜题）；透视，实现；逻辑门；状态处理（捡起或推方块）；往往很难但又有趣的规律</p><h2 id="19-了解你的谜题的状态空间"><a href="#19-了解你的谜题的状态空间" class="headerlink" title="19.了解你的谜题的状态空间"></a>19.了解你的谜题的状态空间</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216233608025.png"></p><p>理解你的状态空间可以帮助你控制你的谜题的时间，难度，状态空间越大，瓶颈越多就越难。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216234002649.png"></p><h2 id="20-理解你的谜题的解法路径"><a href="#20-理解你的谜题的解法路径" class="headerlink" title="20.理解你的谜题的解法路径"></a>20.理解你的谜题的解法路径</h2><p>不单纯指状态空间的路径，还指玩家在解决过程中的尤里卡时刻，尽量不要放一个单一的瓶颈，让玩家可以探索各种东西而不是一条长长的单一的状态链。</p><p>数回：让玩家可以从任何一个地方开始，重复地产生“哦我解决这个了”的想法，这样会对自己在正确的轨道上感到非常兴奋，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216234427439.png"></p><p>线性路径意味着更难，但是能产生有趣的机密思想流，更有艺术性，枝繁叶茂更简单</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216234541380.png"></p><h2 id="21-在与玩家交流中传递乐趣"><a href="#21-在与玩家交流中传递乐趣" class="headerlink" title="21.在与玩家交流中传递乐趣"></a>21.在与玩家交流中传递乐趣</h2><p>点灯游戏：<a href="https://puzz.link/p?akari/10/10/gbibici16.ibi.gcgc7.g.q.g17.h.k.h.icgcgcgbgbi">https://puzz.link/p?akari/10/10/gbibici16.ibi.gcgc7.g.q.g17.h.k.h.icgcgcgbgbi</a></p><p>规则是：1.灯会水平和垂直地照亮一行和一列，而你的目标是用灯光照亮整个网络。二是灯不会互相照到。三是数字代表了上下左右有多少灯</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216234936752.png"></p><p>可以自己解一遍这个谜题，从左下角的1一点一点推出所有不可能存在灯的地方，然后最后一气呵成，非常爽快的体验，在这个过程中有一种和创造者交流的感觉，让自己觉得领悟了作者的想法。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221216235644670.png"></p><p>如何设计出这种如一条路程般的谜题解答体验？</p><h2 id="22-从正面设计"><a href="#22-从正面设计" class="headerlink" title="22.从正面设计"></a>22.从正面设计</h2><p>放置线索的同时进行解密的过程，我们要按照玩家在解密时注意到的顺序来放置线索。一个好的设计者一般是一个好的解密者，因为他设计的过程中能理清楚这个逻辑</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217001844491.png"></p><h2 id="23-让谜题的关键步骤被证明是独一无二的"><a href="#23-让谜题的关键步骤被证明是独一无二的" class="headerlink" title="23.让谜题的关键步骤被证明是独一无二的"></a>23.让谜题的关键步骤被证明是独一无二的</h2><p>逻辑解密的美感的一部分来源于解的唯一性，如果解不唯一，就感觉自己像是在瞎猜，演绎推理的思维流就不可能实现 </p><h2 id="24-添加一个主题"><a href="#24-添加一个主题" class="headerlink" title="24.添加一个主题"></a>24.添加一个主题</h2><p>左边是普通的孔明锁，右边是一个以猪为主题的孔明锁，有一个主题，能够增加玩家的记忆点，形成主题语言</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217003007908.png"></p><h2 id="25-不要在玩家注意不到的地方耍小聪明"><a href="#25-不要在玩家注意不到的地方耍小聪明" class="headerlink" title="25.不要在玩家注意不到的地方耍小聪明"></a>25.不要在玩家注意不到的地方耍小聪明</h2><p>为了一些美学目标可能会牺牲谜题的质量</p><h2 id="26-形式会改变一切"><a href="#26-形式会改变一切" class="headerlink" title="26.形式会改变一切"></a>26.形式会改变一切</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217103818817.png"></p><h2 id="27-做辅助几号的过程可以增加深度"><a href="#27-做辅助几号的过程可以增加深度" class="headerlink" title="27.做辅助几号的过程可以增加深度"></a>27.做辅助几号的过程可以增加深度</h2><p>做记号帮助你限制谜题大的状态空间，攻克一个点就可以让谜题”崩塌“。</p><p>因为玩家的短期记忆是有限的，如果不允许玩家做标记就会导致谜题的深度有限，比如一笔画完的划线游戏和一段一段增加的划线游戏能达到的深度不一样。</p><p>某些游戏做辅助标记的过程就是解密的过程，比如扫雷，但是电子游戏中不太常见，纸质游戏比较常见。</p><h2 id="28-当心互动媒介带来的诱惑"><a href="#28-当心互动媒介带来的诱惑" class="headerlink" title="28.当心互动媒介带来的诱惑"></a>28.当心互动媒介带来的诱惑</h2><p><strong>物理元素</strong>：尤里卡时刻是离散空间的，但是物理元素是在连续空间中，有时候对连续空间的图例并不想对离散空间的推理那样好。比如扔球，你很难确定自己是否站的近了或者就是根本扔不进去，这种从连续空间到离散空间的映射会让玩家失去明确性。</p><p><strong>多状态性</strong></p><p><strong>线性游戏</strong>：会阻碍玩家的进度，如果你想要不卡关就要考虑给玩家过多的提示，但这可能削弱尤里卡时刻的强度。p.s. 我玩文字游戏的时候就会有这一点，经常想直接看提示，总是这样就缺少了一丝快感，现在想起来原来是因为这个原因啊。</p><p><strong>情节驱动的解密游戏</strong></p><p>p.s. 以上规则全都被传送门2打破哈哈哈哈哈哈哈哈哈哈或</p><h2 id="29-打破前面这些规则，有时反常一点"><a href="#29-打破前面这些规则，有时反常一点" class="headerlink" title="29.打破前面这些规则，有时反常一点"></a>29.打破前面这些规则，有时反常一点</h2><p><strong>薛定谔线索</strong></p><p>违反了唯一答案原则，总统大选字谜，中间那一行既可以填CLINTON也可以填BOBDOLE，为了达到这个目标要设计七个薛定谔线索。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217105808013.png"></p><p><strong>故意放红鲱鱼</strong></p><p>把红鲱鱼放出来做成梗，懂得人知道不应该数它，这本身很有趣。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217110119358.png"></p><p><strong>奇特的规定</strong></p><p>合作让黑方不被将死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221217110628237.png"></p><h2 id="30-当你主动寻找好想法时，缘分自然会到来"><a href="#30-当你主动寻找好想法时，缘分自然会到来" class="headerlink" title="30.当你主动寻找好想法时，缘分自然会到来"></a>30.当你主动寻找好想法时，缘分自然会到来</h2><p>伟大的谜题往往是被发现出来的，而不是发明出来的。</p><p>注意自己感受到的尤里卡时刻，并把他们变成谜题，积极寻找那些看起来会超出你预期的东西。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拳头游戏教程</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8B%B3%E5%A4%B4%E6%B8%B8%E6%88%8F%E6%95%99%E7%A8%8B/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%8B%B3%E5%A4%B4%E6%B8%B8%E6%88%8F%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="一、初谈游戏美术"><a href="#一、初谈游戏美术" class="headerlink" title="一、初谈游戏美术"></a>一、初谈游戏美术</h1><h2 id="游戏美术师的作用"><a href="#游戏美术师的作用" class="headerlink" title="游戏美术师的作用"></a>游戏美术师的作用</h2><p>1.<strong>清晰度</strong></p><p>传递信息 </p><p>2.<strong>满足感</strong> </p><p>明确且响应迅速的反馈，</p><p>3.<strong>风格</strong></p><p>呈现某种情绪基调</p><h2 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h2><p>很多都与对比度有关</p><p>1.<strong>强弱对比</strong></p><p>2.<strong>形状和尺寸的对比</strong></p><p>3.<strong>细节的分布</strong></p><h1 id="二、概念创造"><a href="#二、概念创造" class="headerlink" title="二、概念创造"></a>二、概念创造</h1><p> 概念美术师：通过设计视觉上的解决方案帮团队解决问题</p><h2 id="1-项目前期准备"><a href="#1-项目前期准备" class="headerlink" title="1.项目前期准备"></a>1.项目前期准备</h2><p><strong>理解要解决的问题</strong>：一切都是为了解决问题</p><p><strong>设置约束</strong>：游戏的主体、机制、类型都会影响概念设计</p><p><strong>调查研究</strong>：mood board</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205112746783.png" alt="image-20221205112746783"></p><h2 id="2-生成创意"><a href="#2-生成创意" class="headerlink" title="2.生成创意"></a>2.生成创意</h2><p><strong>快速画出你的技巧</strong></p><p><strong>关门技巧</strong>：防止无休止的修改（记下已经抛弃的方面，在感兴趣的地方多修改，从广到窄地拓展</p><h2 id="3-获取反馈"><a href="#3-获取反馈" class="headerlink" title="3.获取反馈"></a>3.获取反馈</h2><p>寻求反馈时问一些更精确的问题；</p><p>不要盛大登场，画的越快越好，有了修改尽快寻求反馈</p><p>认真对待你的作品</p><p>这一话和上一话都提到了要多画，不要纠结于一幅画想要设计的非常好</p><h1 id="三、角色设计"><a href="#三、角色设计" class="headerlink" title="三、角色设计"></a>三、角色设计</h1><h2 id="从概念到3D模型"><a href="#从概念到3D模型" class="headerlink" title="从概念到3D模型"></a>从概念到3D模型</h2><p>抓住标志性的元素</p><h2 id="3D建模的过程"><a href="#3D建模的过程" class="headerlink" title="3D建模的过程"></a>3D建模的过程</h2><p><strong>代理模型</strong>：大色块，方便修改</p><p><strong>高多边形雕塑</strong></p><p><strong>低多边形网格</strong></p><p><strong>UV图</strong>：高多边形雕塑中的细节画进来</p><p><strong>材质烘焙</strong></p><h2 id="表面改变"><a href="#表面改变" class="headerlink" title="表面改变"></a>表面改变</h2><p><strong>材质绘制</strong>：贴图</p><p><strong>着色器</strong>：shader</p><h2 id="解剖学"><a href="#解剖学" class="headerlink" title="解剖学"></a>解剖学</h2><p>创造不存在的生物也很有用</p><h2 id="协作改变"><a href="#协作改变" class="headerlink" title="协作改变"></a>协作改变</h2><p>比如设计角色的盔甲、围巾等部分会对动作有影响的，要和动作是，ta来一起改变</p><h1 id="四、环境设计"><a href="#四、环境设计" class="headerlink" title="四、环境设计"></a>四、环境设计</h1><h2 id="什么是环境美术"><a href="#什么是环境美术" class="headerlink" title="什么是环境美术"></a>什么是环境美术</h2><h2 id="创建的过程"><a href="#创建的过程" class="headerlink" title="创建的过程"></a>创建的过程</h2><p>首先和设计师讨论什么是最重要的部分，概念美术师会定下主基调，设计师会用灰色模块摆出场景需要的元素，比如障碍、陷阱、敌人位置等等。</p><p>灰盒-&gt;白盒-&gt;精细化-&gt;光照等一些打磨</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205152344956.png" alt="image-20221205152344956"></p><p>同样，环境美术也要服务于玩法、并且尽可能清晰地展示信息</p><h2 id="视觉层次"><a href="#视觉层次" class="headerlink" title="视觉层次"></a>视觉层次</h2><p><strong>分层与布置</strong></p><p><strong>光影</strong> </p><p><strong>细节层级</strong></p><h2 id="可信度"><a href="#可信度" class="headerlink" title="可信度"></a>可信度</h2><p><strong>叙事感</strong>：天气、年代、文化等都可以通过环境阐述（涌现式叙事）</p><p><strong>调查研究</strong>：布局，细节</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p><strong>模块化套件</strong>：模型重用，限制低多边形和贴图的数量</p><h1 id="五、技术美术"><a href="#五、技术美术" class="headerlink" title="五、技术美术"></a>五、技术美术</h1><h2 id="骨骼制作"><a href="#骨骼制作" class="headerlink" title="骨骼制作"></a>骨骼制作</h2><h2 id="定制化工具"><a href="#定制化工具" class="headerlink" title="定制化工具"></a>定制化工具</h2><p>为美术师定制细微的需求</p><h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p>简化流程</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>创建更清晰的流程、工具来组织文件</p><p>1.<strong>版本控制</strong></p><p>2.<strong>文件命名方式</strong></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205160033250.png" alt="image-20221205160033250"></p><h2 id="shaders"><a href="#shaders" class="headerlink" title="shaders"></a>shaders</h2><p>自动填充环境</p><h2 id="simulation"><a href="#simulation" class="headerlink" title="simulation"></a>simulation</h2><p>使用数学来模拟布料、材料、头发等各种东西</p><h1 id="六、角色动画"><a href="#六、角色动画" class="headerlink" title="六、角色动画"></a>六、角色动画</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205160601480.png" alt="image-20221205160601480"></p><h2 id="游戏中动画的基本目标"><a href="#游戏中动画的基本目标" class="headerlink" title="游戏中动画的基本目标"></a>游戏中动画的基本目标</h2><p><strong>清晰的展示动作</strong></p><p><strong>构建可信的运动和物理法则</strong></p><p><strong>注入个性</strong></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>参照</strong></p><h2 id="姿势"><a href="#姿势" class="headerlink" title="姿势"></a>姿势</h2><p><strong>作用线</strong></p><p><strong>重量分布</strong>：保证正常中心在脚上，道具离中心越近，可以代表这个道具越重</p><p><strong>独特性</strong></p><h2 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h2><p><strong>距离和间隔</strong></p><p><strong>挤压和拉伸</strong></p><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h2><p>根据速度转换，转向，以及许多互动</p><h1 id="七、视觉效果"><a href="#七、视觉效果" class="headerlink" title="七、视觉效果"></a>七、视觉效果</h1><h2 id="实时视觉特效"><a href="#实时视觉特效" class="headerlink" title="实时视觉特效"></a>实时视觉特效</h2><p><strong>粒子系统</strong> </p><p>如何创建一个火球</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205163647979.png" alt="image-20221205163647979"></p><p>交互性的游戏体验</p><p>需要有约束，不能每一个特效都做的很大很酷炫</p><p><strong>形状</strong>：一致性的图像语言方便区分，比如加号代表恢复，圆形代表护盾，尖刺代表伤害，比色彩更容易区分</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205164129349.png" alt="image-20221205164129349"></p><p><strong>色彩</strong></p><p><strong>时机</strong>：不要线性的设计，加入加速度或者延迟会更有趣</p><h1 id="八、声音设计"><a href="#八、声音设计" class="headerlink" title="八、声音设计"></a>八、声音设计</h1><h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p><strong>提供玩法线索</strong>：Jin鞥是否准备好，是否收到伤害，是否被敌人发现，是否需要更多资源</p><p><strong>提供反馈</strong></p><p><strong>驱动游戏情感</strong></p><h2 id="音频术语"><a href="#音频术语" class="headerlink" title="音频术语"></a>音频术语</h2><p>有时候不用文字来表述，直接bbox来表述</p><p><strong>频率</strong></p><p><strong>包络线</strong></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205165011132.png" alt="image-20221205165011132"> </p><p>起冲代表冲零到最大振幅的时间</p><p>衰减代表冲最大振幅到振幅稳定的时间</p><p>延续代表振幅稳定的时间</p><p>消失代表振幅稳定到零的时间</p><p><strong>动态</strong></p><p>对adsr进行微调就能表现不同的效果</p><h2 id="音频设计工具箱"><a href="#音频设计工具箱" class="headerlink" title="音频设计工具箱"></a>音频设计工具箱</h2><p><strong>衰减</strong>：不同声音的衰减程度不一样</p><p><strong>均衡</strong>：</p><p><strong>混响</strong>：</p><h2 id="融入游戏"><a href="#融入游戏" class="headerlink" title="融入游戏"></a>融入游戏</h2><p>对话，切换角色、boss战</p><h2 id="拟音"><a href="#拟音" class="headerlink" title="拟音"></a>拟音</h2><p>缺少合适的音频就得使用拟音</p><h1 id="九、用户界面设计"><a href="#九、用户界面设计" class="headerlink" title="九、用户界面设计"></a>九、用户界面设计</h1><h2 id="UX和UI"><a href="#UX和UI" class="headerlink" title="UX和UI"></a>UX和UI</h2><p>UX：User Xperience</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205173429183.png" alt="image-20221205173429183"></p><p>UI：User Interface</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221205173440503.png" alt="image-20221205173440503"></p><h2 id="视觉设计的原则"><a href="#视觉设计的原则" class="headerlink" title="视觉设计的原则"></a>视觉设计的原则</h2><p>利用简单的方式展示复杂的信息，以便玩家能快速理解并作出应对</p><p><strong>了解你的玩家</strong>：了解你的玩家会在哪里玩，用什么玩？不同类型对于ui信息的需求也不一样，卡牌，4x游戏ui很丰富，叙事游戏比较简单</p><p><strong>系统性地思考</strong>：统一且高度流畅</p><p><strong>布局</strong>：</p><h2 id="动态影像的原则"><a href="#动态影像的原则" class="headerlink" title="动态影像的原则"></a>动态影像的原则</h2><p>ui不是静态的过程，如果说视觉设计是为了传递一条容易理解的信息，那么动态就是为了让这条信息被清晰感知</p><p><strong>响应性</strong>：点击感觉要流畅轻松</p><p><strong>意图</strong>：将交点转移到关键行动和路径</p><p> <strong>意识</strong>：各种元素自适应地在对应的位置呈现 </p><p><strong>一致性</strong>：规则要已知</p><p><strong>物理直觉</strong>：使用符合游戏品牌的风格化元素</p><h1 id="十、游戏设计"><a href="#十、游戏设计" class="headerlink" title="十、游戏设计"></a>十、游戏设计</h1><h2 id="什么是游戏？"><a href="#什么是游戏？" class="headerlink" title="什么是游戏？"></a>什么是游戏？</h2><p>目标、阻碍、选择和规则，但是最重要的，要有乐趣：比如体验一种幻想世界，经历刺激和冒险，友情和熊庆，精通技巧，探索未知，创意和表达</p><p>因为有趣的定义很主观，所以设计核心体验很重要</p><h2 id="目标和进度"><a href="#目标和进度" class="headerlink" title="目标和进度"></a>目标和进度</h2><p>进度要明显，要注意高潮弧度</p><h2 id="阻碍"><a href="#阻碍" class="headerlink" title="阻碍"></a>阻碍</h2><p>挫败感是必要的，这个可以看一下樱井政博的风险收益理论</p><p><strong>困难与不公平</strong>：如果游戏有不一致或者难以预测的内容，就会让玩家不公平</p><p><strong>运气和技巧</strong>：这个可以看一下万智牌之父在gdc的演讲，高运气高技术的游戏有德扑、吃鸡、自走棋</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>迷人的蔚蓝</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E8%94%9A%E8%93%9D%E7%82%B9%E8%AF%84/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E8%94%9A%E8%93%9D%E7%82%B9%E8%AF%84/</url>
    
    <content type="html"><![CDATA[<p>作为一款横版游戏，主角的操纵感良好非常重要，蔚蓝手感紧凑、精确且灵敏，能准确控制落点，流畅精准地穿梭平台之间。Madeline的加速曲线和跳跃曲线都调得非常棒，让人感觉快的行云流水，又慢得让人感觉掌控一切。</p><p>游戏中还有意设计了许多有益于玩家的机制，比如土狼时间、抓跳、蹬墙跳，对比jump king、掘地求升这类从操作层面恶心玩家的游戏，在蔚蓝的每次死亡只会让我觉得是自己失误了而不是游戏有问题，它更加鼓励我去思考“怎么破解障碍，怎么优化操作”。</p><p>设计者在给想做横版跳跃游戏的人的建议中也提到：“确保每一刻都很舒服，这么一来，当玩家拿着手柄做那，关卡也许空无一物，但仅是操控角色就让他们感觉良好，只需角色本身能做些精彩动作就很有趣。”</p><p>蔚蓝的关卡设计更是标杆，蔚蓝的基础操作很简单，跑、跳、爬和冲刺，引入体力条让它成了一款资源管理解密游戏：在一段垂直空间，你要选择何时何地使用什么操作，先冲刺，然后跳跃，接着落地补充体力，然后开始新的旅程，每个动作有不同的手感、速度和操控性，赋予了游戏刺激且多变的节奏。</p><p>设计者把每一个关卡当成一个故事来设计，<strong>告诉玩家要做什么，但是不会告诉玩家怎么做</strong>，在<strong>不断传授新知识</strong>的过程中保持新鲜感，蔚蓝使用了<strong>动态难度</strong>（你可以自由选择是否去拿草莓、是否挑战b面），而且设计师有意将一些比较难的关卡设置为不影响主线的死角房间，让每个层次的玩家都得到了很好的体验。</p><p>还有紧凑的音乐，出色的人物塑造，感人的剧情，神庙救出Theo夜谈的那部分太让我触动了，这一切的一切都共同构成了蔚蓝，这一款令人着迷的游戏。 </p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蔚蓝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种焦虑</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E4%B8%A4%E7%A7%8D%E7%84%A6%E8%99%91/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E4%B8%A4%E7%A7%8D%E7%84%A6%E8%99%91/</url>
    
    <content type="html"><![CDATA[<p>最近陷入了两种焦虑，其一是鼹鼠囤积癖，因为之前豆瓣建政被封了半年，写的标记的好多东西都有一种会丢掉的感觉，有过自己建博客的想法，但是上班摸鱼的时候看的好多十几年前的博客，也都随风飘散了，真是如红豆唱的那般：“没有什么是永垂不朽。“于是乎买了好多游戏卡带，实体书，看着steam里面的那么多游戏，也非常担心某一天消失。</p><p>再者就是生活好像在一天天的循规蹈矩中找不到意义了，本人刚毕业，在做游戏开发，工作强度不大，但是一旦适应了这个节奏，生活中好像就没有其他自己的时间了，整个十月没看什么电影，没有自学怎么做自己想做的游戏。回顾一下自己干了什么，好像真的只有那些能数字化的东西能带给自己意义，比如游戏时长、健身重量、观影量阅读量，人生的意义似乎都被这些数字占领了，真可怕。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Florence</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/Florence/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/Florence/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20230102205814787.png" alt="image-20230102205814787"></p><p>Florence，一个流程很短（40min就能玩完的游戏）的故事，讲述了一个简单的恋爱故事。或许这才是交互性叙事游戏该有的样子，全程没有一句台词，通过画面、音乐和各种有代入感的点击和拖拽来让你自己脑补出剧情，画面和音乐真的太棒了。</p><p>很有印象的几个点，拼图聊天通过拼凑次数表示出彼此的聊天越来越接近，又用尖锐程度看出吵架的激烈；吵架过后，两个人虽然回去睡觉，但怎么也拼不到一起去了；快要离别的时候，放下手柄用鼠标来最大权利的拼好拼图，但是最终还是无能为力;放手这一个章节，可以一直按住在原地等着他，但是故事也不会继续推进，sigh…；搬离房间的时候，我早就忘记了彼此的物品，可是一开始还是我自己一件一件放进来的。玩的时候还觉得前面的各种糖太甜了，可是留下印象的确实各种刀子….</p><p>分享两句设计师的设计哲学：1. 把玩家的注意力当作一种有限资源，有效的表达来自于对这种资源的控制；2. 用游戏机制达成的模拟和隐喻来讲故事，用机制的进化、微调和重复来表达进展。</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>florence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发行游戏要避免的误区</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8F%91%E8%A1%8C%E6%B8%B8%E6%88%8F%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E8%AF%AF%E5%8C%BA/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8F%91%E8%A1%8C%E6%B8%B8%E6%88%8F%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E8%AF%AF%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>这里写关于页的正文，支持 Markdown, HTML</p><p>最重要的两个问题</p><p>1.这个游戏值得做吗？2.这个游戏能被做出来吗？</p><p>误区：</p><h3 id="1-背景不重要"><a href="#1-背景不重要" class="headerlink" title="1.背景不重要"></a>1.背景不重要</h3><p>别花大篇幅介绍背景，大篇幅介绍世界观没有任何意义。</p><h3 id="2-别介绍背包系统了"><a href="#2-别介绍背包系统了" class="headerlink" title="2.别介绍背包系统了"></a>2.别介绍背包系统了</h3><p>同理适用于别介绍了那些平平误区的游戏元素</p><p>3.别让别人帮你设计游戏</p><p>不要用问题开头，比如什么你觉得什么是3A游戏，用问题做开场白很不好。</p><p>4.游戏主题和亮点不是一个东西。</p><p>5.至少要讲讲游戏体验。</p><p>6.不要用“现实”来为你的游戏找借口。<br>别人问你为什么这样创新的时候，你不能说因为现实中人们不能二段跳。</p><p>7.你不需要一个框架来编排好你的展示。</p><p>展示就简单点，不需要那么多上下文，只是一个game show</p><p>8.不要用致敬作为糟糕设计的借口。</p><p>9.不要忽视有可能遇到的技术难题。</p><p>10.在样品demo里优先展示核心玩法而不是容易开发的部分。</p><p>11.概念图在精不在多。</p><p>12.只使用灰盒，或者成品质量的美术资源。</p><p>13.不要过早的打磨细节。</p><p>14.游戏中的文字应该足够吸引人。</p><p>15.不要为赶热点而赶热点。</p><p>16.在练习之前，做好应有的发行商调研。</p><p>17.即使是山寨游戏，也该有独特的闪光点。</p><p>18.不要指望投资发行商会为你争取一个IP。</p><p>19.多讲游戏细节，把商业计划留到开发后期决定。</p><p>20.对于游戏的开发时间和成本应该有所估量。</p><p>21.在练习发行商前，确保你有一个可信的团队。</p><p>22.不要把你的商业计划基于过去的某个特例。</p><p>23.不要表现的像一个很难合作的人。</p><p>24.不要指望发行商听说过你的大名。</p><p>25.面对提问从容应对，因为这是个好迹象。</p><p>26.不要用手机来演示PPT和视频。</p><p>27.为演示视频准备好耳机。</p><p>28.保持良好的精神面貌。</p><p>29.不要说其他游戏&#x2F;公司&#x2F;开发者坏话。</p><p>30.保持洁净。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>好玩的好设计</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%A5%BD%E8%AE%BE%E8%AE%A1/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%A5%BD%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>桌游无非是一个玩法，不应受困于道具或者表现方式，当你有了一个好玩的想法，抓住这个灵感，去将它实现吧！</p><p>读这本书是很开心的，书中的桌游美术都十分优秀，赏心悦目，不过机制方面就比较简单了，许多根本称不上是一个游戏，只是一个简单的原型，可玩性很差。快速翻阅的过程中的第一感觉：“啊，机制都很简单啊，以后自己也要多记录一下想法，来尝试做做桌游。“</p><h3 id="一、先考虑故事背景"><a href="#一、先考虑故事背景" class="headerlink" title="一、先考虑故事背景"></a>一、先考虑故事背景</h3><p>先想好故事背景，更偏向于艺术性的表达而不是玩法，背景足够丰富再套一个其他成熟机制的皮，是一个不错的思路，不过这些都是对美术要求很高，机制玩法的创新不足。</p><p>《台湾妖怪斗阵》：调查了很多妖怪的故事，美术很用心，机制一般。</p><p><img src="C:/Users/Administrator/Desktop/微信图片_20221029005744.jpg" alt="微信图片_20221029005744"></p><p>《勃鲁盖尔主义》：这个画风我蛮喜欢，而且自己创造出架空世界，构建世界观的体验很不错，有机会我也要试试。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/89b3682e8cd18c79f78b68510d5b726.jpg" alt="89b3682e8cd18c79f78b68510d5b726"></p><h3 id="二、解决问题的桌游"><a href="#二、解决问题的桌游" class="headerlink" title="二、解决问题的桌游"></a>二、解决问题的桌游</h3><p>《手语游戏》：针对少数群体的游戏，一个很温暖有趣的游戏。</p><p>《故事》：看图说话的桌游很多，感觉这个没啥意思，画物语和驴桥也很有意思，这种聚会游戏还得是看人，规则就是看图说故事，没什么创新。</p><p>《区域》：一个关于城市规划的桌游，这种能学习到知识的还是蛮有意思的，游戏本身就是学习的好方式，之前有想过能不能做一款模拟经营的游戏，来学习经济学知识，类似商战模拟？好像有同学参加过，有游戏化的可能。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221029005744.jpg" alt="微信图片_20221029005744"></p><p>《迷情36问》：号称是相亲桌游，其实感觉不如普思斯特问卷，另一个款我比较喜欢的聊天破冰桌游叫命悬一线，玩法就是根据自己的价值观以及和对别人价值观的了解来排序，玩的时候挺可以了解彼此的价值观的。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/a68365a027857bd79422ce37edb5a66.jpg" alt="a68365a027857bd79422ce37edb5a66"></p><p>《我的太空冒险》：儿童桌游，看图讲故事，儿童桌游不需要很强的竞争性和目的性，算是一个方向吧，目的就是为了认识词汇量。</p><h3 id="三、表达观点"><a href="#三、表达观点" class="headerlink" title="三、表达观点"></a>三、表达观点</h3><p>《包办婚姻》：一个巴基斯坦反对包办婚姻主题的桌游，主题很新颖，目标是是打牌来抵制包办婚宴，卡牌都是很现实中的事情，比如躲避媒人、健身、故意和男生逛街，玩法和主题结合的很好，引人深思。</p><p>书中还提到的其他的主题有：环保、节约水资源、北极熊、女权。</p><h3 id="四、地域文化宣传"><a href="#四、地域文化宣传" class="headerlink" title="四、地域文化宣传"></a>四、地域文化宣传</h3><p>都是背景优先，其实德式桌游很经典的一个设计方法就是一个数学模型套好多皮，比如《现代艺术》，套了几十个国家的名画，机制非常重要，下面放两张香港美食和台湾变电箱题材的桌游，后者蛮有意思。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221029005124.jpg" alt="微信图片_20221029005124"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221029005131.jpg" alt="微信图片_20221029005131"></p><h3 id="五、奇怪的委托"><a href="#五、奇怪的委托" class="headerlink" title="五、奇怪的委托"></a>五、奇怪的委托</h3><p>《我们的故事》：是一个求婚礼物，我一直觉得为自己喜欢的人创作东西非常地酷，非常地浪漫啊，玩法有点像像跑团，又或者说是桌面版双人成行，最后一个任务的结束语是：“你愿意嫁给我吗”，太赞了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221028230225.jpg" alt="微信图片_20221028230225"></p><p>《勃鲁盖尔主义》：这个画风我蛮喜欢，而且自己创造出架空世界，构建世界观的体验很不错，有机会我也要试试。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/89b3682e8cd18c79f78b68510d5b726.jpg" alt="89b3682e8cd18c79f78b68510d5b726"></p><h3 id="二、解决问题的桌游-1"><a href="#二、解决问题的桌游-1" class="headerlink" title="二、解决问题的桌游"></a>二、解决问题的桌游</h3><p>《手语游戏》：针对少数群体的游戏，一个很温暖有趣的游戏。</p><p>《故事》：看图说话的桌游很多，感觉这个没啥意思，画物语和驴桥也很有意思，这种聚会游戏还得是看人，规则就是看图说故事，没什么创新。</p><p>《区域》：一个关于城市规划的桌游，这种能学习到知识的还是蛮有意思的，游戏本身就是学习的好方式。</p><p>《迷情36问》：号称是相亲桌游，其实感觉不如普思斯特问卷，另一个款我比较喜欢的聊天破冰桌游叫命悬一线，玩法就是根据自己的价值观以及和对别人价值观的了解来排序，玩的时候挺可以了解彼此的价值观的。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/a68365a027857bd79422ce37edb5a66.jpg" alt="a68365a027857bd79422ce37edb5a66"></p><p>《我的太空冒险》：儿童桌游，看图讲故事，儿童桌游不需要很强的竞争性和目的性，算是一个方向吧，目的就是为了认识词汇量。</p><h3 id="三、表达观点-1"><a href="#三、表达观点-1" class="headerlink" title="三、表达观点"></a>三、表达观点</h3><p>《包办婚姻》：一个巴基斯坦反对包办婚姻主题的桌游，主题很新颖，目标是是打牌来抵制包办婚宴，卡牌都是很现实中的事情，比如躲避媒人、健身、故意和男生逛街，玩法和主题结合的很好，引人深思。</p><p>书中还提到的其他的主题有：环保、节约水资源、北极熊、女权。</p><h3 id="四、地域文化宣传-1"><a href="#四、地域文化宣传-1" class="headerlink" title="四、地域文化宣传"></a>四、地域文化宣传</h3><p>都是背景优先，其实德式桌游很经典的一个设计方法就是一个数学模型套好多皮，比如《现代艺术》，套了几十个国家的名画，机制非常重要，下面放两张香港美食和台湾变电箱题材的桌游，后者蛮有意思。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221029005124.jpg" alt="微信图片_20221029005124"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221029005131.jpg" alt="微信图片_20221029005131"></p><h3 id="五、奇怪的委托-1"><a href="#五、奇怪的委托-1" class="headerlink" title="五、奇怪的委托"></a>五、奇怪的委托</h3><p>《我们的故事》：是一个求婚礼物，我一直觉得为自己喜欢的人创作东西非常地酷，非常地浪漫啊，玩法有点像像跑团，又或者说是桌面版双人成行，最后一个任务的结束语是：“你愿意嫁给我吗”，太赞了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221028230225.jpg" alt="微信图片_20221028230225"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【gdc讲座】关卡设计讲座</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E5%85%B3%E5%8D%A1%E8%AE%BE%E8%AE%A1%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>一、优秀的关设计拥有有趣的指引</p><p>观察性：</p><p>战略性</p><p>指引性</p><p>建立一致性的视觉语言很重要(镜之边缘)</p><p>有时候制造混乱也很重要</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221026213328369.png" alt="image-20221026213328369"></p><p>二、优秀的关卡设计不依赖文字来讲述故事</p><p>让玩家自行添补缺口，缺口的大小（难度）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20221026213427823.png" alt="image-20221026213427823"></p><p>叙事类型：明示型、暗示型和涌现型</p><p>后两种是构建缺口的重要方法</p><p>涌现型是玩家自己构思的剧情</p><p>暗示型：环境叙事</p><p>涌现型：通过玩家选择来做到，但是太多的选择会让玩家困惑</p><p>三、告诉玩家要做什么，但是不会告诉玩家怎么做</p><p>不要惩罚玩家的即兴行为，要把这个做进游戏中</p><p>提供并行的任务目标</p><p>四、不断传授新知识</p><p>A Theory of Fun Raph Koster</p><p>人类喜欢分析一些模式，将其存储在大脑并在之后提炼并使用</p><p>分析正式乐趣所在</p><p>塞尔达系列！这一原则的巅峰，会让你使用每一种道具的不同使用玩法</p><p>learn-&gt;play-&gt;challenge-&gt;surprise</p><p>先直接教会玩家，然后提供一个安全区域练习，之后附带一些敌人，当玩家觉得感觉良好是，用一些难度</p><p>五、好的设计是令人惊喜的</p><p>不是惊吓，而是包含新鲜感，不要墨守成规</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>樱井政博教程</title>
    <link href="/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A8%B1%E4%BA%95%E6%94%BF%E5%8D%9A%E6%95%99%E7%A8%8B/"/>
    <url>/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A8%B1%E4%BA%95%E6%94%BF%E5%8D%9A%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>RPG的游戏性</p><p>游戏开发绝非游戏</p><p>樱井的这套观点和岩田聪当年表达的基本一致：“比起喜欢游戏，我更擅长于做游戏，所以我选择了这个行业。”两个人理念相合，在七年多之后遥相呼应，也是一种高山流水了。</p><p>演讲就要多快好省</p><p>速度，切除冗余，直入中心</p><p>游戏回报理论</p><p>冒风险获得收益 </p><p>游戏性是指控制风险并获得回报的乐趣，攻略是指控制风险并获得回报的方法</p><p>能控制风险的机制是游戏平衡性的关键</p><p>游戏性的来源：压力的施加与释放</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>只需一套词卡&amp;只需一副扑克就能玩的桌游</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E5%8F%AA%E9%9C%80%E4%B8%80%E5%A5%97%E8%AF%8D%E5%8D%A1&amp;%E5%8F%AA%E9%9C%80%E4%B8%80%E5%89%AF%E6%89%91%E5%85%8B%E5%B0%B1%E8%83%BD%E7%8E%A9%E7%9A%84%E6%A1%8C%E6%B8%B8/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E5%8F%AA%E9%9C%80%E4%B8%80%E5%A5%97%E8%AF%8D%E5%8D%A1&amp;%E5%8F%AA%E9%9C%80%E4%B8%80%E5%89%AF%E6%89%91%E5%85%8B%E5%B0%B1%E8%83%BD%E7%8E%A9%E7%9A%84%E6%A1%8C%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>首先来说说猜词桌游，你只需要花一百多，去买一个叫行动代号的桌游，你就能买到几百张词卡，有了这套词卡，你可以至少玩五个机制不同的猜词游戏。</p><p>首先是行动代号本身，一款很经典的猜词游戏，双方分为两队，两队需要在25个词中猜中8个词，由队长轮流提出线索，先猜中所有词的队伍获得胜利。队长需要找出这8个词的关系，给出的线索必须是一个词+一个数字的组合，代表有几个词和这个线索词有关。比如你希望对方猜中足球和篮球，那么你可以说运动和2，代表你告诉你的队员在这25个词中有两个词跟运动有关，如果你们的脑电波对上了，那么就成功完成这一轮，但是如果你的队友比较猪鼻，那么他可能误解你的意思，猜中无关词，甚至猜中对方的词帮助对方推进了进度。</p><p>第二个叫埋雷猜词，你的目的是猜中对方的猜词逻辑，埋雷让对方猜中。举个例子，这一次敌方队长要给他们队员传递的词足球，你们需要先讨论一段时间，写出五个你们觉得他在描述这个词的过程会说的五个词，比如运动，中国，退钱，世界杯，梅西，你可以很直球也可以很玩梗，这取决于你们对对方队长的了解，然后埋好雷之后就开始对方队长的猜词环节，队员有无数次猜词的机会，但是队长只要在描述的过程中说出了你们写下的词，你们就获胜了，反之，如果没有说出这些词的情况下敌方队员猜中了这个词，他们胜利。</p><p>第三个猜词游戏是一个纯合作游戏，叫独家暗语，游戏玩法如下：每个人轮流抽一张词卡，你自己不能看这种词卡，其他人的目标是写词让你猜出这个词，有趣的来了，他们写下自己的词的时候是不能互相交流讨论的，在他们给你看他们写下的词之前，彼此需要互相对一下，如果恰好想到一起去了，比如再猜犀牛的时候，有两个人都写了偷猎， 那么他们两个的词你都无法看，你的线索就少了两条，这个游戏的魅力就在于你的梗不能和别人太对上，但是如果都太抽象那么会让猜词的人很难办，所以也是一个非常有意思的角度。</p><p>第四个猜词游戏叫截码战，是一个合作对抗游戏，这个游戏的玩梗程度我认为是达到了巅峰，具体规则可以看看这个视频，他的精髓就在于在不断的试探过程中你的词语会逐渐被对方猜到，所以为了抽象会让队友看着自己的词也非常难猜，当然要是你能说出一些只有你和你队友之间互相才知道的黑话，那就非常有意思并且非常有成就感了。这个游戏需要一些支架，可以用笔来代替，如下图。</p><p>还有一些猜词游戏比如说驴桥、命悬一线、传情画意、言下之意下次有机会再介绍吧，这些也都是可以用一套词卡来玩的，总之就是非常得多种多样物超所值！</p><p>再介绍一些扑克游戏，想赌博的话可以玩玩德州扑克，非常刺激，买一些便宜的筹码就可以了，还有一种吃墩类型的游戏有非常多的花样，分别是souct，潜航员（这个是合作吃墩），巫师牌，巫师牌极限版，tichu（这个相当有意思，2v2斗地主），桥牌（桥牌算分有点复杂）。当然还可以扑克牌玩一些身份类游戏，狼人杀阿瓦隆之类的，直接在牌上写字就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>桌游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>祝我生日快乐</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%97%A5%E6%96%87%E7%AB%A0/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%97%A5%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>今天是22岁生日，正好工作也一个月多了，借着这个机会写点东西吧。</p><p>首先说说上班的感受吧，完美世界的工作强度还是很让人开心的，有一种回到大学的感觉，每天三顿吃食堂，早十晚七，两小时午休，双休。没有什么pua、加班的情况，组里的人都极度友善，大家的口癖是牛逼，做了啥事都是这个评价，开会的时候也都是笑嘻嘻的，可以说是一点压力都没有感受到。唯一不同的是回到租的房子是一个人，不过也好，有自己的一片小天地，自由、安静、能干一些自己喜欢的事。</p><p>化了两周时间做完了图形学小项目之后，便开始看项目源码，我被分到了重置版，代码结构和规范相比于20年前的老项目好太多了，。配置好环境拉好资源之后，看着这么大一个游戏真的在visual studio里跑起来，内心的震撼程度不亚于亲手造了一辆车or飞机。有一种希望强烈弄懂所有细节的冲动，很难想象前辈是如何一点一点地构造出整个系统的，引擎、客户端、服务端，如此复杂的系统，在我看来就是一座宝库，要是我能够弄清这些逻辑，该如何美妙。</p><p>于是我开始如饥似渴地地阅读庞大的源码，但很快就令人感到有些挫败，第一次看这种几百个文件的大项目的源码，实在是一头雾水，方法论比较欠缺，文档和注释也接近于没有，，嗯看了两天搜了好多方法，比如什么画思维导图、top-down和bottom-up相结合。 又看了一周，写写画画了很多，一边写</p><p>有些不满的地方也在于此，上班一个月了，没有任何官方的培训，每天就只是自己看代码，从图形学项目到项目源码，大部分时间都是在自学，很担心自己的理解是否正确，有一种强烈的危机感，害怕自己在混学不到东西被淘汰。一开始也比较社恐不敢去问leader，担心打扰工作什么的，后来做了一个小需求和leader交流了发现其实leader非常随和，交流也都是以鼓励为主，而且还是北航学长，瞬间放下防备！</p><p>不加班的好处，就是能有大把晚上时间做自己想做的事情，一发工资就买了许多想看的书，因为白天里看屏幕实在太久，所以能翻阅纸质书真的成了一种享受，</p><p>未来的计划，首先就是抓紧</p><p>最后想引用一段《DOOM启示录》中的话：“在信息时代，客观障碍已不复存在，所谓障碍都是主观上的。如果你想动手开发什么全新的技术，你不需要几百万美元的资金，你只需要在冰箱里放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心”</p><p>最近一周的晚上很沉迷学unity，这个学起来太爽了，看完自己公司的shit moutain再来学unity顿时感觉神清气爽，能直接做出一个小demo的感觉太棒了，这种实践中学习的感觉效果太好了，</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些沉迷学习的时光</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E4%B8%80%E4%BA%9B%E6%B2%89%E8%BF%B7%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%B6%E5%85%89/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E4%B8%80%E4%BA%9B%E6%B2%89%E8%BF%B7%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%97%B6%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>最近在学计算机图形学，为了完成一个小任务，刷games101以及看各种directx教程博客，手写笔记做了大半本，从一开始的一头雾水到逐渐能渲染出目标物体，一步一步创造自己世界的感觉实在是太棒了，这种刚刚学到的知识公式就能立马应用于代码中的感觉重燃了我对于学习的热情，并且在上课过程中，许多我本科学的感觉无用的知识，比如数字信号处理、数值分析、正逆运动学、欧拉方程……都能立马得到应用，这太令我开心了，也让我疯狂联想：天哪，游戏行业是多么美妙的事情，他包罗万象，我的阅读、音乐、观影，还有那么多无用的知识，或许都能用得到！</p><p>因为本人大学不学无术，涉猎各种娱乐，所以我从前的规划是进入游戏行业，创造自己理想的游戏，我理想中的游戏产生是第九艺术，灵感创造，但是现在想想，或许钻研技术开发游戏引擎什么的也不错，我之前对于游戏开发还是有一种浪漫化艺术化的想像，现在或许更接近工程师了。</p><p>这种学习上瘾的时刻在人生中还有几次：初中某次看天文书籍的时候，那时候连椭圆是什么都不知道，但看到能自己推出行星间的运动规律大感神奇，于是痴迷了很久焦点啊、；高中参加生物生物奥赛，如今看来就是记忆力比赛，那时候翻看厚厚的各种生物学大学教材，植物学动物学微生物学生物化学，手写了两三个本子的笔记，那时候走在路上，对于各种花花草草都熟悉得不得了，什么科什么属，花是什么形状怎么传粉，想想还蛮浪漫的。</p><p>再然后遇到了一个非常好的高中数学老师，他讲的课让我有一种能应对任何题型的成就感，从圆锥曲线到导数，他的每一次课堂都能让我有一种妙啊的快感，再加上大量的刷题，反过来他的讲解也进一步印证了他的体系的完备，就是他！给了我对于数学的自信和喜爱！</p><p>最近的沉迷学习时刻就是准备工作面试，那时候压力蛮大，但是也有个明确的计划，一边面试一遍看面经刷编程题，面试不会的知识点当天搞懂，然后又通过下一次面试来验证学过的知识，如此反复，颇有一种打怪升级的感觉。</p><p>这些时刻都是有一定的压力，满足了自身兴趣，能够按照预先制定好的计划来努力，并且可以及时地得到正反馈（刷题正确率，面试成功，任务完成），获得游戏般的上瘾体验，理论知识和实践互相印证，学习效率非常高。</p><p>好，希望我能继续热情下去。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>汕头旅行</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E6%B1%95%E5%A4%B4%E6%97%85%E8%A1%8C/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E6%B1%95%E5%A4%B4%E6%97%85%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>旅行的意义不是做了什么，而是和谁在一起，</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>桌游记录</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E6%A1%8C%E6%B8%B8%E8%AE%B0%E5%BD%95/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E6%A1%8C%E6%B8%B8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="玩过"><a href="#玩过" class="headerlink" title="玩过"></a>玩过</h1><h2 id="花砖物语"><a href="#花砖物语" class="headerlink" title="花砖物语"></a>花砖物语</h2><p>和zzh和阿咩玩了一局三人局，zzh的感觉是我一开始讲规则的时候没想到有如此深远的影响，总的来说还是挺有策略性的，最重要的是可以恶心人，但是有一点感觉很奇怪，后期会被扣分扣得太多了，有点奇怪啊。</p><h2 id="七大奇迹对决"><a href="#七大奇迹对决" class="headerlink" title="七大奇迹对决"></a>七大奇迹对决</h2><p>非常好的二人游戏，和娟儿玩了两把他上瘾了，这种拔河的感觉还是很有意思的，</p><h2 id="Bible（储藏室）"><a href="#Bible（储藏室）" class="headerlink" title="Bible（储藏室）"></a>Bible（储藏室）</h2><h2 id="行动代号"><a href="#行动代号" class="headerlink" title="行动代号"></a>行动代号</h2><p>这个游戏这个假期（2022）推的好成功，基本每个局都挺上瘾，不过还是很容易演变为队长之间的对决，有点问题</p><h2 id="行动代号：二重奏"><a href="#行动代号：二重奏" class="headerlink" title="行动代号：二重奏"></a>行动代号：二重奏</h2><h2 id="截码战"><a href="#截码战" class="headerlink" title="截码战"></a>截码战</h2><p>这个不知道为什么，我第一次和大师吴奇玩的时候</p><h2 id="暗杀神"><a href="#暗杀神" class="headerlink" title="暗杀神"></a>暗杀神</h2><p>经典dbg，太有趣了，可惜中文只有一个扩，在steam买的话可以直接40玩到全部扩，当时玩了暗杀神上瘾的直接下载了杀戮尖塔、怪物火车和欺诈之地，玩下来感觉杀戮尖塔设计的是真的好。</p><h2 id="富饶之城"><a href="#富饶之城" class="headerlink" title="富饶之城"></a>富饶之城</h2><h2 id="璀璨宝石"><a href="#璀璨宝石" class="headerlink" title="璀璨宝石"></a>璀璨宝石</h2><h2 id="山屋惊魂（小黑屋）"><a href="#山屋惊魂（小黑屋）" class="headerlink" title="山屋惊魂（小黑屋）"></a>山屋惊魂（小黑屋）</h2><p>随机性太差，剧本质量参差不齐，附一个评价</p><p>有战斗的桌游，战斗系统都比小黑屋好。有剧情的桌游，剧本写的都比小黑屋专业。合作的桌游，至少都能用人物技能打combo。有奸徒的桌游，至少大家都明争暗斗，各怀鬼胎。随机性强的桌游，都比小黑屋内容丰富。2018年，真的找不到小黑屋什么优点，除了新人也能玩以外。</p><h2 id="深海谍影（Sonar）"><a href="#深海谍影（Sonar）" class="headerlink" title="深海谍影（Sonar）"></a>深海谍影（Sonar）</h2><h2 id="我是大老板"><a href="#我是大老板" class="headerlink" title="我是大老板"></a>我是大老板</h2><p>早期非常沉迷的一款撕逼嘴炮游戏，向各种朋友安利了很多次，也开过很多次，基本上是一玩就会上瘾，但是大家都会玩之后就有点缺少变化了。</p><p>2021.7.18</p><p>哦我开始厌倦这个游戏了，说实话总体策略就是拱火然后最后出手，太容易陷入僵局了，一旦一轮生意all in全部牌很长一段时间会陷入很无聊的境地，</p><h2 id="拉斯维加斯"><a href="#拉斯维加斯" class="headerlink" title="拉斯维加斯"></a>拉斯维加斯</h2><p>非常简单无脑的毛线互车骰子游戏，有些时候完全随机的赌狗游戏也挺有意思的。</p><h2 id="终极密码"><a href="#终极密码" class="headerlink" title="终极密码"></a>终极密码</h2><p>原来达芬奇密码才是盗版…我佛了，有一定策略但是运气成分又挺大，总的来说两个人玩的话我甚至觉得运气占了很大一部分。因为很多时候是无法准确确定的，不过这个也有心理战。</p><h2 id="波多黎各"><a href="#波多黎各" class="headerlink" title="波多黎各"></a>波多黎各</h2><p>经典的可变行动机制游戏！也是一款很经典的入门德策，五人局略卡，人多要顾着别人的话就会想的太多，</p><h2 id="传情画意"><a href="#传情画意" class="headerlink" title="传情画意"></a>传情画意</h2><p>意外地玩起来不那么卡，或许是因为第一次效果太好了所以忽略了一点传递时的沉闷，总之来说这种会因为队友误操作产生的奇妙效果的合作游戏非常棒啊。</p><h2 id="现代艺术"><a href="#现代艺术" class="headerlink" title="现代艺术"></a>现代艺术</h2><p>不愧是最好的拍卖游戏！既能满足渴望代入感的戏精玩家又能满足策略感为重的精算玩家，实在是非常妙，高玩应该可以做到根据起始手牌来直接规划好一整局的走向。</p><h2 id="画物语"><a href="#画物语" class="headerlink" title="画物语"></a>画物语</h2><h2 id="犯罪现场"><a href="#犯罪现场" class="headerlink" title="犯罪现场"></a>犯罪现场</h2><h2 id="骷髅牌"><a href="#骷髅牌" class="headerlink" title="骷髅牌"></a>骷髅牌</h2><h2 id="怒海求生"><a href="#怒海求生" class="headerlink" title="怒海求生"></a>怒海求生</h2><h2 id="第一类接触"><a href="#第一类接触" class="headerlink" title="第一类接触"></a>第一类接触</h2><h2 id="诡镇奇谈版图版"><a href="#诡镇奇谈版图版" class="headerlink" title="诡镇奇谈版图版"></a>诡镇奇谈版图版</h2><h2 id="旭日战魂录"><a href="#旭日战魂录" class="headerlink" title="旭日战魂录"></a>旭日战魂录</h2><h2 id="疯狂深渊"><a href="#疯狂深渊" class="headerlink" title="疯狂深渊"></a>疯狂深渊</h2><h2 id="谁是牛头王"><a href="#谁是牛头王" class="headerlink" title="谁是牛头王"></a>谁是牛头王</h2><h2 id="巫师牌极限版"><a href="#巫师牌极限版" class="headerlink" title="巫师牌极限版"></a>巫师牌极限版</h2><h1 id="云过（知道规则or看过实况）"><a href="#云过（知道规则or看过实况）" class="headerlink" title="云过（知道规则or看过实况）"></a>云过（知道规则or看过实况）</h1><p>这一部分或许可以作为没玩过之前的预感受和期待</p><h2 id="现代艺术-1"><a href="#现代艺术-1" class="headerlink" title="现代艺术"></a>现代艺术</h2><p>插画非常好看！！可以让人无成本的体验刺激的拍卖，不过人数好像限制的挺死，45人应该玩的比较舒服，希望能快点到让我明天可以试玩一下。</p><h2 id="现代艺术旅游版"><a href="#现代艺术旅游版" class="headerlink" title="现代艺术旅游版"></a>现代艺术旅游版</h2><p>把拍卖机制完全阉割掉了….感觉失去了很多乐趣，完全看自己的牌够不够多了，不过有各种功能牌或许还有一定的策略性，不做过多的期待。</p><h2 id="七大奇迹"><a href="#七大奇迹" class="headerlink" title="七大奇迹"></a>七大奇迹</h2><p>玩过七大奇迹对决，看了下多人版的规则感觉有点太毛线了，总体来说对决的规则更有策略性和对抗性。多人版就只能和周围的两个人互动，有点无聊啊，不是很期待，不够可以试试。</p><h2 id="电力公司"><a href="#电力公司" class="headerlink" title="电力公司"></a>电力公司</h2><p>莫名觉得规则也没那么复杂，流程挺清晰的，能做的选择</p><h2 id="神秘大地"><a href="#神秘大地" class="headerlink" title="神秘大地"></a>神秘大地</h2><p>银河竞逐</p><p>矩阵潜袭</p><p>荣耀秘境</p><h2 id="花砖物语-1"><a href="#花砖物语-1" class="headerlink" title="花砖物语"></a>花砖物语</h2><p>最适合2人，算接下来每步比较简单，竞技性比较好，适合推新，很容易上手，很容易想到策略，不过我和我弟玩了几把竟然都输了，我接受不了。</p><h2 id="诡镇奇谈lcg"><a href="#诡镇奇谈lcg" class="headerlink" title="诡镇奇谈lcg"></a>诡镇奇谈lcg</h2><p>跑团的雏形，合作类游戏</p><h2 id="勃艮第城堡"><a href="#勃艮第城堡" class="headerlink" title="勃艮第城堡"></a>勃艮第城堡</h2><h1 id="一些玩桌游的感悟"><a href="#一些玩桌游的感悟" class="headerlink" title="一些玩桌游的感悟"></a>一些玩桌游的感悟</h1><p>2021.7.17</p><p>在玩了两天连续的coup之后突然感觉毛线嘴炮游戏对我失去了吸引力，感觉玩不来也get不到点了，不知道为什么..这难道就是桌游玩家必经的道路吗，先喜欢毛线，后喜欢轻策然后逐渐变重</p><p>2021.7.18</p><p>今天夸夸老谭局加入了大美女ozz，yysy面对这种桌游新手我表现得有点不耐烦，就很不想解释规则就想直接开玩，然后zzh有些不认真听规则让我很烦，总是会问一些很弱智的规则问题，而且我感觉zzh真的是一个很纯的毛线嘴炮玩家，单是我刚一说七大奇迹他就一副很不屑地“啊这不会是那种刷分游戏吧”，想玩电力公司结果没完成，想玩现代艺术结果没到，然后开了一下撕逼船发现这游戏节奏真的很慢啊，很无聊，败笔，我只能玩这个很败笔，早知道</p><p>2022 1.10</p><p>这次的桌游局加入的是娟儿他们的13班局，说实话这次让我体会到了一些新的乐趣，就是有一个妹子（lhy）一开始叫我大名，然后在游玩过程中逐渐改口叫我外号，这种逐渐拉近距离的感觉真美妙，还有就是今年年度桌游应该就是冰冷的她醒来之前了，玩了三个桌游局大家都很喜欢，真好。</p><p>2022 1.30</p><p>最近开桌游局开麻了，十几天开了七次局，21男生班，zz小谭局，22班网友温泉局，学妹弟弟局，鸡狗叶晓璐黑风局，谭弟咩弟我弟局，13班局，玩了这么多天我人真的要麻了，有点猪脑过载了，这些局最舒服的应该是叶晓璐局，叶晓璐和鸡狗都好会玩并且节目效果拉满，而且真的能感受到她们在认真玩</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>桌游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研失败总结</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E8%80%83%E7%A0%94%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E8%80%83%E7%A0%94%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>考研成功的人总是相似的，考研失败的人各有各的失败</p><p>直面一下自己的失败，也为大家的选择提供一个参考，首先分析一下自己失败的原因，直接原因就是数学考差了，数学考的分还没英语高。。。（英语85），政治和专业课也都挺不错的，自我感觉数学已经刷了很多题了，对比一起复习的同学进度也很快，他一轮还没看完的时候我就开始刷真题了，然后二十多年的真题都刷了， 模拟题也刷了二十多套，感觉还是刷的太快了，没有好好总结，也跟我跨考要学太多专业课有关。我写数学的时候还是实践不够，眼高手低，某些很基础的概念和公式没有仔细辨析，今年小题连出三道那种概念辨析题，太过于弯弯绕绕让我直接慌了神，然后有一道微分方程的题解了半天没解出来，搞得我都质疑自己是不是公式记错了，然后算了很久，然后就是填空题有两道计算也算了很久，经过前面的这些压力，拿到证明题，看着很熟悉，也感觉很简单，但是就是没有头绪，各种什么中值定律的套路全都忘了</p><p>更高一些的原因就是决定考研的决心不够，也没想好为啥要考研，考研太痛苦了，整整半年多的时间苦学，而且是一种自己与自己的斗争，看到周围人保研的，找工作的，难免会动摇，想着自己花那么多功夫只为了求一个给导师当免费劳动力，图啥啊，上课没意思，做项目的成长可能也没有工作快，自己也不想写论文，纠各种细节，所以总是会出现怀疑自己是否适合考研，为什么要考研的念头，其实说白了，就是想逃避工作，逃避社会，想着再玩两年，再混两年，但其实如果抱着这种想法不如直接工作，对于程序员来说，工作成长得或许更快。</p><p>不过我感觉我考研的时候还是很努力的，每天七点半起床，八点到十一点半去图书馆，中午小睡一会，一点半到四点半学，然后两天健身一次，晚上六点半or七点到十点学习，四个科目都按照自己的计划有节奏地推进，一轮复习二轮强化三轮刷题我都做了，可惜结果如此不尽人意，考完研的那个寒假真是最开心的一个假期，基本每两天约人出去桌游，和小学初中高中同学换着约桌游，然后在假期的结尾来了这么一出。</p><p>很明智的一个决定是寒假的时候抱着找工作的目标来准备复试，一直在刷编程题，虽然知道没希望了之后迷茫了两天，但是很快就调整了过来了，开始海投简历，背八股文，刷题，刷面经，然后就是焦虑地等待和参加各种面试，我不仅公司海投，连岗位也海投，主要是游戏开发和嵌入式，还有各种的软件开发和测试也投了一些，那段时间就是每天都疯狂做题，可以算是很充实了，每天都咬着一口气在狂学</p><p>总结一下得失，得就是系统过了一遍计算机要学的四门课，这让我在找工作的时候可以有底气的说出自己学过这些课，而且也敢往简历上写，说实话我学四门专业课的时候是真的很开心，尤其是操作系统和计网，学的很开心，有种在学自己擅长并且喜欢科目的感觉，</p><p>失就是浪费了秋招的时机，如果早就规划了自己还要找工作，那么从大四一开始就开始背八股文刷题，可能能找到一线大厂的工作岗位（不过完美世界也算准一线了0.0），拿的钱或许也能更多。从春招开始从零面试还是太赶了，想想也真是很幸运能拿到完美的offer，是自己很喜欢的游戏开发，太幸运了。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>人狼村之谜</title>
    <link href="/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E4%BA%BA%E7%8B%BC%E6%9D%91%E4%B9%8B%E8%B0%9C/"/>
    <url>/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E4%BA%BA%E7%8B%BC%E6%9D%91%E4%B9%8B%E8%B0%9C/</url>
    
    <content type="html"><![CDATA[<p>为什么人狼村之谜如此令人上瘾，有着极强的代入感，游戏的氛围感也相当不错.</p><p>不过游戏的局限性也相当明显，三个女主都显得这么恋爱脑，</p><p>文字冒险游戏的选择性没有那么强。</p><p>但是这不是一个关于主角大杀四方一命通关的故事，即使你拥有时间回溯这样逆天的能力，在一次次的死亡、bad ending之后，你同样会感到绝望，</p><p>第一次，你拼尽全力让心爱的女孩摆脱洗脑，逃出这地狱般的村庄，但是你做不到，她消失了，在如同迷宫的蜜水中，你们走了很久很久，女孩越来越虚弱，太消失了，被她一直念叨的神明带走了，</p><p>第二次，你费尽心机来到村庄，用外乡人的身份赢下了这场游戏，但是</p><p>第三次，你变成了恐怖的狼，如履薄冰地见证了从人变成鬼的过程，在牺牲了两个的队友的情况下，你终于见到了那个最可怕的结局。</p><p>第四次，费尽千辛万苦的你，你发现原来在这个轮回中，同样有一个人也保留着记忆，难怪啊，难怪他会</p>]]></content>
    
    
    <categories>
      
      <category>游戏锐评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人狼村之谜</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学德育总结</title>
    <link href="/%E9%9A%8F%E7%AC%94/%E5%BE%B7%E8%82%B2%E6%80%BB%E7%BB%93/"/>
    <url>/%E9%9A%8F%E7%AC%94/%E5%BE%B7%E8%82%B2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>我的大学就是一部失败史，完全没有任何值得叙说的东西，没有交朋友，没有参加比赛，没有奖学金，没有，我印象很深刻，考研失败找工作面试的时候，面试官问我：“你大学四年干什么了？如果你真的认真在学c++，你的水平不应该是这样。”，那一刻，我呆住了，我张了张嘴，想辩解什么但是说不出口，只能笑了笑然后继续。</p><p>我记得我刚选上机器人专业的时候，看到知乎的一个机器人入门指南，兴奋的不得了，立志要好好学习，进机器人队什么的，参加各种比赛什么的，结果机器人队落选了，就又开始开摆了，之后的考研 也想着努力，但是努力不代表有好结果，还是失败了。</p><p>我不太想找什么借口，大学四年很长一段时间都是处于无目标无奋斗的状态中度过的，当然，我可以从结果论的角度来分析自己兴趣广泛，涉猎很多，所以导致了我能够进入游戏行业工作，但是不得不承认的一点，我直到找到工作之前还是没有确定自己的人生规划，投简历 也是海投，</p><p>人是有惰性的，是有极限的，社会是很残酷的，找工作的过程中才发现，即使看的电影、书、动漫再多，对于自身而言，也仅仅是娱乐罢了，没有更深层次的内审和总结，他就变成了过眼云烟，一下子就忘记了，记忆是很不可靠的，我要再说一次，我能很明显地感受到，随着年龄的增长，我思考人生，反思自己的次数在变得越来越少，更多的时间花在了奶头乐，打嘴炮上面，我在大二就有想过要是大一某些节点要是做出不一样的选择会怎样，乘着大学四年过完了，我也想对四年前的自己告诫一下有什么能做，给的建议都是有实操性的，当然，有些建议现在开始也不晚：</p><ol><li>写博客，一定要早点开始写博客，各种各样的东西都可以写，书评影评游戏评，技术博客，都得写，从大二开始才在豆瓣上发内容，才积累了一千粉，做内容太难了，不过为了自己的鉴赏素养的提升， 也得写，多写。不过写内容是很痛苦的，得有</li><li>早点找实习，寒假暑假不要浪费了，越早开始接触工作越好，实习经历非常重要，国内对于实习的教育太少了，似乎都想把人往考研上赶，这或许也和国内不需要大学生自己承担生活费有关，每个寒暑假基本都在虚无度日，如果能有用这些时间多接触不同的工作，也会对未来更有认识，找工作也会更加轻松。我有点想做的实习有：桌游店讲解员（因为疫情封校了好久，知道家后面有个东华学姐开的桌游店就想着考完研去打工，但是考完研才发现他们已经倒闭了，实在可惜），还有就是想进游戏公司做一些实习，想看看各个岗位要什么技能，工作内容是什么，甚至还想去豆瓣实习，但他们应该不会招实习生吧。</li><li>早点开始健身，保持好身体太重要了，健身还是很有乐趣的，如同游戏一般，有着即时的正反馈，非常有成就感，如果我大一就开始健身而不是大三才开始，或许我的力量会更加强大，目前我的卧推是100kg，深蹲是140kg，硬拉是150kg。</li><li>虽然我很想给你谈恋爱的建议，但是似乎我也不知道怎么说，认识人太难了，本身自己也不够优秀，我还记得刚上大学的时候，还想着自己实力够强就会让别人主动来认识自己，然而想法是没错的，自己本身却不够优秀，然后也不体验什么集体活动、社团什么的，当然我本身也不后悔没去参加这些活动，只是大学四年都没谈过恋爱，未免显得有些过于寂寞了。</li></ol><p>那么我的时间都花在哪里了呢？我看了很多书，很多很多，可以看到在图书馆我的借阅量是304本，文学类的闲书占了很大一部分，这些书基本上都是读过的，还有很大一部分是工具书或者是补充的教材，这些的话就是</p><p>我还花了很多的时间打游戏，其实英雄联盟玩的是最多的，这种社交类的网游，并且由于玩了太多年了，已经进入舒适区了，补兵就是一种享受，而且自走棋融合rougelike的云顶之弈设计的实在是太棒了，真的非常好啊。单机游戏的话也玩了不少，跟着王老菊玩了很多有意思的小游戏，3A大作的话也体验了一些，比如老头环、赛博朋克，只狼、文明6之类的，但是说实话吸引我的还是那些设计精妙的独立游戏，3A大作的系统有点太过于繁杂，上手难度太高了，反而让人产生一种点电子养胃的感觉，上手成本太高了。</p><p>我还玩了很多桌游，这也主要是我大三开始玩，这么一想我大一大二基本都在自顾自地看闷书，然后学一些课外的关于人文的课程学习了很多规则，也向自己身边的很朋友安利了很多桌游，桌游是一个能够自由地与朋友交流的框架，非常有意思。</p><p>我还报名了数学二学位，虽然北航的数学二学位没有什么含金量，但是大一报名的时候我是真的抱着能学习知识的目的去学习的，或许会让觉得不自量力，明明本专业学的那么差劲，可是转专业只有学的最好的才能好，如此讽刺，学的好的才有离开的权利，没有天赋选错的人却只能一直困在这里。</p><p>还有的话就是练习了一些编程，学习了很多语言，并且都有意识地训练了一下，C++、python、matlab、Go、微信小程序（主要是jshtml），这些都是经过至少一个学期以上学习练习时间的语言，越往前的语言越熟悉。</p><p>越成长就越难走出舒适区，玩游戏、交朋友，都是这样，大一大二回到家还会接着看好多新书，但是之后就只能看看各种以前看过的书了，给我一颗子弹看了好多遍，王小波全集也是如此，挪威的森林简直是哪一页写了什么都一清二楚，就是如此夸张。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>救猫咪笔记</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%91%E7%8C%AB%E5%92%AA%E7%AC%94%E8%AE%B0/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%91%E7%8C%AB%E5%92%AA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="他讲的是什么？"><a href="#他讲的是什么？" class="headerlink" title="他讲的是什么？"></a>他讲的是什么？</h1><p>尝试写一句话故事，这是创作的开头而不是总结，需要满足下面四个要求：</p><ol><li>反讽</li><li>美妙的脑补画面</li><li>目标观众和拍摄成本</li><li>绝杀的片名</li></ol><p>一些可以尝试的练习</p><p>1.尝试向朋友们推荐最近的电影，这个或许可以自己看电影总结的来做，其实之前写影评写书评也有这种想法，就是当做在写信向自己的朋友推荐这本书or这部电影，尝试着说出这个电影的一句话故事，看看能不能勾起对方的兴趣</p><p>2.对陌生人推销自己的一句话故事</p><p>3.创意游戏</p><h1 id="电影的类型"><a href="#电影的类型" class="headerlink" title="电影的类型"></a>电影的类型</h1><p>屋里有怪物、金羊毛、愿望成真、陷入困境、人生变迁、伙伴情谊、推理调查、傻瓜获胜、体制之下、超级英雄</p><p><strong>屋里有怪物</strong></p><p>别被吃掉，封闭空间、罪恶时间、超自然、逃跑和躲藏</p><p><strong>金羊毛</strong></p><p>一位英雄为了寻找某样东西而“踏上旅途”，并在旅途结束后找到了另一样东西——他自己；自我发现很重要</p><p><strong>愿望成真</strong></p><p>对立面是受到诅咒，“愿望成真”的规则是：主角是灰姑娘型任务，因此我们会很希望有个人，或者什么东西能给他带来一点点幸福。然而，符合人性本质的另一条规则是：其实我们并不想看到任何人，哪怕是最落魄的角色，能一直当赢家，最终，主角必须明白，魔法并不是一切，像观众一样当个普通人才是最好的</p><p>如果因果报应的故事，就是反向操作：主角得是一个非常欠扁的人，但他身上必须有一些值得挽救的地方。</p><p><strong>陷入困境</strong></p><p>一个普通人发现自己陷入了不普通的处境当中</p><p><strong>人生变迁</strong></p><p>讲述痛苦和折磨，但其来源通常是一种外在力量：生活，所有人都”知道是怎么回事“，只有主角除外，解决问题的唯一方式就是让主角亲子去经历一番。</p><p>主角面对他既不能掌控也无法理解的自然力量时，虽然心有愤恨但只能一步步接受的过程。当主角最终能够微笑面对的时候，他就胜利了。</p><p>伙伴情谊</p><p><strong>推理调查</strong></p><p>优秀的“推理调查“类故事讲的不是主角的转变，而是让观众在”罪案“发生之后，发现一些他们以前觉得不可能存在的人性阴暗面。</p><p>观众其实就是破案的侦探，虽然银幕上的角色在替我们追查线索，但最终筛查信息的还是我么你自己，被查到的东西深深震惊的也是我们自己。</p><p><strong>傻瓜获胜</strong></p><p>要让一个卑微的傻瓜与一个更强大、更有力量的，通常也更有权势的坏人对立起来。看着一个所谓的“白痴”打败大家眼中的人生赢家，这能让我们感受到希望，同时也对日常生活中严格的等级秩序进行了嘲讽。</p><p>要素很简单：一个失败：看起来特别废柴，特别没用，身边所有的人都不相信他能成功（而且在设定中要反复强调这一点）一个体质；通常傻瓜还有一个同伙，一个知道是怎么回事的”局内人“，觉得傻瓜绝对不可能掏出他的掌控。</p><p><strong>体制之下</strong></p><p>既赞颂了体制，也暴露了体制吞噬个人的问题。对群体忠诚有时会违反常识，甚至威胁到自身生存，但我们依然会那样做。这类电影通常会以一个外来者的视角展开，可以让我们普通人看到，一个“疯狂”的世界是什么样的。</p><p><strong>超级英雄</strong></p><h1 id="来构建节拍吧"><a href="#来构建节拍吧" class="headerlink" title="来构建节拍吧"></a>来构建节拍吧</h1><p>节拍表</p><ol><li>开场画面（1）</li><li>阐明主题（5）</li><li>布局铺垫（1-10）</li><li>触发事件（12）</li><li>展开讨论（12-25）</li><li>进入第二幕（25）</li><li>副线故事（30）</li><li>玩闹和游戏（30-35）</li><li>中点（55）</li><li>反派逼近（55-75）</li><li>失去一切（75）</li><li>灵魂黑夜（75-85）</li><li>进入第三幕（85）</li><li>结局（85-110）</li><li>终场画面（110）</li></ol><h1 id="剧本创作的不变法则"><a href="#剧本创作的不变法则" class="headerlink" title="剧本创作的不变法则"></a>剧本创作的不变法则</h1><p>救猫咪</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>effective C++</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective%20C++/"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/effective%20C++/</url>
    
    <content type="html"><![CDATA[<p><strong>尽量以const，enum，inline替换define</strong></p><ol><li>define会把变量名直接换成数字，比如把name换成16.5，debug的时候就只会显示16.5而不会显示name，这样就不方便debug，可以这样改：const double name &#x3D; 16.5</li><li>写函数时用define必须全部加括号，并且加了也会发生一些很奇怪的错误，所以尽量用inline</li><li>enum和define一样不会导致不必要的内存分配（模板方法）</li></ol><p><strong>尽可能使用const</strong></p><ol><li>const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果左右两边都有表示两个都是常量。</li><li>让函数的返回值是常量，可以避免很多错误</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理考研笔记</title>
    <link href="/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;os%E4%BB%A3%E7%A0%81/"/>
    <url>/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;os%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">PreOrder</span><span class="hljs-params">(Tree T)</span></span>&#123;<br>    <span class="hljs-built_in">Visit</span>(T);<br>    <span class="hljs-built_in">PreOrder</span>(T-&gt;lchild);<br>    <span class="hljs-built_in">PreOrder</span>(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归</p><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">LevelOrder</span><span class="hljs-params">(Tree T)</span></span>&#123;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    BiTree p;<br>    <span class="hljs-built_in">EnQueue</span>(Q,T);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br>        <span class="hljs-built_in">DeQueue</span>(Q,p);<br>        <span class="hljs-built_in">visit</span>(p);<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">EnQueue</span>(Q,p-&gt;lchild);<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>) <span class="hljs-built_in">EnQueue</span>(Q,p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><p>Prim</p><p>Kruskal</p><p>Dijkstra</p><p>拓扑排序</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">InsertSort</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;j &gt;= <span class="hljs-number">0</span>;j--)&#123;<br>            <span class="hljs-keyword">if</span>(A[j] &lt; A[i])&#123;<br>                <span class="hljs-type">int</span> swap = A[i];<br>                A[i] = A[j];<br>                A[j] = swap;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">BubbleSort</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> swap = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; A[j])&#123;<br>                swap = A[i];<br>                A[i] = A[j];<br>                A[j] =swap;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">QuickSort</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-type">int</span> pivotpos = <span class="hljs-built_in">Partition</span>(A, low, high);<br>        <span class="hljs-built_in">QuickSort</span>(A, low, pivotpos - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(A, pivotpos, high);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">QuickSort</span>(A, high, low);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    ElemType pivo = A[low];<br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123; <span class="hljs-comment">//循环跳出条件，其实就是保证遍历一遍</span><br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; <span class="hljs-comment">//两边间隔这样找，好处是交换写的很方便，可以不用考虑太多写的很简洁</span><br>        A[low] = A[high];<br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; A[low] &lt;= pivot) ++low;<br>        A[high] = A[low];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">SeletSort</span><span class="hljs-params">(ElemType A[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> swap = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        min = i;<br>        <span class="hljs-keyword">for</span>(j = i + <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(A[j] &lt; A[min]) min = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min != i)&#123;<br>            swap = A[i];<br>            A[i] = A[min];<br>            A[min] = swap;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Void <span class="hljs-title">Merge</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = high - low + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> k;<br>    ElemType *B = (ElemType *)<span class="hljs-built_in">malloc</span>((n+<span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = low;i &lt;= high;i++) B[i] = A[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = low, j = mid+<span class="hljs-number">1</span>, k = i;i &lt;= mid&amp;&amp;j &lt;= high;k++)&#123;<br>        <span class="hljs-keyword">if</span>(B[i]&lt;B[j]) A[k] = B[i++];<br>        <span class="hljs-keyword">else</span> A[k] = B[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) A[k++] = B[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=high) A[k++] = B[j++];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(ElemType A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MergeSort</span>(A,low,mid);<br>        <span class="hljs-built_in">MergeSort</span>(A,mid,high);<br>        <span class="hljs-built_in">Merge</span>(A,low,mid,high);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">MerSort</span>(A,high,low);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>semaphore</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>一组生产者和一组消费者共享初始为空，大小为n的缓冲区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">//临界区互斥变量</span><br>semaphore empty = n; <span class="hljs-comment">//空闲缓冲区</span><br>semaphore full = <span class="hljs-number">0</span>; <span class="hljs-comment">//缓冲区初始为0</span><br><span class="hljs-built_in">producer</span>()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        生产; <span class="hljs-comment">//生产数据</span><br>        <span class="hljs-built_in">P</span>(empty); <span class="hljs-comment">//获取缓冲区单元</span><br>        <span class="hljs-built_in">P</span>(mutex); <span class="hljs-comment">//进入临界区</span><br>        把数据放进缓冲区; <span class="hljs-comment">//将数据放进缓冲区</span><br>        <span class="hljs-built_in">V</span>(mutex); <span class="hljs-comment">//离开临界区，释放互斥信号量</span><br>        <span class="hljs-built_in">V</span>(full); <span class="hljs-comment">//慢缓冲区数加1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">consumer</span>()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(full);<br>        <span class="hljs-built_in">P</span>(mutex);<br>        拿东西;<br>        <span class="hljs-built_in">V</span>(mutex);<br>        <span class="hljs-built_in">V</span>(empty);<br>        消费;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore rw = <span class="hljs-number">1</span>;<br>semaphore w = <span class="hljs-number">1</span>; <span class="hljs-comment">//保证写进程优先，防止饿死</span><br><span class="hljs-built_in">writer</span>()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(w);<br>        <span class="hljs-built_in">P</span>(rw);<br>        writing;<br>        <span class="hljs-built_in">V</span>(rw);<br>        <span class="hljs-built_in">V</span>(w);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">reader</span>()&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(w);<br>        <span class="hljs-built_in">P</span>(mutex);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) <span class="hljs-built_in">P</span>(rw); <span class="hljs-comment">//阻止写进程写</span><br>        count++;<br>        <span class="hljs-built_in">V</span>(mutex);<br>        <span class="hljs-built_in">V</span>(w);<br>        reading;<br>        <span class="hljs-built_in">P</span>(mutex);<br>        count--;<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) <span class="hljs-built_in">V</span>(rw);<br>        <span class="hljs-built_in">V</span>(mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>要同时拿起两个筷子才能吃，注意防止饥饿</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">semaphore chopsticks[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>semaphore mutex = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">Pi</span>()&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-built_in">P</span>(mutex);<br>        <span class="hljs-built_in">P</span>(chopsticks[i]);<br>        <span class="hljs-built_in">P</span>(chopsticks[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>        <span class="hljs-built_in">V</span>(mutex);<br>        eat;<br>        <span class="hljs-built_in">V</span>(chopsticks[i]);<br>        <span class="hljs-built_in">V</span>(chopsticks[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>        think;<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h2><p>轮流抽烟，这个是个同步问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>semaphore offer1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//分别对应三种组合</span><br>semaphore offer2 = <span class="hljs-number">0</span>;<br>semaphore offer3 = <span class="hljs-number">0</span>;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//提供者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        num++;<br>        num = num % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-built_in">V</span>(offer1);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) <span class="hljs-built_in">V</span>(offer2);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">V</span>(offer3);<br>        <span class="hljs-built_in">P</span>(finish); <span class="hljs-comment">//保证抽了才放下一个</span><br>    &#125;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P2</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//三个吸烟者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(offer1);<br>        抽;<br>        <span class="hljs-built_in">V</span>(finish);<br>    &#125;    <br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P3</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//三个吸烟者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(offer2);<br>        抽;<br>        <span class="hljs-built_in">V</span>(finish);<br>    &#125;    <br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P4</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//三个吸烟者</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">P</span>(offer3);<br>        抽;<br>        <span class="hljs-built_in">V</span>(finish);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="根据指针p所指节点找双亲节点"><a href="#根据指针p所指节点找双亲节点" class="headerlink" title="根据指针p所指节点找双亲节点"></a>根据指针p所指节点找双亲节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BTree* <span class="hljs-title">getParent</span><span class="hljs-params">(BTree* t, Btree* p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(t == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//所指结点为空节点</span><br>    <span class="hljs-keyword">if</span>(t == p) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//所指节点是根节点</span><br>    <span class="hljs-keyword">if</span>(t-&gt;lchild == p || t-&gt;rchild == p) <span class="hljs-keyword">return</span> p;<br>    BTree* parent = <span class="hljs-built_in">getParent</span>(t-lchild, p);<br>    <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> parent;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">getParent</span>(t-rchild, p);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h1><p>即把后p个移动到前面<br>$$<br>思路是这样的，目标是ab变成ba，所以先a^{-1}b，再a^{-1}b^{-1}，然后整体交换变成ba<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> R[], <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> temp</span><br><span class="hljs-function">    <span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = from;i&lt;(to-from+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;i++)</span></span>&#123;<br>        temp = R[from + i];<br>        R[from + i] = R[to - i];<br>        R[to - i] = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Converse</span><span class="hljs-params">(<span class="hljs-type">int</span> R[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-built_in">Reverse</span>(R, <span class="hljs-number">0</span>, p - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Reverse</span>(R, p, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Reverse</span>(R, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一定要注意标准化语言</p><p>给出将一个正整数字符串转化为对应的整数值的递归描述</p><p>递归出口：</p><ol><li>若子串为空串，返回一个标记表示无法转化</li><li>若子串长度等于1，则直接返回对应的整数</li></ol><p>递归：</p><ol><li>将子串最末尾的字符转换为整数</li><li>递归地将除末尾字符的字符的子串转换为整数，并加转换结果乘10加上末尾字符整数返回。</li></ol>]]></content>
    
    
    <categories>
      
      <category>考研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>-数据结构 -计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统考研笔记</title>
    <link href="/%E8%80%83%E7%A0%94/os/"/>
    <url>/%E8%80%83%E7%A0%94/os/</url>
    
    <content type="html"><![CDATA[<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="计算文件占多少个簇号"><a href="#计算文件占多少个簇号" class="headerlink" title="计算文件占多少个簇号"></a>计算文件占多少个簇号</h2><p>先找到起始号然后一直往下找，直到遇到值为FFT的表项号为止</p><h2 id="缺页次数"><a href="#缺页次数" class="headerlink" title="缺页次数"></a>缺页次数</h2><p>CLOCK页面淘汰算法</p><h2 id="页式存储管理系统"><a href="#页式存储管理系统" class="headerlink" title="页式存储管理系统"></a>页式存储管理系统</h2><p>比如说一个块是4KB，那么也就是2^12次方，所以要用16位，这是块内地址尾数，然后块号要用4位来表示</p><p>比如说逻辑地址是[0,72]，但是第一位对应的是主存的第9块，那么实际内存地址就是1001 0000 0000 0100 1000</p><h2 id="磁盘各种调度算法汇总"><a href="#磁盘各种调度算法汇总" class="headerlink" title="磁盘各种调度算法汇总"></a>磁盘各种调度算法汇总</h2><p>FCFS（先来先服务 First Come First Serve）（只有这个是不偏心的）</p><p>SSTF（最短寻找时间优先 Shortest Seek Time First）</p><p>SCAN（扫描）</p><p>先找最近的，然后直接移动到那一端</p><p>C-SCAN（循环扫描）</p><p>单向服务，走完一端快速到另一端啥也不服务，然后再走过去</p><p>LOOK</p><p>改进了SCAN和C-SCAN，不用非得到另一端，只用到最远的那个即可</p><h2 id="磁盘存取时间"><a href="#磁盘存取时间" class="headerlink" title="磁盘存取时间"></a>磁盘存取时间</h2><p>存取时间 &#x3D; 寻到时间 + 延迟时间 + 传输时间</p><p>平均延迟时间为旋转半周的的时间</p><h2 id="文件系统最大文件可以达到多少"><a href="#文件系统最大文件可以达到多少" class="headerlink" title="文件系统最大文件可以达到多少"></a>文件系统最大文件可以达到多少</h2><p>会有各种什么直接索引，二次间接索引什么的。</p><p>例：物理块大小是2KB，每个索引项占用4个字节（即4B），有8个直接索引项，1个一次间接索引项，1个二次间接索引项，最大怎么算？<br>$$<br>8*2KB + (2KB&#x2F;4B)<em>2KB + (2KB&#x2F;4B)</em>(2KB&#x2F;4B)*2KB\<br>2KB&#x2F;4B代表一个物理块能有多少个索引<br>$$</p><h2 id="段页式存储系统访问内存次数"><a href="#段页式存储系统访问内存次数" class="headerlink" title="段页式存储系统访问内存次数"></a>段页式存储系统访问内存次数</h2><p>段页式如果想成功拿出数据要访问三次内存，第一次访问段表，得到页表地址；第二次访问页表，取得该页所在的物理地址；第三次访问物理地址拿到数据；但是，如果发生了越界就会次数变少，比如段越界，比如段只有0-7你想访问8，那就访问0次；如果页越界，就只访问1次。</p><h2 id="n体交叉编址模块序号"><a href="#n体交叉编址模块序号" class="headerlink" title="n体交叉编址模块序号"></a>n体交叉编址模块序号</h2><p>模块序号 &#x3D; 访存地址 % 存储器交叉模块数</p><h1 id="背"><a href="#背" class="headerlink" title="背"></a>背</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ol><li>当操作系统完成用户请求的“系统调用”后，应使CPU从内核态转到用户态工作</li><li>用户程序设计，使用系统调用命令，经过编译后，形成若干参数和陷入（trap）指令，现有参数再执行trap指令。</li><li>用户程序创建一个新进程，需使用操作系统提供的系统调用接口</li></ol><h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><ol><li>当前比较流行的能支持多处理机运行的OS，几乎全都采用微内核结构</li><li>模块化OS结构的原则是：分解和模块化</li><li>微内核结构能有效支持多处理机运行，故非常适合于分布式系统环境</li><li>微内核设计并不会让系统更高效</li></ol><h2 id="SPOOLing"><a href="#SPOOLing" class="headerlink" title="SPOOLing"></a>SPOOLing</h2><ol><li>SPOOLing技术是将独占设备改成共享设备，所以肯定要独占设备</li><li>SPOOLing技术通过在磁盘上开辟存储空间模拟脱机输出，可以减少作业输出等待时间，加快作业完成速度</li><li>目的是在输入设备忙时，进程不必等待IO操作的完成</li><li>用户的输出数据先送入输出井，即磁盘固定区域。</li></ol><h2 id="需要用到缓冲技术的场景"><a href="#需要用到缓冲技术的场景" class="headerlink" title="需要用到缓冲技术的场景"></a>需要用到缓冲技术的场景</h2><ol><li>图形用户界面下使用鼠标（如果有高优先级的操作产生就要记录）</li><li>在多任务操作系统下的磁带驱动器</li><li>包含用户文件的磁盘驱动器</li><li>使用存储器映射I&#x2F;O，直接和总线相连的图形卡</li></ol><h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><p><strong>程序查询方式</strong></p><p>优点：实现简单。缺点：需要消耗大量CPU时间来查询，无法发现程序错误，且CPU和设备，设备和设备之间无法并行工作</p><p><strong>中断方式</strong></p><p>优点：可以并行工作，能检测错误。缺点：CPU仍要花费大量时间来处理中断，且并行程度受中断处理时间的限制</p><p><strong>DMA方式</strong></p><p>优点：采用了外设和内存直接交换数据的方式，因此CPU对于IO的时间开销少。缺点：传输结束后仍需要用中断，增加了硬件开销。</p><p><strong>通道方式</strong></p><p>优点：CPU对于IO的时间开销更少。缺点：硬件开销大，通道程序复杂，增加了实现难度</p><h2 id="一些单句的做题点"><a href="#一些单句的做题点" class="headerlink" title="一些单句的做题点"></a>一些单句的做题点</h2><ol><li>只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片。（分页虚拟、固定分区、段页式分区是固定的，分段虚拟是不固定的）</li><li>虚拟页式管理的系统，在其地址变化过程中，进程可能发生被撤销（超越进程的地址空间）和变为阻塞（缺页）</li><li>Linux主机允许root和guest同时登录，因为Linux支持多用户；允许多个客户端通过root账号登录</li><li>互斥信号量的初值一般为1；同步信号量初值不确定（因为互斥是只有一个资源，而同步要看消息是否已经存在，如果尚未存在应该设为0，已经存在应该设为非0的正整数）</li><li>文件控制块就是文件目录项</li><li>操作系统必须提供的功能是处理中断</li><li>忙等待即执行IO操作室进行不能继续执行</li><li>共享资源可以是进程代码和进程所拥有的已打开文件</li></ol><h1 id="新考点"><a href="#新考点" class="headerlink" title="新考点"></a>新考点</h1><h2 id="第二章进程"><a href="#第二章进程" class="headerlink" title="第二章进程"></a>第二章进程</h2><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h3><p>与进程类似：就绪、运行、阻塞</p><h3 id="线程组织和控制"><a href="#线程组织和控制" class="headerlink" title="线程组织和控制"></a>线程组织和控制</h3><p>线程是TCB</p><p>线程切换时要保存和恢复：PC、其他寄存器和堆栈指针</p><h3 id="调度器和调度程序"><a href="#调度器和调度程序" class="headerlink" title="调度器和调度程序"></a>调度器和调度程序</h3><p>进程和线程要了解的都是这样，支持内核级线程就会最小线程是线程</p><p>让谁去运行（先来先服务，短作业优先）</p><p>什么事件会触发：创建新进程、进程退出、运行进程阻塞、IO中断</p><p>非抢占：运行阻塞或退出才触发</p><p>抢占：每个时钟中断或k个时钟中断会触发调度程序工作 </p><h3 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h3><p>调度程序永远的备胎，没有其他就绪进程时就会运行闲逛进程</p><p>特点：优先级最低、可以是0地址指令，末尾也会执行检查中断、能耗低</p><h3 id="上下文及其切换机制"><a href="#上下文及其切换机制" class="headerlink" title="上下文及其切换机制"></a>上下文及其切换机制</h3><p>context：其实就是内存环境的切换</p><p>地址切换代价巨大：</p><ol><li>保存恢复页表寄存器</li><li>TLB全部失效</li><li>Cache全部失效</li><li>新进程运行初期缺页率高</li></ol><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p>每种类型的进程就是一个队列</p><p>系统</p><p>交互式大于批处理，因为交互性比如说打游戏肯定需要更高的即时率</p><p>每种队列的调度算法可以不同</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>互斥锁的主要缺点是忙等待，自旋锁：TSL指令、swap指令、单标志法</p><p>优点：不会一直占用处理机，会有中断让他下处理机，并且等待的期间不用切换上下文（切换的代价很高）。</p><p>常用于多处理器系统，一个核忙等，其他照常工作，并快速释放临界区</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h3><p> 通过内存映射实现的</p><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p> 如果用传统的open read来读文件，往回读的时候必须要用seek，缺点：写代码不方便、open read必须启动磁盘非常慢。</p><p>mmap：memory map</p><h3 id="虚拟存储器的影响因素及改进方式"><a href="#虚拟存储器的影响因素及改进方式" class="headerlink" title="虚拟存储器的影响因素及改进方式"></a>虚拟存储器的影响因素及改进方式</h3><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211125154544479.png" alt="image-20211125154544479"></p><p>页面大就说明页面数量会少，想一个极端的情况，只有一个当然不会缺页</p><h2 id="固态硬盘（OS和计组都加了，很可能出现选择题）"><a href="#固态硬盘（OS和计组都加了，很可能出现选择题）" class="headerlink" title="固态硬盘（OS和计组都加了，很可能出现选择题）"></a>固态硬盘（OS和计组都加了，很可能出现选择题）</h2><p>SSD</p><p><strong>读写性能特性</strong></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211125154820578.png" alt="image-20211125154820578"></p><p>读写以页为单位</p><p>因为写之前必须要先擦除，所有必须先把同一块的其他东西复制到其他块，再往里面写；所以读很快， 但是写很慢。然后挪了之后怎么保持翻译正确，闪存翻译层会保证正确！</p><p>支持随机访问，磁盘不行，磁盘需要什么移动磁臂什么的，所以很慢</p><p><strong>磨损均衡技术</strong></p><p>不要总磨一个地方，平均分布，以提升使用寿命，</p><p>动态：优先选择累积次数少的新闪存块</p><p>静态：读多写少的东西迁移到老块，因为读不用擦，这个是后台悄悄监视的</p><p>理想情况下固态硬盘的寿命</p>]]></content>
    
    
    <categories>
      
      <category>考研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构考研笔记</title>
    <link href="/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/%E8%80%83%E7%A0%94/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>$$<br>{C^2_{2n}&#x2F;(n+1)}\<br>这个东西可能还有一个问法，比如说他说先序序列为a,b,c,d的二叉树的个数，其实就是问你四个的进栈顺序有多少个<br>$$</p><h2 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h2><p>正常方式（利用栈的方式）（考试可能会问你符号栈有多少个元素）</p><p>遇到数字，直接加入后缀表达式</p><p>遇到操作符：</p><ol><li>左括号：直接入栈</li><li>右括号：将符号栈依次弹出，直到遇到一个左括号为止，把遇到的左括号删除而不是弹出</li><li>其他：栈空、栈顶为左括号或者比当前符号优先级低的符号就直接入栈，否则就以此弹出直到遇到前面三种情况再入栈。</li></ol><p>一个取巧的方式</p><p>1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b * c) ) + ( ((d*e)+f) *g ) )</p><p>2)将运算符移到括号的后面，变成((a(bc) * )+(((de) * f)+g)*)+</p><p>3)去掉括号，得到abc*+de<em>f+g</em>+</p><h1 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h1><p>其实只要会算next数组就可以啦</p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>任意节点的左右子树高度绝对值不大于1，左子树与右子树的高度差称为平衡因子</p><h2 id="平衡方法"><a href="#平衡方法" class="headerlink" title="平衡方法"></a>平衡方法</h2><p>当插入新节点时，先检查有无破坏性质，若破坏了，找到离插入节点最近的平衡因子绝对值大于1的节点，让他作为根，设为A，来调整他的子树，然后会有以下四种情况，这四种情况名字很好记和对应不平衡的原因联系起来记比价好记，具体的操作直接看名字就能记忆，结合例子懂得更深。</p><p>LL，即A的左孩子的左子树插入了导致不平衡（下面的都同理就不写了），用一个右旋即可</p><p>RR，用一个左旋</p><p>LR，先左旋再右旋，这个左旋是子树的旋，后面右旋是A的旋</p><p>RL，先右旋再左旋</p><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>相当的easy啊，就是写出序列然后直接前后少了就填对应的就可以了，这就叫线索化啊</p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>哈夫曼树可以解决如下问题：<strong>给定N个带权值的叶子节点，如何构造出一个带权路径长度（WPL）最小的二叉树</strong>，带权路径即从根节点到叶子节点经历的边的数量乘叶子节点的权值。此外，这种二叉树也就是哈夫曼树的定义。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建其实很简单，下面以二叉哈夫曼树为例 给n个点，每个点都有权值，构造一棵哈夫曼树。每次选剩下的两棵根权值最小的树合并成一棵新树，新树的根权值等于两棵合并前树的根权值和。（一开始一个点也看成一棵树，只不过这棵树没有孩子节点）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211025151053491.png" alt="image-20211025151053491"></p><p>哈夫曼树中只有度为0和度为2的节点，且n0&#x3D;n2+1（这个的证明很简单，因为度为1的节点不会产生新的叶节点，一个度为2的产生一个叶子节点，再加上原本的根节点就得到这个公式了，然后哈夫曼树是最优二叉树所以没有度为1的节点）</p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>一篇电文，原文为：AMCADEDDMCCAD。现在要把原文转换成01串发送给对方。为了节省资源，我们当然希望翻译好的01串长度尽量的短。怎么办？</p><p>分析，我们当然希望用的最多编码的串更短，并且不能出现歧义（这时候就要用前缀码了，即没有一个编码是其他编码前缀的编码），这样的话正好就可以用哈夫曼树了，将出现次数视为权值，然后来做</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/47029.png" alt="img"></p><h1 id="树、森林和二叉树互换"><a href="#树、森林和二叉树互换" class="headerlink" title="树、森林和二叉树互换"></a>树、森林和二叉树互换</h1><p>有时候我一直很困惑树和森林的区别是什么，其实森林就是m棵互不相交的树的集合，树删掉了根节点就变成了森林。</p><h2 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h2><p>左兄弟右孩子，所以转换出来的二叉树没有右子树</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/20130916192154203" alt="img"></p><h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><p>把每一个树转换为二叉树，然后再根据左孩子右兄弟来转换（根视为兄弟），这个逆过程也得会，稍微思考一下就懂了。</p><h2 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h2><p>将右孩子断了，然后将，再对断了的右子树递归进行此操作直到没有右子树为止。然后再对每一个树转换为二叉树。</p><p>树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知，森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同</p><h1 id="堆排序（其实也是二叉树的应用）"><a href="#堆排序（其实也是二叉树的应用）" class="headerlink" title="堆排序（其实也是二叉树的应用）"></a>堆排序（其实也是二叉树的应用）</h1><p>堆一般是一种完全二叉树，分为最大堆和最小堆，最大堆即每个父节点都大于子节点，最小堆同理。</p><p>堆排序顺序，创建堆，调整堆，堆排序。</p><p>主要是后两部，调整堆即把一个堆变成最大&#x2F;最小堆，堆排序即将排好的堆的根以此输出（交换元素），并且要维持堆的性质不变。</p><h2 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h2><p>这个调整是一切的基础，以最大堆距离，简单来说是一个迭代的过程，从最后一个元素往前开始，要是此元素小于左右子树的最大值，就把根与该值交换，不断重复直到完全满足要求。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-a71cede24ccc2f9c866762b179883772_r.jpg" alt="preview"></p><h2 id="堆排序（交换元素）"><a href="#堆排序（交换元素）" class="headerlink" title="堆排序（交换元素）"></a>堆排序（交换元素）</h2><p>将根与最后一个没排序好的元素交换，此中要一直保持堆的性质不变</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-843070653f31636b46728b4777a0aac9_r.jpg" alt="preview"></p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>插入先插入末尾，然后向上执行调整操作</p><h1 id="B-树B-树"><a href="#B-树B-树" class="headerlink" title="B+树B-树"></a>B+树B-树</h1><p>B树和B+树是一种查找的手段，主要解决磁盘读取慢的问题</p><p>n阶B树至少要关键词达到n个才分裂</p><p>m阶B树的性质：</p><ol><li>每个结点最多有m个子树，即最多m-1个关键字</li><li>除根节点外的非叶节点至少得有m&#x2F;2（向上取整）个子树，即最少要有m&#x2F;2（向上取整）-1个关键字</li><li>若根节点不是终端结点，则至少有两颗子树</li><li>所有叶节点在同一层次上，且不带信息（表示查找过程）</li></ol><p>m阶B+树的性质：</p><ol><li>每个分支阶段最多有m棵子树</li><li>除根节点外的非叶节点至少得有m&#x2F;2（向上取整）个子树，即最少要有m&#x2F;2（向上取整）-1个关键字</li></ol><p>区别：</p><ol><li>B+树具有n个关键字的结点只有n棵子树，但是B树有n+1棵（所以他们结点数量的最大最小值也不一样嗷）</li><li>B+树叶结点包含信息，B树中</li></ol><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="图的一堆杂七杂八的概念"><a href="#图的一堆杂七杂八的概念" class="headerlink" title="图的一堆杂七杂八的概念"></a>图的一堆杂七杂八的概念</h2><p>完全图：对于无向图，边的最大值是n * (n-1)&#x2F;2，取得最大值的无向图叫完全图，对于有向图同理，但是有向图最大值为n * (n-1)</p><p>连通：若从顶点v到顶点w有路径存在，则称v和w是连通的</p><p>连通图：任意两个顶点都是连通的</p><p>连通分量：无向图中的极大连通子图成为连通分量</p><p>强连通：有向图中，若两个顶点互相都有路径则叫强联通</p><p>强联通图：任何一对顶点都是强联通的</p><p>强联通分量：极大强联通子图</p><p>关键路径是AOE网从起点到终点的最长路径</p><p>一个边对应两个度，一些计算题可以这样算</p><p><strong>存储方法</strong></p><ol><li><p>连接矩阵：就是一个n阶方阵，要注意如果是有向图那么(i,j)代表顶点i到顶点j有边</p></li><li><p>邻接表法：每个点一个链表，链表里的值代表和该点相连的点<img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211118192045266.png" alt="image-20211118192045266"></p></li><li><p>十字链表：</p></li></ol><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>可以先修课程，即没修某门课不能上一门课</p><p>生成方法：1.选择一个没有前驱的顶点并输出2.删除该顶点和所有以它为起点的边，然后重复以上过程</p><p>做题数有几个拓扑排序可以采用树的方法，这样比较清晰，不多谈，你应该懂得。</p><p>记住拓扑排序必须要包括全部的元素</p><h2 id="最小生成树-amp-最短路径"><a href="#最小生成树-amp-最短路径" class="headerlink" title="最小生成树&amp;最短路径"></a>最小生成树&amp;最短路径</h2><p>搞清楚递归过程和结束条件</p><p><strong>最小生成树</strong></p><p>Prim算法</p><p>任取一点加入点集，然后找与现在点相连的边中最小的边（且不能是已经有的点）将该点加入点集，直到全部点都选完</p><p>这个适合边多点少的图</p><p>Kruskal算法</p><p>先把边按照权值大小排列好，把点都打散（这样每个点自成一个连通分量）然后依次选择，如果这个边连接了不同的连通分量，就加入，否则选下一个，以此直到都连通。</p><p>这个适合边少点多的图</p><p><strong>最短路径</strong></p><p>Dijkstra（是找一个点到全部点的最短路径）</p><p>从某一点出发，寻找该点最小的边，然后加入，然后也把这个点的边加入进来考虑最小，直到所有的点都有最短路径。</p><p>Floyd算法</p><p>其实就是一个动态规划，理解这个状态转移方程即可<br>$$<br>dp[i][j]&#x3D;min(dp[i][j],dp[i][k]+dp[k][j])<br>$$</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>m路平衡归并：就是讲m个有序表组合成一个新的有序表，经过一趟后剩下的记录数是原来的1&#x2F;m，所以要求最少的几趟n就是用记录数x&#x2F;m^n向上取整求最小的，但是也不能太大，太大可能不用那么多。</p><p>败者树高度为ceil(log2k)+1所以比较次数为个数*高度</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>选择排序无论如何都是O（n方）的复杂度</p><h1 id="索引表查找"><a href="#索引表查找" class="headerlink" title="索引表查找"></a>索引表查找</h1><p>这个我个人觉得可以理解为二维的二分查找，懂了这个之后就很容易推了，假设一共有n个元素，那么就分成n^1&#x2F;2组，每组n^1&#x2F;2个元素，先对组进行查找，再在组内进行查找。</p><p>折半查找最多次数为log2N（向下取整）+1</p><p>AVL：二叉查找树（Adelson-Velsky-Landis Tree）:是带有平衡条件的BST</p><p>BST：二叉排序树（Binary Search Tree）：左子树值&lt;&#x3D;根值&lt;&#x3D;右子树</p><h1 id="散列表查找"><a href="#散列表查找" class="headerlink" title="散列表查找"></a>散列表查找</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h2 id="处理冲突方法"><a href="#处理冲突方法" class="headerlink" title="处理冲突方法"></a>处理冲突方法</h2><p><strong>开放定址法</strong></p><p>Hi&#x3D;(H(key)+di)%m（下面的方法就是d的取法不同）</p><p>线性探测法</p><p>d取0,1,2……其实就是遇到冲突逐个往后找空闲的位置放下，但这样会造成同义词的堆叠</p><p>平方探测法</p><p>d取0^2,1^2,-1^2……不会堆叠，但最多只能查找一半的长度</p><p>再散列法</p><p>di&#x3D;i*H2(key)</p><p>伪随机序列法</p><p>d&#x3D;伪随机序列</p><p><strong>拉链法</strong></p><p>把所有的同义词都放在同一地址，用线性链表存储，适合经常进行插入和删除的序列</p><h2 id="怎么算成功平均查找长度和失败平均查找长度"><a href="#怎么算成功平均查找长度和失败平均查找长度" class="headerlink" title="怎么算成功平均查找长度和失败平均查找长度"></a>怎么算成功平均查找长度和失败平均查找长度</h2><p>成功平均长度很容易算，就算每一个value要用给定的构造函数和处理方法算几遍才能得到就可以</p><p>失败怎么理解呢？首先你这个数只有可能落在0-p-1的范围内，那你怎么才能知道自己不成功呢？就是一直往后找（这个往后找的意思是用冲突处理的办法来不断往后）遇到一个空的时候就说明肯定没有了呀，就说明你这个元素不在表里，然后把这个结果记录下来，再取平均。</p><h2 id="查找概率"><a href="#查找概率" class="headerlink" title="查找概率"></a>查找概率</h2><p>很长一段时间不太懂这个词到底什么意思，其实就是查的这个词在不在这一堆记录的概率，用来算平均查找长度的话就是查找概率 * 成功平均查找长度 + （1 - 查找概率） * 失败平均查找长度</p><p>装填因子表示一个表装满的程度，当然越满越容易发生冲突</p><h1 id="新考点"><a href="#新考点" class="headerlink" title="新考点"></a>新考点</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>平衡二叉树插入删除很容易破坏平衡特性，破坏了需计算平衡因子，找最小不平衡子树</p><p>而红黑树无需频繁调整树的形态，调整也可以常数时间内完成。</p><p>所以，平衡二叉树适用于查为主，红黑树适用于频繁删除插入</p><p>可能考定义、性质，手绘插入</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ol><li><p>左&lt;根&lt;右</p></li><li><p>每个结点要么是红色要么是黑色</p></li><li><p>根节点和叶节点（外部结点，NULL结点，失败结点，不包含关键字）都是黑色的</p></li><li><p>不存在两个相邻的红结点（即一个红结点的父亲和儿子都不能是红结点，兄弟不算连续）（即查找路径不能连续两个红结点）</p></li><li><p>任一结点到它下面的任一叶节点经历的路径的黑结点数量必须都一样</p></li></ol><p>结点的黑高：从某结点出发（不含该结点）到达任一空叶节点的路径上的黑结点总数</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>从根节点到叶节点的最长路劲不大于最短路径的2倍</li><li>有n个内部结点的高度h&lt;2log2(n+1)（所以查找操作复杂度O(log2n)</li></ol><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入为根：染成黑色</p><p>插入非根：染成红色（因为不会改变黑结点的个数，这样就不会改变顺序）</p><p>如果满足定义，则插入结束</p><p>如果不满足（只用看是否不满足不红红，因为不会改变黑色节点数量），则需要调整（看叔叔的脸色，即父亲结点的兄弟的颜色）</p><p>叔叔为黑色：旋转+染色</p><ul><li>LL：右单旋，父换爷+染色</li><li>RR：左单旋，父换爷+染色</li><li>LR：左、右双旋，儿换爷+染色</li><li>RL：右、左双旋，儿换爷+染色</li></ul><p>叔叔为红色：染色+变新</p><ul><li>叔父爷染色，爷变为新结点</li></ul>]]></content>
    
    
    <categories>
      
      <category>考研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理考研笔记</title>
    <link href="/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%BB%84/"/>
    <url>/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211108131525537.png" alt="image-20211108131525537"></p><p>注意这个m是原码！！举例m为00100000（后面都是0）</p><p>则尾数是(1.0010)（二进制），化成十进制就是1.125</p><h1 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h1><p>DRAM是电容存储所以需要刷新，刷新方式有集中刷新，分散刷新和异步刷新</p><h1 id="Cache写回策略"><a href="#Cache写回策略" class="headerlink" title="Cache写回策略"></a>Cache写回策略</h1><p>写直达法：是指每次写操作数既写入内存也写入Cache</p><p>写回法：写Cache时不写入主存，而当Cache数据被替换出去时才写回主存。为了识别cache数据是否与主存一致，要加一个记录信息状态位，写Cache时设置，Cache数据写回主存时清除。</p><h1 id="微指令相关"><a href="#微指令相关" class="headerlink" title="微指令相关"></a>微指令相关</h1><ol><li>在微程序控制器中，执行指令微程序的首条微指令地址是通过指令操作码映射得到的。</li><li>直接控制：有几位最多就能控制几位；字段直接编码控制：12位想控制3段，必须要不相容，然后分成3段，每段4位，去除一个不用最多有45种状态。</li><li>断定方式确定下一条微指令地址：由微指令的下地址字段直接指出后续微指令地址</li></ol><h1 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h1><p>非格式化容量是指一个盘片上可以记录的二进制位的总数量，而格式化容量（完成划分磁道和扇区，设置文件目录区等操作后的磁盘）通常是指用户可用空间的二进制位的总数量，前者比后者要大。</p><p>将长度超过一个磁道容量的文件记录在同一柱面是合理的，因为不需要重新寻找磁道，省去了极慢的寻道操作，这样数据读&#x2F;写速度快。</p><p>地址格式：磁盘号&#x2F;柱面号&#x2F;盘面号&#x2F;扇区号，直接寻址的最小单位是扇区</p><p>读出一个扇区的数据所用的时间为：平均寻道+平均寻扇区时间+磁头扫过一个扇区的时间</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>内中断</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211117183110305.png" alt="image-20211117183110305"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211117183117323.png" alt="image-20211117183117323"></p><p>注意这个中断图的画法，先是按照设定的来，再按照真正的来。</p><h1 id="计算相关"><a href="#计算相关" class="headerlink" title="计算相关"></a>计算相关</h1><p><strong>浮点数</strong></p><ol><li>short转int要在前面加1</li></ol><p><strong>总线带宽</strong></p><p>时钟周期&#x3D;1&#x2F;时钟频率（1MHZ即0.1us时钟周期），一个总线周期传输的信号量&#x2F;总线周期时间</p><p><strong>RAM最高地址</strong></p><p>32KB的RAM最高地址怎么算？32KB为2^15B所以需要15根地址线，15个1就是7FFFH，如果首地址变了记得要加！</p><p><strong>Cache组相联映射的组号计算</strong></p><p>比如Cache有16块，采用2路相连映射，即分为8组，那么n号单元所在主存块就按照模8来分配</p><p><strong>流水线相关</strong></p><p>加速比：原本时间 &#x2F; 加速后时间</p><p>实际吞吐率：一个流水周期中一条的指令书 &#x2F; 一个流水周期的时间</p><p><strong>Cache块号格式和计算</strong></p><p>主存地址包含3个部分：标记（Tag），组号（Index），块内地址（Offset）</p><p>先将主存地址由十六进制变为二进制，最后4位为块内地址，中间10位为组号，剩下的是标记</p><p><strong>指令流水线</strong></p><p>包含瓶颈段的流水线，设共有k段，且需要执行n调指令，则总的执行时间为<br>$$<br>t_1+……t_k+(n-1)*max(t_1,……,t_k)<br>$$</p><h1 id="单个的要背的错题知识点"><a href="#单个的要背的错题知识点" class="headerlink" title="单个的要背的错题知识点"></a>单个的要背的错题知识点</h1><ol><li><p>间址周期</p></li><li><p>CPI为每条指令所需要的时钟周期数，根具体时钟周期的长短无关（然后时钟频率和时钟周期互为倒数，所以也无关） </p></li><li><p>总线宽度又称为总线位宽，它是总线上能够同时传输的数据位数，同时是指数据总线的根数；总线的传输速率等于中心宽度 * 工作频率</p></li><li><p>指令总是从根据PC从主存中读出</p></li><li><p>中断优先级最高的就是全1，然后依次往下面加0</p></li></ol><p><strong>还没搞懂的内容</strong></p><p><strong>数据冒险</strong></p><h1 id="新考点"><a href="#新考点" class="headerlink" title="新考点"></a>新考点</h1><h2 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h2><p>补码加：按位加就可以了</p><p>补码减：先把减数取反，然后末尾加1，得到-Y，然后再加（最高位的结果丢弃）</p><p>无符号和有符号判断溢出的方法不一样，要用标志位</p><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p>PSW里面会用这些标志位</p><p>OF（Overflow Flag）</p><p>溢出就是1，否则就是0，只有在有符号数加减才有意义，无符号数就算OF是1也不代表溢出了</p><p>计算方法：最高位产生的进位与次高位产生的进位异或</p><p>SF （Sign Flag）</p><p>符号位，取最高位本位，1代表负数，0代表正数，同样也只对无符号数</p><p>ZF（Zero Flag）</p><p>运算结果为0时ZF为1，否则为0</p><p>CF（Carry Flag）</p><p> 进位为1，否则为0，最高位产生的进位和sub异或（sub即那个是加还是减的信号，加法sub为0，减法sub为1），对有符号数没意义</p><h2 id="乘法电路基本结构"><a href="#乘法电路基本结构" class="headerlink" title="乘法电路基本结构"></a>乘法电路基本结构</h2><p>用一个例子理解结构并且记忆溢出之类的</p><p>有符号数会多一个辅助位</p><h2 id="除法电路基本结构"><a href="#除法电路基本结构" class="headerlink" title="除法电路基本结构"></a>除法电路基本结构</h2><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p>选择题概率很高</p><p><strong>SISD</strong></p><p>计组中学的都是这个，不能数据级并行，可以指令流水线</p><p><strong>SIMD</strong></p><p>把数据块分割然后分开到不同的局部存储器，很适合循环操作，因为每一块都是一样的，某些显卡就是这样干的（感觉matlab也是这样呀）这样一条命令就可以控制多个局部存储器，不同执行单元执行同一指令，但是不同数据</p><p>向量处理机：也是数量级并行，SIMD思想的进阶应用</p><p><strong>MISD</strong></p><p>同一数据不同指令，逆天，现实中不存在</p><p><strong>MIMD</strong></p><p>现实很多都是这样</p><p>线程级并行，甚至是进程级并行</p><p>多计算机系统不同用load store直接访问内存，必须用消息传递，所以也成为消息传递系统</p>]]></content>
    
    
    <categories>
      
      <category>考研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络考研笔记</title>
    <link href="/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%BD%91/"/>
    <url>/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>专门总结一下计网中的各种英文缩写，以此串起来复习一下</p><h1 id="各种英文缩写"><a href="#各种英文缩写" class="headerlink" title="各种英文缩写"></a>各种英文缩写</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>分布范围划分</strong></p><p>WAN：广域网（Wide Area Network）</p><p>MAN：城域网 （Metropolitan）</p><p>LAN：局域网（Local）</p><p>PAN：个人区域网（Person）</p><p><strong>协议和服务</strong></p><p>SDU：服务数据单元（Service Data Unit）</p><p>PCI：协议控制单元（Protocol Control Information）</p><p>PDU：协议数据单元（Protocol Data Unit）<br>$$<br>PDU_n &#x3D; PDU_{n-1} + PCI_{n-1}<br>$$</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><strong>编码</strong></p><p>RZ：归零编码（Return Zero Code）（高电平1，低电平0且每个周期中间变成0）</p><p>NRZ：非归零编码（Non-Return Zero Code）（不用归零）</p><p>NRZI：反向非归零编码（Non-Return Zero Inverted Code）（信号反转表示0，不反转表示1）</p><p>曼彻斯顿：</p><p><strong>调幅</strong></p><p>ASK：</p><p>FSK</p><p>PSK</p><p>QAM</p><p>RTT：往返时延(Round-Trip Time)</p><p><strong>传输介质</strong></p><p>STP：屏蔽双绞线（Shielded Twisted Pair）</p><p>UTP：非屏蔽双绞线（Unshielded Twisted Pair）</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>MTU：最大传送单元（Maximum Transmission Unit）</p><p>CRC：循环冗余校验（Cyclic Redundancy Check）（加阶数个0，然后做异或）</p><p><strong>流量控制和可靠传输</strong></p><p>ARQ：自动重传请求（Auto Repeat Request）</p><p>GBN：后退N帧协议（Go-Back-N）</p><p>SR：选择重传协议（Selective Repeat）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211123143804200.png" alt="image-20211123143804200"></p><p><strong>介质访问控制</strong></p><p>MAC：介质访问控制（Medium Access Control）</p><p>信道划分介质</p><p>FDM：频分复用（Frequency Division Multiplexing）</p><p>TDM：时分复用（Time）</p><p>STDM：异步时分复用</p><p>WDM：波分复用</p><p>CDM：码分复用</p><p>CDMA：码分多址（Code Division Multiple Access）（两个向量互相正交）</p><p>随机访问介质控制</p><p>ALOHA（Additive Link On-line Hawaii system)</p><p>CSMA&#x2F;CD</p><p>CSMA&#x2F;CA</p><p>IFS：帧间间隔（InterFrame Space）</p><p>SIFS：</p><p>PIFS：</p><p>DIFS：</p><p>RTS</p><p>CTS</p><p><strong>局域网</strong></p><p>LLC：逻辑链路控制子层（Logical Link Control）（给帧加序号）</p><p>NIC：网络接口卡（Network Interface Card）</p><p><strong>广域网</strong></p><p>PPP：点对点协议（Point to Point Protocol）（串行线路通信的面向字节的协议）</p><p>FCS：帧校验序列（frame check sequence）</p><p>LCP：链路控制协议（Link Control Protocol）（建议配置管理数据链路）</p><p>NCP：网络网控协议（Network）（PPP允许不同的网络层协议，每一个网络层协议需要一个NCP来管理）</p><p>HDLC：高级数据链路控制协议（High-level Data Link Protocol）（ISO指定的面向比特的协议）</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP：网路协议（Internet Protocol）</p><p>Fragment（等于1说明后面还有片）</p><p>TTL：生存时间（Time To Live）</p><p>MF：More Fragment（等于1说明后面还有片）</p><p>DF：Don’t Fragment（等于1不能被分片）</p><p>NAT：网络地址转换（Network Address Translation）（将专用地址转换为公共地址，增加ipv4地址数量）</p><p>CIDR：无分类域间路由选择（Classless Inter-Domain Routing）</p><p>ARP：地址解析协议（Address Resolution Protocol）（将IP地址映射到MAC地址，根据IP地址查询MAC地址）</p><p>DHCP：动态主机配置协议（Dynamic Host Configuration Protocol）（用于给主机动态地分配IP地址，提供了即插即用的联网机制，应用层协议，基于UDP）</p><p>ICMP：网际控制报文协议（Internet Control Message Protocol）（报告错误类型，有五种，工作在网络层，常见应用有PING和Tracert）</p><p><strong>路由协议</strong></p><p>OSPF</p><p>IGP：内部网关协议</p><p>RIP（用UDP传输）</p><p>OSPF（用IP传输）</p><p>EGP：外部网关协议</p><p>BGP-4</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211123154116879.png" alt="image-20211123154116879"></p><p><strong>IP组播</strong></p><p>IGMP：因特网组管理协议（Internet Group Management Protocol）</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><strong>UDP</strong></p><p><strong>TCP</strong></p><p>PSH：推送为（PUSH）（等于1就必须尽快交付给应用进程而不是等到栈满）</p><p>RST：复位位（Reset）（等于1说明出现严重差错必须释放链接重现建立运输链接）</p><p>SYN：同步位（Synchronize Sequence Numbers）</p><p>FIN：终止位（Finish）</p><p><strong>拥塞控制</strong></p><p>cwnd</p><p>rwnd</p><p>ssthresh</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>DNS：域名系统（Domain Name System）（把用于便于人们记忆的域名转换为便于机器处理的IP地址，唯一以一个基于UDP的应用层协议）</p><p>FTP：文件传输协议（File Transfer Protocol）（两个链接，一个控制链接一个数据链接）</p><p>MIME：多用途网络邮件扩充（Multiple Internet Mail Extensions）（因为SMTP只能传输一定长度的ASCII码，用这个协议就可以传送可执行协议及其他二进制对象）</p><p>SMTP：简单邮件传输协议（Simple Mail Transfer Protocol）</p><p>POP3：邮局协议（Post Office Protocol）（简单的邮件读取协议）</p><p>WWW：万维网（World Wide Web）</p><p>HTTP：超文本传输协议（Hyper Text Transfer Protocol）</p><h1 id="各种设备"><a href="#各种设备" class="headerlink" title="各种设备"></a>各种设备</h1><p>在物理层的设备啥都不能隔离，在链路层的设备可以隔离冲突域不能隔离广播域，在网络层设备既可以隔离冲突域也可以隔离广播域</p><p>物理层：集线器、中继器</p><p>链路层：交换机、网桥</p><p>网络层：路由器</p><h1 id="那些计算题"><a href="#那些计算题" class="headerlink" title="那些计算题"></a>那些计算题</h1><p><strong>比特率和波特率</strong></p><p>比特率&#x3D;波特率 * 单个调制状态对应的二进制位数</p><p>两相调制：单个调制状态对应1个二进制位</p><p>四相：2个</p><p>八相：3个</p><p><strong>有效数据传输率</strong></p><ol><li>有效数据传输率&#x3D;发送的有效数据&#x2F;发送有效数据所用的总时间</li><li>数据发送时间要算发送时间和传输时间</li><li>因为冲突检测机制，确认帧的传输时延等于往返传播时延</li></ol><p><strong>香农公式和奈奎斯特公式</strong></p><p>香农公式考虑了噪声，所以即实际情况下的最大数据传输速率</p><p>V&#x3D;W * log2(1+S&#x2F; N)（S&#x2F;N为信噪比）</p><p>奈奎斯特就是单纯的考虑信号</p><p>Cmax &#x3D; f采样 * log2N &#x3D; 2f * log2N</p><p><strong>循环冗余检验</strong></p><p>两个重点</p><ol><li>最高次方是r就是r阶，就要往后面添r个0</li><li>最后生成的冗余码共r位，就算前面有0也不能忽略！！！！</li></ol><p><strong>带宽</strong></p><ol><li>带宽即每秒在一条链路上传输的数据，单位为bit&#x2F;s</li></ol><p>举例：50个路由器的网络，每个表项长度6B，每秒与每个相邻交换一次，那么贷款为6 * 8 * 50 * 2（注意这个8是B有8bit，然后2是因为交换所以同时有两份数据）</p><ol start="2"><li>带宽还可以根据频率范围来算，比如频率范围为3.4MHz-3.9MHz，那么贷款就是0.5MHz</li></ol><p><strong>CSMA&#x2F;CD最小帧长</strong></p><p>其实就是求争用期</p><ol><li>争用期&#x3D;往返距离&#x2F;信号传输速度</li><li>最小帧长&#x3D;争用期 * 数据传输率</li></ol><p>以太网最小传输帧长为64B，小于这个长度必须填充</p><p>MAC帧数据字段最少46个字节</p><p><strong>以太网组播IP地址映射到组播MAC地址</strong></p><p>先把IP地址变成二进制，然后取后23位，4个4个对应成十六进制，但是要注意映射完后20位最前面那一位要变成0再和那3位组成来变成十六进制。<br><strong>IPv6简化写法</strong></p><ol><li>连续冒号只能使用一次，最高位的4个0必须要留一个（如果低位也有连续4个0的话）</li><li>每个4位一组的十六进制数中，如其高位为0，则可忽略</li></ol><p><strong>TCP最大数据传输率和最大窗口尺寸</strong></p><p>相同编号的报文段不能同时在网络中传输，给你序号的大小是让你求最多有几个序号，比如序号大小为8bit那么就有255个序号</p><p>最大数据传输率&#x3D;最大报文段长度  * 序号数量 &#x2F; 寿命</p><p>最大窗口尺寸&#x2F;数据传输率≥往返时间（RTT）</p><p><strong>滑动窗口最大尺寸</strong></p><p>m比特（mbit）</p><p>后退N帧：max≤2^m-1</p><p>选择重传：max≤2^(m-1)</p><p><strong>二进制后退算法</strong></p><p>N次碰撞后，在0-M中选一个随机数</p><p>1≤N&lt;10，M&#x3D;2^N-1</p><p>10≤N&lt;15，M&#x3D;2^10-1&#x3D;1023</p><p>N&#x3D;16，直接丢弃，并给计算机发送一个错误报告</p><h1 id="新考点总结"><a href="#新考点总结" class="headerlink" title="新考点总结"></a>新考点总结</h1><p>删除了令牌环网、HDLC协议、网桥</p><h2 id="VLAN（虚拟局域网-Virtual-Local-Area-Network）"><a href="#VLAN（虚拟局域网-Virtual-Local-Area-Network）" class="headerlink" title="VLAN（虚拟局域网 Virtual Local Area Network）"></a>VLAN（虚拟局域网 Virtual Local Area Network）</h2><p>传统局域网局限</p><p>缺乏流量隔离</p><p>每个VLAN是一个单独的广播域&#x2F;不同的子网</p><p><strong>如何实现</strong></p><p> 在交换机中除了转发表还会有VLAN表，VLAN ID</p><p>也有基于MAC地址的VLAN技术</p><p>不同交换机怎么搞：加标签</p><p>不同VLAN不同互相访问，除非有路由器或三重交换器</p><h2 id="SDN基本概念"><a href="#SDN基本概念" class="headerlink" title="SDN基本概念"></a>SDN基本概念</h2><p>数据平面：根据转发表进行转发</p><p>控制平面</p><p><strong>传统方法</strong>：路由选择算法运行在每台路由器中，并且每台路由器中都包含转发和路由选择两种功能（即数据平面和控制平面在同一个路由器）</p><p><strong>SDN方法（Software-Defined Networking）</strong></p><p>路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用</p><p>使用软件实现的、可编程的</p><p>理解那个框架</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20211104185417943.png" alt="image-20211104185417943"></p>]]></content>
    
    
    <categories>
      
      <category>考研笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
