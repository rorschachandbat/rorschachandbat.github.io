<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R</title>
  
  
  <link href="https://rorschachandbat.github.io/atom.xml" rel="self"/>
  
  <link href="https://rorschachandbat.github.io/"/>
  <updated>2024-12-24T12:21:25.455Z</updated>
  <id>https://rorschachandbat.github.io/</id>
  
  <author>
    <name>R</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UnityAsset%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UnityAsset%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-24T12:21:25.455Z</published>
    <updated>2024-12-24T12:21:25.455Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Assets Unity工程实际的资源目录，所有项目用到的资源、代码、配置、库等等原始资源只有放置在这个文件夹才会被Unity认可和处理。</li><li>Library 存放Unity处理完毕的资源，大部分的资源导入到Assets目录之后，还需要通过Unity转化成Unity认可的文件，转化后的文件会存储在这个目录。</li><li>Packages 这个是2018以后新增的目录，用于管理Unity分离的packages组件。</li><li>ProjectSettings 这个目录用于存放Unity的各种项目设定。</li></ul><p>出于几点原因，Unity并不希望大家过渡使用Resources，是因为 ：</p><p>1、Resources会让内存管理变的困难，因为它的所有资源是初始化全部加载，并且常驻内存。</p><p>2、Resources内的资源会增加应用程序的启动时间和构建时长。</p><p>3、Resources内的资源无法增量更新。这是现在手机游戏开发的致命点。</p><p>优点：</p><p>1、某些资源是项目整个生命周期都必须要用的。</p><p>2、有些很重要，但是却不怎么占内存的。</p><p>3、不怎么需要变化，并且不需要进行平台差异化处理的。</p><p>4、用于系统启动时候最小引导的。</p><p>构建项目的时候，所有的Resources目录下的文件会被合并为一个序列化文件。该文件会有自己的metadata信息和索引信息。内部用<a href="https://zhida.zhihu.com/search?content_id=109719269&content_type=Article&match_order=1&q=%E7%BA%A2%E9%BB%91%E6%A0%91&zhida_source=entity">红黑树</a>实现资源查找，用于索引相应的File GUID和Local ID，并且它还要记录在序列化文件中的偏移量。</p><p>如何解决Resources的这些问题，可以用AssetDatabase或者Addressable Asset System</p><h1 id="AssetDatabase"><a href="#AssetDatabase" class="headerlink" title="AssetDatabase"></a>AssetDatabase</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#">CreateAsset：创建文件<br><br>CreateFolder：创建文件夹<br><br>DeleteAsset：删除文件<br><br>GetAssetPath：获取文件相对于Assets所在目录的相对位置，如“Assets/Images/test.png”<br><br>LoadAssetAtPath：加载文件<br><br>Refresh：刷新整个project窗口<br><br>SaveAssets：保存所有文件<br><br><span class="hljs-keyword">using</span> UnityEditor;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EditorCase1</span><br>&#123;<br>    [<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;Assets/MyEditor/Delete Asset&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CaseMenu</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> obj = Selection.activeObject;<br>        <span class="hljs-keyword">var</span> path = AssetDatabase.GetAssetPath(obj);<br>        AssetDatabase.DeleteAsset(path);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><p><strong>AssetBundle系统提供了一种压缩文件的格式，可以把1到多个文件进行索引和序列化。</strong></p><p>Unity项目在交付安装之后，会通过AssetBundle对不包含代码的资源进行更新。这就允许开发人员先提交一个小的应用程序包，将运行时内存压力降到最低，并有选择地加载针对不同终端用户设备优化后的内容。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>1、一般来说，只要有可能，就应该使用AssetBundle.LoadFromFile。这个API在速度、磁盘使用和运行时内存使用方面是最有效的。</p><p>2、对于必须下载或热更新AssetBundles的项目，强烈建议对使用Unity5.3或更高版本的项目使用UnityWebRequest，对于使用Unity5.2或更老版本的项目使用WWW.LoadFromCacheOrDownload。</p><p>3、当使用UnityWebRequest或WWW.LoadFromCacheOrDownload时，要确保下载程序代码在加载AssetBundle后正确地调用Dispose。另外，C#的using语句是确保WWW或UnityWebRequest被安全处理的最方便的方法。</p><p>4、对于需要独特的、特定的缓存或下载需求的大项目，可以考虑使用自定义的下载器。编写自定义下载程序是一项重要并且复杂的任务，任何自定义的下载程序都应该与AssetBundle.LoadFromFile保持兼容。</p><h2 id="从AssetBundles中加载Assets"><a href="#从AssetBundles中加载Assets" class="headerlink" title="从AssetBundles中加载Assets"></a>从AssetBundles中加载Assets</h2><p>到这里，我们已经能够获得AssetBundles了，那么接下来就是要从AssetBundles里获取Assets。</p><p>Unity提供了三个不同的API从AssetBundles加载UnityEngine.Objects，这些API都绑定到AssetBundle对象上，并且这些API具有同步和异步变体：</p><ul><li>LoadAsset (LoadAssetAsync)</li><li>LoadAllAssets (LoadAllAssetsAsync)</li><li>LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Assets Unity工程实际的资源目录，所有项目用到的资源、代码、配置、库等等原始资源只有放置在这个文件夹才会被Unity认可和处理。&lt;/li&gt;
&lt;li&gt;Library 存放Unity处理完毕的资源，大部分的资源导入到Assets目录之后，还需要通过Unit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-24T12:21:25.206Z</published>
    <updated>2024-12-24T12:21:25.206Z</updated>
    
    <content type="html"><![CDATA[<p>技能系统设计</p><p><a href="https://zhuanlan.zhihu.com/p/416805924">用Unity制作一个极具扩展性的顶视角射击游戏战斗系统 - 猴与花果山的文章 - 知乎</a></p><p>Timeline</p><p>这个技能是怎么放的</p><p>技能框架</p><p>技能可以编程上状态包，上buff</p><p>然后每个buff会有很多回调函数，</p><p>比如OnOccur（打上buff）</p><p>OnRemoved</p><p>OnTick</p><p>OnCast</p><p>OnHit</p><p>OnBehurt</p><p>OnKill</p><p>OnBeKilled</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;技能系统设计&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/416805924&quot;&gt;用Unity制作一个极具扩展性的顶视角射击游戏战斗系统 - 猴与花果山的文章 - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Timeline&lt;/p&gt;
&lt;p&gt;这个技</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/Unity-%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/Unity-%E6%9C%AC%E5%9C%B0%E5%8C%96/</id>
    <published>2024-12-24T12:21:25.204Z</published>
    <updated>2024-12-24T12:21:25.204Z</updated>
    
    <content type="html"><![CDATA[<p>既然TMP这么强大，有这么多好处，理所当然它也是有不足之处。目前为止，遇到两个最大头的问题，第一个是DrawCall,第二是堆内存。</p><p>前面说到，TMP的所有效果都可以在编辑时态调好参数，然后存储为一个材质球。这就意味着每一种效果在运行时就会增加一个DC。比如16号字和18号字哪怕只是改了字号也会多一个出来。和大多数的3D渲染一样，TMP运行时动态赋值（修改参数）的话，也是会使用material而不是sharedMaterial。这造成的结果就是在UI展示的时候，因为多种UI的字体效果，又或者是和UI的图元渲染进行互相的批次打断，从而造成DrawCall增加。</p><p>但这种情况对于一般的UI来说性能影响不是很大，但是对于战斗中大量的飘字和世界沙盘中大量的HUD而言是一个性能重灾区。我们解决方式方式也很简单，分为两个步骤，对于UI上的文字效果，进行提前的收集，并和美术UI的同学确定好预设，最终统计10-20种字体效果，形成缓存池，通过增加组件的方式，让所有相同效果的文字共用一个sharedMaterial来实现UI上批次的减少。</p><p><img src="https://picx.zhimg.com/v2-f63b1a20dd1b552332b138ca2bd54d85_r.jpg" alt="img"></p><p>要实现这个也很简单。多语言的管理和数据都是在游戏初始化的时候进行的，也就是说它会先于所有的UI逻辑完成。等到游戏内开始加载界面的时候，所有的组件和数据都已经可用。所以只需要在Text的相关组件上绑一个自定义的多语言组件，先填好语言文本的Key值，并在Awake的时候进行文本查找和赋值即可。</p><p><img src="https://pic2.zhimg.com/v2-21f27cc196c3da219bd3d0f2f450056b_1440w.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;既然TMP这么强大，有这么多好处，理所当然它也是有不足之处。目前为止，遇到两个最大头的问题，第一个是DrawCall,第二是堆内存。&lt;/p&gt;
&lt;p&gt;前面说到，TMP的所有效果都可以在编辑时态调好参数，然后存储为一个材质球。这就意味着每一种效果在运行时就会增加一个DC。比如1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/Unity%20%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/Unity%20%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</id>
    <published>2024-12-24T12:21:25.202Z</published>
    <updated>2024-12-24T12:21:25.202Z</updated>
    
    <content type="html"><![CDATA[<p>Unity 对象管理</p><p>玩家输入</p><p>Input.GetKeyDown()</p><p>创建物体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateObject</span>()</span>&#123;<br>    Transform t = Instantiatie(prefab);<br>    t.loactionPosition = Random.insideUnitSphere * <span class="hljs-number">5f</span>;<br>    t.locationRotation = Random.rotation;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为要保存这些数据，所以得拿一个数组保存</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>&#123;<br>    objects = <span class="hljs-keyword">new</span> List&lt;Transform&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateObject</span>()</span>&#123;<br>    Transform t = Instantiatie(prefab);<br>    t.loactionPosition = Random.insideUnitSphere * <span class="hljs-number">5f</span>;<br>    t.locationRotation = Random.rotation;<br>    t.localScale = Vector3.one * Random.Range(<span class="hljs-number">0.1f</span>, <span class="hljs-number">1f</span>);<br>    objects.Add(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>写入其实就是找一个文件然后写入这些transform的position，rotation和scale</p><p>这样只是保存了Transform的数据，其实可以把这个抽象成一个组件PersistableObject，然后在这里实现载入和存储的方法</p><p>然后我们要考虑不同的形状，直接造一个 形状工厂，工厂模式就是提供了一个借口，我不需要知道里面的交付细节，只需要知道我要什么然后你给我就行了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#">List&lt;Shape&gt; shapes;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>&#123;<br>    shapes = <span class="hljs-keyword">new</span> List&lt;Shape&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ShapeFactory <span class="hljs-title">shapeFactory</span>()</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> shapeId</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> Instantiate(prefabs[shapeId]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">GetRandom</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> Get(Random.Range(<span class="hljs-number">0</span>, prefabs.Length));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>销毁用Destroy</p><p>因为List是用数组来实现，所以直接删除会比较慢，可以采用直接和最后一个元素交换来实现快一点的交换、</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestoryShpae</span>()</span>&#123;<br>    <span class="hljs-keyword">if</span>(shapes.Count &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">int</span> index = Random.Range(shapes.Count);<br>        Destory(shapes[index].gameObject);<br>        <span class="hljs-built_in">int</span> lastIndex = shapes.Count - <span class="hljs-number">1</span>;<br>        shapes[index] = shapes[lastIndex];<br>        shapes.RemoveAt(lastIndex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样频繁的创建销毁很浪费内存，可以用对象池</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#">List&lt;Shape&gt;[] pools;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatePools</span>()</span>&#123;<br>    pools = <span class="hljs-keyword">new</span> List&lt;Shape&gt;[prefabs.Length];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;pools.Length;i++)&#123;<br>        poolsi<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> shapeId = <span class="hljs-number">0</span>, <span class="hljs-built_in">int</span> materialId = <span class="hljs-number">0</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(recycle)&#123;<br>        <span class="hljs-keyword">if</span>(pools == <span class="hljs-literal">null</span>)&#123;<br>            createPools();<br>        &#125;<br>        List&lt;Shape&gt; pool = pools[shapeId];<br>        <span class="hljs-keyword">in</span> lastIndex = pool.Count - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(lastIndex &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        instance = pool[lastIndex];<br>        instance.gameObject.SetActive(<span class="hljs-literal">true</span>);<br>        pool.RemoveAt(lastIndex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回收就用</p><p>pools[ShapeToRecyle.ShapeId].Add(shapeToRecyle);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity 对象管理&lt;/p&gt;
&lt;p&gt;玩家输入&lt;/p&gt;
&lt;p&gt;Input.GetKeyDown()&lt;/p&gt;
&lt;p&gt;创建物体&lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/UE%20UMG%20%E5%AD%A6%E4%B9%A0/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/UE%20UMG%20%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-12-24T12:21:25.200Z</published>
    <updated>2024-12-24T12:21:25.200Z</updated>
    
    <content type="html"><![CDATA[<p>UE UMG 学习</p><p>UE5-UMG学习笔记（更新中） - 本羊已老矣的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/566576897">https://zhuanlan.zhihu.com/p/566576897</a></p><p>【【虚幻4】UE4教程_中文_入门级_UMG篇【持续更新中~~】】 <a href="https://www.bilibili.com/video/BV1Qi4y1u7kh/?p=4&share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">https://www.bilibili.com/video/BV1Qi4y1u7kh/?p=4&amp;share_source=copy_web&amp;vd_source=5d07d04eb2516df147034367e7af6fd2</a></p><p>蓝图里面</p><p>Create UI Widget</p><p>Add to ViewPoint</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241223173414194.png" alt="image-20241223173414194"></p><p>但是要判断一下ui这个变量是否重复了，不然会很糊，重复创建</p><p>移除：Remove from parent</p><p>用flip flop可以按一下消失</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241223174410861.png" alt="image-20241223174410861"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UE UMG 学习&lt;/p&gt;
&lt;p&gt;UE5-UMG学习笔记（更新中） - 本羊已老矣的文章 - 知乎&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/566576897&quot;&gt;https://zhuanlan.zhihu.com/p/566576</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://rorschachandbat.github.io/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://rorschachandbat.github.io/%E7%AC%94%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2024-12-24T12:21:23.523Z</published>
    <updated>2024-12-24T12:21:23.523Z</updated>
    
    <content type="html"><![CDATA[<p>KMP算法</p><p><em>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;KMP算法&lt;/p&gt;
&lt;p&gt;&lt;em&gt;冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法&lt;/em&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>动作游戏的方方面面</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.850Z</updated>
    
    <content type="html"><![CDATA[<p>动作游戏系统设计</p><p>镜头选型，运动系统，输入模块，战斗能力。</p><h1 id="战斗系统？"><a href="#战斗系统？" class="headerlink" title="战斗系统？"></a>战斗系统？</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>好的攻击方式应该兼具优点和缺点，比如范围大那么久伤害低，伤害高但是攻速慢，或者需要某些特定的资源，或者具有冷却时间</p><p>攻速其实是动画的帧动画</p><p>前摇，判定和后摇</p><p>动画取消</p><p>范围：吸附的范围</p><p>不同的按键组合是不同的攻击方式，当然也可以是和位置不同而变化，比如背刺之类的。</p><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><p>一定顺序，准确时机可以打出不同的连招</p><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><p>防御或者闪避</p><p>弹反和招架：有可能过于强大，让整个游戏都变成了等待</p><p>可以增加弹反惩罚，或者限制弹反次数，或者降低弹反收益：比如只是单纯地给一点子弹时间。</p><p>当然你也要防止你的玩家完全不防御，防止让他一直压制敌人，比如给怪加体力条，体力条没了才能僵直，或者让他面对很多个怪物。</p><p>好的动作游戏，应该鼓励玩家在攻击和防守之间积极地变换。</p><h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><p>敌人的进攻应该有明显的提示，比如画面之类的。</p><p>并且最好不要设计成单一武器才能杀死的敌人 </p><p>如何鼓励玩家进攻多样而不是复读？</p><p>连击有特殊动画，或者直接设计连击分数（比如鬼泣或者猎天使魔女），还有受伤掉分</p><p>如果程序检测到玩家复读某一招，可以相对应地用表现得不一样，这些可以给玩家他适应了你的打法一样（街霸的ai也有类似的感觉，可以学习）</p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>巨大的前摇+飞速的打击动作+判定帧短暂的暂停+后摇缓慢的回复</p><p>刀光特效</p><p>震动屏幕</p><p>爽快的音效</p><h1 id="打击感-1"><a href="#打击感-1" class="headerlink" title="打击感"></a>打击感</h1><p>攻击角色击中被击角色的瞬间，游戏给玩家的反馈所形成的的体验。</p>]]></content>
    
    
    <summary type="html">总结一下一个好的动作游戏的方方面面</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua高性能编程</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h1><p>在代码运行前，Lua会把源码预编译成一种中间码，类似于Java的虚拟机。这种格式然后会通过C的解释器进行解释，整个过程其实就是通过一个while循环，里面有很多的switch…case语句，一个case对应一条指令来解析。</p><p>自Lua 5.0之后，Lua采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多250个寄存器，因为栈的长度是用8个比特表示的。</p><p>有了这么多的寄存器，Lua的预编译器能把所有的local变量储存在其中。这就使得Lua在获取local变量时其效率十分的高。</p><h2 id="使用local引用global变量"><a href="#使用local引用global变量" class="headerlink" title="使用local引用global变量"></a>使用local引用global变量</h2><p>Lua对本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">局部变量</a>的访问是一个O(1)的操作（等价于一个数组地址+偏移），而global变量的获取需要一次<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=hash%E6%9F%A5%E6%89%BE&zhida_source=entity">hash查找</a>。local比global快很多（特别是在计算比较简单时，hash查找的开销反而是大头），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=local%E5%8F%98%E9%87%8F&zhida_source=entity">local变量</a>以外，upvalue的访问也比global快很多（访问上一层upvalue，等价于一次间接跳转之后再访问上一层函数的局部变量，基本还是一个O(1)的开销），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="使用local缓存table查找结果"><a href="#使用local缓存table查找结果" class="headerlink" title="使用local缓存table查找结果"></a>使用local缓存table查找结果</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="3R原则"><a href="#3R原则" class="headerlink" title="3R原则"></a>3R原则</h1><h2 id="Reducing"><a href="#Reducing" class="headerlink" title="Reducing"></a>Reducing</h2><p>避免创建新对象和节约内存</p><h3 id="把table变成数组"><a href="#把table变成数组" class="headerlink" title="把table变成数组"></a>把table变成数组</h3><h3 id="把常量对象的创建放在循环的外面"><a href="#把常量对象的创建放在循环的外面" class="headerlink" title="把常量对象的创建放在循环的外面"></a>把常量对象的创建放在循环的外面</h3><p>xxxxxxxxxx void Awake(){    objects &#x3D; new List<Transform>();}​void CreateObject(){    Transform t &#x3D; Instantiatie(prefab);    t.loactionPosition &#x3D; Random.insideUnitSphere * 5f;    t.locationRotation &#x3D; Random.rotation;    t.localScale &#x3D; Vector3.one * Random.Range(0.1f, 1f);    objects.Add(t);}c#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125; <span class="hljs-comment">--unnecessary redeclare</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span> <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">--这里每次循环会创建一个匿名函数对象</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">local</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fun2) <span class="hljs-comment">--重用循环外定义的func2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Reusing"><a href="#Reusing" class="headerlink" title="Reusing"></a>Reusing</h2><h3 id="复用对象"><a href="#复用对象" class="headerlink" title="复用对象"></a>复用对象</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123; year = i, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;) <span class="hljs-comment">--每次循环创建一个表</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> aux = &#123; year = <span class="hljs-literal">nil</span>, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    aux.year = i <span class="hljs-comment">-- 重用循环外定义的aux</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(aux)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Recycling"><a href="#Recycling" class="headerlink" title="Recycling"></a>Recycling</h2><h3 id="避免GC对象的创建"><a href="#避免GC对象的创建" class="headerlink" title="避免GC对象的创建"></a>避免GC对象的创建</h3><p>string有intenalize管理的开销，table需要开辟内存，lua中所有的function都是闭包，创建开销也不低，此外它们都会增加gc的开销。</p><h3 id="传参时避免构造table"><a href="#传参时避免构造table" class="headerlink" title="传参时避免构造table"></a>传参时避免构造table</h3><p>参数的数量不多时，尽量用独立的变量传递参数，而非构造一个table。</p><h2 id="宿主语言接口调用"><a href="#宿主语言接口调用" class="headerlink" title="宿主语言接口调用"></a>宿主语言接口调用</h2><p>尽量在lua内部完成计算，调用宿主语言接口会带来明显的<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&zhida_source=entity">上下文切换</a>开销，如果不是一个复杂的计算过程，不值的浪费这个开销。</p><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n的整数键，其他的所有键都储存在哈希部分中。</p><p>哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。</p><p>当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。</p><h2 id="创建table时初始化数据"><a href="#创建table时初始化数据" class="headerlink" title="创建table时初始化数据"></a>创建table时初始化数据</h2><p>为了减少不必要的内存开销，table在创建时不会分配任何额外内存，早期几个元素的插入都必然导致rehash操作，这个特性对小table的创建影响特别显著，创建时一并指定初始化数据可以避免rehash的开销。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>t[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>t[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br> <br><span class="hljs-comment">-- good: 200% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="高效的遍历"><a href="#高效的遍历" class="headerlink" title="高效的遍历*"></a>高效的遍历*</h2><p>paris和iparis有函数调用的开销，因此效率不高。在性能敏感的场合，最好缓存table的size，然后使用for loop。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- pairs: 3.078 (217%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">--- ipairs: 3.344 (236%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,x do: 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,#atable do 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,atable_length do: 1.562 (110%)</span><br><span class="hljs-keyword">local</span> length = #a<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,length <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的插入"><a href="#高效的插入" class="headerlink" title="高效的插入*"></a>高效的插入*</h2><p>table.insert有函数调用的开销，因此性能不高。在性能敏感的场合，最好缓存table的size，然后指定下标赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table.insert: 1.250 (727%)</span><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    tinsert(a,i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[i]: 0.172 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[i]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[#a+1]=x: 0.453 (263%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[count++]=x: 0.203 (118%)</span><br><span class="hljs-keyword">local</span> count = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    d[count]=i<br>    count=count+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的unpack"><a href="#高效的unpack" class="headerlink" title="高效的unpack*"></a>高效的unpack*</h2><p>性能敏感的场合不要使用unpack，选择手动展开。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- with [ ]: 0.485 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>],a[<span class="hljs-number">4</span>] )<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- unpack(): 1.093 (225%)</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">unpack</span>(a) )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="array或者hash"><a href="#array或者hash" class="headerlink" title="array或者hash*"></a><a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=array&zhida_source=entity">array</a>或者hash*</h2><p>table有array和hash两部分存储，一般来讲array的存储开销要比hash小一些，访问速度也比hash查找要快，可能的话尽量选array。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 使用hash，内存开销最大 400%</span><br>polyline = &#123;<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">18.3</span>&#125;,<br>  &#123;x= <span class="hljs-number">15.0</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>&#125;  <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 使用数组，内存开销降低 250%</span><br>polyline = &#123;<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">98.5</span> &#125;,<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">18.3</span> &#125;,<br>  &#123; <span class="hljs-number">15.0</span>, <span class="hljs-number">98.5</span> &#125;,<br>  ...<br>&#125; <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 还可以进一步减少table本身的内存开销，只3个table 100%</span><br>polyline = &#123;<br>  x = &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">10.3</span>, <span class="hljs-number">15.0</span>, ... &#125;,<br>  y = &#123; <span class="hljs-number">98.5</span>, <span class="hljs-number">18.3</span>, <span class="hljs-number">98.5</span>, ... &#125;<br>&#125; <span class="hljs-comment">--(tables used: 3)</span><br></code></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。</p><p>所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为Lua需要去查找比较一遍。</p><p>第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变得十分高效。例如在Perl中，$x &#x3D; $y，会将$y的buffer整个的复制到$x的buffer中，当字符串很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。</p><p>但是只保存引用会降低在字符串连接时的速度。在Perl中，$s &#x3D; $s . ‘x’和$s .&#x3D; ‘x’的效率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插入到$x的buffer末尾。</p><p>由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。</p><h2 id="缓存字符串"><a href="#缓存字符串" class="headerlink" title="缓存字符串"></a>缓存字符串</h2><p>避免在运行时构造字符串，尽量缓存那些常量字符串。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>大字符串的拼接，使用table.concat。</p><p>在lua中可以用table来模拟buffer</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">30000</span> <span class="hljs-keyword">do</span><br>    t[#t+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">end</span><br>s = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="语言之外的东西"><a href="#语言之外的东西" class="headerlink" title="语言之外的东西"></a>语言之外的东西</h1><p>使用<a href="http://luajit.org/">LuaJIT</a>，LuaJIT可以使你在不修改代码的情况下获得平均约5倍的加速。查看LuaJIT在<a href="http://luajit.org/performance_x86.html">x86&#x2F;x64下的性能提升比</a>。</p><p>第二、将瓶颈部分用C&#x2F;C++来写。因为Lua和C的天生近亲关系，使得Lua和C可以混合编程。但是C和Lua之间的通讯会抵消掉一部分C带来的优势。</p>]]></content>
    
    
    <summary type="html">关于如何写Lua高性能编程的一些建议</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于蓝图的多人游戏玩法设计</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.662Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18Y41187vo/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2021]与众乐乐 - 基于蓝图的多人游戏玩法设计 | Epic Games 何骞</a> </p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221120244763.png" alt="image-20241221120244763"></p><p>复制Replication</p>]]></content>
    
    
    <summary type="html">一个关于如何用蓝图开发多人游戏的演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>UE蓝图开发最佳实践</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.774Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1oG411M7Y6/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2022]蓝图开发最佳实践 | Epic 何骞</a> </p><h1 id="命名相关"><a href="#命名相关" class="headerlink" title="命名相关"></a>命名相关</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000001964.png" alt="image-20241221000001964"></p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000142710.png" alt="image-20241221000142710"></p><p>减少冗余信息</p><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000236767.png" alt="image-20241221000236767"></p><h1 id="蓝图如何保持整洁"><a href="#蓝图如何保持整洁" class="headerlink" title="蓝图如何保持整洁"></a>蓝图如何保持整洁</h1><h2 id="避免过长的蓝图逻辑，屏幕长度有限"><a href="#避免过长的蓝图逻辑，屏幕长度有限" class="headerlink" title="避免过长的蓝图逻辑，屏幕长度有限"></a>避免过长的蓝图逻辑，屏幕长度有限</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000410021.png" alt="image-20241221000410021"></p><h2 id="事件左对齐"><a href="#事件左对齐" class="headerlink" title="事件左对齐"></a>事件左对齐</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000501706.png" alt="image-20241221000501706"></p><p>保证更改逻辑的时候不会改错</p><h2 id="通过Re-route来减少连线"><a href="#通过Re-route来减少连线" class="headerlink" title="通过Re-route来减少连线"></a>通过Re-route来减少连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000527244.png" alt="image-20241221000527244"></p><h2 id="避免错乱事件连线"><a href="#避免错乱事件连线" class="headerlink" title="避免错乱事件连线"></a>避免错乱事件连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000700985.png" alt="image-20241221000700985"></p><p>不要想到一个事件就立马create出来</p><h2 id="重用Getter或者Pure节点"><a href="#重用Getter或者Pure节点" class="headerlink" title="重用Getter或者Pure节点"></a>重用Getter或者Pure节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000813646.png" alt="image-20241221000813646"></p><h2 id="清晰的返回节点"><a href="#清晰的返回节点" class="headerlink" title="清晰的返回节点"></a>清晰的返回节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000841491.png" alt="image-20241221000841491"></p><p>越复杂的函数为什么return，为什么early return需要写清楚</p><h2 id="Select节点"><a href="#Select节点" class="headerlink" title="Select节点"></a>Select节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000918576.png" alt="image-20241221000918576"></p><p>Text替代String</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000954247.png" alt="image-20241221000954247"></p><h1 id="蓝图注释规则"><a href="#蓝图注释规则" class="headerlink" title="蓝图注释规则"></a>蓝图注释规则</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001053596.png" alt="image-20241221001053596"></p><h2 id="分不同的颜色，规则不一样"><a href="#分不同的颜色，规则不一样" class="headerlink" title="分不同的颜色，规则不一样"></a>分不同的颜色，规则不一样</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001141232.png" alt="image-20241221001141232"></p><h2 id="注释的细节"><a href="#注释的细节" class="headerlink" title="注释的细节"></a>注释的细节</h2><p><strong>每个事件都编写注释</strong></p><p><strong>Sequence的每一段都写注释</strong></p><p>把长的拆分成sequence也可以做</p><p><strong>为复杂的逻辑写注释</strong></p><p><strong>为复杂的函数返回写注释</strong></p><h1 id="如何创建稳固更新的生产线？"><a href="#如何创建稳固更新的生产线？" class="headerlink" title="如何创建稳固更新的生产线？"></a>如何创建稳固更新的生产线？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001347062.png" alt="image-20241221001347062"></p><p>不是一开始就设计好，而是在项目进行到一定阶段在解耦。</p><p>不要复制黏贴，而是作为抽离成function</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>每次冷启动，可以通过log（Unreal Inside）来观察哪里加载的久。</p><p>以及每次添加新节点的时间</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>减少不必要的Cast，特别是复杂蓝图类的cast</strong>。</p><p><strong>用Gameplay Tag和blueprint Interface</strong></p><p><strong>活用命名空间</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002004041.png" alt="image-20241221002004041"></p><p>可以规定某个蓝图这是哪种玩法会用到的，这样就可以减少加载</p><p><strong>减少Hard Reference</strong></p><p>因为每个hard Reference都会加载在内存里面，会影响包体大小，考虑用Tag或者Soft Reference来替换</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002514037.png" alt="image-20241221002514037"></p><p>一个比较好的方式是，脚本语言不去改蓝图function的实现，然后划分好哪些变量会修改，这样也可以作为一个新的category来分类</p><h2 id="蓝图审核"><a href="#蓝图审核" class="headerlink" title="蓝图审核"></a>蓝图审核</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002854518.png" alt="image-20241221002854518"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002937518.png" alt="image-20241221002937518"></p><p>可以持续更新一个Best Practice文档</p><h1 id="编辑器拓展"><a href="#编辑器拓展" class="headerlink" title="编辑器拓展"></a>编辑器拓展</h1><p>Assest Action Utility（这里没太听懂，到时候学习一下）</p><h1 id="如何平衡蓝图和C-？"><a href="#如何平衡蓝图和C-？" class="headerlink" title="如何平衡蓝图和C++？"></a>如何平衡蓝图和C++？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221003705495.png" alt="image-20241221003705495"></p><p><strong>不用过早优化</strong></p><p>因为变化可能很快</p><p><strong>有安全性问题的时候可以考虑转</strong></p><p>比如拿的很多信息不是在本地，而是要通过服务器来request，这种可能放在C++核心类比较好</p><p><strong>直接重定向</strong></p><p>在C++里面写一个<strong>MigrateProperty</strong>这样一个函数，可以把哪些变量，CDO准确的转化过来</p>]]></content>
    
    
    <summary type="html">一个关于如何有效率地编写蓝图演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-垃圾回收</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2024-12-17T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>也是采用标记清除的方式，会从根出发，标记所有</p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，主要分为以下几步：</p><ul><li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；</li><li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。</li><li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。</li></ul><p>堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。</p><h2 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h2><p>当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ul><li>GC会检查堆内存上的每个存储变量；</li><li>对每个变量会检测其引用是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为可回收；</li><li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li></ul><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h2 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h2><p>主要有三个操作会触发垃圾回收：</p><ul><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ul><h2 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a><strong>降低GC的影响的方法</strong></h2><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>基于此，我们可以采用三种策略：</p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。</li><li>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响</li></ul><h2 id="降低GC的具体方法"><a href="#降低GC的具体方法" class="headerlink" title="降低GC的具体方法"></a>降低GC的具体方法</h2><h3 id="减少内存垃圾"><a href="#减少内存垃圾" class="headerlink" title="减少内存垃圾"></a>减少内存垃圾</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>比如循环不要每次都创建新的数组，而是提前创建好</p><h4 id="不要在频分调用的函数里面使用堆内存分配"><a href="#不要在频分调用的函数里面使用堆内存分配" class="headerlink" title="不要在频分调用的函数里面使用堆内存分配"></a>不要在频分调用的函数里面使用堆内存分配</h4><p>比如tick和update里面不要分配内存，而是在之前就创建好，或者通过定时器或者脏标记的方法来改进</p><h4 id="减少链表"><a href="#减少链表" class="headerlink" title="减少链表"></a>减少链表</h4><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>减少内存的释放和创建次数</p><h3 id="造成不必要内存的分配的情况"><a href="#造成不必要内存的分配的情况" class="headerlink" title="造成不必要内存的分配的情况"></a>造成不必要内存的分配的情况</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在c#里面字符串不是值类型而是引用，而且值无法改变，所以改变值会直接创建一个新的值</p><p>　1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p><p>　　2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。</p><p>　　3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>比如说迭代器会产生新的数组（可以通过缓存来解决），调用GameObject.name 或者 GameObject.tag也会有内存垃圾，因为会犯乎一个字符串</p><h4 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h4><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。最好避免。</p><p>比如这种</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> cost = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">string</span> displayString = String.Format(<span class="hljs-string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost);<br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>6.5之前的版本会因为迭代器有内存垃圾</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>比如把对象里面的string拆出来，这样就不用频繁地在GC里面类型检查</p><h3 id="定时执行GC"><a href="#定时执行GC" class="headerlink" title="定时执行GC"></a>定时执行GC</h3><p>比如过场的时候主动调用GC操作</p><h1 id="UE"><a href="#UE" class="headerlink" title="UE"></a>UE</h1><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p><a href="https://zhuanlan.zhihu.com/p/133939450">Lua GC机制分析与理解-上 - 小破孩不会编程序的文章 - 知乎</a></p><h2 id="gc的思想"><a href="#gc的思想" class="headerlink" title="gc的思想"></a>gc的思想</h2><p>会遍历所有对象，标记颜色，那些不可达的就是需要gc的对象，又分为双色和三色，双色就是不能中断，三色可以中断，但是实现复杂，</p><h2 id="何时会触发gc？"><a href="#何时会触发gc？" class="headerlink" title="何时会触发gc？"></a>何时会触发gc？</h2><p>分为两种，一种是自动触发</p><p>在以下代码中，使用 luaC_checkGC 检查 gc 阈值 GCdebt ，当 GCdebt 大于0 时，执行 gc<br>1、创建新数据时 string, thread, userdata, table, closure<br>3、语法解析时<br>4、错误发生时<br>5、字符串拼接时 concat<br>6、栈增长时</p><p>一种是手动触发</p><p>使用 lua API：<br>collectgarbage “step”<br>collectgarbage “collect”</p><h2 id="lua-怎么判定数据可达？"><a href="#lua-怎么判定数据可达？" class="headerlink" title="lua 怎么判定数据可达？"></a>lua 怎么判定数据可达？</h2><p>从 GC根集合（root set） 可访问的对象：<br>gc root set包含三部分：<br>1、主协程 g-&gt;mainthread，其栈记录了当前用到的所有对象<br>2、注册表 g-&gt;l_registry，包含了全局table(_G)，记录了全局变量和全局模块，还包括已加载的模块表 package.loaded<br>3、全局元表 g-&gt;mt，每种数据类型各一个，预留9个，暂时只有table和string的实现，效果如io模块的f:read()和 string模块的s:len()</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>程序是无法推断哪些东西是需要回收的，比如说在数组里的元素，虽然我们不用他了，但是数组还在引用，那么lua就无法自动回收它，这时候就需要弱引用表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p><p>1、导致引用计数+1的情况</p><p>对象被创建，例如a&#x3D;23</p><p>对象被引用，例如b&#x3D;a</p><p>对象被作为参数，传入到一个函数中，例如func(a)</p><p>对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>2、导致引用计数-1的情况</p><p>对象的别名被显式销毁，例如del a</p><p>对象的别名被赋予新的对象，例如a&#x3D;24</p><p>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</p><p>对象所在的容器被销毁，或从容器中删除对象</p><h2 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h2><p>针对循环引用这个问题，比如有两个对象互相引用了对方，当外界没有对他们有任何引用，也就是说他们各自的引用计数都只有1的时候，如果可以识别出这个循环引用，把它们属于循环的计数减掉的话，就可以看到他们的真实引用计数了。基于这样一种考虑，有一种方法，比如从对象A出发，沿着引用寻找到对象B，把对象B的引用计数减去1；然后沿着B对A的引用回到A，把A的引用计数减1，这样就可以把这层循环引用关系给去掉了。</p><p>不过这么做还有一个考虑不周的地方。假如A对B的引用是单向的， 在到达B之前我不知道B是否也引用了A，这样子先给B减1的话就会使得B称为不可达的对象了。为了解决这个问题，python中常常把内存块一分为二，将一部分用于保存真的引用计数，另一部分拿来做为一个引用计数的副本，在这个副本上做一些实验。比如在副本中维护两张链表，一张里面放不可被回收的对象合集，另一张里面放被标记为可以被回收（计数经过上面所说的操作减为0）的对象，然后再到后者中找一些被前者表中一些对象直接或间接单向引用的对象，把这些移动到前面的表里面。这样就可以让不应该被回收的对象不会被回收，应该被回收的对象都被回收了。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h2><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环境的编程中，对于变量在内存中的创建&#x2F;销毁，总有频繁和不那么频繁的。比如任何程序中总有生命周期是全局的、部分的变量。<br>Python将所有的对象分为0，1，2三代；<br>所有的新建对象都是0代对象；<br>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p><p>他们gc的频率不同，这样可以提高性能</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - allen的文章 - 知乎</a></p><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p>]]></content>
    
    
    <summary type="html">垃圾回收可能会问到的一切东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-CAD知识</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-CAD%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-CAD%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2024-12-13T06:52:30.574Z</updated>
    
    <content type="html"><![CDATA[<p>STEP标准</p><p>工业产品几何定义</p>]]></content>
    
    
    <summary type="html">CAD知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-UE相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE最基础的五个类是什么"><a href="#UE最基础的五个类是什么" class="headerlink" title="UE最基础的五个类是什么"></a>UE最基础的五个类是什么</h1><ol><li>GameMode是整个关卡的控制器，用来编写整个关卡的<a href="https://zhida.zhihu.com/search?content_id=212792905&content_type=Article&match_order=1&q=%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&zhida_source=entity">业务逻辑</a>；</li><li>GameState是整个关卡的状态，用来存储整个关卡的游戏数据；</li><li>DefaultPawn是玩家角色，若是角色扮演类游戏则就是在游戏场景中看到的角色实体；</li><li>PlayerController是玩家的控制器，用来编写和玩家相关的控制逻辑；</li><li>PlayerState是玩家的状态，用来存储和玩家相关的状态数据。</li></ol><h1 id="FName和FString"><a href="#FName和FString" class="headerlink" title="FName和FString"></a>FName和FString</h1><p>① <strong>FName：</strong>着重于表示<strong>名称</strong>，<strong>不区分大小写</strong>，<strong>不可更改</strong>，引擎中的资源名称都是FName类型，通过一个轻型系统重复使用字符串，FName创建时会根据内容创建一个<a href="https://zhida.zhihu.com/search?content_id=178876897&content_type=Article&match_order=1&q=Hash%E5%80%BC&zhida_source=entity">Hash值</a>，且同样的内容只会存储一次。通过Hash值在进行FName的查找和访问时速度较快，而在比较的时，也不需要比较字符串内容，直接比较Hash值来区分不同FName字符串。</p><p>另外两种字符串<strong>到FName的转换</strong>（特别注意的是，<strong>FText不能直接转换到FName</strong>，可<strong>先转换为FString</strong>，再转换为FName）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br> <br><span class="hljs-comment">// FString 转 FName：不可靠，丢失大小写信息</span><br>FName name1 = <span class="hljs-built_in">FName</span>(*str);<br><br>FString strFromTxt = txt.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 先转 FString，再转 FName：不可靠，丢失大小写信息，丢失本地化信息可能导致语言转换的潜在风险</span><br>FName name2 = <span class="hljs-built_in">FName</span>(*strFromTxt);<br></code></pre></td></tr></table></figure><p>② <strong>FString：</strong>最接近std::string，着重在于<strong>字符串的操作</strong>，提供了大量对字符串的操作接口，是<strong>三者中唯一可修改的字符串类型</strong>，也正因如此，FString对比其它两种字符串来说<strong>消耗更高</strong>，<strong>性能更低</strong>。</p><p>另外两种字符串<strong>到FString的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br><br><span class="hljs-comment">// FName 转 FString：可靠</span><br>FString str1 = name.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 转 FString：不可靠，丢失本地化信息可能导致语言转换的潜在风险</span><br>FString str2 = txt.<span class="hljs-built_in">ToString</span>();<br></code></pre></td></tr></table></figure><p>③ <strong>FText：</strong>着重在于<strong>显示与本地化</strong>，显示可理解玩家能直接看到的信息，本地化即多语言的处理，<strong>不可更改</strong>。相较于另外两种类型，FText会更加的臃肿，但提供了优秀的本地化功能。</p><p>另外两种字符串<strong>到FText的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br><br><span class="hljs-comment">// FString 转 FText：可靠</span><br>FText txt1 = FText::<span class="hljs-built_in">FromString</span>(str);<br><span class="hljs-comment">// FName 转 FText：可靠</span><br>FText txt2 = FText::<span class="hljs-built_in">FromName</span>(name);<br></code></pre></td></tr></table></figure><h1 id="软引用和硬引用"><a href="#软引用和硬引用" class="headerlink" title="软引用和硬引用"></a>软引用和硬引用</h1><p>加载的步骤</p><h1 id="Actor如何实现一个借口类"><a href="#Actor如何实现一个借口类" class="headerlink" title="Actor如何实现一个借口类?"></a>Actor如何实现一个借口类?</h1><h1 id="UE4反射机制"><a href="#UE4反射机制" class="headerlink" title="UE4反射机制"></a>UE4反射机制</h1><p>UHT</p><p><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a></p><p><a href="https://blog.csdn.net/duan19920101/article/details/127557454">C++反射机制</a></p><h1 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zhuanlan.zhihu.com/p/149392857">UFUNCTION&#x2F;UPROPERTY&#x2F;UCLASS</a></p><p> 反射系统是可以选择加入的。你需要给暴露给反射系统的类型或属性添加注解，这样Unreal Header Tool (UHT)就会在编译工程的时候利用那些信息生成特定的代码。</p><p><strong>标记</strong></p><p>为了标记一个头文件包含反射类型，需要在文件顶部添加一个特殊的include文件。该文件必须放在#include的最后，这让UHT知道它需要考虑这个文件，并且在反射系统的实现里也是需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileName.generated.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>你现在可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()来在头文件中注解不同的类型以及成员变量。每一个宏都会出现在类型或者成员变量的前面，并且可以包含额外的修饰符关键字。</p><p>C++是没法直接通过函数名来调用的，因为存的都是地址，但是在蓝图里面可以，这就用到了反射机制</p><h2 id="常用的有哪些"><a href="#常用的有哪些" class="headerlink" title="常用的有哪些"></a>常用的有哪些</h2><p><a href="https://blog.csdn.net/ttod/article/details/136396379">简述UE中的UFUNCTION宏和UPROPERTY宏常用属性</a></p><p>UFunction</p><table><thead><tr><th><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></th><th>在蓝图编辑工具中显示时指定函数的类别。使用 | 运算符定义嵌套类别。</th></tr></thead><tbody><tr><td><code>Client</code></td><td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>CustomThunk</code></td><td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td></tr><tr><td><code>Exec</code></td><td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td></tr><tr><td><code>NetMulticast</code></td><td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td></tr><tr><td><code>Reliable</code></td><td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>SealedEvent</code></td><td>无法在子类中覆盖此函数。<code>SealedEvent</code>关键词只能用于事件。对于非事件函数，请将它们声明为<code>static</code>或<code>final</code>，以密封它们。</td></tr><tr><td><code>ServiceRequest</code></td><td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>ServiceResponse</code></td><td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>Server</code></td><td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>Unreliable</code></td><td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>WithValidation</code></td><td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td></tr></tbody></table><p>UProperty</p><table><thead><tr><th><code>AdvancedDisplay</code></th><th>属性将被放置在其出现的任意面板的高级（下拉）部分中。</th></tr></thead><tbody><tr><td><code>AssetRegistrySearchable</code></td><td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td></tr><tr><td><code>BlueprintAssignable</code></td><td>只能与组播委托共用。公开属性在蓝图中指定。</td></tr><tr><td><code>BlueprintAuthorityOnly</code></td><td>此属性必须为一个组播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td></tr><tr><td><code>BlueprintCallable</code></td><td>仅用于组播委托。应公开属性在蓝图代码中调用。</td></tr><tr><td><code>BlueprintGetter=GetterFunctionName</code></td><td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>BlueprintReadOnly</code></td><td>此属性可由蓝图读取，但不能被修改。此说明符与 <code>BlueprintReadWrite</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintReadWrite</code></td><td>可从蓝图读取或写入此属性。此说明符与 <code>BlueprintReadOnly</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintSetter=SetterFunctionName</code></td><td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td></tr><tr><td><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></td><td>指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td></tr><tr><td><code>Config</code></td><td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>DuplicateTransient</code></td><td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td></tr><tr><td><code>EditAnywhere</code></td><td>说明此属性可通过属性窗口在原型和实例上进行编辑。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditDefaultsOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditFixedSize</code></td><td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td></tr><tr><td><code>EditInline</code></td><td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td></tr><tr><td><code>EditInstanceOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>Export</code></td><td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td></tr><tr><td><code>GlobalConfig</code></td><td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>Instanced</code></td><td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td></tr><tr><td><code>Interp</code></td><td>说明值可随时间由Sequencer中的一个轨道驱动。</td></tr><tr><td><code>Localized</code></td><td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td></tr><tr><td><code>Native</code></td><td>属性为本地：C++代码负责对其进行序列化并公开到<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-object-handling?application_version=4.27#garbagecollection">垃圾回收</a>。</td></tr><tr><td><code>NoClear</code></td><td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td></tr><tr><td><code>NoExport</code></td><td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td></tr><tr><td><code>NonPIEDuplicateTransient</code></td><td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td></tr><tr><td><code>NonTransactional</code></td><td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td></tr><tr><td><code>NotReplicated</code></td><td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td></tr><tr><td><code>Replicated</code></td><td>属性应随网络进行复制。</td></tr><tr><td><code>ReplicatedUsing=FunctionName</code></td><td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td></tr><tr><td><code>RepRetry</code></td><td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td></tr><tr><td><code>SaveGame</code></td><td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td></tr><tr><td><code>SerializeText</code></td><td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td></tr><tr><td><code>SkipSerialization</code></td><td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>SimpleDisplay</code></td><td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开“高级”部分即可见。</td></tr><tr><td><code>TextExportTransient</code></td><td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>Transient</code></td><td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td></tr><tr><td><code>VisibleAnywhere</code></td><td>说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</td></tr><tr><td><code>VisibleDefaultsOnly</code></td><td>说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr><tr><td><code>VisibleInstanceOnly</code></td><td>说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr></tbody></table><h1 id="PUERTS"><a href="#PUERTS" class="headerlink" title="PUERTS"></a>PUERTS</h1><h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h1 id="ts和js有什么区别"><a href="#ts和js有什么区别" class="headerlink" title="ts和js有什么区别"></a>ts和js有什么区别</h1><h1 id="函数压栈的过程"><a href="#函数压栈的过程" class="headerlink" title="函数压栈的过程"></a>函数压栈的过程</h1><h1 id="四元数和欧拉角"><a href="#四元数和欧拉角" class="headerlink" title="四元数和欧拉角"></a>四元数和欧拉角</h1><h1 id="如何判断在凸多边形的内部还是外部"><a href="#如何判断在凸多边形的内部还是外部" class="headerlink" title="如何判断在凸多边形的内部还是外部"></a>如何判断在凸多边形的内部还是外部</h1><h1 id="如何做一个反弹的手榴弹"><a href="#如何做一个反弹的手榴弹" class="headerlink" title="如何做一个反弹的手榴弹"></a>如何做一个反弹的手榴弹</h1><p>成就系统怎么做</p><p>光照与阴影</p><p>材质系统</p><p>特效</p><p>动画系统</p><h1 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h1><p><a href="https://zhuanlan.zhihu.com/p/434028533">【UE5】给Landscape加一点料-地形篇（零）-前前言 - 徐凯鸣的文章 - 知乎</a></p><p><a href="https://www.youtube.com/watch?v=MRNFcywkUSA&list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3&index=3">Procedural Landmass Generation Youtube</a></p><p>地形编辑</p><p>Houdini</p><h1 id="自定义编辑器FAssetEditorToolkit"><a href="#自定义编辑器FAssetEditorToolkit" class="headerlink" title="自定义编辑器FAssetEditorToolkit"></a>自定义编辑器FAssetEditorToolkit</h1><h3 id="3-1-InitCustomAssetEditor方法："><a href="#3-1-InitCustomAssetEditor方法：" class="headerlink" title="3.1 InitCustomAssetEditor方法："></a><strong>3.1 InitCustomAssetEditor方法：</strong></h3><p>在此方法中，主要分为两个内容：<br><strong>① 初始化编辑器布局，可以使用以下步骤：</strong></p><ol><li>通过创建适当类的实例并设置其属性来定义自定义 FLayout、菜单和工具栏。</li><li>自定义 Slate 窗口现在将绑定到 TabManager，并使用自定义 FLayout、菜单和工具栏显示资产编辑器。</li></ol><p><strong>② 调用父类方法InitAssetEditor将自定义 Slate 窗口绑定到 TabManager。</strong></p><h3 id="3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法："><a href="#3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法：" class="headerlink" title="3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法："></a>3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法：</h3><p>+ 我们首先需要知道，Tab(SDockTab)是引擎定义的一个控件类，每一个Tab都是可以被关闭或打开的SWidget.Tab类型的窗口右上角包含一个关闭按钮。窗口内则可以包含自定义显示的各种Slate内容。</p><p>+ 我们打开编辑器时，就会根据Layout布局加载对应的Tab控件，并显示其中的内容，即Tab装入的子控件(Child Slate)。</p><p>+ 在此方法中，最重要的是调用TabManager对象，TabManager类主要用于管理编辑器中的布局，创建Tab对象。在类中我们需要定义一个FName类型的TabID变量，用于在该方法中指示一个Slate窗口。我们需要通过调用TabManager的方法RegisterTabSpawner绑定TabID和Slate，用于后续定义Slate控件的显示。</p><h3 id="3-3-SpawnTab-CustomWidget方法"><a href="#3-3-SpawnTab-CustomWidget方法" class="headerlink" title="3.3 SpawnTab_CustomWidget方法"></a>3.3 SpawnTab_CustomWidget方法</h3><p>在此方法中，将会创建并返回一个SWidget实例。<br>而RegistorTabSpawner方法通过调用TabManager的接口，将该Slate控件实例注册，与TabID进行绑定，并能够在InitCustomAssetEditor方法中添加到布局Flayout中被显示出来。<br>我们不仅可以创建简单的Slate控件（如SButton、IDetailsViews）,也可以创建较为复杂的窗口，如SEditorViewport(3D预览窗口)、SGraphEditor(可以连接复杂自定义的节点<a href="https://zhida.zhihu.com/search?content_id=222180537&content_type=Article&match_order=1&q=%E5%9B%BE%E8%A1%A8%E7%B3%BB%E7%BB%9F&zhida_source=entity">图表系统</a>)等内容，并将其添加到我们的自定义编辑器中。<br>在本文实例中，我在该方法中创建了一个最简单的Slate类SButton。</p><h1 id="模拟云"><a href="#模拟云" class="headerlink" title="模拟云"></a>模拟云</h1><p>Worley Noise</p><p>在空间中随机随便放点，然后计算最近的点的距离，为了连续，把这个的点放八个地方</p><h1 id="虚幻渲染编程"><a href="#虚幻渲染编程" class="headerlink" title="虚幻渲染编程"></a>虚幻渲染编程</h1><p><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻4渲染编程专题概述及目录 - YivanLee的文章 - 知乎</a></p><h1 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h1><p><a href="https://zhuanlan.zhihu.com/p/486808688">【Unreal】虚幻GAS系统快速入门 - LunarMaxim的文章 - 知乎</a></p><p><a href="https://github.com/DriedMachine/GASDocumentation5.3_CN">GAS Document中文翻译</a></p><h2 id="包括什么东西"><a href="#包括什么东西" class="headerlink" title="包括什么东西"></a>包括什么东西</h2><p>GAS主要包含以下内容：</p><ul><li>Who:ASC(Ability System Component) 主要组件，由C++编写，代码里有很多方法是蓝图未实现的。</li><li>How:GA(Gameplay Abilities) 角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI</li><li>What:AS(Attribute Set) 角色身上<strong>可以用float表示的属性</strong>，如生命值、体力值、魔力值等，有BaseValue和CurrentValue，方便回滚</li><li>Change:GE(Gameplay Effects) 用于<strong>修改属性</strong>，如增加50移动速度10s；还能配合GA实现更多玩法</li><li>Visual:GC(Gameplay Cues) 播放特效、音效等</li><li>If:Tag:用来分类，底层是FName，用.来分隔</li><li>Async：Task：如果想要异步的做一些东西，比如做完技能播一个蒙太奇，可以用这个来搞</li><li>Send：Event:ASC之间通信</li></ul><h2 id="做冷却"><a href="#做冷却" class="headerlink" title="做冷却"></a>做冷却</h2><p>角色在启动的时候可以保存一个specAbility，然后拿一个他的handle。</p><p>比如我想实现一个技能的冷却，其实就是做一个GE，然后这个GE启动的时候挂上在人物身上挂一个cooldown的tag，这个tag是有一个duration的，然后释放技能的时候加一个条件，有这个tag的时候无法释放，在ASC上面有一个Activation Blocked Tags，在里面加上刚刚搞的那个tag</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://zhuanlan.zhihu.com/p/463272214">【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南 - 水曜日鸡的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/38881269">《Exploring in UE4》多线程机制详解[原理分析] - Jerish的文章 - 知乎</a></p><h2 id="FRunnable"><a href="#FRunnable" class="headerlink" title="FRunnable"></a>FRunnable</h2><p>创建一个继承自FRunnable的类，把这个类要执行的任务分发给其他线程去执行。</p><p><img src="https://picx.zhimg.com/v2-21dde7f72b7b87f9133b60ab9190e5b5_r.jpg" alt="img"></p><h2 id="AsyncTask系统"><a href="#AsyncTask系统" class="headerlink" title="AsyncTask系统"></a>AsyncTask系统</h2><h2 id="TaskGraph系统"><a href="#TaskGraph系统" class="headerlink" title="TaskGraph系统"></a>TaskGraph系统</h2><p>Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个<a href="https://zhida.zhihu.com/search?content_id=7702163&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&zhida_source=entity">多线程任务</a>，指定各个任务之间的依赖关系，按照该关系来依次处理任务。具体的实现方式网上也有很多案例，这里先给出UE4Wiki的教程链接：</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>《Exploring in UE4》关于网络同步的理解与思考[概念理解] - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34721113">https://zhuanlan.zhihu.com/p/34721113</a></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>要将一个函数声明为 RPC，您只需将 <code>Server</code>、<code>Client</code> 或 <code>NetMulticast</code> 关键字添加到 <code>UFUNCTION</code> 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UFUNCTION</span>( Client )<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientRPCFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>《Exploring in UE4》RootMotion详解【原理分析】 - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/74554876">https://zhuanlan.zhihu.com/p/74554876</a></p><h1 id="DS-专用服务器"><a href="#DS-专用服务器" class="headerlink" title="DS 专用服务器"></a>DS 专用服务器</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/networking-overview-for-unreal-engine#%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">网络概述官方文档</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://www.bilibili.com/video/BV1mP4y1R7UR/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【[UOD2022]虚幻DS的机遇与挑战 | 晶核 刘豪</a> </p><p>NetworkPrediction</p><h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241220222047918.png" alt="image-20241220222047918"></p><p>等级低只同步自己</p><p>把宠物，npc全放在逻辑服，不用同步</p><p>大世界网格小，副本网格范围大</p><p>摄像机背后的actor同步频率低</p><p>不移动的时候降低同步频率</p><p>把不需要同步的属性清理掉。</p><p>使用pushModel，手动标记哪些属性需要更新，这样就不需要同步所有的信息</p><h3 id="物理计算优化"><a href="#物理计算优化" class="headerlink" title="物理计算优化"></a>物理计算优化</h3><p>服务器剔除角色身上所有的装饰器组件</p><p>服务器关闭动画计算，只有业务需要具体坐标时才计算。</p>]]></content>
    
    
    <summary type="html">UE知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>试玩的一些推箱子游戏记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/</id>
    <published>2024-12-12T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.887Z</updated>
    
    <content type="html"><![CDATA[<p>记录试玩的一些推箱子的idea，希望自己以后也能做出这种puzzle</p><h1 id="箱子联动"><a href="#箱子联动" class="headerlink" title="箱子联动"></a>箱子联动</h1><p>两个双重箱子会联动，并且推墙也会联动</p><p><a href="https://moonsoup.itch.io/sea-snake-safari">https://moonsoup.itch.io/sea-snake-safari</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121116554.png" alt="image-20241117121116554"></p><h1 id="组合箱子"><a href="#组合箱子" class="headerlink" title="组合箱子"></a>组合箱子</h1><p>需要通过拼接箱子的四个边来解谜，而且还能进入箱子里面来实现一些很有意思的操作</p><p><a href="https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09">https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121232954.png" alt="image-20241117121232954"></p><h1 id="推箱子点亮房间"><a href="#推箱子点亮房间" class="headerlink" title="推箱子点亮房间"></a>推箱子点亮房间</h1><p><a href="https://theconspiracy.itch.io/single-screen-scream">https://theconspiracy.itch.io/single-screen-scream</a></p><p>是一个迷宫类的游戏，把箱子推到对应的上面会点亮某个房间的地图，你需要自己画一下这个地图的结构，并且来搞</p><p>代码点评：他的代码太粗暴，每一个level都写了对应的操作，或许这个不太适合用这个编辑器来做，直接用引擎来写会更加简洁，不过创意不错</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121317837.png" alt="image-20241117121317837"></p><h1 id="改变关卡然后再推箱子"><a href="#改变关卡然后再推箱子" class="headerlink" title="改变关卡然后再推箱子"></a>改变关卡然后再推箱子</h1><h2 id="任意的位置"><a href="#任意的位置" class="headerlink" title="任意的位置"></a>任意的位置</h2><p><a href="https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3">https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3</a></p><p>需要先规定步数把关卡的墙壁消除，然后再推箱子，这个引擎竟然还可以这样有先后顺序，非常神奇啊，等等研究一下是怎么搞的， 相当牛逼啊</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117124647189.png" alt="image-20241117124647189"></p><h2 id="变身成铲子来改变，位置是有限的"><a href="#变身成铲子来改变，位置是有限的" class="headerlink" title="变身成铲子来改变，位置是有限的"></a>变身成铲子来改变，位置是有限的</h2><p><a href="https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea">https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea</a></p><p>这个需要捡起铲子来改变地形，会有不同，和自由的不太一样，设计思路也不太一样</p><p>他这个代码也很简单，因为他的规则集很统一，写的很好这个代码，三百行就搞定了</p><p>还讲了个小故事，不赖</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118232458914.png" alt="image-20241118232458914"></p><h2 id="场景中的物体也可以自己编辑"><a href="#场景中的物体也可以自己编辑" class="headerlink" title="场景中的物体也可以自己编辑"></a>场景中的物体也可以自己编辑</h2><p><a href="https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0">https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0</a></p><p>比如这一关是如何把这个小点搞出来</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118235755770.png" alt="image-20241118235755770"></p><h2 id="推箱子本身会改变路"><a href="#推箱子本身会改变路" class="headerlink" title="推箱子本身会改变路"></a>推箱子本身会改变路</h2><p><a href="https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab">https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab</a></p><p>箱子本身是一条以自身为中心的十字路，推箱子会改变主人公能走的位置，要通过这个推完成目标</p><p>关卡有点少，只有四关</p><p>一边推一边思考路的过程还是挺有趣的，要考虑的东西有点意思</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085156436.png" alt="image-20241119085156436"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119083807340.png" alt="image-20241119083807340"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084051277.png" alt="image-20241119084051277"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084505536.png" alt="image-20241119084505536"></p><h1 id="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"><a href="#改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径" class="headerlink" title="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"></a>改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径</h1><p><a href="https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337">https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337</a></p><p>会变成像素的数字，这个是可以走的路，蛮有意思</p><p>如果你吃的一瞬间路变没了，你也会死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119100230326.png" alt="image-20241119100230326"></p><h1 id="会连接在一起的箱子，而且中间的线也会挡住东西"><a href="#会连接在一起的箱子，而且中间的线也会挡住东西" class="headerlink" title="会连接在一起的箱子，而且中间的线也会挡住东西"></a>会连接在一起的箱子，而且中间的线也会挡住东西</h1><p>有点拓扑结构的意思</p><p><a href="https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0">https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117155008183.png" alt="image-20241117155008183"></p><h1 id="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"><a href="#推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物" class="headerlink" title="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"></a>推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物</h1><p><a href="https://notaninart.itch.io/pushing-u">https://notaninart.itch.io/pushing-u</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117163406595.png" alt="image-20241117163406595"></p><h1 id="箱子连接，但是本身自己也可以变成箱子，也可以解冻"><a href="#箱子连接，但是本身自己也可以变成箱子，也可以解冻" class="headerlink" title="箱子连接，但是本身自己也可以变成箱子，也可以解冻"></a>箱子连接，但是本身自己也可以变成箱子，也可以解冻</h1><p><a href="https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29">https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29</a></p><p>非常巧妙，自己可以被冰冻变成箱子，也可以解冻，很地狱笑话，被冰冻才能上飞机，太幽默了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118155250549.png" alt="image-20241118155250549"></p><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h1><p><a href="https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259">https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259</a></p><p>推动国际象棋的棋子，目标是走到对面的皇后位置，不能走到能被吃的位置，但是可以推动棋子可以把推动的棋子给杀了。</p><p>感觉可以做一个中国象棋版的来尝试复刻一下</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117221156115.png" alt="image-20241117221156115"></p><h1 id="有步数限制的推箱子"><a href="#有步数限制的推箱子" class="headerlink" title="有步数限制的推箱子"></a>有步数限制的推箱子</h1><p><a href="https://galactical.itch.io/at-the-hedges-of-time">https://galactical.itch.io/at-the-hedges-of-time</a></p><p>很好理解，也很简单的创意，一个trick的点是箱子不会随着自己回退</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118145646564.png" alt="image-20241118145646564"></p><h1 id="箱子本身是一个能和周围互动的装置"><a href="#箱子本身是一个能和周围互动的装置" class="headerlink" title="箱子本身是一个能和周围互动的装置"></a>箱子本身是一个能和周围互动的装置</h1><p><a href="https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5">https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5</a></p><p>按下开关之后箱子会动，会把自己往什么某个方向推，碰撞体积也会发生改变，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118171505291.png" alt="image-20241118171505291"></p><p>其实有些关设计的挺有意思的，因为你需要反复来回来利用本身他之后弹开的位置来占住那个开关，然后再去推，这样其实有一种联动的感觉，后面感觉会有那种一下联动好几个然后按顺序搞的感觉，感觉很有意思</p><h1 id="保龄球推箱子"><a href="#保龄球推箱子" class="headerlink" title="保龄球推箱子"></a>保龄球推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9">https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9</a></p><p>推的目标箱子推一次会一直往前滚，所以需要用生成的反射东西来组装好路径来搞，设计的比较简单，但是还是挺有意思的，和我们做的反射光的游戏甚至有点像，他里面有一分为二，还有生成东西的道具</p><p>但是他的关卡太简单了，不够多</p><p>而且他这个能推很多次，如果做成只推一次，会好很多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118201017238.png" alt="image-20241118201017238"></p><p>他的还有一个机制是遇到已经放好的花朵会导致提前停下，或许就是因为这一点所以他没有做一击通关，这样难度会很高</p><h1 id="不能自己往上的推箱子"><a href="#不能自己往上的推箱子" class="headerlink" title="不能自己往上的推箱子"></a>不能自己往上的推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb">https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb</a></p><p>因为主角是一个落叶，所以做了往上方向的限制，只能通过喷泉来往上，这种限制也蛮有意思的。但是可以同时推多个箱子，也要利用这个。</p><p>还有一个机制，在水里的话就可以往上推，可以借助水的浮力，比如这一关就是这样</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118234135382.png" alt="image-20241118234135382"></p><h1 id="推箱子和一笔画？"><a href="#推箱子和一笔画？" class="headerlink" title="推箱子和一笔画？"></a>推箱子和一笔画？</h1><p><a href="https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729">https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729</a></p><p>规则很简单，往某个地方推会朝那个方向生成一个箱子，目标是把所有的红色都占满</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085545410.png" alt="image-20241119085545410"></p><h1 id="箱子的状态会被改变（火）"><a href="#箱子的状态会被改变（火）" class="headerlink" title="箱子的状态会被改变（火）"></a>箱子的状态会被改变（火）</h1><p><a href="https://rosden.itch.io/theflames">https://rosden.itch.io/theflames</a></p><p>被火烧了会有几个状态，中间有四步移动的机会，这时候不会完全变成灰烬，还可以被推，可以用来填补空洞；之后会变成灰烬，不能被推动，也不会挡路（第一关就是教你这个，不挡路）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119092837131.png" alt="image-20241119092837131"></p>]]></content>
    
    
    <summary type="html">itch许多类推箱子游戏的游玩记录，总结一下他们的创意</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>我的独立游戏作品合集</title>
    <link href="https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/"/>
    <id>https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/</id>
    <published>2024-10-27T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:26.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完美世界GameJam"><a href="#完美世界GameJam" class="headerlink" title="完美世界GameJam"></a>完美世界GameJam</h1><p>开发日期：2024.3.15</p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a></p><p>一个关于骰子的肉鸽游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"></a></p><h1 id="2024CigaGamejam"><a href="#2024CigaGamejam" class="headerlink" title="2024CigaGamejam"></a>2024CigaGamejam</h1><p>主题：有限与无限</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">试玩连接</a></p><p>一个关于1v3的不对成派对游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"></a></p><h1 id="2024下半年Booom"><a href="#2024下半年Booom" class="headerlink" title="2024下半年Booom"></a>2024下半年Booom</h1><p>主题：change_,not change _</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">试玩连接</a></p><p>一个类似卡坦岛的生存游戏，美术不错</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"></a></p><h1 id="2024TapTapGameJam"><a href="#2024TapTapGameJam" class="headerlink" title="2024TapTapGameJam"></a>2024TapTapGameJam</h1><p>主题：light</p><p>开发日期：2024.10.25-11.1</p><p><a href="https://rorschachandbat.itch.io/lightpuzzle">试玩连接</a></p><p>一个关于光线解密的游戏，尝试着用ai+godot开发，完成度不错，关卡设计的很有意思</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"></a></p>]]></content>
    
    
    <summary type="html">放一个合集，欢迎大家试玩</summary>
    
    
    
    <category term="随笔" scheme="https://rorschachandbat.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>落井下食开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-02T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p class="note note-primary">为了避免危险，你需要派遣伙伴们去合适的地方，它们会帮助你，□□食物，应对晚上的客人。 夜晚来临时，客人们会依次到来，你只需要提供它们需要的食物，它们就会满意的离开。</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png" alt="img"></a></p><h1 id="Luban导表工具"><a href="#Luban导表工具" class="headerlink" title="Luban导表工具"></a>Luban导表工具</h1><p>这次的项目需要填数据的地方非常多，有了上次做肉鸽小游戏的教训，决定搜寻一下有无更加好用的导表工具，最终找到了luban工具，算是比较方便好用的实现方案。</p><p><a href="https://github.com/focus-creative-games/luban">官方链接</a></p><p>作为一个需要大量配表的游戏，最理想的情况是，策划端只需要用excel就可以搞定，程序端也不需要编写处理db的代码，导表工具会自动生成相应的代码。</p><p>具体的例子直接看文档大概能看的明白，当然也有一些实现的非常草率的地方，</p><p>1.无法动态修改数据，就只能重新创建一个一模一样的结构体，因为他自己生成的结构式是read only的，无法实现修改，感觉这个也是可以细想怎么优雅实现的。</p><p>2.没有加数据校验功能，后期策划在编写的时候会出现填错的情况。</p><p>3.excel表无法实现比较复杂的数据结构。</p><h1 id="JKFrame"><a href="#JKFrame" class="headerlink" title="JKFrame"></a>JKFrame</h1><p><a href="http://www.yfjoker.com/JKFrame/">JKFrame使用手册</a></p><p>本次09老师使用了JKFrame作为编程框架，使用起来比较方便，相当于多了一些库，直接用事件系统和ui系统都很方便，以后也可以多用这个框架尝试。</p><h1 id="六边形地图设计"><a href="#六边形地图设计" class="headerlink" title="六边形地图设计"></a>六边形地图设计</h1><p>六边形地图不能直接用二维坐标来表示，并且因为本次项目不需要动态生成，所以就直接在ui上硬编码了整个地图，感觉更加正常的做法是用tilemap，但是因为时间紧迫所以全部都用ui来做了，之后这里可以研究一下如何更优雅的实现这种六边形地图。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png" alt="坐标参考"></a></p><p>坐标参考</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png" alt="demo图"></a></p><p>demo图</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png" alt="最后的成品"></a></p><p>最后的成品</p><p><a href="https://www.redblobgames.com/grids/hexagons/">六边形地图理论基础</a></p><p><a href="https://indienova.com/u/npc233/blogread/11298">六边形地图坐标距离计算（直接看结论版）</a></p><p>计算距离，像这样的坐标体系，有x,y,z三个维度，x,y,z的和始终是0，我们称之为cube坐标，距离计算公式是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br><br>TS<br>diatance=<span class="hljs-built_in">max</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))<br><br>TS<br>func <span class="hljs-built_in">posDistance</span>(pos1,pos2):<br>    <span class="hljs-selector-tag">var</span> cubePos1=<span class="hljs-built_in">getCubePosFromPos</span>(pos1)<br>    <span class="hljs-selector-tag">var</span> cubePos2=<span class="hljs-built_in">getCubePosFromPos</span>(pos2)<br>    <span class="hljs-selector-tag">var</span> distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br>    return distance<br><br>CPP<br></code></pre></td></tr></table></figure><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这次项目作为一个ui游戏，简单的使用了MV框架，前期实现整体游戏循环的过程很快，到后面开始拼ui的时候其实有很大的沟通失误，缺少一个统筹规划工作量的人，来预估这个完成的时间。我自己心目中的完成时间点和实际的完全不一样，比如说地图，到了最后几天才分配给我做，我本以为是第二个周末就能完成的事情，我觉得09花了太多的时间来重构代码，并且重构之后也没经过测试，这个风险非常大，我个人认为应该先保证所有功能都完备了再进行重构的工作，不然卡在这里也无法进行下一步的推进。</p><p>其实这又是一个沟通问题，如果没有一个责任人站出来，那么我就会倾向于摆烂，并且祈祷或者默认其他人能完成，这就导致了我们最后ui和玩法上还有很多bug没修完，如果倒数第二个周末就有人站出来规划好预计的时间，或许最后交上去的结果会好很多。</p><h2 id="测试以及策划功能优先级问题"><a href="#测试以及策划功能优先级问题" class="headerlink" title="测试以及策划功能优先级问题"></a>测试以及策划功能优先级问题</h2><p>再来讲讲测试的问题，理想的情况是做完一个功能就马上有人来验收，并且这个人是知道所有的功能细节，这样是效率最高的测试方法，所以要么是程序自测，要么是策划验收，如果再找一个测试来验收就还需要和他沟通具体的细节。</p><p>但是中期出现的问题是，队伍策划需要干的事情实在<strong>太多了</strong>，既要设计玩法，还要调整数值，还要设计ui，还要验收功能。但是这些事情我认为应该是有优先级的，应该是要保证完成游戏完整性而服务，也就是设计ui和验收功能为更优先，因为这些都是会影响其他人的工作流的，一旦这个地方卡住了，其他人就要<strong>等待这里完成</strong>，会陷入到无事可干，并且必须要完成好最终确定的游戏，才能开始跑游戏测试数值。</p><p>而关于数值设计，既然我们已经分离开了数据和玩法，大可之后再根据测试的反馈来更改数值，数值设计应该也是需要有一套<strong>方法论</strong>的，这个是需要思考学习的。</p><h2 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h2><p>在前期的设计阶段，我总是觉得已有的玩法过于简单，能够一眼望穿，所以提出了很多想要增加策略性的建议，比如增加道具种类，地图增加走格子玩法，白天从三个动物变成牌组的形式，但其实最后做下来，看玩家的反馈已经足够复杂。我开始意识到我走入了一个非常大的误区，作为开发者，对于自己的游戏当然足够熟悉，所以总是会觉得过于简单，而失去了站在旁观者来审视游戏复杂度的能力，很容易把游戏玩法膨胀得很难。当然，这也和我前面提到的<strong>快速测试并且验证思路</strong>有关，总是因为我们没有快速验证的过程，所以会让我有这种恐慌。</p><h2 id="主题和音乐和美术"><a href="#主题和音乐和美术" class="headerlink" title="主题和音乐和美术"></a>主题和音乐和美术</h2><p>这次游戏的另一个教训是有关于游戏的其他方面，我总是太过于在于游戏机制的设计，但是忽略了其他人看中的部分，比如主题、美术和音乐的统一性，ui设计的合理性，还是提到的一点，每个人对于jam最终作品的想象不一样，我所追求的是一个好玩的东西。但是可能其他人更愿意的是一个完整的作品，一个从机制到主题到美术音乐统一并且完整的作品，那就必然牺牲一部分有趣度的考量，而</p><p>这点以后要改进的是，和别人一开始就要沟通清楚<strong>自己的愿景</strong>，这样才能共同朝着一个方向努力。</p><h1 id="获得的一些灵感"><a href="#获得的一些灵感" class="headerlink" title="获得的一些灵感"></a>获得的一些灵感</h1><p><strong>西西弗斯</strong><br>糯米团子，做一个自动放置小游戏，不过是翻山，讽刺一下西西弗这个意象。</p><p><strong>todolist直接改的模拟经营</strong><br>模拟经营，但是像babaisyou一样，目标是可以根据自己的东西来拖动的，比如需要10个肉直接变成需要10个草。</p><p><strong>放置挂机+自走棋</strong></p><p>白天放置挂机拿资源，晚上自走棋战斗，更加纯粹简单的快乐。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次作品的完整性还是相当高的，作为一个三周的作品美术音乐音效玩法都非常融洽，给自己朋友家人试玩也是相当开心，作为自己第一个完整度这么高的作品也是相当开心了。真的相当感谢队友们的付出，队友们都非常给力，性格也相当nice，沟通起来都非常舒服，感谢队友的配合，学到了很多，希望以后能再次合作。</p><h1 id="还需要研究的问题"><a href="#还需要研究的问题" class="headerlink" title="还需要研究的问题"></a>还需要研究的问题</h1><p>1.六边形地图如何优雅实现</p><p>2.导表的问题</p><p>3.学习数值设计方法论</p><p>4.如何导网页端游戏</p>]]></content>
    
    
    <summary type="html">2024下半年Booom参赛作品</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png" alt="image-20240901211645122"></a></p><p>image-20240901211645122</p><p>游戏玩法是1v3的不平衡对抗，每局游戏开始前每个人都会随机到一个关于自身能力的一个buff和一个debuff（比如跳跃次数增加和奔跑速度变慢），人类方的</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>这次比赛的主题是limited and limitless，所以我一开始想的是，给玩家可以自由调控自己的任何能力值，比如奔跑速度，跳跃高度，跳跃次数，冲刺距离……但是你加了一方面的buff，就要选择另一个其他的debuff，然后设计一系列的关卡，看你如何通过你的搭配来最快的过关。这个核心规则比较简单但是变化也相当多，不过被否定了，理由是1.在这种现场试玩做这种一次性的解密游戏很容易让游戏失去游戏性，因为别人看一次就知道怎么玩了，2.可能没有那么多时间来设计关卡。所以他们最后还是决定做一个party game。</p><h1 id="Corgi引擎"><a href="#Corgi引擎" class="headerlink" title="Corgi引擎"></a>Corgi引擎</h1><p><a href="https://corgi-engine-docs.moremountains.com/">corgi引擎文档</a></p><p>先说下corigi引擎的优点，有非常多已经实现的平台跳跃功能，包括丰富的平台，以及人物不同的能力（飞翔，滑翔背包，冲刺），这些都是以</p><h1 id="编码思路和组件思维"><a href="#编码思路和组件思维" class="headerlink" title="编码思路和组件思维"></a>编码思路和组件思维</h1><h1 id="水面shader"><a href="#水面shader" class="headerlink" title="水面shader"></a>水面shader</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png" alt="一开始的效果"></a></p><p>一开始的效果</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png" alt="加了水面shader的效果"></a></p><p>加了水面shader的效果</p><p>一开始的加一个镜面反射和流动水的效果，就好看许多</p><h1 id="测试暴露的问题"><a href="#测试暴露的问题" class="headerlink" title="测试暴露的问题"></a>测试暴露的问题</h1><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>最理想的情况是策划来进行这个关卡的设计，但因为这次的策划是一个比较新手的人，到了最后也没能成功下载unity，并且也没有任何设计关卡的经验，所以只能由我自己来拼一个关卡了。</p><p>我的设计思路是观看我最喜欢的partygame，move or die的一些地图，然后再摆出目前能实现的平台：长条，斜坡，弹跳蘑菇，下落方块，（和mod里面差的也就是一个传送门）当然corgi里面还实现了很多其他平台效果但是都因为我们缺少美术就没有做了，根据</p><h2 id="跳跃手感"><a href="#跳跃手感" class="headerlink" title="跳跃手感"></a>跳跃手感</h2><p>作为一个平台跳跃，跳跃手感是至关重要的，一个很重要的标准是，就算没有任何的关卡，没有任何的剧情，你只需要操控着你的角色跑一下挑一下，如果你觉得很畅快那就是一个好的手感，</p><p>关于手感有许多很好的视频，</p><p><a href="https://www.bilibili.com/video/BV1M441197sr/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【游戏制作工具箱】《蔚蓝》的手感为何迷人？</a></p><p><a href="https://www.bilibili.com/video/BV15C411r7Ju/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【GMTK|中英字幕】马里奥跳跃的秘密</a></p><p>事实上corgi游戏里面已经对跳跃的参数给了很多自由的参数，比如</p><h2 id="试玩的插曲"><a href="#试玩的插曲" class="headerlink" title="试玩的插曲"></a>试玩的插曲</h2><p>线下试玩非常有趣，遇到了一个非常精通平台跳跃的玩家，蔚蓝打通c面的那种，我和他1v1打了许久，一开始我想着让一下他，不要打消他的热情，但是再玩了几把之后我发现是他是真的很强，所以索性放开了跟他玩，但是他还是偶尔能赢，不过由于某些关卡设计和机制设计，让他随机到了只能跳一次就基本赢不了，所以我索性在给他开放了冲刺的功能，让他</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>corgi引擎</p><h2 id="体量"><a href="#体量" class="headerlink" title="体量"></a>体量</h2><p>人手还是不够，这次光是画好人物和boss就已经差不多了，关卡的布置只能自己来搞了，所以做的不是特别好。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计问题也有很多，比如一开始说到的只能四个人玩，导致在现场体验的时候很难凑到四个人，这点还是致命伤啊。</p>]]></content>
    
    
    <summary type="html">2024CigaGamejam</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-08-31T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"></a></p><p>首先简单介绍一下游戏玩法，你和boss会轮流骰两个骰子，你需要选择是分开触发骰子还是合成触发，比如扔到4和6，你可以选择触发4扇区和6扇区，也可以选择只触发10扇区，每个扇区的牌有主动效果和被动效果，自己回合触发的是主动效果，boss回合触发的被动效果，当然每个回合还可以买牌，所以是一个需要你控制概率的肉鸽游戏。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"></a></p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a>(温馨提示，此版本未经过任何的数值调整，平衡和体验都及其不成熟)</p><h1 id="灵感和讨论过程"><a href="#灵感和讨论过程" class="headerlink" title="灵感和讨论过程"></a>灵感和讨论过程</h1><p>本次gamejam的主题是做你想做的游戏，并且也不要求你做出一个可玩的游戏，你做出关于游戏的ppt就能算完成。由此可见完美这次压根就不是想做一个jam，而是抱着一种想要偷你点子给公司赚钱的目的，所以我们索性就做一个自己想玩的游戏算了。</p><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h1 id="技能设计"><a href="#技能设计" class="headerlink" title="技能设计"></a>技能设计</h1><h1 id="dotween"><a href="#dotween" class="headerlink" title="dotween"></a>dotween</h1><h1 id="桌游转电子游戏的痛点和思考"><a href="#桌游转电子游戏的痛点和思考" class="headerlink" title="桌游转电子游戏的痛点和思考"></a>桌游转电子游戏的痛点和思考</h1><p>桌游的乐趣和电子游戏的乐趣非常难转换，桌游的乐趣在于与人互动，虽然也有很多自闭刷分的游戏，但是也是要与人交互的，他要求人与人之间是平等的决策思路，而单机游戏如果简单的转换成打boss，那就会变得很不一样，相当难转换，这就是为什么很多桌游的机制不能用在电子游戏上来，当然这个是一个值得持续思考的问题。</p><h1 id="题外话和八卦"><a href="#题外话和八卦" class="headerlink" title="题外话和八卦"></a>题外话和八卦</h1><p>非常可笑的是，做完jam的第二周，我就被通知优化了，真是唏嘘啊。</p>]]></content>
    
    
    <summary type="html">在完美的最后一舞</summary>
    
    
    
    <category term="游戏锐评" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>UE引擎LGUI框架记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.660Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注册事件的写法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在EventDefine.ts里添加对应的枚举和interface</span><br><br><span class="hljs-title class_">GuideGroupOpening</span>, <span class="hljs-comment">//引导组打开</span><br>    <br>[<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideFocusNeedUiTabView</span>]: <span class="hljs-function">(<span class="hljs-params">stepInfo: GuideStepInfo, focusConf: GuideFocusNew</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>        <br><span class="hljs-comment">// 在对应的Controller的OnAddEvents和OnRemoveEvents添加</span><br>        <br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Add</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Remove</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><br><br><span class="hljs-comment">// 在对应的Model代码添加触发器</span><br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Emit</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Owner</span>!.<span class="hljs-property">Id</span>, isPreExecute);<br></code></pre></td></tr></table></figure><h1 id="LGUI在TS中的绑定写法"><a href="#LGUI在TS中的绑定写法" class="headerlink" title="LGUI在TS中的绑定写法"></a>LGUI在TS中的绑定写法</h1><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>prefab会有一个LGUIComponentsRegistry组件，定义了引用的顺序，例如：</p><p><img src="C:\Users\jiangliyong\AppData\Roaming\Typora\typora-user-images\image-20240619141651430.png" alt="image-20240619141651430"></p><p>然后在OnRegisterComponen方法里面按照熟悉绑定即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">ButtonMask</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextName</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextureBg</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UITexture</span>],<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p><a href="https://kurogame.feishu.cn/wiki/LR2lwhGmci2wxGk0ISPcCp9Enwf">‌⁠‬‌‬‬‬﻿‬﻿‌‌‍‌‬﻿﻿‬⁠‍﻿LGUI设计说明文档 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcn93vYNH8Hduj3SAJaSPuG8f">‌﻿﻿‍⁠⁠‬‬﻿‬﻿‍‬‬‌‍﻿‌‌‌Ts Ui框架说明 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/JicQw8apsiUMXukKIhacLdNInYf">‌⁠‌‬﻿‬‍﻿‌⁠‍‌⁠﻿⁠﻿‌‌⁠‌⁠‌‌‍‬‍‌﻿业务UI框架重构 - 飞书云文档 (feishu.cn)</a></p><p>一些关键的基类：ComponentAction（所有UI类和UIBehavior类的共同最终基类，实现了一套带状态的生命周期调度和可重载接口）、UIPanelBase（提供给小UI，即界面中的格子、小界面等继承，拥有丰富的UI相关操作能力）、UIViewBase（提供给界面继承，它本身也继承自UIPanelBase，在其上扩展了动画、场景、事件、读取UI配置表的能力），继承关系ComponentAction-&gt;UIPanelBase-&gt;UIViewBase</p><p>UiPanelBase.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">ComponentRegisterInfos</span>: <span class="hljs-title class_">TComponentsRegisterInfo</span>[] = [];<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">BtnBindInfo</span>: <span class="hljs-title class_">TBtnBindInfo</span>[] = []; <span class="hljs-comment">//所有按钮绑定事件的定义</span><br><br><span class="hljs-comment">// 重写OnRegisterComponent方法</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CgTextureBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CaptionText</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnAuto</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIItem</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnHide</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        ];<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>生命周期函数（带Async是异步版本）</p><p>OnRegisterComponent：绑定具体界面定义的enum里面的控件。</p><p>OnAddEventListener：添加ui事件监听，按钮啥的</p><p>控件相关的api在UIItem.d.ts里面</p><p>比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetButton</span>(<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>)!.<span class="hljs-property">RootUIComp</span>.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="预制体中组件的显示与隐藏"><a href="#预制体中组件的显示与隐藏" class="headerlink" title="预制体中组件的显示与隐藏"></a>预制体中组件的显示与隐藏</h1><p>SetUIActive</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetItem</span>(<span class="hljs-title class_">ETutorialsPopupComponents</span>.<span class="hljs-property">PnlBottom</span>)!.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="UI动画调用"><a href="#UI动画调用" class="headerlink" title="UI动画调用"></a>UI动画调用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelSequencePlayer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">RootItem</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Start&#x27;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Loop&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="游戏中LGUI层级结构"><a href="#游戏中LGUI层级结构" class="headerlink" title="游戏中LGUI层级结构"></a>游戏中LGUI层级结构</h1><p><a href="https://kurogame.feishu.cn/wiki/wikcntd0SV4OAJV1fG3Md9LxpHV">‌‍‍‌⁠‌﻿⁠‌﻿‬⁠﻿⁠‍‬⁠‌‌‌‍﻿‌‍‌⁠﻿UI层级节点描述文档，包含容器逻辑实现规则 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnNqg8wjO5u8dNApZbfzoJMe">屏幕空间UI层级说明 - 飞书云文档 (feishu.cn)</a></p><h2 id="Hud层"><a href="#Hud层" class="headerlink" title="Hud层"></a>Hud层</h2><p>交互和剧情界面旁白</p><h2 id="Normal层"><a href="#Normal层" class="headerlink" title="Normal层"></a>Normal层</h2><p>常规系统界面，只显示最表面的界面</p><h2 id="NormalMask层"><a href="#NormalMask层" class="headerlink" title="NormalMask层"></a>NormalMask层</h2><p>Normal层的点击阻挡遮罩</p><h2 id="Pop层"><a href="#Pop层" class="headerlink" title="Pop层"></a>Pop层</h2><p>可交互弹窗</p><h2 id="Float层"><a href="#Float层" class="headerlink" title="Float层"></a>Float层</h2><p>飘字和提示</p><h2 id="NetWork层"><a href="#NetWork层" class="headerlink" title="NetWork层"></a>NetWork层</h2><p>网络提示相关的ui</p><h2 id="Mark层"><a href="#Mark层" class="headerlink" title="Mark层"></a>Mark层</h2><p>以上所有层的点击阻挡遮罩</p><h2 id="Pool层"><a href="#Pool层" class="headerlink" title="Pool层"></a>Pool层</h2><p>对象池界面，优化性能使用</p><h1 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h1><p>使用AudioSystem</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">const LOOP_DIGITAL_SCREEN = <span class="hljs-string">&#x27;play_ui_digital_screen&#x27;</span><span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.PostEvent(LOOP_DIGITAL_SCREEN)<span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.ExecuteAction(LOOP_DIGITAL_SCREEN, UE.EAudioActionType.Stop)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="修改某一个组件的具体参数"><a href="#修改某一个组件的具体参数" class="headerlink" title="修改某一个组件的具体参数"></a>修改某一个组件的具体参数</h1><p>使用SetCustomMaterialScalarParameter，这里要用到FName</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> factor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-title class_">FName</span>(<span class="hljs-string">&#x27;factor&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetCustomMaterialScalarParameter</span>(<br>            factor,<br>            <span class="hljs-title class_">ModelManager</span>.<span class="hljs-property">DigitalScreenModel</span>?.<span class="hljs-property">TextFactor</span> ?? <span class="hljs-number">0.2</span>,<br>        );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UE引擎LGUI框架记录</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript知识点总结</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-12-24T12:21:25.659Z</updated>
    
    <content type="html"><![CDATA[<p>PuerTS的常用写法，</p><h1 id="TS基础写法"><a href="#TS基础写法" class="headerlink" title="TS基础写法"></a>TS基础写法</h1><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">PlayStateCheckHandle</span>: <span class="hljs-title class_">TimerHandle</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>|表示联合类型，表示既可以是TimerHandle也可以是undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Proto</span><span class="hljs-attr">_Nodes</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">IProto_NodeInfo</span> &#125;;<br></code></pre></td></tr></table></figure><p> 表示一个索引签名（index signature），用于定义一个对象类型，其中键（key）是字符串类型，而值（value）是 <code>Aki.Protocol.IProto_NodeInfo</code> 类型。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长参数</p><p>…args</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">first: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First argument is <span class="hljs-subst">$&#123;first&#125;</span>`</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);  <span class="hljs-comment">// 输出: First argument is 1, hello, world, !</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，函数内部创建的局部变量确实可以返回并在函数外部被直接修改，但这通常适用于可变类型（mutable types），如对象（包括 <code>Map</code>、<code>Set</code>、数组等）和函数。对于不可变类型（immutable types），如原始数据类型（数字、字符串、布尔值等），则不能直接修改。</p><p><strong>可变类型：</strong></p><p>当函数返回一个可变类型的值时，实际上返回的是这个值的引用（reference）。因此，通过这个引用所做的任何修改都会反映到原始对象上。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">复制function createObject() &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-keyword">prop</span>: 1 &#125;;<br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回对象的引用</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = createObject();<br>myObj.<span class="hljs-keyword">prop</span> = 2; <span class="hljs-comment">// 直接修改了 createObject 函数内部创建的对象</span><br>console.<span class="hljs-built_in">log</span>(myObj.<span class="hljs-keyword">prop</span>); <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><p>这个是因为看的时候看到一段对我来说比较吊诡的代码，在一个私有函数创建了一个map(nodes)，直接set到了另一个map(NodesGroupByStatus)里面，但是直接返回nodes，在另一个函数里面可以直接修改，后面查了才知道，ts如果返回maps这种可修改的变量相当于返回的是引用，所以就是改的原始的nodes</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">AddNodeGroup</span>(<span class="hljs-attr">group</span>: <span class="hljs-title class_">ENodeGroup</span>): <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt;();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">NodesGroupByStatus</span>!.<span class="hljs-title function_">set</span>(group, nodes);<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">AddNodeToStatusGroup</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TBehaviorNode</span>, <span class="hljs-attr">newStatus</span>: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">Proto_NodeStatus</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> groupId = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetGroupIdByStatus</span>(newStatus);<br>    <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetNodesByGroupId</span>(groupId);<br>    <span class="hljs-keyword">if</span> (!nodes) &#123;<br>        nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">AddNodeGroup</span>(groupId);<br>    &#125;<br><br>    nodes.<span class="hljs-title function_">set</span>(node.<span class="hljs-property">NodeId</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>继承extends</p><p><strong>super关键字</strong></p><ol><li><strong>调用父类构造函数</strong>：当你定义一个子类时，如果需要调用其父类的构造函数，可以使用 <code>super()</code>。这是必须的步骤，因为子类的实例在JavaScript&#x2F;TypeScript中总是通过父类的构造函数创建的。</li><li><strong>访问父类成员</strong>：<code>super</code> 也可以用来访问父类中定义的属性和方法，这在你想要扩展或重写父类成员时非常有用。</li><li><strong>访问父类的静态成员</strong>：使用 <code>super</code> 关键字，也可以访问父类的静态属性或方法</li><li><strong>在构造函数中</strong>：在构造函数中使用 <code>super</code> 必须作为第一条语句，因为子类实例的创建是基于父类构造函数的。</li><li><strong>在派生类的静态方法中</strong>：在静态方法中使用 <code>super</code> 来访问父类的静态成员。</li><li><strong>在派生类的方法中</strong>：在非静态方法中使用 <code>super</code> 来访问父类的非静态成员。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>一开始看这个OnUpdate的时候非常懵逼</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">OnUpdate</span>(<span class="hljs-attr">newUpdate</span>: $Undefinable&lt;$Delegate&lt;<span class="hljs-function">(<span class="hljs-params">InProgress: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt;) : $Undefinable&lt;<span class="hljs-title class_">LTweener</span>&gt;;    <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnTick</span>(<span class="hljs-attr">deltaTime</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> tween = <span class="hljs-variable language_">this</span>.<span class="hljs-property">TextPlayTweenComp</span>!.<span class="hljs-title class_">GetPlayTween</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">LGUIPlayTween_Int</span>;<br>        <span class="hljs-keyword">const</span> tweener = tween?.<span class="hljs-title class_">GetTweener</span>();<br>        <span class="hljs-keyword">if</span> (tweener) &#123;<br>            tweener.<span class="hljs-title class_">OnUpdate</span>(<br>                <span class="hljs-title function_">toManualReleaseDelegate</span>((<span class="hljs-attr">progress</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">const</span> pro = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(progress * (tween.<span class="hljs-property">to</span> - tween.<span class="hljs-property">from</span>)) + tween.<span class="hljs-property">from</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> &lt; pro) &#123;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> = pro;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Text</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span>));<br>                    &#125;<br>                &#125;),<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>类型断言，有点类似其他语言的类型转换，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>const id &#x3D; a ? b : c;</p><p>条件 ? 表达式1 : 表达式2</p><ul><li>如果 <code>条件</code>（在这里是变量 <code>a</code>）为真（truthy），那么整个表达式的结果是 <code>表达式1</code>（在这里是变量 <code>b</code>）。</li><li>如果 <code>条件</code> 为假（falsy），那么结果是 <code>表达式2</code>（在这里是变量 <code>c</code>）。</li></ul><h3 id="x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</h3><ol><li><strong>严格等于 (<code>===</code>)</strong>:<ul><li><code>===</code> 是严格等于运算符，它比较两个值是否完全相等，包括它们的类型。</li><li>如果两个操作数的类型不同，<code>===</code> 返回 <code>false</code>。</li><li>只有当两个操作数的类型和值都相同时，<code>===</code> 才返回 <code>true</code>。</li></ul></li><li><strong>等于 (<code>==</code>)</strong>:<ul><li><code>==</code> 是等于运算符，它比较两个值是否等价。</li><li>如果操作数的类型不同，JavaScript 会进行类型转换，然后再比较它们的值。</li><li><code>==</code> 会根据需要将操作数转换为数字或字符串，然后进行比较。</li></ul></li><li>!&#x3D;&#x3D;</li></ol><p>​不相等，但是不会进行类型转换</p><h3 id="和"><a href="#和" class="headerlink" title="?.和!."></a>?.和!.</h3><p><code>!</code> 被称为非空断言操作符，它用来告诉 TypeScript 编译器，某个位置的值不应该为 <code>null</code> 或 <code>undefined</code>。</p><p>?.是一种语法糖， 如果多层访问中间有null或者undefined就会返回undefined，不用自己再另写类型检查</p><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>表示调用这个对象或者参数的时候这个参数可选</p><h3 id="-1"><a href="#-1" class="headerlink" title="??"></a>??</h3><p>逻辑运算符，用于返回两个操作数中第一个非空值（non-nullish value），或者在两个操作数都为空值（null 或 undefined）时返回右侧的操作数。</p><h1 id="UE4容器使用"><a href="#UE4容器使用" class="headerlink" title="UE4容器使用"></a>UE4容器使用</h1><h2 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/">TArray：虚幻引擎中的数组 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h3 id="创建和填充"><a href="#创建和填充" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建</span><br>TArray&lt;int32&gt; IntArray;<br><br><span class="hljs-comment">// 填充</span><br>IntArray.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 等价于下面</span><br><span class="hljs-comment">// IntArray = [10, 10, 10, 10, 10]</span><br><br><span class="hljs-comment">// 在末尾增加用Add或者Emplace</span><br><span class="hljs-comment">// Add会创建一个新实例，Emplace不会</span><br><br>TArray&lt;FString&gt; StrArr;<br>StrArr.<span class="hljs-built_in">Add</span>    (<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>StrArr.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;]</span><br><br><span class="hljs-comment">// 利用 Append 可一次性添加其他 TArray 中的多个元素</span><br><br>FString Arr[] = &#123; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;of&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Tomorrow&quot;</span>) &#125;;<br>StrArr.<span class="hljs-built_in">Append</span>(Arr, <span class="hljs-built_in">ARRAY_COUNT</span>(Arr));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;]</span><br><br><span class="hljs-comment">// 仅在尚不存在等值元素时， AddUnique 才会向容器添加新元素。</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;,&quot;!&quot;]</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr is unchanged as &quot;!&quot; is already an element</span><br><br><span class="hljs-comment">// Insert</span><br><br>StrArr.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Brave&quot;</span>), <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// SetNum,如新数量大于当前数量，则使用元素类型的默认构造函数新建元素</span><br><span class="hljs-comment">// 如新数量小于当前数量， SetNum 将移除元素。</span><br><br><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ranged-for</span><br>FString JoinedStr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; Str :StrArr)<br>&#123;<br>    JoinedStr+=Str;<br>&#125;<br><br><span class="hljs-comment">// 直接for循环</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index != StrArr.<span class="hljs-built_in">Num</span>(); ++Index)<br>&#123;<br>    JoinedStr += StrArr[Index];<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 数组迭代器:CreateIterator读写；CreateConstIterator只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> It = StrArr.<span class="hljs-built_in">CreateConstIterator</span>();It;++It)<br>&#123;<br>    JoinedStr += *It;<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Sort，基于快排</span><br><span class="hljs-comment">// HeapSort，堆排序</span><br><span class="hljs-comment">// StableSort，基于归并排序，可以保证等值元素的相对顺序，上面两个无法保证</span><br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Num，查询数量</span><br><br><span class="hljs-comment">// GetData,返回指针元素</span><br><br><span class="hljs-comment">// Contains，查询是否包含特定元素</span><br><br><span class="hljs-comment">// ContainsByPredicate,可自己写规则</span><br><br><span class="hljs-type">bool</span> bHello   = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-type">bool</span> bGoodbye = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>));<br><span class="hljs-comment">// bHello   == true</span><br><span class="hljs-comment">// bGoodbye == false</span><br><br><span class="hljs-type">bool</span> bLen5 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">5</span>;<br>&#125;);<br><span class="hljs-type">bool</span> bLen6 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">6</span>;<br>&#125;);<br><span class="hljs-comment">// bLen5 == true</span><br><span class="hljs-comment">// bLen6 == false</span><br><br><span class="hljs-comment">// Find，返回找到的第一个元素的索引</span><br><span class="hljs-comment">// FindLast,范围找到的最后一个元素的索引</span><br>int32 IndexLast;<br><span class="hljs-keyword">if</span> (StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>), IndexLast))<br>&#123;<br>    <span class="hljs-comment">// IndexLast == 3, because there aren&#x27;t any duplicates</span><br>&#125;<br><br><span class="hljs-comment">// 上面时返回布尔值，也可以直接返回索引，未找到时INDEX_NONE</span><br>int32 Index2     = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexLast2 = StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexNone  = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><span class="hljs-comment">// Index2     == 3</span><br><span class="hljs-comment">// IndexLast2 == 3</span><br><span class="hljs-comment">// IndexNone  == INDEX_NONE</span><br><br><span class="hljs-comment">// IndexOfByKey</span><br><span class="hljs-comment">// IndexOfByPredicate</span><br><br><span class="hljs-comment">// FilterByPredicate可以直接找到匹配的元素数组</span><br><span class="hljs-keyword">auto</span> Filter = StrArray.<span class="hljs-built_in">FilterByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> !Str.<span class="hljs-built_in">IsEmpty</span>() &amp;&amp; Str[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&#x27;M&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除所有提供元素等值的元素</span><br><span class="hljs-comment">// RemoveSingle,移除首个匹配元素</span><br><span class="hljs-comment">// RemoveAt，移除特定位置元素</span><br><span class="hljs-comment">// RemoveAll,可以自己定义规则</span><br><br><br><span class="hljs-comment">// 如果不需要保证排序，可以用下面的来加快速度</span><br><span class="hljs-comment">// RemoveSwap,RemoveAtSwap,RemoveAllSwap</span><br><br><span class="hljs-comment">// Empty 清空</span><br></code></pre></td></tr></table></figure><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// +=，串联</span><br><br><span class="hljs-comment">// MoveTemp，移动语义，清空源数组</span><br>ValArr3 = <span class="hljs-built_in">MoveTemp</span>(ValArr4);<br><span class="hljs-comment">// ValArr3 == [5,2,3,1,2,3]</span><br><span class="hljs-comment">// ValArr4 == []</span><br><br><span class="hljs-comment">// == 和 != 进行比较，必须排序和数量都一样</span><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h2 id="TMap"><a href="#TMap" class="headerlink" title="TMap"></a>TMap</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">TMap | 虚幻引擎4.27文档 (unrealengine.com)</a></p><p>TMap键不能重复，TMultiMap键不唯一</p><h3 id="创建和填充-1"><a href="#创建和填充-1" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TMap&lt;int32, FString&gt; FruiMap;<br><br><span class="hljs-comment">// 填充都一样，但是要是填重复的键会覆盖之前的值</span><br><br></code></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>类似TArrays，不过迭代元素是TPair</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains来查询是否包含特定键</span><br><br><span class="hljs-comment">// Find，失败返回null</span><br><br><span class="hljs-comment">// FindOrAdd，不存在该键会新创建一个元素</span><br><br><span class="hljs-comment">// FindRef，没找到会返回默认值，不会创建新元素</span><br><br>FString&amp; Ref7 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// Ref7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;</span><br><span class="hljs-comment">// ]</span><br>FString&amp; Ref8 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// Ref8     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br>FString Val7 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">7</span>);<br>FString Val6 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// Val7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// Val6     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// FindKey，按值查找</span><br></code></pre></td></tr></table></figure><h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除对应键的元素</span><br>FruitMap.<span class="hljs-built_in">Remove</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// FindAndRemoveChecked，移除元素并返回该值</span><br>FString Removed7 = FruitMap.<span class="hljs-built_in">FindAndRemoveChecked</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// RemoveAndCopyValue 函数的作用与 Remove 相似，不同点是会将已移除元素的值复制到引用参数</span><br>FString Removed;<br><span class="hljs-type">bool</span> bFound2 = FruitMap.<span class="hljs-built_in">RemoveAndCopyValue</span>(<span class="hljs-number">2</span>, Removed);<br><br><span class="hljs-comment">// Empty和Reset，清空</span><br></code></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KeySort或者ValueSort</span><br>FruitMap.<span class="hljs-built_in">KeySort</span>([](int32 A, int32 B) &#123;<br>    <span class="hljs-keyword">return</span> A &gt; B; <span class="hljs-comment">// sort keys in reverse</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h3><p>有复制和移动语义</p><h3 id="Slack-1"><a href="#Slack-1" class="headerlink" title="Slack"></a>Slack</h3><h3 id="KeyFuncs"><a href="#KeyFuncs" class="headerlink" title="KeyFuncs"></a>KeyFuncs</h3><h2 id="TSet"><a href="#TSet" class="headerlink" title="TSet"></a>TSet</h2><h1 id="UE4回调"><a href="#UE4回调" class="headerlink" title="UE4回调"></a>UE4回调</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/">委托 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate - 知乎 (zhihu.com)</a></p><p>UE支持三种委托：单点委托，组播委托（事件），动态委托</p><h3 id="单点委托"><a href="#单点委托" class="headerlink" title="单点委托"></a>单点委托</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><h3 id="动态委托"><a href="#动态委托" class="headerlink" title="动态委托"></a>动态委托</h3><h1 id="UE4对象函数"><a href="#UE4对象函数" class="headerlink" title="UE4对象函数"></a>UE4对象函数</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Functions/">UFunctions | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h1 id="UE4引用"><a href="#UE4引用" class="headerlink" title="UE4引用"></a>UE4引用</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/ReferencingAssets/">引用资源 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/ReferenceAssets/">引用 Actor | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnLhvL7EdoiVzOhE8P2cjTCh">UE引用类型说明 - 飞书云文档 (feishu.cn)</a></p><p>引用分为两种，硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载；软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。</p><p>一种是通过UPROPERTY</p><p><strong>直接属性引用</strong></p><p>通过设置变量的UPROPERTY直接在编辑器设置对应资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** construction start sound stinger */</span><br><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Building)<br><br>USoundCue* ConstructionStartStinger;<br></code></pre></td></tr></table></figure><p><strong>构造时引用</strong></p><p>构造时加载对应资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/** gray health bar texture */</span><br><br><span class="hljs-constructor">UPROPERTY()</span><br><br><span class="hljs-keyword">class</span> UTexture2D* BarFillTexture;<br><br>AStrategyHUD::<span class="hljs-constructor">AStrategyHUD(<span class="hljs-params">const</span> FObjectInitializer&amp; ObjectInitializer)</span> :<br>    <span class="hljs-constructor">Super(ObjectInitializer)</span><br>&#123;<br>    static ConstructorHelpers::FObjectFinder&lt;UTexture2D&gt; <span class="hljs-constructor">BarFillObj(TEXT(<span class="hljs-string">&quot;/Game/UI/HUD/BarFill&quot;</span>)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>BarFillTexture = BarFillObj.Object;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>一种是用字符串来引用，如果UObject已经加载就用FindObject&lt;&gt;()，没有加载就使用LoadObject&lt;&gt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AFunctionalTest* TestToRun = <span class="hljs-built_in">FindObject</span>&lt;AFunctionalTest&gt;(TestsOuter, *TestName);<br>GridTexture = <span class="hljs-built_in">LoadObject</span>&lt;UTexture2D&gt;(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/EngineMaterials/DefaultWhiteGrid.DefaultWhiteGrid&quot;</span>), <span class="hljs-literal">NULL</span>, LOAD_None, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h1 id="UE4FName"><a href="#UE4FName" class="headerlink" title="UE4FName"></a>UE4FName</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/">FName | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p>在 <strong>内容浏览器</strong> 中为新资源命名时，变更动态材质实例中的参数或访问骨骼网格体中的一块骨骼时需要使用 <strong>FNames</strong> 。 FName 通过一个轻型系统使用字符串。在此系统中，特定字符串即使会被重复使用，在数据表中也只存储一次。</p><p>FNames 不区分大小写。它们为不可变，无法被操作。FNames 的存储系统和静态特性决定了通过键进行 FNames 的查找和访问速度较快。 FName 子系统的另一个功能是使用散列表为 FName 转换提供快速字符串。</p><p>FNames 不区分大小写，作为索引组合存储在唯一字符串和实例编号的表格中。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName TestName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Test&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FMame到FString</span><br>TestString = TestName.<span class="hljs-built_in">ToSring</span>();<br><br><span class="hljs-comment">// FName到FText</span><br>TestText = FText::<span class="hljs-built_in">FromName</span>(TestName);<br><br><span class="hljs-comment">// Fstring和FText到Fname都不可靠，因为FName不区分大小写</span><br><br><span class="hljs-comment">// FString到FName</span><br>TestName = <span class="hljs-built_in">FName</span>(*TextString);<br><br><span class="hljs-comment">// FText无法直接到FName</span><br></code></pre></td></tr></table></figure><p>对比是否相同直接比较索引的数值，不用执行字符串的对比</p>]]></content>
    
    
    <summary type="html">TypeScript知识点总结</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
</feed>
