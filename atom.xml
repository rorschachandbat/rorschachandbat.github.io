<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R</title>
  
  
  <link href="https://rorschachandbat.github.io/atom.xml" rel="self"/>
  
  <link href="https://rorschachandbat.github.io/"/>
  <updated>2025-11-04T16:15:02.107Z</updated>
  <id>https://rorschachandbat.github.io/</id>
  
  <author>
    <name>R</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE松散八叉树分析</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E6%9D%BE%E6%95%A3%E5%85%AB%E5%8F%89%E6%A0%91%E5%88%86%E6%9E%90/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E6%9D%BE%E6%95%A3%E5%85%AB%E5%8F%89%E6%A0%91%E5%88%86%E6%9E%90/</id>
    <published>2025-11-04T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="朴素的八叉树"><a href="#朴素的八叉树" class="headerlink" title="朴素的八叉树"></a>朴素的八叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FOTreeNode</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    TUniquePtr&lt;FOTreeNode&gt; Childs[<span class="hljs-number">8</span>];<br>    TUniquePtr&lt;FOTreeNode&gt; Parent;<br>    <br>    FVector Origin = FVector:ZeroVector;<br>    FVector Extent = FVector:ZeroVector;<br>    <br>    Tarray&lt;AActor*&gt; Actors;<br>    <span class="hljs-type">bool</span> bLeaf = <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>Origin（原点）</strong></p><ul><li><p>表示节点的中心点坐标</p></li><li><p>是该节点代表的3D空间盒子的中心位置</p></li><li><p>类型：FVector（X, Y, Z 坐标）</p></li></ul><p><strong>Extent（范围）</strong></p><ul><li><p>表示从中心点到边界的半径距离</p></li><li><p>定义了该节点空间的大小</p></li><li><p>类型：FVector（X轴半径、Y轴半径、Z轴半径）</p></li></ul><p>如何优化？</p><ul><li>8个子节点都用TUniqePtr，有点内存浪费</li><li>八个子节点的Parent都相同，没必要每个子节点都存一份Parent</li><li>每个节点不需要自己存Origin和Extent，只要知道父节点的数据，以及自己多少层即可</li><li>bLeaf也不用单独存</li></ul><h2 id="UE八叉树节点定义"><a href="#UE八叉树节点定义" class="headerlink" title="UE八叉树节点定义"></a>UE八叉树节点定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FNode</span><br>&#123;<br>FNodeIndex ChildNodes = INDEX_NONE;<br>uint32 InclusiveNumElements = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsLeaf</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> ChildNodes == INDEX_NONE;<br>&#125;<br>&#125;;<br><br>TArray&lt;FNode&gt; TreeNodes;<br>TArray&lt;FNodeIndex&gt; ParentLinks;<br></code></pre></td></tr></table></figure><p>UE八叉树的一个约定是，一个节点包含的所有元素，其Bounds也在这个节点边界内。那么即使待插入元素的Center在某个子树中，但Bounds超出了子树边界，也不能强行把他加入到子树中去。UE做法是直接把元素插入到父节点的TreeElements数组即可。</p><p>比如下面那个跨越边界的节点，会被直接插入到父节点的元素数组中</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/v2-57b2891ac5d1b6749a6ae617c16751b0_1440w.jpg" alt="img"></p><p>但是这么操作，Bounds稍微超过子节点，元素就会存到父节点，父节点存了太多元素怎么办，这又会影响后续查询效率。UE做法是把子树边界适当放宽 1&#x2F;16 的大小，缓解一下，目的是让一些处于子树边界上的元素，如果Bounds不大，就还是存在子树里，这个细节看下面的node有分析。</p><h1 id="UE4源码分析"><a href="#UE4源码分析" class="headerlink" title="UE4源码分析"></a>UE4源码分析</h1><p>主要看了一下这个文件：GenericOctree.h</p><h2 id="碰撞盒"><a href="#碰撞盒" class="headerlink" title="碰撞盒"></a>碰撞盒</h2><p>碰撞盒检测数学原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 两个盒子相交，当且仅当在所有轴上都相交</span><br>|CenterA - CenterB| &lt;= ExtentA + <span class="hljs-built_in">ExtentB</span>  (对于 X, Y, Z 轴)<br></code></pre></td></tr></table></figure><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><h3 id="有啥好处？"><a href="#有啥好处？" class="headerlink" title="有啥好处？"></a>有啥好处？</h3><p>SIMD &#x3D; Single Instruction, Multiple Data（单指令多数据）</p><p>传统 CPU 指令：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">一次只能处理一个数据<br>ADD 寄存器A, 寄存器B  → 计算 A + B<br></code></pre></td></tr></table></figure><p>SIMD</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">一次处理多个数据（通常4个或8个）<br>VADD 向量寄存器A, 向量寄存器B  → 同时计算 [A0+B0, A1+B1, A2+B2, A3+B3]<br></code></pre></td></tr></table></figure><p>看源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">friend</span> FORCEINLINE <span class="hljs-type">bool</span> <span class="hljs-title">Intersect</span><span class="hljs-params">(<span class="hljs-type">const</span> FBoxCenterAndExtent&amp; A, <span class="hljs-type">const</span> FBoxCenterAndExtent&amp; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// CenterDifference is the vector between the centers of the bounding boxes.</span><br>    <span class="hljs-type">const</span> VectorRegister CenterDifference = <span class="hljs-built_in">VectorAbs</span>(<span class="hljs-built_in">VectorSubtract</span>(<span class="hljs-built_in">VectorLoadAligned</span>(&amp;A.Center), <span class="hljs-built_in">VectorLoadAligned</span>(&amp;B.Center)));<br><br>    <span class="hljs-comment">// CompositeExtent is the extent of the bounding box which is the convolution of A with B.</span><br>    <span class="hljs-type">const</span> VectorRegister CompositeExtent = <span class="hljs-built_in">VectorAdd</span>(<span class="hljs-built_in">VectorLoadAligned</span>(&amp;A.Extent), <span class="hljs-built_in">VectorLoadAligned</span>(&amp;B.Extent));<br><br>    <span class="hljs-comment">// For each axis, the boxes intersect on that axis if the projected distance between their centers is less than the sum of their</span><br>    <span class="hljs-comment">// extents.  If the boxes don&#x27;t intersect on any of the axes, they don&#x27;t intersect.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">VectorAnyGreaterThan</span>(CenterDifference, CompositeExtent) == <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如是传统写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Intersect_Slow</span><span class="hljs-params">(<span class="hljs-type">const</span> FBoxCenterAndExtent&amp; A, <span class="hljs-type">const</span> FBoxCenterAndExtent&amp; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 需要9次浮点运算</span><br>    <span class="hljs-type">float</span> DiffX = <span class="hljs-built_in">abs</span>(A.Center.X - B.Center.X);  <span class="hljs-comment">// 2次运算</span><br>    <span class="hljs-type">float</span> DiffY = <span class="hljs-built_in">abs</span>(A.Center.Y - B.Center.Y);  <span class="hljs-comment">// 2次运算</span><br>    <span class="hljs-type">float</span> DiffZ = <span class="hljs-built_in">abs</span>(A.Center.Z - B.Center.Z);  <span class="hljs-comment">// 2次运算</span><br>    <br>    <span class="hljs-type">float</span> SumExtentX = A.Extent.X + B.Extent.X;  <span class="hljs-comment">// 1次运算</span><br>    <span class="hljs-type">float</span> SumExtentY = A.Extent.Y + B.Extent.Y;  <span class="hljs-comment">// 1次运算</span><br>    <span class="hljs-type">float</span> SumExtentZ = A.Extent.Z + B.Extent.Z;  <span class="hljs-comment">// 1次运算</span><br>    <br>    <span class="hljs-comment">// 3次比较</span><br>    <span class="hljs-keyword">return</span> (DiffX &lt;= SumExtentX) &amp;&amp; (DiffY &lt;= SumExtentY) &amp;&amp; (DiffZ &lt;= SumExtentZ);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用FVector4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Intersect_Fast</span><span class="hljs-params">(<span class="hljs-type">const</span> FBoxCenterAndExtent&amp; A, <span class="hljs-type">const</span> FBoxCenterAndExtent&amp; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 只需要3条SIMD指令！</span><br>    <span class="hljs-type">const</span> VectorRegister CenterDiff = <span class="hljs-built_in">VectorAbs</span>(<span class="hljs-built_in">VectorSubtract</span>(<br>        <span class="hljs-built_in">VectorLoadAligned</span>(&amp;A.Center),    <span class="hljs-comment">// 1条：加载</span><br>        <span class="hljs-built_in">VectorLoadAligned</span>(&amp;B.Center)));  <span class="hljs-comment">// 2条：减法+绝对值（同时处理X,Y,Z,W）</span><br>    <br>    <span class="hljs-type">const</span> VectorRegister CompositeExtent = <span class="hljs-built_in">VectorAdd</span>(<br>        <span class="hljs-built_in">VectorLoadAligned</span>(&amp;A.Extent),    <span class="hljs-comment">// 3条：加法（同时处理X,Y,Z,W）</span><br>        <span class="hljs-built_in">VectorLoadAligned</span>(&amp;B.Extent));<br>    <br>    <span class="hljs-comment">// 4条：比较（同时比较X,Y,Z,W）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">VectorAnyGreaterThan</span>(CenterDiff, CompositeExtent) == <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用FVector4还有一个好处是内存对齐，刚好是16个字节，FVector只有12个字节</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>再说两个SIMD指令</p><p>首先VectorCompareGT，可以用SIMD指令一次性比较4对浮点数，返回结果依然是一个Vector4。对于每一对浮点数，如果大于会存0xFFFFFFFF，小于存0。</p><p>然后VectorMaskBits，又可以把4个有符号数，把符号都转化为bitmask，组成一个int数。最后把这个int数当成子节点下标即可。</p><h2 id="两个很神的结构"><a href="#两个很神的结构" class="headerlink" title="两个很神的结构"></a>两个很神的结构</h2><h3 id="FOctreeChildNodeRef"><a href="#FOctreeChildNodeRef" class="headerlink" title="FOctreeChildNodeRef"></a>FOctreeChildNodeRef</h3><p>看了很久终于看懂了，其实这个就是类的关键就是，用一个index来表达该选择八个节点中的哪一个，一般来说这个需要三个参数xyz，但是ue用巧妙的位运算就可以一个index来搞定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** A reference to a child of an octree node. */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FOctreeChildNodeRef</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    int8 Index;<br><br>    <span class="hljs-comment">/** Initialization constructor. */</span><br>    <span class="hljs-built_in">FOctreeChildNodeRef</span>(int8 InX, int8 InY, int8 InZ)<br>    &#123;<br>        <span class="hljs-built_in">checkSlow</span>(InX &gt;= <span class="hljs-number">0</span> &amp;&amp; InX &lt;= <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">checkSlow</span>(InY &gt;= <span class="hljs-number">0</span> &amp;&amp; InY &lt;= <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">checkSlow</span>(InZ &gt;= <span class="hljs-number">0</span> &amp;&amp; InZ &lt;= <span class="hljs-number">1</span>);<br>        Index = <span class="hljs-built_in">int8</span>(InX &lt;&lt; <span class="hljs-number">0</span>) | <span class="hljs-built_in">int8</span>(InY &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-built_in">int8</span>(InZ &lt;&lt; <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Initialized the reference with a child index. */</span><br>    <span class="hljs-built_in">FOctreeChildNodeRef</span>(int8 InIndex = <span class="hljs-number">0</span>)<br>        : <span class="hljs-built_in">Index</span>(InIndex)<br>    &#123;<br>        <span class="hljs-built_in">checkSlow</span>(Index &lt; <span class="hljs-number">8</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Advances the reference to the next child node.  If this was the last node remain, Index will be 8 which represents null. */</span><br>    <span class="hljs-function">FORCEINLINE <span class="hljs-type">void</span> <span class="hljs-title">Advance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        ++Index;<br>    &#125;<br><br>    <span class="hljs-comment">/** @return true if the reference isn&#x27;t set. */</span><br>    <span class="hljs-function">FORCEINLINE <span class="hljs-type">bool</span> <span class="hljs-title">IsNULL</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> Index &gt;= <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-function">FORCEINLINE <span class="hljs-type">void</span> <span class="hljs-title">SetNULL</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        Index = <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-function">FORCEINLINE int32 <span class="hljs-title">X</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (Index &gt;&gt; <span class="hljs-number">0</span>) &amp; <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function">FORCEINLINE int32 <span class="hljs-title">Y</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (Index &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function">FORCEINLINE int32 <span class="hljs-title">Z</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (Index &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为啥要这样干呢？因为有个关键函数GetContainingChild，也就是判断一个元素是否完全被某一个子节点包含，如果是返回那个子节点索引，否则返回 NULL。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FORCEINLINE FOctreeChildNodeRef <span class="hljs-title">FOctreeNodeContext::GetContainingChild</span><span class="hljs-params">(<span class="hljs-type">const</span> FBoxCenterAndExtent&amp; QueryBounds)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>FOctreeChildNodeRef Result;<br><br><span class="hljs-comment">// Load the query bounding box values as VectorRegisters.</span><br><span class="hljs-type">const</span> VectorRegister QueryBoundsCenter = <span class="hljs-built_in">VectorLoadAligned</span>(&amp;QueryBounds.Center);<br><span class="hljs-type">const</span> VectorRegister QueryBoundsExtent = <span class="hljs-built_in">VectorLoadAligned</span>(&amp;QueryBounds.Extent);<br><br><span class="hljs-comment">// Compute the bounds of the node&#x27;s children.</span><br><span class="hljs-type">const</span> VectorRegister BoundsCenter = <span class="hljs-built_in">VectorLoadAligned</span>(&amp;Bounds.Center);<br><span class="hljs-type">const</span> VectorRegister ChildCenterOffsetVector = <span class="hljs-built_in">VectorLoadFloat1</span>(&amp;ChildCenterOffset);<br><span class="hljs-type">const</span> VectorRegister NegativeCenterDifference = <span class="hljs-built_in">VectorSubtract</span>(QueryBoundsCenter,<span class="hljs-built_in">VectorSubtract</span>(BoundsCenter,ChildCenterOffsetVector));<br><span class="hljs-type">const</span> VectorRegister PositiveCenterDifference = <span class="hljs-built_in">VectorSubtract</span>(<span class="hljs-built_in">VectorAdd</span>(BoundsCenter,ChildCenterOffsetVector),QueryBoundsCenter);<br><br><span class="hljs-comment">// If the query bounds isn&#x27;t entirely inside the bounding box of the child it&#x27;s closest to, it&#x27;s not contained by any of the child nodes.</span><br><span class="hljs-type">const</span> VectorRegister MinDifference = <span class="hljs-built_in">VectorMin</span>(PositiveCenterDifference,NegativeCenterDifference);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">VectorAnyGreaterThan</span>(<span class="hljs-built_in">VectorAdd</span>(QueryBoundsExtent,MinDifference),<span class="hljs-built_in">VectorLoadFloat1</span>(&amp;ChildExtent)))<br>&#123;<br>Result.<span class="hljs-built_in">SetNULL</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Return the child node that the query is closest to as the containing child.</span><br>Result.Index = <span class="hljs-built_in">VectorMaskBits</span>(<span class="hljs-built_in">VectorCompareGT</span>(QueryBoundsCenter, BoundsCenter)) &amp; <span class="hljs-number">0x7</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> Result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面用了很多SIMD操作，全都是向量操作</p><p>这个函数是在插入节点的时候用的AddElementInternal</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-type">const</span> FOctreeChildNodeRef ChildRef = NodeContext.<span class="hljs-built_in">GetContainingChild</span>(ElementBounds);<br>    <span class="hljs-keyword">if</span> (ChildRef.<span class="hljs-built_in">IsNULL</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> ElementIndex = TreeElements[CurrentNodeIndex].<span class="hljs-built_in">Emplace</span>(Element);<br>        <span class="hljs-built_in">SetElementId</span>(Element, <span class="hljs-built_in">FOctreeElementId2</span>(CurrentNodeIndex, ElementIndex));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        FNodeIndex ChildNodeIndex           = TreeNodes[CurrentNodeIndex].ChildNodes + ChildRef.Index;<br>        FOctreeNodeContext ChildNodeContext = NodeContext.<span class="hljs-built_in">GetChildContext</span>(ChildRef);<br>        <span class="hljs-built_in">AddElementInternal</span>(ChildNodeIndex, ChildNodeContext, ElementBounds, Element, TempElementStorage);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FOctreeChildNodeSubset"><a href="#FOctreeChildNodeSubset" class="headerlink" title="FOctreeChildNodeSubset"></a>FOctreeChildNodeSubset</h3><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p>ue5的子node不存储控件信息，而是在遍历的时候动态生成，因为子节点的空间信息完全由父节点决定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** Child node initialization constructor. */</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> FOctreeNodeContext <span class="hljs-title">GetChildContext</span><span class="hljs-params">(FOctreeChildNodeRef ChildRef)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    FBoxCenterAndExtent LocalBounds;<br>    VectorRegister ZeroW = <span class="hljs-built_in">MakeVectorRegister</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>);<br>    <span class="hljs-built_in">VectorStoreAligned</span>(<span class="hljs-built_in">VectorMultiply</span>(ZeroW, <span class="hljs-built_in">VectorAdd</span>(<span class="hljs-built_in">VectorLoadAligned</span>(&amp;Bounds.Center), <span class="hljs-built_in">GetChildOffsetVec</span>(ChildRef.Index))), &amp;LocalBounds.Center);<br>    <span class="hljs-built_in">VectorStoreAligned</span>(<span class="hljs-built_in">VectorMultiply</span>(ZeroW, <span class="hljs-built_in">VectorSetFloat1</span>(ChildExtent)), &amp;LocalBounds.Extent);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">FOctreeNodeContext</span>(LocalBounds);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第 302-308 行</span><br><span class="hljs-function">FOctreeNodeContext <span class="hljs-title">GetChildContext</span><span class="hljs-params">(FOctreeChildNodeRef ChildRef)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    FBoxCenterAndExtent LocalBounds;<br>    <br>    <span class="hljs-comment">// 子节点中心 = 父节点中心 + 偏移向量</span><br>    LocalBounds.Center = Bounds.Center + <span class="hljs-built_in">GetChildOffsetVec</span>(ChildRef.Index);<br>    <br>    <span class="hljs-comment">// 子节点范围 = ChildExtent（父节点已经预计算好）</span><br>    LocalBounds.Extent = ChildExtent;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">FOctreeNodeContext</span>(LocalBounds);<br>&#125;<br></code></pre></td></tr></table></figure><p>而且ue的八叉树的节点不是紧密排列的，节点之间有碰撞，可以看这个初始化方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">FOctreeNodeContext</span>(<span class="hljs-type">const</span> FBoxCenterAndExtent&amp; InBounds, uint32 InInCullBits, uint32 InOutCullBits)<br>    : <span class="hljs-built_in">Bounds</span>(InBounds), <span class="hljs-built_in">InCullBits</span>(InInCullBits), <span class="hljs-built_in">OutCullBits</span>(InOutCullBits)<br>&#123;<br>    <span class="hljs-comment">// A child node&#x27;s tight extents are half its parent&#x27;s extents, and its loose extents are expanded by 1/LoosenessDenominator.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> TightChildExtent = Bounds.Extent.X * <span class="hljs-number">0.5f</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> LooseChildExtent = TightChildExtent * (<span class="hljs-number">1.0f</span> + <span class="hljs-number">1.0f</span> / (<span class="hljs-type">float</span>)LoosenessDenominator);<br><br>    ChildExtent                  = LooseChildExtent;<br>    ChildCenterOffset            = Bounds.Extent.X - LooseChildExtent;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种有重叠的好处跨越边界的时候不会频繁改动，在重叠区比较稳定，重叠比例是1&#x2F;16，应该是epic的黑科技，这样做的目的</p><h1 id="参考笔记"><a href="#参考笔记" class="headerlink" title="参考笔记"></a>参考笔记</h1><p><a href="https://zhuanlan.zhihu.com/p/1968430320870221035">UE5的八叉树实现 - 南京周润发的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/1968430320870221035">UE5的八叉树实现 - 南京周润发的文章 - 知乎</a></p>]]></content>
    
    
    <summary type="html">UE的松散八叉树，非常多工程细节，非常的恐怖啊，但是学到了很多~</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>虚幻引擎UI的制作与优化</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8EUI%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8EUI%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2025-11-02T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Slate基础原理"><a href="#Slate基础原理" class="headerlink" title="Slate基础原理"></a>Slate基础原理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103220809121.png" alt="image-20251103220809121"></p><p>SWiget控件的类型</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103231436436.png" alt="image-20251103231436436"></p><p>Slot参数</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103234226397.png" alt="image-20251103234226397"></p><p>布局流程</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103234552015.png" alt="image-20251103234552015"></p><p>计算控件大小</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103234823698.png" alt="image-20251103234823698"></p><p>有一些函数会Prepass，比如字符串，这种无法预先知道大小</p><h1 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h1><p>一些基础的优化手段</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103235326259.png" alt="image-20251103235326259"></p><p>手机看不太清可以更激进</p><p>逻辑清晰的时候，可以override上述提到的，比如说计算size，直接给出答案或者缓存，可以加快速度</p><p>LayerId其实就是调用OnPaint的返回值</p><h2 id="无效盒"><a href="#无效盒" class="headerlink" title="无效盒"></a>无效盒</h2><p>会自动缓存</p><p>RetainerBox:其实就是比如说一个很复杂的图，我提前画好，之后每次都直接用这个就好了，但是会费一点内存</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251103235649170.png" alt="image-20251103235649170"></p><h2 id="在UI上显示模型"><a href="#在UI上显示模型" class="headerlink" title="在UI上显示模型"></a>在UI上显示模型</h2><p>UERT是什么？这个不太懂（需要查找一下）</p><p>AI解释：</p><h3 id="核心组件解释"><a href="#核心组件解释" class="headerlink" title="核心组件解释"></a>核心组件解释</h3><h4 id="1-SceneCaptureComponent2D"><a href="#1-SceneCaptureComponent2D" class="headerlink" title="1. SceneCaptureComponent2D"></a>1. SceneCaptureComponent2D</h4><ul><li><p>一个场景捕获组件，用于捕获场景的2D视图（相机视角）</p></li><li><p>类似于给场景拍一张照片&#x2F;截图</p></li><li><p>可以放在一个独立的场景或 Actor 中，让模型在视野中渲染</p></li></ul><h4 id="2-RT（Render-Target）"><a href="#2-RT（Render-Target）" class="headerlink" title="2. RT（Render Target）"></a>2. RT（Render Target）</h4><ul><li><p>这里指 Render Target（渲染目标），不是 Ray Tracing</p></li><li><p>一个纹理资源，用于存储渲染结果</p></li><li><p>SceneCaptureComponent2D 会把渲染内容输出到这个纹理上</p></li><li><p>在 UE 中通常是 TextureRenderTarget2D</p></li></ul><h4 id="3-Image-控件"><a href="#3-Image-控件" class="headerlink" title="3. Image 控件"></a>3. Image 控件</h4><ul><li><p>UI 中的图片控件（UMG&#x2F;Widget 中的 Image Widget）</p></li><li><p>可以显示纹理</p></li><li><p>把 Render Target 赋给 Image 控件，就能在 UI 中显示</p></li></ul><h3 id="工作原理流程"><a href="#工作原理流程" class="headerlink" title="工作原理流程"></a>工作原理流程</h3><p>3D模型 → SceneCaptureComponent2D捕获 → Render Target纹理 → Image控件显示</p><ol><li><p>放置模型和 SceneCaptureComponent2D</p></li><li><p>组件把模型的渲染结果输出到 Render Target</p></li><li><p>在蓝图中将 Render Target 赋给 Image 控件的 Brush 或 Texture</p></li></ol><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251104000147367.png" alt="image-20251104000147367"></p><h3 id="如何把这个Slate导出成UMG来使用？"><a href="#如何把这个Slate导出成UMG来使用？" class="headerlink" title="如何把这个Slate导出成UMG来使用？"></a>如何把这个Slate导出成UMG来使用？</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251104000751359.png" alt="image-20251104000751359"></p><h1 id="Brush和材质"><a href="#Brush和材质" class="headerlink" title="Brush和材质"></a>Brush和材质</h1><h3 id="Brush"><a href="#Brush" class="headerlink" title="Brush"></a>Brush</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20251104000827073.png" alt="image-20251104000827073"></p>]]></content>
    
    
    <summary type="html">学习一下优化</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>二重螺旋工作记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E4%BA%8C%E9%87%8D%E8%9E%BA%E6%97%8B%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E4%BA%8C%E9%87%8D%E8%9E%BA%E6%97%8B%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</id>
    <published>2025-11-02T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大秘境杀怪时间进度条"><a href="#大秘境杀怪时间进度条" class="headerlink" title="大秘境杀怪时间进度条"></a>大秘境杀怪时间进度条</h1><h2 id="svn提交"><a href="#svn提交" class="headerlink" title="svn提交"></a>svn提交</h2><p>【【大秘境】倒计时+杀怪进度UI—客户端】<br><a href="https://www.tapd.cn/31626021/prong/stories/view/1131626021001235215">https://www.tapd.cn/31626021/prong/stories/view/1131626021001235215</a></p><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><p>输入 gm completecondition 4220 解锁大秘境</p><p>gm EnterAbyss 2011011 10</p><p>直接进入大秘境，因为现在页面大秘境有点bug(好像又没了)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>之前有两个条，现在要把两个变成一个</p><p><strong>杀怪进度条</strong></p><p>Abyss_BattleProgress</p><p>AbysssComponent.lua，这个在这里面打开和关闭</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AbyssComponent:SetAbyssBattlePanelVisibility</span><span class="hljs-params">(IsShow)</span></span><br><span class="hljs-keyword">local</span> AbyssBattleUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;Abyss_BattleProgress&quot;</span>)<br><span class="hljs-keyword">if</span> AbyssBattleUI <span class="hljs-keyword">then</span><br>AbyssBattleUI:SetAbyssBattleVisibility(IsShow)<br><span class="hljs-keyword">else</span><br>DebugPrint(<span class="hljs-string">&quot;AbyssComponent:SetAbyssBattlePanelVisibility找不到AbyssBattleUI&quot;</span>, IsShow)<br>Traceback()<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>倒计时</strong></p><p>Abyss_CountDown</p><p>GameStateInterface.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-----------------------大秘境相关-----------------------------</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:AbyssBattle_Lua</span><span class="hljs-params">()</span></span><br>    DebugPrint(<span class="hljs-string">&quot;AbyssBattle_Lua&quot;</span>)<br>    <span class="hljs-keyword">local</span> AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> AbyssCountDownUI <span class="hljs-keyword">then</span><br>        AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):LoadUINew(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    AbyssCountDownUI:ShowAbyssCountDown(<span class="hljs-string">&quot;AbyssBattle&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:RemoveAbyssBattle_Lua</span><span class="hljs-params">()</span></span><br>    DebugPrint(<span class="hljs-string">&quot;RemoveAbyssBattle_Lua&quot;</span>)<br>    <span class="hljs-keyword">local</span> AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> AbyssCountDownUI <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    AbyssCountDownUI:HideAbyssCountDown(<span class="hljs-string">&quot;AbyssBattle&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:AbyssNextRoom_Lua</span><span class="hljs-params">()</span></span><br>    DebugPrint(<span class="hljs-string">&quot;AbyssNextRoom_Lua&quot;</span>)<br>    <span class="hljs-keyword">local</span> AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">if</span> AbyssCountDownUI <span class="hljs-keyword">then</span><br>        AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):LoadUINew(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    AbyssCountDownUI:ShowAbyssCountDown(<span class="hljs-string">&quot;AbyssNextRoom&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:RemoveAbyssNextRoom_Lua</span><span class="hljs-params">()</span></span><br>    DebugPrint(<span class="hljs-string">&quot;RemoveAbyssNextRoom_Lua&quot;</span>)<br>    <span class="hljs-keyword">local</span> AbyssCountDownUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;Abyss_CountDown_Progress&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> AbyssCountDownUI <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    AbyssCountDownUI:HideAbyssCountDown(<span class="hljs-string">&quot;AbyssNextRoom&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这些入口要改一下</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>活动界面有问题，我注释了一下排序就能打开了。</p><p>现在进入大秘境直接崩溃，不知道为啥</p><p>19:28</p><p>223163</p><p>222844</p><h3 id="Destruct"><a href="#Destruct" class="headerlink" title="Destruct()"></a>Destruct()</h3><p>这个玩意还要调一下父类的Destruct()，类似这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.Super.Destruct(<span class="hljs-built_in">self</span>)<br></code></pre></td></tr></table></figure><h3 id="LoadUI的问题"><a href="#LoadUI的问题" class="headerlink" title="LoadUI的问题"></a>LoadUI的问题</h3><p> LoadUI,parameter : 0, error msg : class UIState needed but got WBP_Abyss_Progress_C</p><p>要在蓝图的Graph的Class Setting里面，把class options的父类型变成UIState</p><h1 id="大秘境ESC界面"><a href="#大秘境ESC界面" class="headerlink" title="大秘境ESC界面"></a>大秘境ESC界面</h1><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h3><p><strong>调用接口</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">BP_UIManagerComponent_C:</span>ShowCommonPopupUI(PopupId, Params, ParentWidget)<br></code></pre></td></tr></table></figure><p>PopupId：通用弹窗表 的 ID</p><p>Params： 程序需要给进去的额外参数，可以覆盖表中的内容、填充数据、绑定回调等</p><p>ParentWidget： 关闭弹窗后，会重新Focus到ParentWidget上</p><p><strong>可以配置的参数</strong></p><p>可以看WPB_Common_Dialog_PC_C.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---@class Common_Dialog_Params_FundInfo</span><br><span class="hljs-comment">---@field FundId number @货币ID</span><br><span class="hljs-comment">---@field FundNeed number @需要的数量</span><br><br><span class="hljs-comment">---@class Common_Dialog_Params_ItemInfo </span><br><span class="hljs-comment">---@field ItemId number @物品ID</span><br><span class="hljs-comment">---@field ItemType string @物品类型[&quot;Weapon&quot; | &quot;Mod&quot; | &quot;Resource&quot;]</span><br><span class="hljs-comment">---@field ItemNum number @(可选)物品数量</span><br><span class="hljs-comment">---@field ItemNeed number @(可选)需要的物品数量</span><br><span class="hljs-comment">---@field ItemUuid number @(可选)物品的UuId</span><br><br><span class="hljs-comment">---@class Common_Dialog_Text03_ListViewContent </span><br><span class="hljs-comment">---@field Title string @标题</span><br><span class="hljs-comment">---@field Text string @文本内容</span><br><br><span class="hljs-comment">---@class Common_Dialog_Params_PageFlipInfo </span><br><span class="hljs-comment">---@field PageNumber number @页签总页数</span><br><span class="hljs-comment">---@field CurrentPage number @当前页签</span><br><br><span class="hljs-comment">---@class Common_Dialog_Params </span><br><span class="hljs-comment">---@field IsHideBg bool @(可选)显隐Bg_Switch,true隐藏，false显示</span><br><span class="hljs-comment">---@field Title string @(可选)弹窗标题，覆盖表中内容</span><br><span class="hljs-comment">---@field ShortText string @(可选)短文本内容，覆盖表中内容</span><br><span class="hljs-comment">---@field LongText string @(可选)长文本内容，覆盖表中内容</span><br><span class="hljs-comment">---@field HintText string @(可选)选择框文本内容，覆盖表中内容</span><br><span class="hljs-comment">---@field Text03_ListView Common_Dialog_Text03_ListViewContent[] @(可选) 带分割线的文本列表内容</span><br><span class="hljs-comment">---@field Tips string[] @(可选)Tip内容数组，覆盖表中内容</span><br><span class="hljs-comment">---@field HideItemTips bool @(可选) 初始化时是否隐藏Tip</span><br><span class="hljs-comment">---@field ItemList Common_Dialog_Params_ItemInfo[] @(可选)通用物品栏信息</span><br><span class="hljs-comment">---@field Funds Common_Dialog_Params_FundInfo[] @(可选)货币信息列表</span><br><span class="hljs-comment">---@field DynamicNodes table @(可选)动态挂接Widget列表，里面传组件实例</span><br><span class="hljs-comment">---@field ForbidLeftBtn bool @(可选) 设置左侧按钮禁用态</span><br><span class="hljs-comment">---@field ForbidRightBtn bool @(可选) 设置右侧按钮禁用态</span><br><span class="hljs-comment">---@field PageFlipInfo Common_Dialog_Params_PageFlipInfo @(可选) 如果为页签模式，页签的页数</span><br><span class="hljs-comment">---@field ForbiddenLeftCallbackObj table @(可选)左侧按钮禁用态点击回调的接收对象</span><br><span class="hljs-comment">---@field ForbiddenLeftCallbackFunction function @(可选)左侧按钮禁用态点击的回调</span><br><span class="hljs-comment">---@field ForbiddenRightCallbackObj table @(可选)右侧按钮禁用态点击回调的接收对象</span><br><span class="hljs-comment">---@field ForbiddenRightCallbackFunction function @(可选)右侧按钮禁用态点击的回调</span><br><span class="hljs-comment">---@field LeftCallbackObj table @(可选)左侧按钮回调的接收对象</span><br><span class="hljs-comment">---@field LeftCallbackFunction function @(可选)左侧按钮的回调</span><br><span class="hljs-comment">---@field RightCallbackObj table @(可选)右侧按钮回调的接收对象</span><br><span class="hljs-comment">---@field RightCallbackFunction function @(可选)右侧按钮的回调</span><br><span class="hljs-comment">---@field CloseBtnCallbackObj table @(可选)右上角关闭按钮回调的接收对象</span><br><span class="hljs-comment">---@field CloseBtnCallbackFunction function @(可选)右上角关闭按钮回调</span><br><span class="hljs-comment">---@field DontCloseWhenLeftBtnClicked bool @(可选)左侧按钮点击时不关闭弹窗</span><br><span class="hljs-comment">---@field DontCloseWhenRightBtnClicked bool @(可选)右侧按钮点击时不关闭弹窗</span><br><span class="hljs-comment">---@field OnKeyDownCallbackObj table @(可选)弹窗内按键回调的接收对象</span><br><span class="hljs-comment">---@field OnKeyDownCallbackFunction function @(可选)弹窗内按键时的回调</span><br><span class="hljs-comment">---@field DontPlayOutAnimation bool @(可选)关闭时不播放Out动画</span><br><span class="hljs-comment">---@field DontFocusParentWidget bool @(可选)关闭时不聚焦ParentWidget</span><br><span class="hljs-comment">---@field ShowParentTabCoin bool @(可选)显示父级Tab右上角的货币信息</span><br></code></pre></td></tr></table></figure><h3 id="弹窗的Tab怎么写"><a href="#弹窗的Tab怎么写" class="headerlink" title="弹窗的Tab怎么写"></a>弹窗的Tab怎么写</h3><p>self:BindDialogEvent(DialogEvent.OnTitleTabSelected, self.OnTabSelected)</p><p>这样绑一下然后写逻辑</p><h2 id="如何显示大秘境信息？"><a href="#如何显示大秘境信息？" class="headerlink" title="如何显示大秘境信息？"></a>如何显示大秘境信息？</h2><p>好像都放在Abyss.lua里面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Avatar.Abysses[AbyssId]<br></code></pre></td></tr></table></figure><p>如何拿AbyssId？</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_AbyssComponent_C:InitAbyssComponent</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.GameMode = <span class="hljs-built_in">self</span>:GetOwner()<br><br>    <span class="hljs-keyword">if</span> GWorld.GameInstance.TempAbyssInfo <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 支持用GM直接进入对应AbyssDungeonId和Difficulty的关卡</span><br>        <span class="hljs-built_in">self</span>.AbyssDungeonId = GWorld.GameInstance.TempAbyssInfo.AbyssDungeonId<br>        <span class="hljs-built_in">self</span>.AbyssDifficulty = GWorld.GameInstance.TempAbyssInfo.AbyssDifficulty<br>        GWorld.GameInstance.TempAbyssInfo = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">self</span>.AbyssLogicServerInfo = <span class="hljs-built_in">self</span>.GameMode.PreInitInfo<br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">self</span>.AbyssLogicServerInfo, <span class="hljs-string">&quot;BP_AbyssComponent_C 从逻辑服拿到的信息为空！&quot;</span>)<br>        DebugPrint(<span class="hljs-string">&quot;BP_AbyssComponent_C:InitAbyssComponent 从逻辑服拿到的信息 AbyssId&quot;</span>, <span class="hljs-built_in">self</span>.AbyssLogicServerInfo.AbyssId, <span class="hljs-string">&quot;AbyssLevelId&quot;</span>, <span class="hljs-built_in">self</span>.AbyssLogicServerInfo.AbyssLevelId, <span class="hljs-string">&quot;AbyssDungeonId&quot;</span>, <span class="hljs-built_in">self</span>.AbyssLogicServerInfo.AbyssDungeonId)<br>        <span class="hljs-built_in">self</span>.AbyssDungeonId = <span class="hljs-built_in">self</span>.AbyssLogicServerInfo.AbyssDungeonId<br>        <span class="hljs-built_in">self</span>.AbyssDifficulty = <span class="hljs-built_in">self</span>:GetAbyssDifficulty()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.GameMode:SetGameModeLevel(<span class="hljs-built_in">self</span>.AbyssDifficulty)<br><br>    <span class="hljs-built_in">self</span>.AbyssDungeonInfo = DataMgr.AbyssDungeon[<span class="hljs-built_in">self</span>.AbyssDungeonId]<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">self</span>.AbyssDungeonInfo, <span class="hljs-string">&quot;BP_AbyssComponent_C AbyssDungeon表读表失败！ AbyssDungeonId &quot;</span>..<span class="hljs-built_in">self</span>.AbyssDungeonId)<br><br>    <span class="hljs-built_in">self</span>.AbyssRoomIndex = <span class="hljs-number">0</span><br>    <span class="hljs-built_in">self</span>.CurRoomId = <span class="hljs-number">0</span><br>    DebugPrint(<span class="hljs-string">&quot;BP_AbyssComponent_C:InitAbyssComponent AbyssDungeonId&quot;</span>, <span class="hljs-built_in">self</span>.AbyssDungeonId, <span class="hljs-string">&quot;AbyssDifficulty&quot;</span>, <span class="hljs-built_in">self</span>.AbyssDifficulty)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里也有,这里是直接把所有的加载进来了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WBP_Abyss_Main_C:OnClickedAbyssModeSelectionCell</span><span class="hljs-params">(AbyssModeSelectionCell)</span></span><br>    <span class="hljs-keyword">if</span> AbyssModeSelectionCell.IsLocked <span class="hljs-keyword">then</span><br>        UIManager(<span class="hljs-built_in">self</span>):ShowUITip(UIConst.Tip_CommonToast, GText(DataMgr.AbyssSeason[AbyssModeSelectionCell.AbyssId].DifficultyLockToast))<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.SelectCell <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.SelectCell:UnSelected()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.SelectCell = AbyssModeSelectionCell<br>    <span class="hljs-built_in">self</span>.SelectCell:Selected()<br>    <span class="hljs-built_in">self</span>.SelectIndex = AbyssModeSelectionCell.Index<br>    <span class="hljs-built_in">self</span>.SelectAbyssId = AbyssModeSelectionCell.AbyssId<br>    <span class="hljs-built_in">self</span>:RefreshAbyssLevelInfo(<span class="hljs-built_in">self</span>.SelectAbyssId)<br>    <span class="hljs-built_in">self</span>:RefreshRewardBtnInfo(<span class="hljs-built_in">self</span>.SelectAbyssId)<br>    <span class="hljs-built_in">self</span>:RefreshTimerInfo(<span class="hljs-built_in">self</span>.SelectAbyssId)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这种子类Component里面的可以直接用TriggerDungeonComponentFun来拿到</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> HostageEid = <span class="hljs-built_in">self</span>.GameMode:TriggerDungeonComponentFun(<span class="hljs-string">&quot;GetHostageEid&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="通用按钮Close"><a href="#通用按钮Close" class="headerlink" title="通用按钮Close"></a>通用按钮Close</h1><h2 id="游戏运行时查看ui"><a href="#游戏运行时查看ui" class="headerlink" title="游戏运行时查看ui"></a>游戏运行时查看ui</h2><p>Window-&gt;Development Tool-&gt;WidgetReflector，然后鼠标带年纪</p><p>或者直接波浪号~，然后输出WidgetReflector也可以</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>这个就是关闭的时候，关闭太快了，没有显示出click动效，重新改一下脚本的逻辑就可以了，bind一个事件在动画播放完再执行就可以了</p><h1 id="Reward按钮增加手柄逻辑"><a href="#Reward按钮增加手柄逻辑" class="headerlink" title="Reward按钮增加手柄逻辑"></a>Reward按钮增加手柄逻辑</h1><p>Common_Button_Reward_PC.lua</p><p>给Reward增加切换手柄的时候切换图标的功能，按钮的绑定是页面自己做的，类似这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--手柄监听</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WBP_Abyss_Settle_P_C:Handle_OnGamePadDown</span><span class="hljs-params">(InKeyName)</span></span><br>    <span class="hljs-keyword">if</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Bottom&quot;</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">-- 下一关</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.Btn_NextStage:IsVisible() <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>:OnNextLevel()<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">elseif</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Left&quot;</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">--重新挑战</span><br>        <span class="hljs-built_in">self</span>:OnReplay()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">elseif</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Right&quot;</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">--退出到关卡信息界面</span><br>        <span class="hljs-built_in">self</span>:ReturnLevelInfoUI()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>主要的逻辑有以下两个</p><p>绑定切换时机</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 绑定输入设备切换的委托</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Common_Button_Reward_PC:BindInputMethodChangedDelegate</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> PlayerController = UE4.UGameplayStatics.GetPlayerController(<span class="hljs-built_in">self</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">local</span> GameInputModeSubsystem = UGameInputModeSubsystem.GetGameInputModeSubsystem(PlayerController)<br>    <span class="hljs-keyword">if</span> (IsValid(GameInputModeSubsystem)) <span class="hljs-keyword">then</span><br>        GameInputModeSubsystem.OnInputMethodChanged:Add(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnInputMethodChanged)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>设置Icon</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-------------------------------------------------------------------- 手柄图标部分 -------------------------------------------------------------------------</span><br><span class="hljs-comment">-- 设置手柄Icon样式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Common_Button_Reward_PC:SetGamePadImg</span><span class="hljs-params">(ImgShortPath, ImgLongPath)</span></span><br>    <span class="hljs-keyword">local</span> ImgPath, Img = <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">if</span> ImgShortPath <span class="hljs-keyword">and</span> ImgShortPath~=<span class="hljs-string">&quot;None&quot;</span> <span class="hljs-keyword">then</span><br>        ImgPath = UIUtils.UtilsGetKeyIconPathInGamepad(ImgShortPath, <span class="hljs-built_in">self</span>.CurGamepadName)<br>        Img = LoadObject(ImgPath)<br>    <span class="hljs-keyword">elseif</span> ImgLongPath <span class="hljs-keyword">then</span><br>        Img = LoadObject(ImgLongPath)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> IsValid(Img)) <span class="hljs-keyword">then</span><br>        DebugPrint(<span class="hljs-string">&quot;缺少图片资源: ImgPath = &quot;</span>, ImgPath, ImgShortPath, ImgLongPath)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.Img_GamePad:SetBrushResourceObject(Img)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="MOD界面手柄"><a href="#MOD界面手柄" class="headerlink" title="MOD界面手柄"></a>MOD界面手柄</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>svn</p><p><a href="https://www.tapd.cn/31626021/prong/stories/view/1131626021001228007">https://www.tapd.cn/31626021/prong/stories/view/1131626021001228007</a></p><h2 id="手柄对应"><a href="#手柄对应" class="headerlink" title="手柄对应"></a>手柄对应</h2><p>用SetDefaultGamePadImg对应的名字</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250222140734093.png" alt="image-20250222140734093"></p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>用这个接口:SetNavigationRuleExplicit，来设置不同widget之间的</p><p>ESC是默认</p><p>手柄的操作是模拟鼠标操作</p><p>禁止导航的就把可见性设置成HitTestInvisible，之后再设置回来就行了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.Sift:SetVisibility(UE4.ESlateVisibility.HitTestInvisible)<br></code></pre></td></tr></table></figure><h3 id="手柄切换即选中"><a href="#手柄切换即选中" class="headerlink" title="手柄切换即选中"></a>手柄切换即选中</h3><p>如果你想做一个切换并选中的功能，直接打开游戏，然后看他是哪个item，然后看OnListItemObjectSet</p><p>ListView可以用GetItemAt来获取Item，但是拿到的只是Object，如果要看ui保存在哪里，要看具体的Item子代码里面的OnListItemObjectSet，一般是UI，也可能会有其他名字，比如SelfWidget</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Content.UI = <span class="hljs-built_in">self</span><br></code></pre></td></tr></table></figure><p>然后再用BP_OnItemSelectionChanged</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:BP_OnItemSelectionChanged</span><span class="hljs-params">(IsSelected)</span></span><br>    <span class="hljs-built_in">self</span>.IsSelected = IsSelected<br>    <span class="hljs-keyword">if</span> IsSelected <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.ButtonArea:SetChecked(<span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>而且NavigateToIndex没法触发OnselectItem这个事件，必须要用SetSelectedIndex才行0.0</p><p>但是这个可以解决聚焦，不过再获取他的第一个了，直接NavigateToIndex就可以了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.List_Item:NavigateToIndex(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">OnFocusReceived</span><br></code></pre></td></tr></table></figure><h3 id="Key的创建"><a href="#Key的创建" class="headerlink" title="Key的创建"></a><strong>Key的创建</strong></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.Key_Talk_GamePad:CreateCommonKey(&#123;<br>    KeyInfoList=&#123;<br>        &#123;<br>            Type = <span class="hljs-string">&quot;Img&quot;</span>,<br>            ImgShortPath = <span class="hljs-string">&quot;A&quot;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="tab栏的可以添加移开焦点绑定"><a href="#tab栏的可以添加移开焦点绑定" class="headerlink" title="tab栏的可以添加移开焦点绑定"></a>tab栏的可以添加移开焦点绑定</h3><p>但要注意不要循环触发，所以可以用状态锁来处理一样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:OnResourceBarRemovedFromFocusPath</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.IsFocusOnResourceBar <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.IsProcessingFocusChange <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.IsProcessingFocusChange = <span class="hljs-literal">true</span><br>        <span class="hljs-built_in">self</span>.Mod_1:SetFocus()<br>        <span class="hljs-built_in">self</span>.IsFocusOnResourceBar = <span class="hljs-literal">false</span><br>        <span class="hljs-built_in">self</span>.IsProcessingFocusChange = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>绑定的写法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">ResourceBar:BindEvents(<span class="hljs-built_in">self</span>,&#123;<br>    OnRemovedFromFocusPath = <span class="hljs-built_in">self</span>.OnResourceBarRemovedFromFocusPath<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="一个单独控件加聚焦和丢失聚焦逻辑"><a href="#一个单独控件加聚焦和丢失聚焦逻辑" class="headerlink" title="一个单独控件加聚焦和丢失聚焦逻辑"></a>一个单独控件加聚焦和丢失聚焦逻辑</h3><h1 id="【手柄】升级熔炼"><a href="#【手柄】升级熔炼" class="headerlink" title="【手柄】升级熔炼"></a>【手柄】升级熔炼</h1><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.tapd.cn/31626021/prong/stories/view/1131626021001227992">https://www.tapd.cn/31626021/prong/stories/view/1131626021001227992</a></p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="手柄相关const"><a href="#手柄相关const" class="headerlink" title="手柄相关const"></a>手柄相关const</h3><p>Const.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 手柄按键相关接口</span><br>Const.GamepadSpecialLeft = <span class="hljs-string">&quot;Gamepad_Special_Left&quot;</span>         <span class="hljs-comment">-- 左菜单键</span><br>Const.GamepadSpecialRight = <span class="hljs-string">&quot;Gamepad_Special_Right&quot;</span>       <span class="hljs-comment">-- 右菜单键</span><br>Const.GamepadDPadLeft = <span class="hljs-string">&quot;Gamepad_DPad_Left&quot;</span>               <span class="hljs-comment">-- 左方向键</span><br>Const.GamepadDPadRight = <span class="hljs-string">&quot;Gamepad_DPad_Right&quot;</span>             <span class="hljs-comment">-- 右方向键</span><br>Const.GamepadDPadUp = <span class="hljs-string">&quot;Gamepad_DPad_Up&quot;</span>                   <span class="hljs-comment">-- 上方向键</span><br>Const.GamepadDPadDown = <span class="hljs-string">&quot;Gamepad_DPad_Down&quot;</span>               <span class="hljs-comment">-- 下方向键</span><br>Const.GamepadFaceButtonLeft = <span class="hljs-string">&quot;Gamepad_FaceButton_Left&quot;</span>   <span class="hljs-comment">-- Xbox X键</span><br>Const.GamepadFaceButtonRight = <span class="hljs-string">&quot;Gamepad_FaceButton_Right&quot;</span> <span class="hljs-comment">-- Xbox B键</span><br>Const.GamepadFaceButtonUp = <span class="hljs-string">&quot;Gamepad_FaceButton_Top&quot;</span>      <span class="hljs-comment">-- Xbox Y键</span><br>Const.GamepadFaceButtonDown = <span class="hljs-string">&quot;Gamepad_FaceButton_Bottom&quot;</span>   <span class="hljs-comment">-- Xbox A键</span><br>Const.GamepadLeftShoulder = <span class="hljs-string">&quot;Gamepad_LeftShoulder&quot;</span>        <span class="hljs-comment">-- 左肩键</span><br>Const.GamepadLeftTrigger = <span class="hljs-string">&quot;Gamepad_LeftTrigger&quot;</span>          <span class="hljs-comment">-- 左扳机</span><br>Const.GamepadRightShoulder = <span class="hljs-string">&quot;Gamepad_RightShoulder&quot;</span>      <span class="hljs-comment">-- 右肩键</span><br>Const.GamepadRightTrigger = <span class="hljs-string">&quot;Gamepad_RightTrigger&quot;</span>        <span class="hljs-comment">-- 右扳机</span><br>Const.GamepadRightThumbstick = <span class="hljs-string">&quot;Gamepad_RightThumbstick&quot;</span>  <span class="hljs-comment">-- 右摇杆按钮</span><br>Const.GamepadLeftThumbstick = <span class="hljs-string">&quot;Gamepad_LeftThumbstick&quot;</span>  <span class="hljs-comment">-- 左摇杆按钮</span><br></code></pre></td></tr></table></figure><p><strong>结构</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">Enhance = &#123;<br>    [CommonConst.ArmoryType.Weapon] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.CardLevel.CardLevel_C_WeaponComp&quot;</span>,<br>&#125;,<br><span class="hljs-comment">-- 升级</span><br>LevelUp = &#123;<br>    [CommonConst.ArmoryType.Weapon] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.Armory_CharOrWeaponLvup_Component&quot;</span>,<br>    [CommonConst.ArmoryType.Char] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.Armory_CharOrWeaponLvup_Component&quot;</span>,<br>    [CommonConst.ArmoryType.Mod] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.Mod.Armory_ModLevelUp_Component&quot;</span>,<br>    [CommonConst.ArmoryType.Pet] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.Armory_PetLvup_Component&quot;</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><p>第一个是熔炼，后面有两个升级</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">[CommonConst.ArmoryType.Mod] = <span class="hljs-string">&quot;BluePrints.UI.WBP.Armory.Mod.Armory_ModEnhance_Component&quot;</span>,<br></code></pre></td></tr></table></figure><p>这个是增幅</p><p>按键的转发用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.OnKeyDownComp <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">self</span>:OnKeyDownComp(MyGeometry, InKeyName)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>True</p><p>switcher切换</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.WidgetSwitcher_Key:SetActiveWidgetIndex(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="结算界面手柄bug"><a href="#结算界面手柄bug" class="headerlink" title="结算界面手柄bug"></a>结算界面手柄bug</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>gm EnterDungeon 90602</p><p>按L进入一个副本</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>WidgetBlueprint’&#x2F;Game&#x2F;UI&#x2F;WBP&#x2F;Settlement&#x2F;PC&#x2F;WBP_Settlement_P.WBP_Settlement_P’</p><h1 id="连线小游戏"><a href="#连线小游戏" class="headerlink" title="连线小游戏"></a>连线小游戏</h1><p>MiGongLogic</p><h1 id="神庙结算页面接手柄"><a href="#神庙结算页面接手柄" class="headerlink" title="神庙结算页面接手柄"></a>神庙结算页面接手柄</h1><p>命令</p><p>gm enterdungeon 80901</p><p>gm enterdungeon 80703</p><p>gm enterdungeon 80704</p><p>这傻逼结算界面和副本结算界面是同一个脚本，太变态了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> DungeonInfo.DungeonType <span class="hljs-keyword">and</span> DungeonInfo.DungeonType == <span class="hljs-string">&quot;Temple&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="如何拿一个物品的数量"><a href="#如何拿一个物品的数量" class="headerlink" title="如何拿一个物品的数量"></a>如何拿一个物品的数量</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Resource = Avatar.Resources[<span class="hljs-built_in">self</span>.RId] <span class="hljs-keyword">or</span> &#123;Count = <span class="hljs-number">0</span>&#125;<br><span class="hljs-built_in">self</span>.Text_Num:SetText(Resource.Count)<br></code></pre></td></tr></table></figure><h1 id="止流商店界面"><a href="#止流商店界面" class="headerlink" title="止流商店界面"></a>止流商店界面</h1><p>命令：gm openui ZhiliuEventTask</p><p>GM_Command.lua，可以先用这个编译一下试试</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250308150623903.png" alt="image-20250308150623903"></p><p>商店主页面其实也是支持不同Shop复用的，学习一下就可以了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---跳转到指定商店页面</span><br><span class="hljs-comment">---@param MainTabIdx number @商城主页面index</span><br><span class="hljs-comment">---@param SubTabIdx number @商城子页面index</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PageJumpUtils:JumpToShopPage</span><span class="hljs-params">(MainTabIdx, SubTabIdx, ShopItemId, ShopType)</span></span><br>    <span class="hljs-keyword">local</span> GameInstance = GWorld.GameInstance<br>    <span class="hljs-keyword">local</span> UIManager = GameInstance:GetGameUIManager()<br><br>    <span class="hljs-keyword">local</span> ShopMainPage = UIManager:GetUIObj(<span class="hljs-string">&quot;ShopMain&quot;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> ShopMainPage) <span class="hljs-keyword">then</span><br>        ShopMainPage = UIManager:LoadUINew(<span class="hljs-string">&#x27;ShopMain&#x27;</span>, MainTabIdx, SubTabIdx, ShopItemId, ShopType)<br>        UIManager:AddToJumpPageDeque(ShopMainPage)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">-- 已经存在的界面</span><br>        UIManager:PlaceJumpUIToTop(ShopMainPage, <span class="hljs-string">&quot;ShopMain&quot;</span>)<br>        ShopMainPage:InitShop(MainTabIdx, SubTabIdx, ShopItemId, ShopType)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>OpenUI,”ShopMain”,801,8010,ShopItemId,”FishingShop”</p><h2 id="如何动态加载bg"><a href="#如何动态加载bg" class="headerlink" title="如何动态加载bg"></a>如何动态加载bg</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:InitShopBG</span><span class="hljs-params">(ShopType)</span></span><br>    <span class="hljs-comment">-- 商店类型对应的背景路径</span><br>    <span class="hljs-keyword">local</span> bgPathMap = &#123;<br>        [<span class="hljs-string">&quot;ZhiLiuEntrust&quot;</span>] = <span class="hljs-string">&quot;/Game/UI/WBP/Activity/Widget/Shop/ShopBG/WBP_Activity_Shop_BG_ZhiliuEvent.WBP_Activity_Shop_BG_ZhiliuEvent&quot;</span><br>        <span class="hljs-comment">-- 可以在这里添加更多的商店类型和对应的背景路径</span><br>    &#125;<br>    <span class="hljs-comment">-- 获取背景路径，如果没有对应的则使用默认背景</span><br>    <span class="hljs-keyword">local</span> bgPath = bgPathMap[ShopType] <span class="hljs-keyword">or</span> bgPathMap[<span class="hljs-string">&quot;ZhiLiuEntrust&quot;</span>]<br>    <span class="hljs-keyword">local</span> WidgetClass = LoadClass(bgPath)<br>    <span class="hljs-built_in">self</span>.Group_BG:ClearChildren()<br>    <span class="hljs-keyword">if</span> WidgetClass <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> Widget = UE4.UWidgetBlueprintLibrary.Create(<span class="hljs-built_in">self</span>, WidgetClass)<br>        <span class="hljs-built_in">self</span>.Group_BG:AddChild(Widget)<br>        <span class="hljs-keyword">local</span> OverlaySlot = UE4.UWidgetLayoutLibrary.SlotAsOverlaySlot(Widget)<br>        OverlaySlot:SetPadding(FMargin(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>        OverlaySlot:SetHorizontalAlignment(EHorizontalAlignment.HAlign_Fill)<br>        OverlaySlot:SetVerticalAlignment(EVerticalAlignment.VAlign_Fill)<br>        Widget:PlayAnimation(Widget.In)<br>    <span class="hljs-keyword">else</span><br>        DebugPrint(<span class="hljs-string">&quot;Error: 无法加载商店背景: &quot;</span> .. bgPath)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>重点是设置这个</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">OverlaySlot:SetHorizontalAlignment(EHorizontalAlignment.HAlign_Fill)<br>OverlaySlot:SetVerticalAlignment(EVerticalAlignment.VAlign_Fill)<br></code></pre></td></tr></table></figure><h1 id="大秘境ESC界面-1"><a href="#大秘境ESC界面-1" class="headerlink" title="大秘境ESC界面"></a>大秘境ESC界面</h1><p>输入 gm completecondition 4220 解锁大秘境</p><p>gm EnterAbyss 2011011 10</p><p>直接进入大秘境，因为现在页面大秘境有点bug(好像又没了)</p><p>拿Icon</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> SlotType = SlotName2Type[EName]<br><span class="hljs-keyword">local</span> DataType = SlotType2DataType[SlotType]<br><span class="hljs-keyword">local</span> Unit = Avatar[DataType..<span class="hljs-string">&quot;s&quot;</span>][Uuid]<br><span class="hljs-keyword">local</span> UnitData = Unit:Data()<br><span class="hljs-keyword">local</span> Content = &#123;<br>    Icon = UnitData.Icon,<br>    GachaIcon = UnitData.GachaIcon,<br>    Uuid = Uuid,<br>&#125;<br>DungeonPanel:UpdateSlot(EName, Content)<br></code></pre></td></tr></table></figure><h1 id="进度条优化"><a href="#进度条优化" class="headerlink" title="进度条优化"></a>进度条优化</h1><p>现在是没有区分，现在的加载有三个部分，场景，特效，还有一些杂七杂八，在编辑器里面会卡场景，然后就一直是0，所以现在要改一下，比如0-50是场景，50-90是特效，杂七杂八是后面的</p><p>场景找沈旻晖，特效找吴志军</p><p>场景加载完会走这个尝试关loading，说白了所有需要等待的地方都会走tryendloading</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250314143210622.png" alt="image-20250314143210622"></p><p>场景</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250314143159646.png" alt="image-20250314143159646"></p><p>杂七杂八</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250314143145703.png" alt="image-20250314143145703"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br></code></pre></td></tr></table></figure><p>这个Load分为很多个，LevelLoad会自己管理这个进度条，但是WorldLevel不会，只会直接0-90，他们都继承这个EMLevelLoader</p><p>  GameState.bAssetsPreloading &#x3D; true</p><p>区域加载是BP_WorldLoader_C</p><h1 id="好友界面接手柄"><a href="#好友界面接手柄" class="headerlink" title="好友界面接手柄"></a>好友界面接手柄</h1><h1 id="公告接手柄"><a href="#公告接手柄" class="headerlink" title="公告接手柄"></a>公告接手柄</h1><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:OnAnalogValueChanged</span><span class="hljs-params">(MyGeometry,InAnalogInputEvent)</span></span><br>    <span class="hljs-keyword">local</span> InKey = UE4.UKismetInputLibrary.GetKey(InAnalogInputEvent)<br>    <span class="hljs-keyword">local</span> InKeyName = UE4.UFormulaFunctionLibrary.Key_GetFName(InKey)<br>    <span class="hljs-keyword">if</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_RightY&quot;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IsValid(<span class="hljs-built_in">self</span>.ItemDetailsWidget) <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> a = UKismetInputLibrary.GetAnalogValue(InAnalogInputEvent) * <span class="hljs-number">30</span><br>        <span class="hljs-keyword">local</span> CurScrollOffset = <span class="hljs-built_in">self</span>.ItemDetailsWidget.EMScrollBox_1:GetScrollOffset()<br>        <span class="hljs-keyword">local</span> ScrollOffset = <span class="hljs-built_in">math</span>.clamp(CurScrollOffset - a,<span class="hljs-number">0</span>, <span class="hljs-built_in">self</span>.ItemDetailsWidget.EMScrollBox_1:GetScrollOffsetOfEnd())<br>        <span class="hljs-built_in">self</span>.ItemDetailsWidget.EMScrollBox_1:SetScrollOffset(ScrollOffset)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> UWidgetBlueprintLibrary.Unhandled()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>得用ExecuteJavascript</p><p>是否可滚动</p><p>self.ScrollBox_List:GetScrollOffsetOfEnd()</p><p>ListView也用这个</p><p>SetScrollOffset</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:OnAnalogValueChanged</span><span class="hljs-params">(MyGeometry,InAnalogInputEvent)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.MaxListScrollOffset <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.MaxListScrollOffset = UIUtils.GetMaxScrollOffsetOfListView(<span class="hljs-built_in">self</span>.List_ScoreItem)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> InKey = UE4.UKismetInputLibrary.GetKey(InAnalogInputEvent)<br>    <span class="hljs-keyword">local</span> InKeyName = UE4.UFormulaFunctionLibrary.Key_GetFName(InKey)<br>    <span class="hljs-keyword">local</span> AddOffset = UKismetInputLibrary.GetAnalogValue(InAnalogInputEvent) * <span class="hljs-number">0.5</span><br>    <br>    <span class="hljs-comment">-- 死区</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(AddOffset) &lt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">then</span> <br>        <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.UnHandled()<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> InKeyName == <span class="hljs-string">&quot;Gamepad_RightY&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> CurScrollOffset = <span class="hljs-built_in">self</span>.List_ScoreItem:GetScrollOffset()<br>        <span class="hljs-keyword">local</span> ScrollOffset = <span class="hljs-built_in">math</span>.clamp(CurScrollOffset - AddOffset, <span class="hljs-number">0</span>, <span class="hljs-built_in">self</span>.MaxListScrollOffset)<br>        <span class="hljs-built_in">self</span>.List_ScoreItem:SetScrollOffset(ScrollOffset)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.UnHandled()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="地图gui迭代"><a href="#地图gui迭代" class="headerlink" title="地图gui迭代"></a>地图gui迭代</h1><p>要做一个随着鼠标一直动的东西，之前有一个WBP_Map_Select</p><p>区域地图看LevelMap_Wild_Dialog_PC_C.lua</p><h1 id="QA关卡静态点导出工具"><a href="#QA关卡静态点导出工具" class="headerlink" title="QA关卡静态点导出工具"></a>QA关卡静态点导出工具</h1><p>1EditorTool</p><p>写蓝图代码，加上在WCEditFunctionLibrary.h里面写函数，可以在蓝图里面直接用，然后蓝图的逻辑大概就是遍历所有Levels下面的文件，然后筛出里面带有Design的level</p><h1 id="历练等级活动界面"><a href="#历练等级活动界面" class="headerlink" title="历练等级活动界面"></a>历练等级活动界面</h1><p>gm openui TrainingLevel</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ActivityConfigData = DataMgr.EventMain[ActivityId]<br><br>ActivityPage = UIManager(<span class="hljs-built_in">self</span>):CreateWidgetAsync(ActivityPageName, CoroutineObj, ActivityConfigData.PCBluePrint)<br></code></pre></td></tr></table></figure><p>这个ActivitConfigData里面有蓝图数据</p><p>所以活动界面其实都是策划配置，这个Event.xlsx里面啥都能配，我只需要写这个页面的逻辑就可以了</p><h1 id="自定义tab"><a href="#自定义tab" class="headerlink" title="自定义tab"></a>自定义tab</h1><p>在这个tab定义的时候加一个ChildWidgetBPPath，然后Tabs这里面加一个icon，然后在自己的item里面新写一个脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua">    TabConfigData = &#123;<br>        PlatformName = PlatformName,<br>        Tabs = &#123;<br>            &#123;<br>                Text = GText(DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;Text&quot;</span>]),<br>                TabId = <span class="hljs-number">1</span>,<br>                Icon = DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;IconPath&quot;</span>]<br>            &#125;,<br>            &#123;<br>                Text = GText(DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">2</span>][<span class="hljs-string">&quot;Text&quot;</span>]),<br>                TabId = <span class="hljs-number">2</span>,<br>                Icon = DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">2</span>][<span class="hljs-string">&quot;IconPath&quot;</span>]<br>            &#125;,<br>            &#123;<br>                Text = GText(DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">3</span>][<span class="hljs-string">&quot;Text&quot;</span>]),<br>                TabId = <span class="hljs-number">3</span>,<br>                Icon = DataMgr[<span class="hljs-string">&quot;NoticeTab&quot;</span>][<span class="hljs-number">3</span>][<span class="hljs-string">&quot;IconPath&quot;</span>]<br>            &#125;<br>        &#125;,<br>        ChildWidgetBPPath = <span class="hljs-string">&quot;WidgetBlueprint&#x27;/Game/UI/WBP/Announcement/Widget/WBP_Announcement_TabItem.WBP_Announcement_TabItem&#x27;&quot;</span><br>    &#125;<br>&#125;<br>UIManager(GWorld.GameInstance):ShowCommonPopupUI(<span class="hljs-number">100134</span>, Params, ParentWidget, Coroutine)<br></code></pre></td></tr></table></figure><p>新写的如下</p><p>WBP_Annoucement_TabItem.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--</span><br><span class="hljs-comment">-- DESCRIPTION</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- @COMPANY **</span><br><span class="hljs-comment">-- @AUTHOR **</span><br><span class="hljs-comment">-- @DATE $&#123;date&#125; $&#123;time&#125;</span><br><span class="hljs-comment">--</span><br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;UnLua&quot;</span><br><br><span class="hljs-comment">---@type WBP_Announcement_TabItem_C</span><br><span class="hljs-keyword">local</span> M = Class(&#123;<span class="hljs-string">&quot;BluePrints.UI.WBP.Common.Tab.Widget.WBP_Com_TabSubItem01_P_C&quot;</span>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:Update</span><span class="hljs-params">(Idx, Info, PlatformDeviceName)</span></span><br>    M.Super.Update(<span class="hljs-built_in">self</span>, Idx, Info, PlatformDeviceName)<br>    <span class="hljs-built_in">self</span>.Icon_Tab:SetBrushFromTexture(LoadObject(Info.Icon))<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><h1 id="监听buff写ui"><a href="#监听buff写ui" class="headerlink" title="监听buff写ui"></a>监听buff写ui</h1><p>可以参考Battle_FeinaSkill.lua，主要是RegisterOnBuffsChangedDelegate、ReceiveOnBuffsChanged这两个函数</p><p>要手动解绑绑定，不然没法响应</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>:UnRegisterOnBuffsChangedDelegate()<br><span class="hljs-built_in">self</span>:K2_SetBuffsOwner(Owner)<br><span class="hljs-built_in">self</span>:RegisterOnBuffsChangedDelegate()<br></code></pre></td></tr></table></figure><p>widget也要改</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250407161507215.png"></p><p>removebuff</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GM_Command:RemoveBuff</span><span class="hljs-params">(BuffId, Eid)</span></span><br>    <span class="hljs-comment">-- 移除玩家身上的某个buff</span><br>    <span class="hljs-comment">-- example: gm RemoveBuff 101</span><br>    BuffId = <span class="hljs-built_in">tonumber</span>(BuffId)<br>    <span class="hljs-built_in">assert</span>(BuffId, <span class="hljs-string">&#x27;BuffId要填数字&#x27;</span>)<br>    <span class="hljs-built_in">assert</span>(DataMgr.Buff[BuffId], <span class="hljs-string">&#x27;找不到[&#x27;</span> .. <span class="hljs-built_in">tostring</span>(BuffId) .. <span class="hljs-string">&#x27;]对应的Buff&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Eid <span class="hljs-keyword">then</span><br>        Eid = <span class="hljs-built_in">self</span>.Player.Eid<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>:ServerBattleCommand(<span class="hljs-string">&#x27;RemoveBuff&#x27;</span>, Eid, BuffId)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GM_Command:AddBuff</span><span class="hljs-params">(BuffId,LastTime, Value, Eid)</span></span><br>    <span class="hljs-comment">-- 给某个对象添加buff</span><br>    <span class="hljs-comment">-- example: gm AddBuff 101 10</span><br><br>    BuffId = <span class="hljs-built_in">tonumber</span>(BuffId)<br>    Eid = <span class="hljs-built_in">tonumber</span>(Eid)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Eid <span class="hljs-keyword">then</span><br>        Eid = <span class="hljs-built_in">self</span>.Player.Eid<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">assert</span>(BuffId, <span class="hljs-string">&#x27;BuffId要填数字&#x27;</span>)<br>    <span class="hljs-built_in">assert</span>(DataMgr.Buff[BuffId], <span class="hljs-string">&#x27;找不到[&#x27;</span> .. <span class="hljs-built_in">tostring</span>(BuffId) .. <span class="hljs-string">&#x27;]对应的Buff&#x27;</span>)<br>    LastTime = <span class="hljs-built_in">tonumber</span>(LastTime)<br>    <span class="hljs-built_in">assert</span>(LastTime <span class="hljs-keyword">and</span> (LastTime ~= <span class="hljs-number">0</span>), <span class="hljs-string">&#x27;LastTime要填数字且不能为0&#x27;</span>)<br>    <span class="hljs-keyword">if</span> Value <span class="hljs-keyword">then</span><br>        Value = <span class="hljs-built_in">tonumber</span>(Value)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>:ServerBattleCommand(<span class="hljs-string">&#x27;AddBuff&#x27;</span>, Eid, BuffId, <span class="hljs-built_in">tonumber</span>(LastTime), Value)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="推理界面2-0"><a href="#推理界面2-0" class="headerlink" title="推理界面2.0"></a>推理界面2.0</h1><p>之前红点只记录了AnswerId,但现在有很多个问题同时有，所以得改，好像不对，answer其实是唯一的，好像不用改啊</p><p><strong>红点</strong></p><p>可能已经处理好了，但是还要处理每一个问题自身的红点</p><p>红点是否要记录上线下线？在reddot表里加一个本地缓存就好了</p><p><strong>多结局单结局，多选单选</strong></p><p>我现在理解的是结局指的是可能需要的线索ProbablyNeededAnswers，多选单选指的是需要提交的线索**(似乎还没配表)**</p><p><strong>跳到剧情</strong></p><p>有接口？</p><p><strong>选中和选择</strong></p><p>联想界面的奇怪的东西</p><p><strong>失败后的提示</strong></p><p>联想要有，怎么判断，有很多中情况</p><p>第一：不需要联想（没配，或者是已经齐全了）<strong>（通用提示）</strong></p><p>第二：需要联想，但是收集的线索不够，或者线索不全（文案包装）</p><p><strong>list</strong></p><p>任务标题怎么拿？（可能要加字段）</p><p><strong>这个显示时机是什么意思？</strong></p><p>现在的意思是说，一直都会有个人在讲话，但是会根据你选择的线索的各种情况，来显示不同的话，比如如果有关联可能会显示什么什么，如果不能联想可能会显示什么什么，…</p><p><strong>记录对方案的结果</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250407161955049.png"></p><p><strong>线索来源</strong></p><p>只有主问题的线索才有可能有来源，这个线索的来源是来自哪个子问题的推理结果</p><h1 id="光环mod"><a href="#光环mod" class="headerlink" title="光环mod"></a>光环mod</h1><p>判断条件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> HaloMod = DataMgr.Mod[<span class="hljs-built_in">self</span>.ParentWidget.ItemId]<br><span class="hljs-keyword">if</span> HaloMod.ApplySlot <span class="hljs-keyword">and</span> #HaloMod.ApplySlot == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> HaloMod.ApplySlot[<span class="hljs-number">1</span>] == <span class="hljs-number">9</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">self</span>.ParentWidget.Img_Aura:SetVisibility(ESlateVisibility.SelfHitTestInvisible)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">self</span>.ParentWidget.Img_Aura:SetVisibility(ESlateVisibility.Collapsed)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>需要改的地方</p><p>背包</p><p>WBP_Bag_Item_C</p><p>获得奖励</p><h1 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h1><p>最后是在bp_CharacterFashion这里面做的</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250408204849600.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250408204956644.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UMeshComponent::SetVectorParameterValueOnMaterials</span><span class="hljs-params">(<span class="hljs-type">const</span> FName ParameterName, <span class="hljs-type">const</span> FVector ParameterValue)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!bEnableMaterialParameterCaching)<br>    &#123;<br>        <span class="hljs-type">const</span> TArray&lt;UMaterialInterface*&gt; MaterialInterfaces = <span class="hljs-built_in">GetMaterials</span>();<br>        <span class="hljs-keyword">for</span> (int32 MaterialIndex = <span class="hljs-number">0</span>; MaterialIndex &lt; MaterialInterfaces.<span class="hljs-built_in">Num</span>(); ++MaterialIndex)<br>        &#123;<br>            UMaterialInterface* MaterialInterface = MaterialInterfaces[MaterialIndex];<br>            <span class="hljs-keyword">if</span> (MaterialInterface)<br>            &#123;<br>                UMaterialInstanceDynamic* DynamicMaterial = <span class="hljs-built_in">Cast</span>&lt;UMaterialInstanceDynamic&gt;(MaterialInterface);<br>                <span class="hljs-keyword">if</span> (!DynamicMaterial)<br>                &#123;<br>                    DynamicMaterial = <span class="hljs-built_in">CreateAndSetMaterialInstanceDynamic</span>(MaterialIndex);<br>                &#125;<br>                DynamicMaterial-&gt;<span class="hljs-built_in">SetVectorParameterValue</span>(ParameterName, ParameterValue);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (bCachedMaterialParameterIndicesAreDirty)<br>        &#123;<br>            <span class="hljs-built_in">CacheMaterialParameterNameIndices</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// Look up material index array according to ParameterName</span><br>        <span class="hljs-keyword">if</span> (FMaterialParameterCache* ParameterCache = MaterialParameterCache.<span class="hljs-built_in">Find</span>(ParameterName))<br>        &#123;<br>            <span class="hljs-type">const</span> TArray&lt;int32&gt;&amp; MaterialIndices = ParameterCache-&gt;VectorParameterMaterialIndices;<br>            <span class="hljs-comment">// Loop over all the material indices and update set the parameter value on the corresponding materials</span><br>            <span class="hljs-keyword">for</span> (int32 MaterialIndex: MaterialIndices)<br>            &#123;<br>                UMaterialInterface* MaterialInterface = <span class="hljs-built_in">GetMaterial</span>(MaterialIndex);<br>                <span class="hljs-keyword">if</span> (MaterialInterface)<br>                &#123;<br>                    UMaterialInstanceDynamic* DynamicMaterial = <span class="hljs-built_in">Cast</span>&lt;UMaterialInstanceDynamic&gt;(MaterialInterface);<br>                    <span class="hljs-keyword">if</span> (!DynamicMaterial)<br>                    &#123;<br>                        DynamicMaterial = <span class="hljs-built_in">CreateAndSetMaterialInstanceDynamic</span>(MaterialIndex);<br>                    &#125;<br>                    DynamicMaterial-&gt;<span class="hljs-built_in">SetVectorParameterValue</span>(ParameterName, ParameterValue);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><ul><li><p>全部放固态，不然根本工作不了，机械太垃圾了</p></li><li><p>尽量只更新Content，别更新Source，后者里面有cpp，每次更都要重新编译，慢的一批</p></li><li><p>强调一下，副本UI，客户端相关的东西，以及服务器相关的，不要从gameinstance上拿副本id,统一都去gamestate上用方法拿</p></li><li><p>想要拿到必须要勾上Is Variable</p></li></ul><p>Xbox手柄图</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250307145412350.png" alt="image-20250307145412350"></p><p>延迟一帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250317103119345.png" alt="image-20250317103119345"></p><p>深拷贝</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">BottomKeyInfo = CommonUtils.CopyTable(<span class="hljs-built_in">self</span>.BottomKeyInfo),<br></code></pre></td></tr></table></figure><p>不用这个会导致外面改的被改了</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">self.BottomKeyInfo = &#123;</span><br><span class="language-xml">    &#123;GamePadInfoList =  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">Type</span>=<span class="hljs-string">&quot;Img&quot;</span>, <span class="hljs-attr">ImgShortPath</span>=<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-attr">Owner</span>=self&#125;&#125;</span><span class="language-xml">, Desc = GText(&quot;UI_Controller_Check&quot;)&#125;,</span><br><span class="language-xml">    &#123;GamePadInfoList =  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">Type</span>=<span class="hljs-string">&quot;Img&quot;</span>, <span class="hljs-attr">ImgShortPath</span>=<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-attr">Owner</span>=self&#125;&#125;</span><span class="language-xml">, Desc = GText(&quot;UI_RougeLike_BlessingConfirm&quot;)&#125;,</span><br><span class="language-xml">    &#123;</span><br><span class="language-xml">        KeyInfoList = </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">Type</span>=<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;Esc&quot;</span>, <span class="hljs-attr">ClickCallback</span>=BackCb, <span class="hljs-attr">Owner</span>=self&#125;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">        GamePadInfoList = </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">Type</span>=<span class="hljs-string">&quot;Img&quot;</span>, <span class="hljs-attr">ImgShortPath</span>=<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-attr">ClickCallback</span>=BackCb, <span class="hljs-attr">Owner</span>=self&#125;&#125;</span><span class="language-xml">,</span><br><span class="language-xml">        Desc=GText(&quot;UI_BACK&quot;)</span><br><span class="language-xml">    &#125;,</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>这样竟然会循环引用，因为有个Owner&#x3D;self</p><p>如果阳神改的没问题的话，BP_GetDesiredFocusTarget这个会在界面收到聚焦和界面切换手柄时，主动做一次聚焦，聚焦的控件为BP_GetDesiredFocusTarget的返回值</p><p>设置光标可见性</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.GameInputModeSubsystem:SetNavigateWidgetVisibility(<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>刷新</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:OnUpdateUIStyleByInputTypeChange</span><span class="hljs-params">(CurInputDevice, CurGamepadName)</span></span><br>    <span class="hljs-keyword">if</span> CommonUtils.GetDeviceTypeByPlatformName(<span class="hljs-built_in">self</span>) == <span class="hljs-string">&quot;Mobile&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> CurInputDevice == ECommonInputType.MouseAndKeyboard <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>:ShowMouseAndKeyboardView()<br>    <span class="hljs-keyword">elseif</span> CurInputDevice == ECommonInputType.Gamepad <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>:ShowGamepadView()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>导出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">C:/WorkEngine/Engine/Binaries/Win64/UE4Editor-Cmd.exe E:\WorkGame\EM.uproject -run=RegionData -path=Content/Maps/Levels/Chapter01/Chapter01_Abyss_Boss01.umap<br></code></pre></td></tr></table></figure><p>HandLevelRegionLevel</p><p>播放音效</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">AudioManager(<span class="hljs-built_in">self</span>):SetEventSoundParam(<span class="hljs-built_in">self</span>, <span class="hljs-string">&quot;EnergySupplyOpen&quot;</span>, &#123;ToEnd = <span class="hljs-number">1</span>&#125;)<br><br>AudioManager(<span class="hljs-built_in">self</span>):PlayUISound(<span class="hljs-built_in">self</span>, <span class="hljs-string">&quot;event:/ui/common/click_btn_small&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p>可以在wcedit function library里面搞一下</p><p>接动态材质</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (Info.IconPath) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">local</span> Icon = LoadObject(Info.IconPath)<br>    <span class="hljs-keyword">local</span> Material = <span class="hljs-built_in">self</span>.Img_TabIcon:GetDynamicMaterial()<br>    Material:SetTextureParameterValue(<span class="hljs-string">&quot;Mask&quot;</span>, Icon)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>scrollbox无法拖动</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250331162722001.png" alt="image-20250331162722001"></p><p>查找是否staticmeshactor是否有不对的lightmaptype</p><p>使用方法是把全部的level都加载进来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UWCEditFunctionLibrary::ExportStaticMeshActorInfoFromWorld</span><span class="hljs-params">(UWorld* World)</span></span><br><span class="hljs-function"></span>&#123;<br>UWorld* CurrentWorld = World;<br><span class="hljs-keyword">if</span> (!CurrentWorld)<br>&#123;<br><span class="hljs-built_in">UE_LOG</span>(LogTemp, Log, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;JLY_ 111111111 Current World Is NUll &quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>TArray&lt;AActor*&gt; StaticMeshActors;<br><span class="hljs-comment">//UGameplayStatics::GetAllActorsOfClass(World, AStaticMeshActor::StaticClass(), StaticMeshActors);</span><br>UGameplayStatics::<span class="hljs-built_in">GetAllActorsOfClass</span>(GEditor-&gt;<span class="hljs-built_in">GetEditorWorldContext</span>().<span class="hljs-built_in">World</span>(), AStaticMeshActor::<span class="hljs-built_in">StaticClass</span>(), StaticMeshActors);<br><br><span class="hljs-comment">// 在for循环之前准备日志内容的开头部分</span><br>FString LogFileName = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;MeshData.log&quot;</span>);<br>FString SavePath = FPaths::<span class="hljs-built_in">ProjectContentDir</span>() + <span class="hljs-string">&quot;Script/Datas/QA_DesignLevel_data/ErrorLog&quot;</span>;<br>FString LogFilePath = FPaths::<span class="hljs-built_in">Combine</span>(SavePath, LogFileName);<br><br><span class="hljs-comment">// 创建新的日志内容</span><br>FString WorldName = World-&gt;<span class="hljs-built_in">GetName</span>();<br>FString NewLogContent = FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;关卡 %s 中存在以下LightmapType不为2的StaticMeshActor:\n\n&quot;</span>), *WorldName);<br><br><span class="hljs-type">bool</span> bFoundInvalidMeshes = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> StaticMeshActor : StaticMeshActors)<br>&#123;<br>AStaticMeshActor* MeshActor = <span class="hljs-built_in">Cast</span>&lt;AStaticMeshActor&gt;(StaticMeshActor);<br>UStaticMeshComponent* component = MeshActor-&gt;<span class="hljs-built_in">GetStaticMeshComponent</span>();<br><br><span class="hljs-keyword">if</span> (component-&gt;LightmapType == ELightmapType::ForceSurface) &#123;<br><span class="hljs-comment">// 只记录Actor的名称</span><br>NewLogContent += FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; 关卡%s - %s\n&quot;</span>), *MeshActor-&gt;<span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">GetName</span>() ,*MeshActor-&gt;<span class="hljs-built_in">GetName</span>());<br>bFoundInvalidMeshes = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 只有在找到不符合条件的Mesh时才写入日志</span><br><span class="hljs-keyword">if</span> (bFoundInvalidMeshes)<br>&#123;<br><span class="hljs-comment">// 确保目录存在</span><br>IFileManager::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">MakeDirectory</span>(*SavePath, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 读取现有日志内容（如果存在）</span><br>FString ExistingLogContent;<br>FFileHelper::<span class="hljs-built_in">LoadFileToString</span>(ExistingLogContent, *LogFilePath);<br><br><span class="hljs-comment">// 将新内容追加到现有内容后面</span><br>FString CombinedLogContent = ExistingLogContent + NewLogContent;<br><br><span class="hljs-comment">// 保存合并后的日志文件</span><br>FFileHelper::<span class="hljs-built_in">SaveStringToFile</span>(CombinedLogContent, *LogFilePath);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置光标透明度dun</p><p>0 是透明</p><p>1 是不透明</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.GameInputModeSubsystem:SetNavigateWidgetOpacity(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>button禁用态</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">SetForbidden<br></code></pre></td></tr></table></figure><p>运行时修改材质参数</p><p>SetScalarParameterValue是一个单变量</p><p>SetVectorParameterValue可以设置</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:SetDyeable</span><span class="hljs-params">(bDyeable)</span></span><br>    <span class="hljs-keyword">local</span> IconDynaMaterial = <span class="hljs-built_in">self</span>.Img_Item:GetDynamicMaterial()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IconDynaMaterial <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">if</span> bDyeable <span class="hljs-keyword">then</span><br>        IconDynaMaterial:SetScalarParameterValue(<span class="hljs-string">&quot;NonDye&quot;</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">self</span>:SetCornerColorAlpha(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span><br>        IconDynaMaterial:SetScalarParameterValue(<span class="hljs-string">&quot;NonDye&quot;</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">self</span>:SetCornerColorAlpha(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 新增函数：设置角落颜色的透明度</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:SetCornerColorAlpha</span><span class="hljs-params">(alphaValue)</span></span><br>    <span class="hljs-keyword">local</span> IconDynaMaterial = <span class="hljs-built_in">self</span>.Img_Item:GetDynamicMaterial()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> IconDynaMaterial <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">local</span> defaultColor = UE4.FLinearColor(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, alphaValue)<br>    IconDynaMaterial:SetVectorParameterValue(<span class="hljs-string">&quot;CornerColor&quot;</span>, defaultColor)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250414215853197.png" alt="材质示例"></p><p>获取这个值，K2_GetScalarParameterValue</p><p>长按短按</p><p>这个东西竟然是直接挂在BP_PlayerCharacter_C.lua上面的，在打开StartOpenMap这里多加了一个定时器来判断</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_PlayerCharacter_C:StartOpenMap</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.IsStartOpenMap = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> UIUtils.UtilsGetCurrentInputType() ~= ECommonInputType.Gamepad <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>:OpenMap()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> Avatar = GWorld:GetAvatar()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Avatar <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> Avatar:CheckUIUnlocked(<span class="hljs-string">&quot;Chat&quot;</span>) <span class="hljs-keyword">then</span> <br>        <span class="hljs-built_in">self</span>:OpenMap()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> BattleMainUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;BattleMain&quot;</span>)<br>    <span class="hljs-keyword">if</span> BattleMainUI <span class="hljs-keyword">and</span> BattleMainUI.Key_ChatEntry <span class="hljs-keyword">then</span> <br>        BattleMainUI.Key_ChatEntry:OnButtonPressed()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.LongPressThreshold = <span class="hljs-built_in">self</span>.LongPressThreshold <span class="hljs-keyword">or</span> <span class="hljs-number">0.8</span><br>    <span class="hljs-built_in">self</span>.ChatUpdateTimer = URuntimeCommonFunctionLibrary.K2_SetTimerDelegate(&#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.ChatUpdate&#125;, <span class="hljs-built_in">self</span>.LongPressThreshold, <span class="hljs-literal">true</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_PlayerCharacter_C:StopOpenMap</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.IsStartOpenMap <span class="hljs-keyword">then</span> <br>        <span class="hljs-built_in">self</span>.IsStartOpenMap = <span class="hljs-literal">false</span><br>        <span class="hljs-built_in">self</span>:OpenMap()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">self</span>.ChatUpdateTimer) <span class="hljs-keyword">then</span><br>        URuntimeCommonFunctionLibrary.K2_ClearAndInvalidateTimerHandle(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.ChatUpdateTimer)<br>        <span class="hljs-built_in">self</span>.ChatUpdateTimer = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> BattleMainUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;BattleMain&quot;</span>)<br>    <span class="hljs-keyword">if</span> BattleMainUI <span class="hljs-keyword">and</span> BattleMainUI.Key_ChatEntry <span class="hljs-keyword">then</span> <br>        BattleMainUI.Key_ChatEntry:OnButtonReleased()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_PlayerCharacter_C:ChatUpdate</span><span class="hljs-params">()</span></span><br>    ChatController:OpenView(<span class="hljs-built_in">self</span>,<span class="hljs-literal">true</span>)<br>    <span class="hljs-built_in">self</span>.IsStartOpenMap = <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后在PlayerCharacter.cpp上加点绑定就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;OpenMap&quot;</span>), IE_Pressed, &amp;APlayerCharacter::StartOpenMap);<br><span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;OpenMap&quot;</span>), IE_Released, &amp;APlayerCharacter::StopOpenMap);<br></code></pre></td></tr></table></figure><p>获得mod命令</p><p>sgm aom xxxx 获取指定Id的Mod</p><p>测试命令</p><p>gm SuccQuestChain 110109</p><p>gm SuccQuestChain 200227</p><h1 id="固定光消失问题"><a href="#固定光消失问题" class="headerlink" title="固定光消失问题"></a>固定光消失问题</h1><p>出现了一个很奇怪的问题，某些固定光会奇怪的只在editor里面显示，但是打包和运行起来就不对了，原因是勾了这个</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250520144907705.png" alt="image-20250520144907705"></p><h1 id="如何离开副本自动打开一个界面？"><a href="#如何离开副本自动打开一个界面？" class="headerlink" title="如何离开副本自动打开一个界面？"></a>如何离开副本自动打开一个界面？</h1><p>再进去的时候保存一下本地信息，然后AfterLoading这里会再写一个逻辑，根据保存的信息打开</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250521144140603.png" alt="image-20250521144140603"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250521144144132.png" alt="image-20250521144144132"></p><h1 id="要看手机场景的命令"><a href="#要看手机场景的命令" class="headerlink" title="要看手机场景的命令"></a>要看手机场景的命令</h1><p>stats.UseMapPhoneInPC true</p><h1 id="LevelProxy改完之后要看什么"><a href="#LevelProxy改完之后要看什么" class="headerlink" title="LevelProxy改完之后要看什么"></a>LevelProxy改完之后要看什么</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250521210021655.png" alt="image-20250521210021655"></p><p>看ArtData下面，每个这个Lod，点进去看看有没有什么奇怪的地方</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250521210052596.png" alt="image-20250521210052596"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250521210057095.png" alt="image-20250521210057095"></p><h1 id="东国探索活动"><a href="#东国探索活动" class="headerlink" title="东国探索活动"></a>东国探索活动</h1><p>用CommonQuestEvent里面的结构，这里之前是新手引导用的，</p><h2 id="前往"><a href="#前往" class="headerlink" title="前往"></a>前往</h2><p>这个之前已经有接口了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:GoToSystem</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> TaskConfigData = DataMgr.StarterQuestDetail[<span class="hljs-built_in">self</span>.QuestId]<br>    PageJumpUtils:JumpToTargetPageByJumpId(TaskConfigData.JumpUIId)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h1 id="ListView的一些注意事项"><a href="#ListView的一些注意事项" class="headerlink" title="ListView的一些注意事项"></a>ListView的一些注意事项</h1><p>ListView的Content可能会比显示的要多，所以通过GetDisplayEntryWidgets():Num()的index来用GetIndexAt()可能是有问题的，因为可能取到的是</p><p>想正确地取可以直接pairs来取</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> UIUtils.UtilsGetCurrentInputType() == ECommonInputType.Gamepad <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">for</span> i, Entry <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.Common_PolarityList_PC.List:GetDisplayedEntryWidgets()) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> Item = <span class="hljs-built_in">self</span>.Common_PolarityList_PC.List:GetItemAt(i)<br>        <span class="hljs-keyword">if</span> Entry <span class="hljs-keyword">then</span><br>            Entry:SetNavigationRuleCustom(EUINavigation.Up, &#123;<span class="hljs-built_in">self</span>,<span class="hljs-built_in">self</span>.OnUIPolarityListNavigationMod&#125;)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.needNavigation == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>                Entry:SetNavigationRuleExplicit(EUINavigation.Down, <span class="hljs-built_in">self</span>.List_Select_Mod)<br>            <span class="hljs-keyword">else</span><br>                Entry:SetNavigationRuleBase(EUINavigation.Down, EUINavigationRule.Stop)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">self</span>.Common_PolarityList_PC.List:GetDisplayedEntryWidgets():Num() <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">if</span> Entry <span class="hljs-keyword">then</span><br>                Entry:SetNavigationRuleBase(EUINavigation.Right, EUINavigationRule.Stop)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="看资产模型lod问题"><a href="#看资产模型lod问题" class="headerlink" title="看资产模型lod问题"></a>看资产模型lod问题</h1><p>全选所有静态模型，跑脚本，然后看lod1和lod2差距大不大</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250523111435520.png" alt="image-20250523111435520"></p><p>然后这个脚本可能创建新的贴图，这个也要上传</p><h1 id="领奖活动"><a href="#领奖活动" class="headerlink" title="领奖活动"></a>领奖活动</h1><h2 id="条件如何判断"><a href="#条件如何判断" class="headerlink" title="条件如何判断"></a>条件如何判断</h2><p>应该是用这个</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConditionUtils.CheckCondition</span><span class="hljs-params">(Avatar, ConditionIds, bShowFailed)</span></span><br></code></pre></td></tr></table></figure><h2 id="活动如何加红点？"><a href="#活动如何加红点？" class="headerlink" title="活动如何加红点？"></a>活动如何加红点？</h2><p>在ActivityUtils.lua里面</p><h1 id="神奇的函数调用方式"><a href="#神奇的函数调用方式" class="headerlink" title="神奇的函数调用方式"></a>神奇的函数调用方式</h1><p>最简单的是用点号和冒号调用，这个也很容理解</p><h2 id="动态函数调用"><a href="#动态函数调用" class="headerlink" title="动态函数调用"></a>动态函数调用</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConditionUtils.CheckConditionInternal</span><span class="hljs-params">(Avatar, ConditionId, ConditionCheckId)</span></span><br>    <span class="hljs-keyword">local</span> ConditionInfo = DataMgr.Condition[ConditionId]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ConditionInfo <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> Logic = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">lower</span>(ConditionInfo.ConditionLogic)<br>    <span class="hljs-keyword">if</span> Logic == <span class="hljs-string">&quot;and&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> Condition, List <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(ConditionInfo.ConditionMap) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, #List <span class="hljs-keyword">do</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ConditionUtils[<span class="hljs-string">&quot;Judge&quot;</span>..Condition](Avatar, List[i], ConditionCheckId) <span class="hljs-keyword">then</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">elseif</span> Logic == <span class="hljs-string">&quot;or&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> Condition, List <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(ConditionInfo.ConditionMap) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, #List <span class="hljs-keyword">do</span><br>                <span class="hljs-keyword">if</span> ConditionUtils[<span class="hljs-string">&quot;Judge&quot;</span>..Condition](Avatar, List[i], ConditionCheckId) <span class="hljs-keyword">then</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;UnExpected ConditionLogic: &quot;</span>..Logic)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个地方ConditionUtils[“Judge”..Condition]就是调用下面的函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConditionUtils:JudgePlayerLevelMin</span><span class="hljs-params">(Params)</span></span><br>    <span class="hljs-keyword">if</span> GWorld:IsSkynetServer() <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> IsDedicatedServer(GWorld.GameInstance) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.Level &gt;= Params<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="社区关注活动"><a href="#社区关注活动" class="headerlink" title="社区关注活动"></a>社区关注活动</h1><p>ServerInfo.Area</p><p>avatar.hostnum</p><p>是你的hostnum</p><p>然后去devserverlist下</p><p>找对应的area</p><p>可以知道你是哪个大区</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250605143412009.png" alt="image-20250605143412009"></p><p>如何区分b服和官服</p><p>从avatar.channelid去判断</p><p>去commonconst.channels去查你的channel渠道</p><h1 id="东陆探索活动"><a href="#东陆探索活动" class="headerlink" title="东陆探索活动"></a>东陆探索活动</h1><p>需要新增一个跳转的页面</p><p>在InterfaceJump里面新增一个类型</p><p>然后在PageJumpUtils.lua的JumpToTargetPageByJumpId新增类型</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250606141557474.png" alt="image-20250606141557474"></p><p>表的位置CommonQuestEvent</p><h1 id="通用活动结算界面"><a href="#通用活动结算界面" class="headerlink" title="通用活动结算界面"></a>通用活动结算界面</h1><p>退出和继续的接口</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">------------------------ 接收结算面板调用 -------------------------</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:ContinueDungeonSettlement</span><span class="hljs-params">(BattleInfo, Callback, TicketId, SquadId)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsInDungeon() <span class="hljs-keyword">then</span><br><span class="hljs-built_in">self</span>:EnterDungeon(BattleInfo, <span class="hljs-literal">nil</span>, Callback, <span class="hljs-literal">nil</span>, TicketId, SquadId)<br><span class="hljs-keyword">elseif</span> <span class="hljs-built_in">self</span>:IsInHardBoss() <span class="hljs-keyword">then</span><br><span class="hljs-built_in">self</span>:EnterHardBoss(BattleInfo.HardBossId, BattleInfo.DifficultyId, Callback)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:ExitDungeonSettlement</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsInDungeon() <span class="hljs-keyword">then</span><br><span class="hljs-built_in">self</span>:ExitDungeon()<br><span class="hljs-keyword">elseif</span> <span class="hljs-built_in">self</span>:IsInHardBoss() <span class="hljs-keyword">then</span><br><span class="hljs-built_in">self</span>:ExitHardBoss()<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="推理获得线索接口"><a href="#推理获得线索接口" class="headerlink" title="推理获得线索接口"></a>推理获得线索接口</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--解锁推理线索RPC</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:DetectiveQuestionUnlockAnswer</span><span class="hljs-params">(Answer)</span></span><br>    DebugPrint(<span class="hljs-string">&quot;DetectiveQuestionUnlockAnswer&quot;</span>, Answer)<br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cb</span><span class="hljs-params">(ErrCode)</span></span><br>        DebugPrint(<span class="hljs-string">&quot;DetectiveQuestionUnlockAnswer Cb&quot;</span>,ErrorCode:Name(ErrCode))<br>        <span class="hljs-keyword">if</span> ErrCode == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> DetectiveMinigameUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;DetectiveMinigame&quot;</span>)<br>            <span class="hljs-keyword">local</span> ItemInformationUI = UIManager(<span class="hljs-built_in">self</span>):GetUIObj(<span class="hljs-string">&quot;ItemInformation&quot;</span>)<br>            <span class="hljs-comment">-- 推理界面没开的时候跳tips，推理界面内获得的线索在推理界面内处理</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> DetectiveMinigameUI <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> ItemInformationUI <span class="hljs-keyword">then</span><br>                UIManager(<span class="hljs-built_in">self</span>):LoadUINew(<span class="hljs-string">&quot;DetectiveMinigameTips&quot;</span>, Answer)<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-comment">-- 任务节点用Callback</span><br>            <span class="hljs-built_in">self</span>:DoAnswerTaskNodeCallback(Answer)<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ReddotManager.GetTreeNode(<span class="hljs-string">&quot;DetectiveAnswer&quot;</span>) <span class="hljs-keyword">then</span><br>                ReddotManager.AddNode(<span class="hljs-string">&quot;DetectiveAnswer&quot;</span>)<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">local</span> CacheKey = Answer<br>            <span class="hljs-keyword">local</span> CacheDetail = ReddotManager.GetLeafNodeCacheDetail(<span class="hljs-string">&quot;DetectiveAnswer&quot;</span>)<br>            <span class="hljs-keyword">if</span> CacheDetail <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">if</span> CacheDetail[CacheKey] == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>                    CacheDetail[CacheKey] = <span class="hljs-literal">true</span><br>                    ReddotManager.IncreaceLeafNodeCount(<span class="hljs-string">&quot;DetectiveAnswer&quot;</span>)<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>:CallServer(<span class="hljs-string">&quot;RpcDetectiveQuestionUnlockAnswer&quot;</span>,Cb,Answer)<br><br>    <span class="hljs-comment">-- 在这儿弹新线索</span><br>    EventManager:FireEvent(EventID.OnHomeBaseeBtnShowNewClue, <span class="hljs-string">&quot;TaskPanel&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="条件断点如何断FString"><a href="#条件断点如何断FString" class="headerlink" title="条件断点如何断FString"></a>条件断点如何断FString</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">wcscmp((TCHAR*)Str1.Data.AllocatorInstance.Data,L<span class="hljs-string">&quot;Str2&quot;</span>)==<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>Str1是被比较的字符串变量，”Str2”是字符串常量，替换成你想要比较的值</p><h1 id="ListView通过代码更改子Item的类型"><a href="#ListView通过代码更改子Item的类型" class="headerlink" title="ListView通过代码更改子Item的类型"></a>ListView通过代码更改子Item的类型</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ItemClass = LoadClass(<span class="hljs-string">&quot;WidgetBlueprint&#x27;/Game/UI/WBP/Activity/Widget/Settlement/WBP_Activity_Settlement_ScoreItem_2.WBP_Activity_Settlement_ScoreItem_2&#x27;&quot;</span>)<br><span class="hljs-keyword">if</span> ItemClass <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">self</span>.List_ScoreItem.EntryWidgetClass = ItemClass<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="NPC交互图标是怎么改的"><a href="#NPC交互图标是怎么改的" class="headerlink" title="NPC交互图标是怎么改的"></a>NPC交互图标是怎么改的</h1><p>首先，stl有一个行为可以刷新静态点，ChangeStaticCreatorNode，然后静态刷新点，可以配置刷新出来的Actor是什么，这个就是NPC上面的， 具体就可以看NPC.xlsx里面了，然后NPC上面有一个交互组件：BP_NpcTalkInteractiveComponent_C，初始化代码如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_NpcTalkInteractiveComponent_C:Init</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.bIsInit = <span class="hljs-literal">true</span><br>    <span class="hljs-built_in">self</span>:SetInteractiveName(<span class="hljs-built_in">self</span>.Owner.NpcData.UnitName)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.Owner.NpcData.CommonUIConfirmID <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>:InitCommonUIConfirmID(<span class="hljs-built_in">self</span>.Owner.NpcData.CommonUIConfirmID)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.InteractiveTag = <span class="hljs-string">&quot;Interactive&quot;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里是改变这个Component的CommonUIConfirmID</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_InteractiveBaseComponent_C:InitCommonUIConfirmID</span><span class="hljs-params">(CommonUIConfirmID)</span></span><br><span class="hljs-built_in">self</span>.CommonUIConfirmID = CommonUIConfirmID<br><span class="hljs-keyword">local</span> Data = DataMgr.CommonUIConfirm[CommonUIConfirmID]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Data <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">self</span>.InteractiveDistance = Data.InteractiveRadius <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveDistance<br><span class="hljs-built_in">self</span>.InteractiveAngle = Data.InteractiveAngle <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveAngle<br><span class="hljs-built_in">self</span>.InteractiveFaceAngle = Data.PlayerFaceAngle <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveFaceAngle<br><span class="hljs-built_in">self</span>.ListPriority = Data.InteractivePriority <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>因为拿Icon是根据这个拿的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--- 根据配置的ID获取Icon，有特殊需求的在子类中重写</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_InteractiveBaseComponent_C:GetInteractiveIcon</span><span class="hljs-params">(PlayerActor)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsLocked() <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Texture2D&#x27;/Game/UI/Texture/Dynamic/Atlas/Interactive/T_Interactive_Lock.T_Interactive_Lock&#x27;&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsForbidden(PlayerActor) <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Texture2D&#x27;/Game/UI/Texture/Dynamic/Atlas/Interactive/T_Interactive_Forbidden.T_Interactive_Forbidden&#x27;&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> Data = DataMgr.CommonUIConfirm[<span class="hljs-built_in">self</span>.CommonUIConfirmID]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Data <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> Data.Icon <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> Data.Icon<br>    <span class="hljs-comment">-- local ImageResource = LoadObject(Data.Icon)</span><br>    <span class="hljs-comment">-- return ImageResource</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>所以只要在NPC表新增一列就可以了，不过这个只有NPC对话组件能用，其他的等以后有需求再说</p><p>后续：大佬们觉得这个改动有点大，就不动了， 所以策划直接改生成的NPC类型就可以了，太好了</p><h1 id="新增一种通用Tab类型"><a href="#新增一种通用Tab类型" class="headerlink" title="新增一种通用Tab类型"></a>新增一种通用Tab类型</h1><p>复制WBP_Com_Tab_P_C.lua和WBP_Com_Tab_M_C.lua</p><p>很多换一下名字就好了</p><p>然后聊天直接全部注释了，为了以防万一他们之后要加聊天，Group_Chat相关</p><p>然后没有切换的快捷键了，这个只能点击，没有qe和手柄的快捷键，手柄也全凭虚拟光标，这个的影响是先把Key_Left和Key_Right相关的删了，然后还要删keydown吧</p><p>阵容配置肯定是没了，Entrance_Build</p><h1 id="手柄聚焦SetFocus和SetUserFocus"><a href="#手柄聚焦SetFocus和SetUserFocus" class="headerlink" title="手柄聚焦SetFocus和SetUserFocus"></a>手柄聚焦SetFocus和SetUserFocus</h1><ol><li><h1 id="聚焦的相关接口"><a href="#聚焦的相关接口" class="headerlink" title="聚焦的相关接口"></a>聚焦的相关接口</h1></li></ol><p>聚焦到某个控件:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable language_">self</span>.<span class="hljs-title class_">Btn</span><span class="hljs-symbol">:SetFocus</span>()<br></code></pre></td></tr></table></figure><p>或者在处理输入事件时返回<code>SetUserFocus</code>回复（建议使用此方法设置聚焦）。</p><p>由于<code>SetUserFocus</code>第一个参数是引用，传进去的值可能被修改，因此尽量传用新构造的事件回复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Plain">正确的用法：<br>function M:OnKeyDown(MyGeometry, InKeyEvent)<br>    return UWidgetBlueprintLibrary.SetUserFocus(UWidgetBlueprintLibrary.Handled(),self.Btn)<br>end<br><br>错误的用法，这种写法会导致后面使用self.Handled时出现意料之外的情况：<br>function M:OnKeyDown(MyGeometry, InKeyEvent)<br>    return UWidgetBlueprintLibrary.SetUserFocus(self.Handled,self.Btn)<br>end<br></code></pre></td></tr></table></figure><p><strong>Q:</strong><code>SetFocus</code>和 <code>SetUserFocus</code>有什么区别？</p><p>**A:**功能上没有区别，区别在于程序设计思路。<code>SetFocus</code>可以在任意位置调用，过于自由，如果使用者滥用<code>SetFocus</code>很容易造成抢聚焦的情况。一个经典的场景：A界面在B界面的下层，由于某些事件导致A界面数据刷新，而A的刷新逻辑里使用了<code>SetFocus</code>。而<code>SetUserFocus</code>基本不会出现这种情况，因为它只能在输入事件里作为返回值调用，可以保证每次聚焦变化必定跟随在一次输入之后，又由于没有聚焦的控件一般不会接受到输入事件，从而可以在程序设计阶段就避免抢聚焦的问题。</p><h1 id="武器密券活动模板"><a href="#武器密券活动模板" class="headerlink" title="武器密券活动模板"></a>武器密券活动模板</h1><p>用了之前的条件领奖</p><p>打开预览界面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">UIManager(<span class="hljs-built_in">self</span>):LoadUINew(<span class="hljs-string">&quot;ArmoryDetail&quot;</span>,&#123;PreviewCharIds = &#123;CharId&#125;,<br>                                            bHideCharAppearance = <span class="hljs-literal">true</span>,<br>                                            bHideWeaponAppearance = <span class="hljs-literal">true</span>,<br>                                            EPreviewSceneType = CommonConst.EPreviewSceneType.PersonInfo,<br>                                            OnCloseDelegate = <span class="hljs-literal">nil</span>&#125;)<br></code></pre></td></tr></table></figure><h1 id="listview填充空态"><a href="#listview填充空态" class="headerlink" title="listview填充空态"></a>listview填充空态</h1><p> <strong>2025&#x2F;01&#x2F;22更新  EMListView和EMTileView集成了空态填充接口，可以傻瓜式接入，以下是新接口的使用步骤：</strong></p><ol><li><strong>你需要在界面Construct函数里先绑定委托，给列表获取空态的Content，（注意需要在Destruct里Unbind该委托）</strong></li></ol><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/asynccode" alt="img"></p><ol><li><strong>在你的列表填充完数据的代码之后来一句 RequestFillEmptyContent，就能无脑实现空态填充了</strong></li></ol><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/asynccode" alt="img"></p><p>如果是通用道具框，jiu这样写Content</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Content.Id = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="mod系统手柄优化"><a href="#mod系统手柄优化" class="headerlink" title="mod系统手柄优化"></a>mod系统手柄优化</h1><p>现在主要的改变就是进去会自动选中这个mod，但这个选中只是右边有提示，真正开始选还是要按A，然后进入选中态之后这里显然是要变的</p><p>这里要改的是上下两个mod的选中逻辑</p><p>Armory_Mod_C.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 手柄有额外逻辑</span><br>ArmoryMod:HandleGamepadModSelection(Content)<br></code></pre></td></tr></table></figure><p>Armory_Mod_Slot_C.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 手柄有额外逻辑</span><br><span class="hljs-keyword">if</span> (UIUtils.UtilsGetCurrentInputType() == ECommonInputType.Gamepad) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> ModModel:IsInPolarityEditMode() <span class="hljs-keyword">or</span> ModModel:IsModUIPreview() <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> Handled<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> GamePadSelectedStuff = ModModel:GetGamePadSelectedStuff()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> GamePadSelectedStuff <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> GamePadSelectedStuff.ModUuid) <span class="hljs-keyword">then</span><br>        ModModel:SetGamePadSelectedStuff(<span class="hljs-built_in">self</span>.SlotUIData.ModEid, <span class="hljs-built_in">self</span>.SlotUIData.SlotId)<br>        <span class="hljs-keyword">local</span> Item = <span class="hljs-built_in">self</span>.Parent.List_Select_Mod:GetItemAt(<span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">self</span>.Parent.List_Select_Mod:BP_SetSelectedItem(Item)<br>        Item.UI:SetFocus()<br>    <span class="hljs-keyword">elseif</span> (GamePadSelectedStuff.ModUuid) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> (GamePadSelectedStuff.SlotId) <span class="hljs-keyword">then</span><br>            ModController:SendExchangeMod(ModModel:GetTarget(), GamePadSelectedStuff.SlotId, <span class="hljs-built_in">self</span>.SlotUIData.SlotId)<br>        <span class="hljs-keyword">else</span><br>            ModController:SendChangeMod(ModModel:GetTarget(), <span class="hljs-built_in">self</span>.SlotUIData.SlotId, GamePadSelectedStuff.ModUuid)<br>        <span class="hljs-keyword">end</span><br>        ModModel:SetGamePadSelectedStuff(<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>)<br>        <span class="hljs-built_in">self</span>.Parent:RecoverFromGamepad()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后这里需要根据是否选中了mod，在mouseenter的时候有不同的逻辑，这个之前也有类似的，因为我选中的时候会设置一下SetGamePadSelectedStuff</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 先判断一下是不是选中mod的状态</span><br><span class="hljs-keyword">if</span>(ModModel:GetGamePadSelectedStuff()) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Top&quot;</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">-- Y键</span><br>        ModController:OpenModIntensify()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">elseif</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Left&quot;</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">-- X键</span><br>        <span class="hljs-keyword">local</span> EquipedSlotId = ModModel:GetSelectStuff().SlotId<br>        <span class="hljs-keyword">if</span> EquipedSlotId <span class="hljs-keyword">then</span><br>            ModController:SendTakeOffMod(ModModel:GetTarget(), EquipedSlotId)<br>        <span class="hljs-keyword">else</span><br>            ModController:QuickEquipMod(ModModel:GetSelectStuff().ModUuid)<br>        <span class="hljs-keyword">end</span><br>        ModModel:SetGamePadSelectedStuff(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">elseif</span> (InKeyName == <span class="hljs-string">&quot;Gamepad_FaceButton_Right&quot;</span> ) <span class="hljs-keyword">then</span> <span class="hljs-comment">-- B键</span><br>        <span class="hljs-built_in">self</span>:RecoverFromGamepad()<br>        ModModel:SetGamePadSelectedStuff(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>        ModController:SetSelectedStuff(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="ListView初始化逻辑"><a href="#ListView初始化逻辑" class="headerlink" title="ListView初始化逻辑"></a>ListView初始化逻辑</h1><p>道具框导航逻辑最好还是写在各自界面里，列表项写在OnEntryInitialized会灵活点</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.List_Select_Mod.BP_OnEntryInitialized:Add(<span class="hljs-built_in">self</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, Content, Entry)</span></span><br>    <span class="hljs-keyword">if</span> Content.bAutoFocusForMod <span class="hljs-keyword">then</span><br>        Entry:SetFocus()<br>        Content.bAutoFocusForMod = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br>    Entry:SetNavigationRuleCustom(EUINavigation.Up, &#123;<span class="hljs-built_in">self</span>,<span class="hljs-built_in">self</span>.OnListModNavigationMod&#125;)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>这个函数listview每个content都会执行</p><h1 id="剧院活动"><a href="#剧院活动" class="headerlink" title="剧院活动"></a>剧院活动</h1><p>这个列表展开怎么做，可以参考宠物升级</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua">```<br><br>每轮活动半个小时开一轮，直接本地算<br><br><br><br># 报错处理<br><br>## lua的变量不要用全局，要用<span class="hljs-keyword">local</span><br><br>## 构造函数中不要使用虚函数<br><br>Calling the <span class="hljs-string">&#x27;SetCollisionEnabled&#x27;</span> virtual <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">constructor</span> <span class="hljs-title">may</span> <span class="hljs-title">lead</span> <span class="hljs-title">to</span> <span class="hljs-title">unexpected</span> <span class="hljs-title">result</span> <span class="hljs-title">at</span> <span class="hljs-title">runtime</span>.</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">这个是因为在<span class="hljs-title">UE</span>中，构造函数执行时对象可能还没有完全初始化，调用虚函数可能不安全，之前是这样写的</span><br><span class="hljs-function"></span><br><span class="hljs-function">```<span class="hljs-title">cpp</span></span><br><span class="hljs-function"><span class="hljs-title">URegionOnlineInterInviteTeamComp</span>::<span class="hljs-title">URegionOnlineInterInviteTeamComp</span><span class="hljs-params">()</span></span><br>&#123;<br>PrimaryComponentTick.bCanEverTick = <span class="hljs-literal">false</span>;<br>SphereRadius = <span class="hljs-number">50.</span>f;<br>    UPrimitiveComponent::SetCollisionProfileName(TEXT(<span class="hljs-string">&quot;Interactive&quot;</span>));<br>SetCollisionEnabled(ECollisionEnabled::NoCollision);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在把他放在BeginPlay里面</p><p>头文件也要对应的修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EM_API</span> URegionOnlineInterInviteTeamComp : <span class="hljs-keyword">public</span> UInteractiveBaseComponent, <span class="hljs-keyword">public</span> IUnLuaInterface<br>&#123;<br><span class="hljs-built_in">GENERATED_BODY</span>()<br><br><span class="hljs-built_in">URegionOnlineInterInviteTeamComp</span>();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> FString <span class="hljs-title">GetModuleName_Implementation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">FString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;BluePrints.Story.Interactive.InteractiveComponent.BP_RegionOnlineInterInviteTeamComponent_C&quot;</span>)); &#125;;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// Called when the game starts or when spawned</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">BeginPlay</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">URegionOnlineInterInviteTeamComp::<span class="hljs-built_in">URegionOnlineInterInviteTeamComp</span>()<br>&#123;<br>PrimaryComponentTick.bCanEverTick = <span class="hljs-literal">false</span>;<br>SphereRadius = <span class="hljs-number">50.f</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">URegionOnlineInterInviteTeamComp::BeginPlay</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>UPrimitiveComponent::<span class="hljs-built_in">SetCollisionProfileName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Interactive&quot;</span>));<br><span class="hljs-built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="手柄端虚拟光标导致聚焦bug"><a href="#手柄端虚拟光标导致聚焦bug" class="headerlink" title="手柄端虚拟光标导致聚焦bug"></a>手柄端虚拟光标导致聚焦bug</h1><p>现在手柄端会有一个默认的虚拟光标聚焦到中间，导致会有hover，可以看看是否可以通过改变位置来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSlateApplication::UsePlatformCursorForCursorUser</span><span class="hljs-params">(<span class="hljs-type">bool</span> bUsePlatformCursor)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (TSharedPtr&lt;FSlateUser&gt; SlateUser = <span class="hljs-built_in">GetUser</span>(CursorUserIndex))<br>    &#123;<br>        <span class="hljs-type">bool</span> bIsUsingPlatformCursor = SlateUser-&gt;<span class="hljs-built_in">GetCursor</span>() == PlatformApplication-&gt;Cursor;<br><br>        <span class="hljs-keyword">if</span> (bIsUsingPlatformCursor != bUsePlatformCursor)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (PlatformApplication &amp;&amp; PlatformApplication-&gt;Cursor)<br>            &#123;<br>                SlateUser-&gt;<span class="hljs-built_in">OverrideCursor</span>(bUsePlatformCursor ? PlatformApplication-&gt;Cursor : <span class="hljs-built_in">MakeShared</span>&lt;FFauxSlateCursor&gt;());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSlateApplication::SetPlatformCursorVisibility</span><span class="hljs-params">(<span class="hljs-type">bool</span> bNewVisibility)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (PlatformApplication &amp;&amp; PlatformApplication-&gt;Cursor)<br>    &#123;<br>        PlatformApplication-&gt;Cursor-&gt;<span class="hljs-built_in">SetType</span>(bNewVisibility ? EMouseCursor::Default : EMouseCursor::None);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="获得属性计算"><a href="#获得属性计算" class="headerlink" title="获得属性计算"></a>获得属性计算</h1><p>在character.lua里面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Char:DumpDefaultBattleAttr</span><span class="hljs-params">(Avatar, ExtraInfo)</span></span><br>ExtraInfo = ExtraInfo <span class="hljs-keyword">or</span> &#123;&#125;<br>ExtraInfo.ModSuit = <span class="hljs-built_in">self</span>.ModSuitIndex<br>AvatarUtils:InitModInfo(Avatar, ExtraInfo,<span class="hljs-built_in">self</span>)<br><span class="hljs-keyword">local</span> BattleAttrs = <span class="hljs-built_in">self</span>:DumpBattleAttr(Avatar, ExtraInfo)<br><span class="hljs-keyword">return</span> BattleAttrs<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>繁重的计算在DumpBattleAttr，可以传各种参数</p><h1 id="富文本响应不同手柄来显示不同的手柄图标"><a href="#富文本响应不同手柄来显示不同的手柄图标" class="headerlink" title="富文本响应不同手柄来显示不同的手柄图标"></a>富文本响应不同手柄来显示不同的手柄图标</h1><p>先看一下富文本的SetText逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SRichTextBlock::SetText</span><span class="hljs-params">(<span class="hljs-type">const</span> TAttribute&lt;FText&gt;&amp; InTextAttr)</span></span><br><span class="hljs-function"></span>&#123;<br>    BoundText = InTextAttr;<br>    <span class="hljs-built_in">Invalidate</span>(EInvalidateWidget::LayoutAndVolatility);<br>    <span class="hljs-built_in">InvalidatePrepass</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会更新BoudText，然后下面InValidate里面会打上脏标记，下一帧会更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FastPathProxyHandle.<span class="hljs-built_in">MarkWidgetDirty</span>(InvalidateReason);<br></code></pre></td></tr></table></figure><p>在这个里面会进行文本的更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FVector2D <span class="hljs-title">SRichTextBlock::ComputeDesiredSize</span><span class="hljs-params">(<span class="hljs-type">float</span> LayoutScaleMultiplier)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ComputeDesiredSize will also update the text layout cache if required</span><br>    <span class="hljs-type">const</span> FVector2D TextSize = TextLayoutCache-&gt;<span class="hljs-built_in">ComputeDesiredSize</span>(<br>                                   FSlateTextBlockLayout::<span class="hljs-built_in">FWidgetArgs</span>(BoundText, HighlightText, WrapTextAt, AutoWrapText, WrappingPolicy, TransformPolicy, Margin, LineHeightPercentage, Justification),<br>                                   LayoutScaleMultiplier * TextBlockScale, TextStyle) *<br>                               TextBlockScale;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">FVector2D</span>(FMath::<span class="hljs-built_in">Max</span>(TextSize.X, MinDesiredWidth.<span class="hljs-built_in">Get</span>()), TextSize.Y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面会遍历富文本上面的Decorator，如果Support返回的是true，那么就会拿对应的图片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TSharedPtr&lt;ITextDecorator&gt; <span class="hljs-title">FRichTextLayoutMarshaller::TryGetDecorator</span><span class="hljs-params">(<span class="hljs-type">const</span> FString&amp; Line, <span class="hljs-type">const</span> FTextRunParseResults&amp; TextRun)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> DecoratorIter = InlineDecorators.<span class="hljs-built_in">CreateConstIterator</span>(); DecoratorIter; ++DecoratorIter)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((*DecoratorIter)-&gt;<span class="hljs-built_in">Supports</span>(TextRun, Line))<br>        &#123;<br>            <span class="hljs-keyword">return</span> *DecoratorIter;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> DecoratorIter = Decorators.<span class="hljs-built_in">CreateConstIterator</span>(); DecoratorIter; ++DecoratorIter)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((*DecoratorIter)-&gt;<span class="hljs-built_in">Supports</span>(TextRun, Line))<br>        &#123;<br>            <span class="hljs-keyword">return</span> *DecoratorIter;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以只需要改这个Support函数就可以了，给这个装饰器加一个属性，之前这个装饰器的Support逻辑就是只看能不能拿到对应id的图片，现在要加一个判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">Supports</span><span class="hljs-params">(<span class="hljs-type">const</span> FTextRunParseResults&amp; RunParseResult, <span class="hljs-type">const</span> FString&amp; Text)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (RunParseResult.Name == <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;img&quot;</span>) &amp;&amp; RunParseResult.MetaData.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;id&quot;</span>)))<br>    &#123;<br>        <span class="hljs-type">const</span> FTextRange&amp; IdRange = RunParseResult.MetaData[<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;id&quot;</span>)];<br>        <span class="hljs-type">const</span> FString TagId       = Text.<span class="hljs-built_in">Mid</span>(IdRange.BeginIndex, IdRange.EndIndex - IdRange.BeginIndex);<br><br>        <span class="hljs-comment">// 检查是否指定了platform属性</span><br>        <span class="hljs-keyword">if</span> (RunParseResult.MetaData.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;platform&quot;</span>)))<br>        &#123;<br>            <span class="hljs-type">const</span> FTextRange&amp; PlatformRange = RunParseResult.MetaData[<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;platform&quot;</span>)];<br>            <span class="hljs-type">const</span> FString PlatformName = Text.<span class="hljs-built_in">Mid</span>(PlatformRange.BeginIndex, PlatformRange.EndIndex - PlatformRange.BeginIndex);<br>            <br>            <span class="hljs-comment">// 如果此装饰器指定了Platforms，则检查是否匹配</span><br>            <span class="hljs-keyword">if</span> (Decorator &amp;&amp; Decorator-&gt;Platforms.<span class="hljs-built_in">Num</span>() &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 支持多个平台值（数组形式）</span><br>                <span class="hljs-type">bool</span> bPlatformMatched = <span class="hljs-literal">false</span>;<br>                <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FString&amp; SupportedPlatform : Decorator-&gt;Platforms)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (PlatformName.<span class="hljs-built_in">Equals</span>(SupportedPlatform.<span class="hljs-built_in">TrimStartAndEnd</span>(), ESearchCase::IgnoreCase))<br>                    &#123;<br>                        bPlatformMatched = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 如果指定的平台与装饰器的平台不匹配，则不支持</span><br>                <span class="hljs-keyword">if</span> (!bPlatformMatched)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果装饰器没有指定Platforms，则支持所有平台</span><br>        &#125;<br>        <span class="hljs-comment">// 如果没有指定platform属性，则按原来的逻辑处理</span><br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bWarnIfMissing = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> Decorator-&gt;<span class="hljs-built_in">FindImageBrush</span>(*TagId, bWarnIfMissing) != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用示例：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1. 在蓝图中配置装饰器：</span><br><span class="hljs-comment">   - 创建两个 URichTextBlockImageDecorator 子类的蓝图实例</span><br><span class="hljs-comment">   - 第一个实例：设置 Platform = &quot;ps5&quot;，ImageSet = PS5手柄图标数据表</span><br><span class="hljs-comment">   - 第二个实例：设置 Platform = &quot;xbox&quot;，ImageSet = XBOX手柄图标数据表</span><br><span class="hljs-comment">   - 将两个装饰器都添加到 RichTextBlock 的 DecoratorClasses 数组中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2. 在富文本中使用带platform属性的img标签：</span><br><span class="hljs-comment">   &lt;img id=&quot;Gamepad_FaceButton_Top&quot; platform=&quot;ps5&quot;&gt;  // 只在PS5装饰器时显示</span><br><span class="hljs-comment">   &lt;img id=&quot;Gamepad_FaceButton_Top&quot; platform=&quot;xbox&quot;&gt; // 只在XBOX装饰器时显示</span><br><span class="hljs-comment">   &lt;img id=&quot;Gamepad_FaceButton_Top&quot;&gt;                 // 不指定platform时，所有装饰器都尝试处理</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3. 检测逻辑：</span><br><span class="hljs-comment">   - 如果指定了platform属性，会检查装饰器的Platform设置是否匹配</span><br><span class="hljs-comment">   - 如果匹配，则使用该装饰器渲染图片</span><br><span class="hljs-comment">   - 如果不匹配，则跳过该装饰器，尝试下一个装饰器</span><br><span class="hljs-comment">   - 如果装饰器的Platform为空，则支持所有平台</span><br><span class="hljs-comment">   - 如果没有指定platform属性，则按原来的逻辑处理</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 优势：</span><br><span class="hljs-comment">   - 可以在蓝图中直接配置每个装饰器支持的平台</span><br><span class="hljs-comment">   - 不需要在代码中动态设置平台</span><br><span class="hljs-comment">   - 更清晰的配置管理</span><br><span class="hljs-comment">   - 支持多个装饰器同时存在，每个处理不同的平台</span><br><span class="hljs-comment">   - 不依赖外部系统，更稳定可靠</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="新加一个padding的listview导航方式"><a href="#新加一个padding的listview导航方式" class="headerlink" title="新加一个padding的listview导航方式"></a>新加一个padding的listview导航方式</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NavigateToItemWithPadding</span><span class="hljs-params">(UObject* Item, <span class="hljs-type">float</span> Padding)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Item &amp;&amp; MyListView.<span class="hljs-built_in">IsValid</span>())<br>&#123;<br><span class="hljs-comment">// 获取Item在列表中的索引</span><br><span class="hljs-type">const</span> int32 IndexOfItem = ListItems.<span class="hljs-built_in">Find</span>(Item);<br><span class="hljs-keyword">if</span> (IndexOfItem != INDEX_NONE)<br>&#123;<br><span class="hljs-comment">// 获取当前可见的Widget数量</span><br><span class="hljs-type">const</span> TArray&lt;UUserWidget*&gt;&amp; DisplayedWidgets = <span class="hljs-built_in">GetDisplayedEntryWidgets</span>();<br><span class="hljs-type">float</span> NumLiveWidgets = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(DisplayedWidgets.<span class="hljs-built_in">Num</span>());<br><span class="hljs-keyword">if</span> (NumLiveWidgets == <span class="hljs-number">0.0f</span>)<br>&#123;<br><span class="hljs-comment">// 如果没有可见的Widget，使用估计值</span><br>NumLiveWidgets = <span class="hljs-number">5.0f</span>; <span class="hljs-comment">// 默认估计值</span><br>&#125;<br><br><span class="hljs-comment">// 计算新的滚动偏移量，考虑Padding</span><br><span class="hljs-type">double</span> NewScrollOffset = IndexOfItem;<br><br><span class="hljs-comment">// 将Item居中显示，并减去Padding的影响</span><br>NewScrollOffset -= (NumLiveWidgets / <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 应用Padding（将Padding转换为项目偏移量）</span><br><span class="hljs-keyword">if</span> (Padding &gt; <span class="hljs-number">0.0f</span>)<br>&#123;<br><span class="hljs-comment">// 获取Item的高度，将Padding转换为项目偏移量</span><br><span class="hljs-type">float</span> ItemHeight = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">if</span> (DisplayedWidgets.<span class="hljs-built_in">Num</span>() &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 使用第一个显示的条目来获取高度</span><br>UUserWidget* FirstWidget = DisplayedWidgets[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (FirstWidget &amp;&amp; FirstWidget-&gt;<span class="hljs-built_in">GetCachedWidget</span>().<span class="hljs-built_in">IsValid</span>())<br>&#123;<br><span class="hljs-type">const</span> FGeometry&amp; WidgetGeometry = FirstWidget-&gt;<span class="hljs-built_in">GetCachedWidget</span>()-&gt;<span class="hljs-built_in">GetCachedGeometry</span>();<br>ItemHeight = WidgetGeometry.<span class="hljs-built_in">GetLocalSize</span>().Y;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果无法获取高度，使用默认值</span><br><span class="hljs-keyword">if</span> (ItemHeight &lt;= <span class="hljs-number">0.0f</span>)<br>&#123;<br>ItemHeight = <span class="hljs-number">50.0f</span>; <span class="hljs-comment">// 默认高度</span><br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PaddingOffset = Padding / ItemHeight;<br>NewScrollOffset -= PaddingOffset;<br>&#125;<br><br><span class="hljs-comment">// 限制偏移量在有效范围内</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> MaxScrollOffset = FMath::<span class="hljs-built_in">Max</span>(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(ListItems.<span class="hljs-built_in">Num</span>()) - NumLiveWidgets);<br>NewScrollOffset = FMath::<span class="hljs-built_in">Clamp</span>&lt;<span class="hljs-type">double</span>&gt;(NewScrollOffset, <span class="hljs-number">0.0</span>, MaxScrollOffset);<br><br><span class="hljs-comment">// 设置滚动偏移量</span><br>MyListView-&gt;<span class="hljs-built_in">SetScrollOffset</span>(NewScrollOffset);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="UnrealInsights看不到对应的Tracks"><a href="#UnrealInsights看不到对应的Tracks" class="headerlink" title="UnrealInsights看不到对应的Tracks"></a>UnrealInsights看不到对应的Tracks</h1><p>需要把这个打开</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250807145225040.png" alt="image-20250807145225040"></p><h1 id="additem在item初始化的时候初始化每个Item的导航"><a href="#additem在item初始化的时候初始化每个Item的导航" class="headerlink" title="additem在item初始化的时候初始化每个Item的导航"></a>additem在item初始化的时候初始化每个Item的导航</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.ForgeContent.BP_OnEntryInitialized:Add(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnForgeContentEntryInit)<br></code></pre></td></tr></table></figure><h1 id="需要一个全局简单的判断当前平台的方法"><a href="#需要一个全局简单的判断当前平台的方法" class="headerlink" title="需要一个全局简单的判断当前平台的方法"></a>需要一个全局简单的判断当前平台的方法</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">(UIUtils.UtilsGetCurrentInputType() == ECommonInputType.Gamepad<br></code></pre></td></tr></table></figure><h1 id="通用按钮音效逻辑"><a href="#通用按钮音效逻辑" class="headerlink" title="通用按钮音效逻辑"></a>通用按钮音效逻辑</h1><p>通用按钮，如果蓝图里面不填AudioEventPath就会走其他的逻辑，所以需要自己绑定一下，类似这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>.Btn_Entry:TryOverrideSoundFunc(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    AudioManager(<span class="hljs-built_in">self</span>):PlayUISound(<span class="hljs-built_in">self</span>, <span class="hljs-string">&quot;event:/ui/common/click_btn_small&quot;</span>,<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>逻辑在这</p><p>会走SoundFunc</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M:OnBtnPressed</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.IsForbidden == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.CurrentClickIsForbid = <span class="hljs-literal">true</span><br>        <span class="hljs-built_in">self</span>.ForbidSoundFunc(<span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.PressTime = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">clock</span>()<br>    <span class="hljs-comment">--通用按钮的音效已经有比较固定的接入方式了，和蓝图内置音效稍微做点兼容</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.AudioEventPath == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.SoundFunc(<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">self</span>.AudioPlayCase == EUIAudioPlayCase.OnMouseDown <span class="hljs-keyword">then</span><br>        AudioManager(<span class="hljs-built_in">self</span>):PlayUISound(<span class="hljs-built_in">self</span>,<span class="hljs-built_in">self</span>.AudioEventPath,<span class="hljs-literal">nil</span>,<span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.CurrentClickIsForbid = <span class="hljs-literal">false</span><br>    <span class="hljs-built_in">self</span>.IsPressing = <span class="hljs-literal">true</span><br>    <span class="hljs-built_in">self</span>:PlayButtonPressAnim()<br><br>    <span class="hljs-keyword">for</span> obj,funcs <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.PressLogics) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(funcs) <span class="hljs-keyword">do</span><br>            v.Event(obj, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(v.Params))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这样看来，直接在蓝图里面接也是对的，我真佛了啊</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250901171948021.png" alt="image-20250901171948021"></p><h1 id="交互控件的逻辑链条"><a href="#交互控件的逻辑链条" class="headerlink" title="交互控件的逻辑链条"></a>交互控件的逻辑链条</h1><p>首先新建了一个Component，叫RegionInterLogic，这里面管理了线上交互组件的逻辑，然后添加到PlayerCharacter这个类里面，这个类里面有一个进入交互区域的入口，EnableRegionSync</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::EnableRegionSync</span><span class="hljs-params">(<span class="hljs-type">bool</span> InEnable)</span></span><br><span class="hljs-function"></span>&#123;<br>EnterRegion = InEnable;<br><span class="hljs-keyword">if</span> (EnterRegion)<br>&#123;<br><span class="hljs-built_in">SyncLocationImmediately</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(MoveSyncHandler.<span class="hljs-built_in">IsValid</span>())<br>&#123;<br>UKismetSystemLibrary::<span class="hljs-built_in">K2_ClearAndInvalidateTimerHandle</span>(<span class="hljs-keyword">this</span>, MoveSyncHandler);<br>MoveSyncHandler.<span class="hljs-built_in">Invalidate</span>();<br>&#125;<br><span class="hljs-keyword">if</span> (EnterRegion)<br>&#123;<br><span class="hljs-keyword">auto</span> RegionObj =  <span class="hljs-built_in">AddObject</span>&lt;URegionPlayerInterLogic&gt;();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(RegionObj))<br>&#123;<br>RegionObj-&gt;<span class="hljs-built_in">SetupRegionInterInfo</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">auto</span> RegionObj = <span class="hljs-built_in">GetObject</span>&lt;URegionPlayerInterLogic&gt;();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(RegionObj))<br>&#123;<br>RegionObj-&gt;EidToPos.<span class="hljs-built_in">Empty</span>();<br>RegionObj-&gt;<span class="hljs-built_in">FindPersonCanbeInteract</span>();<br><br>&#125;<br><span class="hljs-built_in">RemoveObject</span>(URegionPlayerInterLogic::<span class="hljs-built_in">StaticClass</span>());<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>添加了新的逻辑，如果进入就AddObject，如果离开就RemoveObject</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (EnterRegion)<br>&#123;<br><span class="hljs-keyword">auto</span> RegionObj =  <span class="hljs-built_in">AddObject</span>&lt;URegionPlayerInterLogic&gt;();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(RegionObj))<br>&#123;<br>RegionObj-&gt;<span class="hljs-built_in">SetupRegionInterInfo</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">auto</span> RegionObj = <span class="hljs-built_in">GetObject</span>&lt;URegionPlayerInterLogic&gt;();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsValid</span>(RegionObj))<br>&#123;<br>RegionObj-&gt;EidToPos.<span class="hljs-built_in">Empty</span>();<br>RegionObj-&gt;<span class="hljs-built_in">FindPersonCanbeInteract</span>();<br><br>&#125;<br><span class="hljs-built_in">RemoveObject</span>(URegionPlayerInterLogic::<span class="hljs-built_in">StaticClass</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>PlayerCharacter里面会有一个寻找可交互玩家的函数，在这里面初始化这个组件的一些东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::FindPlayerToInteract</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!EnterRegion)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">auto</span> RegionInterLogic = <span class="hljs-built_in">GetObject</span>&lt;URegionPlayerInterLogic&gt;();<br><br><span class="hljs-keyword">if</span> (!RegionInterLogic)<br>&#123;<br>RegionInterLogic = <span class="hljs-built_in">AddObject</span>&lt;URegionPlayerInterLogic&gt;();<br>&#125;<br>RegionInterLogic-&gt;<span class="hljs-built_in">FindPersonCanbeInteract</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个Logic组件的关键在这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ComponentCanbeTrigger = ProspectivePlayer-&gt;RegionInterComp;<br>ComponentCanbeTrigger-&gt;<span class="hljs-built_in">InitCommonUIConfirmID</span>(CommonUIConfirmID);<br>ComponentCanbeTrigger-&gt;<span class="hljs-built_in">DisplayInteractiveBtn</span>(OwnerCharacter)<br></code></pre></td></tr></table></figure><p>这个RegionInterComp是在PlayerCharacter.h上面的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UPROPERTY</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">URegionOnlineInterComp</span>* RegionInterComp = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>是在AddInteractiveComponent上面初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::AddInteractiveComponent</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!FromOtherWorld)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>RegionInterComp = <span class="hljs-built_in">NewObject</span>&lt;URegionOnlineInterComp&gt;(<span class="hljs-keyword">this</span>, URegionOnlineInterComp::<span class="hljs-built_in">StaticClass</span>());<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsValid</span>(RegionInterComp))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>RegionInterComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br><br>RegionInterInviteTeamComp = <span class="hljs-built_in">NewObject</span>&lt;URegionOnlineInterInviteTeamComp&gt;(<span class="hljs-keyword">this</span>, URegionOnlineInterInviteTeamComp::<span class="hljs-built_in">StaticClass</span>());<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsValid</span>(RegionInterInviteTeamComp))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>RegionInterInviteTeamComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br><br>RegionInterAddFriendComp = <span class="hljs-built_in">NewObject</span>&lt;URegionOnlineInterAddFriendComp&gt;(<span class="hljs-keyword">this</span>, URegionOnlineInterAddFriendComp::<span class="hljs-built_in">StaticClass</span>());<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsValid</span>(RegionInterAddFriendComp))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>RegionInterAddFriendComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br><br>RegionInterPersonInfoComp = <span class="hljs-built_in">NewObject</span>&lt;URegionOnlineInterPersonInfoComp&gt;(<span class="hljs-keyword">this</span>, URegionOnlineInterPersonInfoComp::<span class="hljs-built_in">StaticClass</span>());<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsValid</span>(RegionInterPersonInfoComp))<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>RegionInterPersonInfoComp-&gt;<span class="hljs-built_in">RegisterComponent</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口是为了提供给lua里面写逻辑的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_EMGameInstance_C:SpawnOtherRole</span><span class="hljs-params">(ObjId, RoleInfo, MoveInfo)</span></span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoadClassFinished</span><span class="hljs-params">(self, UnitBlueprint)</span></span> <br><span class="hljs-keyword">local</span> Avatar = GWorld:GetAvatar()<br><span class="hljs-keyword">if</span> Avatar <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span>(Avatar.OtherRoleInfo[ObjId].BornState == Const.ShouldDetory ) <span class="hljs-keyword">then</span> <br>Avatar.OtherRoleInfo[ObjId] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> Location = FVector(MoveInfo.Location.X, MoveInfo.Location.Y, MoveInfo.Location.Z)<br>        <span class="hljs-keyword">local</span> Rotation = FRotator(MoveInfo.Rotation.Pitch, MoveInfo.Rotation.Yaw, MoveInfo.Rotation.Roll):ToQuat()<br>        <span class="hljs-keyword">local</span> SpawnTransform = FTransform(Rotation, Location)<br>        <span class="hljs-keyword">local</span> CurrentCharacter = <span class="hljs-built_in">self</span>:GetWorld():SpawnActor(UnitBlueprint, SpawnTransform, UE4.ESpawnActorCollisionHandlingMethod.AlwaysSpawn)<br>CurrentCharacter.FromOtherWorld = <span class="hljs-literal">true</span><br><span class="hljs-keyword">local</span> Info =&#123;&#125;<br><span class="hljs-keyword">local</span> GameMode = UE4.UGameplayStatics.GetGameMode(<span class="hljs-built_in">self</span>)<br>Info.RoleId = RoleInfo.CharId<br>Info.SkinId = RoleInfo.SkinId<br>Info.FromOtherWorld = <span class="hljs-literal">true</span><br>Info.AppearanceSuit = RoleInfo.AppearanceSuit<br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CharacterRead</span><span class="hljs-params">(Character)</span></span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>.LogTag, <span class="hljs-string">&quot;CharacterRead&quot;</span>, Character:K2_GetActorLocation(), Character:K2_GetActorRotation())<br><span class="hljs-keyword">local</span> Avatar = GWorld:GetAvatar()<br><span class="hljs-keyword">if</span> Avatar <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span>(Avatar.OtherRoleInfo[ObjId].BornState == Const.ShouldDetory <span class="hljs-keyword">and</span> Character) <span class="hljs-keyword">then</span> <br>Character:K2_DestroyActor()<br>Avatar.OtherRoleInfo[ObjId] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span> <br><span class="hljs-keyword">end</span><br>Avatar.OtherRoleInfo[ObjId].BornState = Const.Bonred<br>Avatar.OtherRoleInfo[ObjId].CharEid = Character.Eid<br><span class="hljs-comment">-- PrintTable(&#123;SpawnOtherRole = &#123;AvatarId = ObjId, OtherRoleInfo = Avatar.OtherRoleInfo[ObjId]&#125;&#125;, 4)</span><br><span class="hljs-keyword">end</span><br>Character:AddInteractiveComponent()<br><span class="hljs-keyword">if</span>(Character.RegionInterComp) <span class="hljs-keyword">then</span><br>Character.RegionInterComp:InitRegionInfo(Character.Eid, ObjId)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span>(Character.RegionInterAddFriendComp) <span class="hljs-keyword">then</span><br>Character.RegionInterAddFriendComp:InitRegionInfo(Character.Eid, ObjId)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span>(Character.RegionInterInviteTeamComp) <span class="hljs-keyword">then</span><br>Character.RegionInterInviteTeamComp:InitRegionInfo(Character.Eid, ObjId)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span>(Character.RegionInterPersonInfoComp) <span class="hljs-keyword">then</span><br>Character.RegionInterPersonInfoComp:InitRegionInfo(Character.Eid, ObjId)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>Info.LoadFinishCallback = CharacterRead<br>CurrentCharacter:InitCharacterInfoForRegionPlayer(Info)<br>EventManager:FireEvent(EventID.AddRegionIndicatorInfo, CurrentCharacter.Eid, RoleInfo.Uid, CurrentCharacter:K2_GetActorLocation(), ObjId)<br><span class="hljs-keyword">end</span>     <br>    <span class="hljs-keyword">local</span> Path = <span class="hljs-string">&#x27;/Game/BluePrints/Char/BP_PlayerCharacter.BP_PlayerCharacter_C&#x27;</span><br>    UE4.UResourceLibrary.LoadClassAsync(<span class="hljs-built_in">self</span>, Path, &#123;<span class="hljs-built_in">self</span>, LoadClassFinished&#125;)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>所以如果想把新增的三个组件也初始化CommonUIConfirmID，可以在RegionPlayerInterLogic里面写逻辑，之前CommonUIConfirmId是写在Lua的常量表里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CommonUIConfirmID = UEMLuaConst::Vars.RegionPlayerInterId;<br></code></pre></td></tr></table></figure><p>EMLuaConst.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UPROPERTY</span>()<br>int32 RegionPlayerInterId;<br></code></pre></td></tr></table></figure><p>EMLuaConst.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">EMLuaConst.RegionPlayerInterId = <span class="hljs-number">100032</span><br></code></pre></td></tr></table></figure><p>这样就可以用上我lua里面写的逻辑了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--- 根据配置的ID获取Icon，有特殊需求的在子类中重写</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_RegionOnlineInterInviteTeamComponent_C:GetInteractiveIcon</span><span class="hljs-params">(PlayerActor)</span></span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsLocked() <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Texture2D&#x27;/Game/UI/Texture/Dynamic/Atlas/Interactive/T_Interactive_Lock.T_Interactive_Lock&#x27;&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>:IsForbidden(PlayerActor) <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Texture2D&#x27;/Game/UI/Texture/Dynamic/Atlas/Interactive/T_Interactive_Forbidden.T_Interactive_Forbidden&#x27;&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> Data = DataMgr.CommonUIConfirm[<span class="hljs-built_in">self</span>.CommonUIConfirmID]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Data <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> Data.Icon <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> Data.Icon<br>    <span class="hljs-comment">-- local ImageResource = LoadObject(Data.Icon)</span><br>    <span class="hljs-comment">-- return ImageResource</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_RegionOnlineInterInviteTeamComponent_C:GetInteractiveName</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">return</span> GText(<span class="hljs-string">&quot;UI_Friend_Invite&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_RegionOnlineInterInviteTeamComponent_C:InitCommonUIConfirmID</span><span class="hljs-params">(CommonUIConfirmID)</span></span><br><span class="hljs-built_in">self</span>.CommonUIConfirmID = CommonUIConfirmID<br><span class="hljs-keyword">local</span> Data = DataMgr.CommonUIConfirm[CommonUIConfirmID]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> Data <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">self</span>.InteractiveDistance = Data.InteractiveRadius <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveDistance<br><span class="hljs-built_in">self</span>.InteractiveAngle = Data.InteractiveAngle <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveAngle<br><span class="hljs-built_in">self</span>.InteractiveFaceAngle = Data.PlayerFaceAngle <span class="hljs-keyword">or</span> <span class="hljs-built_in">self</span>.InteractiveFaceAngle<br><span class="hljs-built_in">self</span>.ListPriority = Data.InteractivePriority <span class="hljs-keyword">or</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="理解一下Component的一些接口"><a href="#理解一下Component的一些接口" class="headerlink" title="理解一下Component的一些接口"></a>理解一下Component的一些接口</h1><p>一般服务器会写这个东西，然后客户端如果要接红点相关可以在EnterWorld和_OnPropChangeTheaterActivity来做</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:_OnPropChangeTheaterActivity</span><span class="hljs-params">(key)</span></span><br>    <span class="hljs-built_in">self</span>:RefreshTheaterEventRewardReddot()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个OnProp会在EntityBase里面的ClientPropSet里面调用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component:ClientPropSet</span><span class="hljs-params">(name, key, value)</span></span><br><span class="hljs-built_in">self</span>.logger.<span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;ClientPropSet&quot;</span>, name, key)<br><br><span class="hljs-keyword">local</span> _type = <span class="hljs-built_in">self</span>.__Class__<br><span class="hljs-keyword">local</span> prop = _type.Props[name]<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prop <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> OldValue = <span class="hljs-built_in">self</span>[name][key]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">and</span> value.__type <span class="hljs-keyword">and</span> value.value <span class="hljs-keyword">then</span><br><span class="hljs-built_in">self</span>[name][key] = value.value<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">local</span> _type = prop:GetType()<br><span class="hljs-keyword">local</span> _key_type = _type.KeyType<br><span class="hljs-keyword">local</span> _value_type = _type.ValueType<br><span class="hljs-keyword">local</span> _value_type_name = _value_type.__Name__<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.UseProtoAttr <span class="hljs-keyword">and</span> <span class="hljs-built_in">self</span>.AttrTypes[_value_type_name] <span class="hljs-keyword">and</span> value ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>value = pb.decode(<span class="hljs-string">&quot;.&quot;</span>.._value_type_name, value)<br><span class="hljs-comment">-- self.logger.debug(&quot;ClientPropSet&quot;, name, Serpent.block(value))</span><br><span class="hljs-built_in">self</span>[name]._inner[_key_type:convert(key)] = _value_type:proto_load(value)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">self</span>[name][key] = value<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> func = <span class="hljs-built_in">self</span>[<span class="hljs-string">&quot;_OnPropChange&quot;</span>..name]<br><span class="hljs-keyword">if</span> func ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>func(<span class="hljs-built_in">self</span>,&#123;key&#125;, OldValue)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="学习一下导航"><a href="#学习一下导航" class="headerlink" title="学习一下导航"></a>学习一下导航</h1><p>导航代码入口？：NavigationFunctionLibrary.cpp</p><p>按V冒出一个黄光指引目标位置：BP_CreatPathEffectTrail</p><h1 id="战斗手柄按键如何做的（输入系统总览）"><a href="#战斗手柄按键如何做的（输入系统总览）" class="headerlink" title="战斗手柄按键如何做的（输入系统总览）"></a>战斗手柄按键如何做的（输入系统总览）</h1><p>总的过程</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">硬件输入 → Windows消息 → UE输入系统 → InputComponent → Action绑定 → 回调函数<br></code></pre></td></tr></table></figure><p>需要动态绑组合键，比如平时X是普攻，但是按爪LB和X就是技能1，这种怎么做？</p><p>比较好的思路如下：</p><p>动态修改InputSetting里的ActionMapping，按下技能组合键时，把原先”X键映射Attack”删掉，新增一条”X键映射Skill1”松开技能组合键时，把”X键映射Skill1”删掉，重新加入”X键映射Attack</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250904163401533.png" alt="image-20250904163401533"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 根据表格，把所有手柄键位初始化一次</span><br><span class="hljs-keyword">for</span> _, UserData <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(ActionMappings) <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> ActionName = UserData.ActionName<br>    <span class="hljs-keyword">if</span> GamepadSet[ActionName] <span class="hljs-keyword">and</span> GamepadSet[ActionName].GamepadKey <span class="hljs-keyword">and</span> GamepadSet[ActionName].GamepadKey[KeySet] <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> KeyName = <span class="hljs-string">&quot;Gamepad_&quot;</span> .. GamepadSet[ActionName].GamepadKey[KeySet]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(UserData.Key.KeyName,<span class="hljs-string">&#x27;Gamepad&#x27;</span>) <span class="hljs-keyword">and</span> UserData.Key.KeyName ~= KeyName <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.InputSetting:RemoveActionMapping(UserData) <span class="hljs-comment">-- 删掉不匹配的</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> NewKey = UE4.EKeys[KeyName]<br>        UserData.Key = NewKey<br>        <span class="hljs-built_in">self</span>.InputSetting:AddActionMapping(UserData) <span class="hljs-comment">-- 加上匹配的</span><br>    <span class="hljs-keyword">elseif</span> GamepadSet[ActionName] <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> GamepadSet[ActionName].GamepadKey <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> GamepadSet[ActionName].GamepadKey[KeySet])<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(UserData.Key.KeyName,<span class="hljs-string">&#x27;Gamepad&#x27;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.InputSetting:RemoveActionMapping(UserData) <span class="hljs-comment">-- 如果是个组合按键，删掉残留的</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>首先会把按键和Action一一对应绑定，之后ue里面只会发出Action的信号来通知写逻辑，然后再把Action和逻辑绑定，这样分一层的好处是解耦，action就写自己的逻辑，不用把按键和逻辑绑定，之后改键只用改按键是怎么触发不同的Action就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在SetupPlayerInputComponent中绑定输入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::SetupPlayerInputComponent</span><span class="hljs-params">(UInputComponent* PlayerInputComponent)</span></span><br><span class="hljs-function"></span>&#123;<br>    Super::<span class="hljs-built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);<br>    <br>    <span class="hljs-comment">// 绑定Attack动作</span><br>    <span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Attack&quot;</span>), IE_Pressed, &amp;APlayerCharacter::PressAttack);<br>    <span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Attack&quot;</span>), IE_Released, &amp;APlayerCharacter::ReleaseAttack);<br>    <br>    <span class="hljs-comment">// 绑定其他动作...</span><br>    <span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Jump&quot;</span>), IE_Pressed, &amp;APlayerCharacter::StartJump);<br>    <span class="hljs-built_in">BindAction</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Skill1&quot;</span>), IE_Pressed, &amp;APlayerCharacter::PressSkill1);<br>    <span class="hljs-comment">// ... 更多绑定</span><br>&#125;<br></code></pre></td></tr></table></figure><p>绑定BindAction的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EM游戏的自定义绑定函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::BindAction</span><span class="hljs-params">(<span class="hljs-type">const</span> FName&amp; ActionName, <span class="hljs-type">const</span> EInputEvent KeyEvent, <span class="hljs-type">void</span> (APlayerCharacter::* Delegate)())</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 添加到绑定映射表</span><br>    BindActions.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">TTuple</span>&lt;FName, EInputEvent&gt;(ActionName, KeyEvent), Delegate);<br>    <br>    <span class="hljs-comment">// 2. 绑定到UE4的输入系统</span><br>    InputComponent-&gt;<span class="hljs-built_in">BindAction</span>&lt;ActionDelegate, APlayerCharacter, FName&gt;(<br>        ActionName, KeyEvent, <span class="hljs-keyword">this</span>, &amp;APlayerCharacter::ActionCallback, ActionName, KeyEvent);<br>    <br>    <span class="hljs-comment">// 3. 记录按下状态</span><br>    <span class="hljs-keyword">if</span> (KeyEvent == IE_Released) <br>        PressedKeyActions.<span class="hljs-built_in">Add</span>(ActionName, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个BindAction其实用的是UE的项目设置里面那个Action系统</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Binds a delegate function to an Action defined in the project settings.</span><br><span class="hljs-comment"> * Returned reference is only guaranteed to be valid until another action is bound.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegateType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClass</span>, <span class="hljs-keyword">typename</span>... VarTypes&gt;<br><span class="hljs-function">FInputActionBinding&amp; <span class="hljs-title">BindAction</span><span class="hljs-params">(<span class="hljs-type">const</span> FName ActionName, <span class="hljs-type">const</span> EInputEvent KeyEvent, UserClass* Object, <span class="hljs-keyword">typename</span> DelegateType::<span class="hljs-keyword">template</span> TUObjectMethodDelegate&lt;UserClass&gt;::FMethodPtr Func, VarTypes... Vars)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">FInputActionBinding <span class="hljs-title">AB</span><span class="hljs-params">(ActionName, KeyEvent)</span></span>;<br>    AB.ActionDelegate.<span class="hljs-built_in">BindDelegate</span>&lt;DelegateType&gt;(Object, Func, Vars...);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">AddActionBinding</span>(<span class="hljs-built_in">MoveTemp</span>(AB));<br>&#125;<br></code></pre></td></tr></table></figure><p>Callback逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::ActionCallback</span><span class="hljs-params">(FName ActionName, EInputEvent KeyEvent)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 获取最终动作名称（可能经过转换）</span><br>    FName _ActionName = <span class="hljs-built_in">GetFinalActionName</span>(ActionName, KeyEvent);<br>    <br>    <span class="hljs-comment">// 2. 检查禁止标签</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckForbidTags</span>(_ActionName))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (KeyEvent == IE_Released)<br>        &#123;<br>            <span class="hljs-built_in">ResetAttackProperty</span>(ActionName);<br>            <span class="hljs-comment">// 处理特殊状态重置</span><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 输入缓存处理</span><br>    <span class="hljs-keyword">if</span> (KeyEvent == IE_Pressed &amp;&amp; _ActionName != <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Attack&quot;</span>))<br>    &#123;<br>        <span class="hljs-built_in">SetInputCache</span>(_ActionName.<span class="hljs-built_in">ToString</span>());<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 初始化检查</span><br>    <span class="hljs-keyword">if</span> (!InitSuccess || !<span class="hljs-built_in">IsAllWeaponInitSuccess</span>()) <br>        <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 5. 更新按键状态</span><br>    <span class="hljs-built_in">UpdatePressedKeyActionMap</span>(_ActionName, KeyEvent);<br>    <br>    <span class="hljs-comment">// 6. 查找并执行对应的处理函数</span><br>    TTuple&lt;FName, EInputEvent&gt; Key = <span class="hljs-built_in">TTuple</span>&lt;FName, EInputEvent&gt;(_ActionName, KeyEvent);<br>    <span class="hljs-type">bool</span> KeyExist = BindActions.<span class="hljs-built_in">Contains</span>(Key);<br>    <br>    <span class="hljs-keyword">if</span> (KeyExist) &#123;<br>        (<span class="hljs-keyword">this</span>-&gt;*BindActions[Key])();  <span class="hljs-comment">// 调用对应的处理函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后拿攻击的逻辑做一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">APlayerCharacter::PressAttack</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    bPressedAttack = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 1. 道具效果检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckSkillOccupiedByProp</span>(ESkillName::HeavyAttack))<br>    &#123;<br>        <span class="hljs-comment">// 设置道具长按计时器</span><br>        <span class="hljs-built_in">GetWorldTimerManager</span>().<span class="hljs-built_in">SetTimer</span>(Timer_PropHoldAttack, [<span class="hljs-keyword">this</span>]()<br>        &#123;<br>            PropEffectComponent-&gt;CurrentPropEffect-&gt;<span class="hljs-built_in">OnHoldAttack</span>();<br>        &#125;, HoldDelayTime, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 道具攻击处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckSkillOccupiedByProp</span>(ESkillName::Attack))<br>    &#123;<br>        PropEffectComponent-&gt;CurrentPropEffect-&gt;<span class="hljs-built_in">OnAttackPressed</span>();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 获取重击技能ID</span><br>    <span class="hljs-type">const</span> int32 HoldAttackSkillId = <span class="hljs-built_in">GetSkillByType</span>(ESkillType::HeavyAttack);<br>    <span class="hljs-keyword">if</span> (HoldAttackSkillId == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 4. 技能禁用检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CheckSkillIsBan</span>(ESkillName::Attack))<br>    &#123;<br>        <span class="hljs-comment">// 显示UI提示</span><br>        UIManager-&gt;<span class="hljs-built_in">ShowUITip_BattleCommonTop</span>(Const::Tip_CommonTop, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;UI_MELEE_FORBIDDEN&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 输入禁止检查</span><br>    <span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">CheckCanSkillCancel</span>(HoldAttackSkillId) &amp;&amp; <span class="hljs-built_in">CheckForbidInput</span>()) || <br>        <span class="hljs-built_in">CheckSkillInActive</span>(ESkillName::Attack))<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 设置长按计时器</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetWorldTimerManager</span>().<span class="hljs-built_in">IsTimerActive</span>(Timer_PropHoldAttack))<br>    &#123;<br>        HoldingSkillName = UEMNameRegisterLibrary::EMName_Attack;<br>        <span class="hljs-built_in">GetWorldTimerManager</span>().<span class="hljs-built_in">SetTimer</span>(Timer_HoldAttack, [<span class="hljs-keyword">this</span>, HoldAttackSkillId]()<br>        &#123;<br>            <span class="hljs-built_in">HoldSkill</span>(HoldAttackSkillId, UEMNameRegisterLibrary::EMName_Attack);<br>        &#125;, HoldDelayTime, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="事件系统EventManager"><a href="#事件系统EventManager" class="headerlink" title="事件系统EventManager"></a>事件系统EventManager</h1><p>在lua里面的事件系统比较简单，AddEvent就是拿了一个表，来存这个回调的事件，值得注意的是，这个回调可以是多个，因为Event也拿了一个表来储存</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventManager:AddEvent</span><span class="hljs-params">(eventName, obj, func)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> obj <span class="hljs-keyword">then</span> <br>        Traceback(ErrorTag, <span class="hljs-string">&quot;EventManager:AddEvent，事件的对象不能为空！！！&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> func <span class="hljs-keyword">then</span><br>        Traceback(ErrorTag, <span class="hljs-string">&quot;EventManager:AddEvent，传入的函数回调不能为空！！&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.EventDic[eventName] == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.EventDic[eventName] = Event:New()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.EventDic[eventName]:Add(obj,func)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个最后的EventDic[eventName]:Add(obj, func)调的就是Event的Add</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Event:Add</span><span class="hljs-params">(obj,funcion)</span></span><br>    <span class="hljs-comment">---@note 事件会按序执行，存储回调的是list</span><br>    <span class="hljs-comment">-- table.insert(self.List,&#123;obj=obj,funcion=funcion&#125;)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.List[obj] <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.List[obj] = &#123;&#125;<br>        <span class="hljs-built_in">self</span>.FuncMap[obj] = &#123;&#125;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">self</span>.FuncMap[obj][funcion] <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">self</span>.List[obj], funcion)<br>        <span class="hljs-built_in">self</span>.FuncMap[obj][funcion] = <span class="hljs-number">1</span><br>        <span class="hljs-built_in">self</span>.NowCount = <span class="hljs-built_in">self</span>.NowCount + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>FIreEvent也很简单，就是直接Invoke对应的Event就行了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventManager:FireEvent</span><span class="hljs-params">(eventName,...)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.EventDic[eventName] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.EventDic[eventName]:Invoke(...)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Invoke</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Event:Invoke</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-comment">-- for i, event in ipairs(self.List)  do</span><br>    <span class="hljs-comment">--     local obj = event.obj</span><br>    <span class="hljs-comment">--     if obj then</span><br>    <span class="hljs-comment">--         -- PrintTable(&#123;Obj = obj&#125;, 10)</span><br>    <span class="hljs-comment">--         local objType = type(obj)</span><br>    <span class="hljs-comment">--         if ((objType == &quot;userdata&quot; or (objType==&quot;table&quot; and obj.Object)) and IsValid(obj)) or (objType == &quot;table&quot; and not obj.Object) then</span><br>    <span class="hljs-comment">--             if(event.funcion) then</span><br>    <span class="hljs-comment">--                 event.funcion(obj,...)</span><br>    <span class="hljs-comment">--             end</span><br>    <span class="hljs-comment">--         end</span><br>    <span class="hljs-comment">--     end</span><br>    <span class="hljs-comment">-- end</span><br><br>    <span class="hljs-comment">-- for i = #self.List, 1, -1 do</span><br>    <span class="hljs-comment">--     local Event = self.List[i]</span><br>    <span class="hljs-comment">--     if Event.obj == nil then</span><br>    <span class="hljs-comment">--         table.remove(self.List, i)</span><br>    <span class="hljs-comment">--     end</span><br>    <span class="hljs-comment">-- end</span><br>    <span class="hljs-keyword">local</span> InvalidObjs = &#123;&#125;<br>    <span class="hljs-keyword">local</span> TmpCalls = &#123;&#125;<br>    <span class="hljs-keyword">for</span> obj, funcs <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.List) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> objType = <span class="hljs-built_in">type</span>(obj)<br>            <span class="hljs-keyword">if</span> ((objType == <span class="hljs-string">&quot;userdata&quot;</span> <span class="hljs-keyword">or</span> (objType==<span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">and</span> obj.Object)) <span class="hljs-keyword">and</span> IsValid(obj)) <span class="hljs-keyword">or</span> (objType == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> obj.Object) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(TmpCalls, &#123;obj, funcs&#125;)<br>                <span class="hljs-comment">-- for _, func in ipairs(funcs) do</span><br>                <span class="hljs-comment">--     func(obj, ...)</span><br>                <span class="hljs-comment">-- end</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(InvalidObjs, obj)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">local</span> args = &#123;...&#125;<br>    <span class="hljs-keyword">for</span> _, call <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(TmpCalls) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> obj = call[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">local</span> funcs = call[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">for</span> _, func <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(funcs) <span class="hljs-keyword">do</span><br>        try &#123;<br>        exec = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>            func(obj, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(args))<br>        <span class="hljs-keyword">end</span>,<br>        catch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span></span><br>        GWorld.logger.<span class="hljs-built_in">error</span>(Traceback(ErrorTag, err,<span class="hljs-literal">true</span>))<br>        <span class="hljs-keyword">end</span><br>    &#125;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">for</span> _, obj <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(InvalidObjs) <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">self</span>.List[obj] = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>下面再看一下检测内存泄漏方法，用来确保代码只Add了没有remove的情况，防止一些奇怪的调用，也是在EventManager里面包了一个调用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventManager:CheckIsLeak</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> bLog = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> GWorld.IsDev <span class="hljs-keyword">then</span> <br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    DebugPrint(WarningTag, <span class="hljs-string">&quot;检测EventMananger事件泄漏...&quot;</span>)<br>    <span class="hljs-keyword">for</span> eventName, Event <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.EventDic) <span class="hljs-keyword">do</span><br>        Event:CheckIsLeak(eventName, bLog)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个逻辑也比较简单，因为Add和Remove的时候会更新一下self.NowCount，如果发现self.LastCount~&#x3D;0（也就是非第一次检查）并且比nowcount小，就说明有地方没有正确remove了，如果是第一次检查会把self.LastCount &#x3D; self.NowCount</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Event:CheckIsLeak</span><span class="hljs-params">(eventName, bLog)</span></span><br>    <span class="hljs-comment">--bLog = true</span><br>    <span class="hljs-comment">--DebugPrint(string.format(&quot;EventManager事件，%s，LastCount:%s，NowCount:%s&quot;,eventName,self.LastCount, self.NowCount))</span><br>    <span class="hljs-keyword">local</span> RealCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.LastCount~=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">self</span>.LastCount &lt; <span class="hljs-built_in">self</span>.NowCount <span class="hljs-keyword">and</span> bLog <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> Visited = &#123;&#125;<br>        ScreenPrint(ErrorTag..<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;EventManager事件 %s 发现内存泄漏，请检查该事件注册后是否正确清理，LastCount:%s，NowCount:%s&quot;</span>,eventName,<span class="hljs-built_in">self</span>.LastCount, <span class="hljs-built_in">self</span>.NowCount))<br>        <span class="hljs-keyword">for</span> obj, List <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.List) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> obj.Overridden <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> Visited[obj.Overridden] <span class="hljs-keyword">then</span><br>                DebugPrint(ErrorTag,<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;该泄漏的事件绑定的函数数量:%s, 类名:&quot;</span>,#List),(obj.Overridden))<br>                Visited[obj.Overridden] = <span class="hljs-number">1</span><br>                <span class="hljs-comment">-- if not obj:IsValid() then</span><br>                <span class="hljs-comment">--     DebugPrint(WarningTag, &quot;该UObject对象已经无效，对泄漏的绑定做保底清理&quot;)</span><br>                <span class="hljs-comment">--     self:Remove(obj)</span><br>                <span class="hljs-comment">--     goto continue</span><br>                <span class="hljs-comment">-- end</span><br>            <span class="hljs-keyword">elseif</span> obj.__Name__ <span class="hljs-keyword">then</span>  <span class="hljs-comment">--这里是故意不加Visited，因为Entity可能有多个componment，但是他们类名都一样，如果贸然去重可能会漏掉一些检测</span><br>                DebugPrint(ErrorTag,<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;该泄漏的事件绑定的函数数量:%s, 类名:%s&quot;</span>,#List, obj.__Name__ ))<br>                <span class="hljs-comment">-- if not GWorld.EntityManager:GetEntity(obj.id) then</span><br>                <span class="hljs-comment">--     DebugPrint(WarningTag, &quot;该Entity类型对象已经无效，对泄漏的绑定做保底清理&quot;)</span><br>                <span class="hljs-comment">--     self:Remove(obj)</span><br>                <span class="hljs-comment">--     goto continue</span><br>                <span class="hljs-comment">-- end</span><br>            <span class="hljs-keyword">elseif</span> <span class="hljs-keyword">not</span> Visited[obj] <span class="hljs-keyword">then</span><br>                DebugPrintTable(obj,<span class="hljs-number">1</span>,ErrorTag,<span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;该泄漏的事件绑定的函数数量:%s, 对象:&quot;</span>,#List))<br>                Visited[obj] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">end</span><br>            RealCount = RealCount + #List<br>            <span class="hljs-comment">--::continue::</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-built_in">self</span>.NowCount = RealCount<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.LastCount = <span class="hljs-built_in">self</span>.NowCount<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>现在调用这个的时机是世界清除（应该是下线？）还有创建一个Entity的时候</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_TcpConnection_C:CreateEntity</span><span class="hljs-params">(entity_type, entity_id, info, use_protoattr)</span></span><br>    DebugNetPrint(<span class="hljs-string">&quot;CreateEntity &quot;</span>, entity_type, use_protoattr)<br>    <span class="hljs-keyword">local</span> entity = GWorld.EntityManager:GetEntity(entity_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> entity <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> entity_type == <span class="hljs-string">&quot;Avatar&quot;</span> <span class="hljs-keyword">then</span><br>EventManager:CheckIsLeak()<br><span class="hljs-keyword">end</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>.LogTag, <span class="hljs-string">&quot;CreateNewEntity&quot;</span>, entity_type)<br>        entity = GWorld.EntityFactory:CreateEntity(entity_type, entity_id)<br><br>        <span class="hljs-keyword">if</span> entity <span class="hljs-keyword">then</span><br>            entity:SetServerProxy(<span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> entity <span class="hljs-keyword">then</span><br>        DebugPrint(<span class="hljs-string">&quot;InitFromDict before&quot;</span>, <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>())<br>        entity:InitFromDict(info, use_protoattr)<br>        DebugPrint(<span class="hljs-string">&quot;InitFromDict after&quot;</span>, <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>())<br>        entity:CreateSuccess()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BP_EMGameInstance_C:OnPostWorldCleanup</span><span class="hljs-params">(World, bSessionEnded, bCleanupResources)</span></span><br><span class="hljs-keyword">if</span> World:GetName() == <span class="hljs-built_in">self</span>:GetWorld():GetName() <span class="hljs-keyword">then</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> GWorld:GetAvatar() <span class="hljs-keyword">then</span><br>EventManager:CheckIsLeak()<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>接入Icon </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> Icon = LoadObject(Content.Icon)<br><span class="hljs-built_in">self</span>.Icon_Head:SetBrushFromTexture(Icon)<br></code></pre></td></tr></table></figure><h1 id="手机端的虚拟手柄是怎么做的？"><a href="#手机端的虚拟手柄是怎么做的？" class="headerlink" title="手机端的虚拟手柄是怎么做的？"></a>手机端的虚拟手柄是怎么做的？</h1><p>尝试了两种方法，一种是TouchComponent，这个组件可以管理不同的touch逻辑，但是组合到自己的UI之后发现有报错，所以就换了一种；另一种其实就是直接用OnTouch内部，手柄其实只不过是一个Image，然后通过Touch的位置来控制显示的位置而已</p><p>首先UE处理触控有三个流程，OnTouchStarted，OnTouchMoved和OnTouchEnded，Component的处理方式也只是把暴露了可以绑定的方法，有一个AddMovedSubTouchItem</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:AddMovedSubTouchItem</span><span class="hljs-params">(SubTouchName, SubTouchItem, ParentWidget, AllCallBack, LimitParams)</span></span><br>    <span class="hljs-comment">-- LimitParams为限制区域相关设置，常见的如矩形，椭圆</span><br>    <span class="hljs-built_in">self</span>.UpdatePosFlag[SubTouchName] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllCallBack) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.AllTouchCallBack[k] == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.AllTouchCallBack[k] = &#123;&#123;Name=SubTouchName,Value=v&#125;&#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">self</span>.AllTouchCallBack[k], &#123;Name=SubTouchName,Value=v&#125;)<br>        <span class="hljs-keyword">end</span> <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.AllParentWidget[SubTouchName] = ParentWidget<br>    <span class="hljs-built_in">self</span>.LimitRangeParam[SubTouchItem] = LimitParams<br>    <span class="hljs-built_in">self</span>.AllTouchItems[SubTouchName] = SubTouchItem<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>具体用法如下，可以说明这个touch的形状，然后就是三个函数调用的逻辑，然后Component里面会重写ue内部的那几个Touch函数，再根据touch的位置来判断应该是哪个来响应，分发出去，这样外部就只用自己实现Down,Move,Up三个函数就好了，其他自己会处理</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">self</span>:AddMovedSubTouchItem(<span class="hljs-string">&quot;BattleFortJoystick&quot;</span>, <span class="hljs-built_in">self</span>.Joystick, <span class="hljs-literal">nil</span>, &#123;Down=<span class="hljs-built_in">self</span>.ButtonDown, Move=<span class="hljs-built_in">self</span>.ButtonMove, Up=<span class="hljs-built_in">self</span>.ButtonUp&#125;,<br>        &#123;Type=<span class="hljs-string">&quot;Circle&quot;</span>, Param=&#123;Radius=<span class="hljs-built_in">self</span>.Radius, NeedReset=<span class="hljs-literal">false</span>&#125;, TouchTimes=<span class="hljs-number">-1</span>, NeedResetPos=<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><p>写的挺好的，我就直接把全部摘录下来了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br><span class="hljs-built_in">require</span> <span class="hljs-string">&quot;UnLua&quot;</span><br><br><span class="hljs-comment">-- 封装touch事件判断</span><br><span class="hljs-keyword">local</span> TouchComponent = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:Initialize</span><span class="hljs-params">(Initializer)</span></span><br>    <span class="hljs-built_in">self</span>.WidgetStartPos = <span class="hljs-literal">nil</span>           <span class="hljs-comment">-- 交互对象的开始位置（Local）</span><br>    <span class="hljs-built_in">self</span>.WidgetCurPos = <span class="hljs-literal">nil</span>             <span class="hljs-comment">-- 交互对象的当前位置（Local）</span><br>    <span class="hljs-built_in">self</span>.NowTouchPos = &#123;&#125;               <span class="hljs-comment">-- 当前触控点位置（Key是PointerIndex）</span><br>    <span class="hljs-built_in">self</span>.m_LastPosTable = &#123;&#125;            <span class="hljs-comment">-- 上一次停留的Pos位置（Key是PointerIndex）</span><br>    <span class="hljs-built_in">self</span>.LastTouch_Time = <span class="hljs-number">0</span>        <span class="hljs-comment">-- 上一次点击时间</span><br>    <span class="hljs-built_in">self</span>.Click_MaxLen = <span class="hljs-number">5</span>               <span class="hljs-comment">-- 单击判断的最大距离</span><br>    <span class="hljs-built_in">self</span>.DClick_Prepared = <span class="hljs-literal">false</span>        <span class="hljs-comment">-- 是否可以触发连击</span><br>    <span class="hljs-built_in">self</span>.Lpress_Began = <span class="hljs-literal">false</span>           <span class="hljs-comment">-- 是否已经触发长按</span><br>    <span class="hljs-built_in">self</span>.Lpress_Interval = <span class="hljs-number">0.5</span>          <span class="hljs-comment">-- 长按最小时间间隔</span><br>    <span class="hljs-built_in">self</span>.Lpress_MaxLen = <span class="hljs-number">20</span>             <span class="hljs-comment">-- 长按最大移动距离</span><br>    <span class="hljs-built_in">self</span>.Touching_Flag = &#123;&#125;             <span class="hljs-comment">-- 标识符，当前手指是否正处于拖动（Key是PointerIndex）</span><br>    <span class="hljs-built_in">self</span>.AllTouchItems = &#123;&#125;             <span class="hljs-comment">-- 所有的可拖拽控件</span><br>    <span class="hljs-built_in">self</span>.AllParentWidget = &#123;&#125;           <span class="hljs-comment">-- 所有可拖动的SubWidget的父Widget</span><br>    <span class="hljs-built_in">self</span>.SubTouchItems = &#123;&#125;             <span class="hljs-comment">-- 正在拖动交互的所有SubWidget</span><br>    <span class="hljs-built_in">self</span>.SubTouchParentWidget = &#123;&#125;      <span class="hljs-comment">-- 正在拖动交互的所有SubWidget的父Widget</span><br>    <span class="hljs-built_in">self</span>.SubTouchItemsName = &#123;&#125;         <span class="hljs-comment">-- 正在拖动交互的所有SubWidget的Name</span><br>    <span class="hljs-built_in">self</span>.SubTouchItemsStartPos = &#123;&#125;     <span class="hljs-comment">-- Widget在当前控件之中的起始位置   </span><br>    <span class="hljs-built_in">self</span>.UpdatePosFlag = &#123;&#125;             <span class="hljs-comment">-- 是否需要实际拖动子SubWidget(Widget位置发生改变)</span><br>    <span class="hljs-built_in">self</span>.m_LastHandleMoveTimeStamp = &#123;&#125;     <span class="hljs-comment">-- 上一次处理触控移动的时间戳</span><br>    <span class="hljs-built_in">self</span>.CurrentTouchingGeometry = &#123;&#125;       <span class="hljs-comment">-- 几何体信息（Key是PointerIndex）</span><br>    <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent = &#123;&#125;   <span class="hljs-comment">-- Gesture信息（Key是PointerIndex）</span><br>    <span class="hljs-built_in">self</span>.AllTouchCallBack = &#123;&#125;              <span class="hljs-comment">-- 所有的Touch回调函数</span><br>    <span class="hljs-built_in">self</span>.Owner_Player = <span class="hljs-literal">nil</span>                 <span class="hljs-comment">-- 所属的Player对象</span><br><br>    <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X = <span class="hljs-literal">false</span>        <span class="hljs-comment">-- X方向的回弹</span><br>    <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_Y = <span class="hljs-literal">false</span>        <span class="hljs-comment">-- Y方向的回弹</span><br>    <span class="hljs-built_in">self</span>.CanLimitRange = <span class="hljs-literal">false</span>              <span class="hljs-comment">-- 是否限制拖动的范围</span><br>    <span class="hljs-built_in">self</span>.LimitRangeParam = &#123;&#125;               <span class="hljs-comment">-- 拖动范围信息参数</span><br>    <span class="hljs-built_in">self</span>.IsAutoAdjustByMultiTouch = <span class="hljs-literal">false</span>   <span class="hljs-comment">-- 是否需要在多指触控下自动调整自身大小</span><br>    <span class="hljs-built_in">self</span>.DefaultPixelSeries = <span class="hljs-number">1.5</span>           <span class="hljs-comment">-- 自定义的放大比例因子</span><br>    <span class="hljs-built_in">self</span>.MultiTouchLastTimeStamp = <span class="hljs-number">-1</span>       <span class="hljs-comment">-- 多指触控上一次释放时间戳（多指变单指）</span><br>    <span class="hljs-built_in">self</span>.Offset = FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)           <span class="hljs-comment">-- 暂时没有用</span><br>    <span class="hljs-built_in">self</span>.BackgroundPlateOffset = <span class="hljs-number">100</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:SetClickMaxLen</span><span class="hljs-params">(MaxLen)</span></span><br>    <span class="hljs-built_in">self</span>.ClickMaxLen = MaxLen<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:SetLongTouchInterval</span><span class="hljs-params">(Interval)</span></span><br>    <span class="hljs-built_in">self</span>.LpressInterval = Interval<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:InitTouchLayer</span><span class="hljs-params">(OwnerPlayer, UpdatetimeX, UpdatetimeY)</span></span><br>    <span class="hljs-built_in">self</span>.Owner_Player = OwnerPlayer<br>    <span class="hljs-built_in">self</span>.m_SavePrePos = FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">self</span>.m_SaveTarPos = FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">self</span>.Updatetime_X = UpdatetimeX<br>    <span class="hljs-built_in">self</span>.Updatetime_Y = UpdatetimeY<br>    <span class="hljs-built_in">self</span>.m_LastHandleMoveTimeStamp = &#123;&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:InitTouchListenEvent</span><span class="hljs-params">()</span></span><br>    EventManager:AddEvent(EventID.CharDie, <span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.HandleOnCharDie)<br>    EventManager:AddEvent(EventID.StartTalk, <span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.HandleEventByInterrupt)<br>    <span class="hljs-built_in">self</span>:ListenForInputAction(<span class="hljs-string">&quot;OpenMenu&quot;</span>, EInputEvent.IE_Pressed, <span class="hljs-literal">false</span>, &#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.HandleEventByInterrupt&#125;)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:RemoveTouchListenEvent</span><span class="hljs-params">()</span></span><br>    EventManager:RemoveEvent(EventID.CharDie, <span class="hljs-built_in">self</span>)<br>    EventManager:RemoveEvent(EventID.StartTalk, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-built_in">self</span>:StopListeningForInputAction(<span class="hljs-string">&quot;OpenMenu&quot;</span>, EInputEvent.IE_Pressed)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:HandleOnCharDie</span><span class="hljs-params">(Eid)</span></span><br>    <span class="hljs-keyword">local</span> Entity = GWorld.Battle:GetEntity(Eid)<br>    <span class="hljs-keyword">if</span> (Entity <span class="hljs-keyword">and</span> Entity.IsMainPlayer <span class="hljs-keyword">and</span> Entity:IsMainPlayer()) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>:HandleEventByInterrupt()<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:HandleEventByInterrupt</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">for</span> k, CurrentGeometry <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.CurrentTouchingGeometry) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.Touching_Flag[k]) <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>:MouseOrTouchButtonUp(CurrentGeometry, <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent[k], k - <span class="hljs-number">1</span>)  <br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:AddStaticSubTouchItem</span><span class="hljs-params">(SubTouchName, SubTouchItem, AllCallBack)</span></span><br>    <span class="hljs-built_in">self</span>.UpdatePosFlag[SubTouchName] = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllCallBack) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.AllTouchCallBack[k] == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.AllTouchCallBack[k] = &#123;&#123;Name=SubTouchName,Value=v&#125;&#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">self</span>.AllTouchCallBack[k], &#123;Name=SubTouchName,Value=v&#125;)<br>        <span class="hljs-keyword">end</span> <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.AllTouchItems[SubTouchName] = SubTouchItem<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:AddMovedSubTouchItem</span><span class="hljs-params">(SubTouchName, SubTouchItem, ParentWidget, AllCallBack, LimitParams)</span></span><br>    <span class="hljs-comment">-- LimitParams为限制区域相关设置，常见的如矩形，椭圆</span><br>    <span class="hljs-built_in">self</span>.UpdatePosFlag[SubTouchName] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllCallBack) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.AllTouchCallBack[k] == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.AllTouchCallBack[k] = &#123;&#123;Name=SubTouchName,Value=v&#125;&#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">self</span>.AllTouchCallBack[k], &#123;Name=SubTouchName,Value=v&#125;)<br>        <span class="hljs-keyword">end</span> <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.AllParentWidget[SubTouchName] = ParentWidget<br>    <span class="hljs-built_in">self</span>.LimitRangeParam[SubTouchItem] = LimitParams<br>    <span class="hljs-built_in">self</span>.AllTouchItems[SubTouchName] = SubTouchItem<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnTouchStarted</span><span class="hljs-params">(InGeometry, InGestureEvent)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>:MouseOrTouchButtonDown(InGeometry, InGestureEvent)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnTouchMoved</span><span class="hljs-params">(InGeometry, InGestureEvent)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>:MouseOrTouchButtonMove(InGeometry, InGestureEvent)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnTouchEnded</span><span class="hljs-params">(InGeometry, InGestureEvent)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>:MouseOrTouchButtonUp(InGeometry, InGestureEvent)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:GetOwningPlayer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.Owner_Player<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:GetWorldPos</span><span class="hljs-params">(Widget)</span></span><br>    <span class="hljs-comment">-- 获取绝对坐标</span><br>    <span class="hljs-keyword">local</span> GameInstance = UE4.UGameplayStatics.GetGameInstance(<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">local</span> UIManager = GameInstance:GetGameUIManager()<br>    <span class="hljs-keyword">if</span> (UIManager == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> UIManager:GetWorldPosition(Widget), UIManager:GetWidgetRenderSize(Widget)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:GetLastPosTableLength</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> NowCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.m_LastPosTable) <span class="hljs-keyword">do</span><br>        NowCount = NowCount + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> NowCount<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:GetNowTouchPosTableLength</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> NowCount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.NowTouchPos) <span class="hljs-keyword">do</span><br>        NowCount = NowCount + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> NowCount<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--处理鼠标/触摸按下事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:MouseOrTouchButtonDown</span><span class="hljs-params">(InGeometry, InGestureEvent)</span></span><br>    <span class="hljs-keyword">local</span> Scale = UE4.UWidgetLayoutLibrary.GetViewportScale(<span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">local</span> ScreenSpacePosition = UE4.UKismetInputLibrary.PointerEvent_GetScreenSpacePosition(InGestureEvent)<br>    <span class="hljs-keyword">local</span> thisPos = UE4.USlateBlueprintLibrary.AbsoluteToLocal(InGeometry, ScreenSpacePosition) * Scale<br>    <span class="hljs-keyword">local</span> SubTouchItem, SubTouchItemName, SubTouchItemStartPos, SubTouchParentWidget = <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.AllTouchItems) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> WidgetWorldPos, WidgetWorldSize = <span class="hljs-built_in">self</span>:GetWorldPos(v)<br>        <span class="hljs-comment">-- local CanvasSize = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(v):GetSize()</span><br>        <span class="hljs-keyword">local</span> WidgetWorldPos = UE4.USlateBlueprintLibrary.AbsoluteToLocal(InGeometry, WidgetWorldPos) * Scale<br>        <span class="hljs-keyword">if</span> ((thisPos.X &gt; WidgetWorldPos.X <span class="hljs-keyword">and</span> thisPos.X &lt; WidgetWorldPos.X + WidgetWorldSize.X * Scale) <span class="hljs-keyword">and</span> <br>            (thisPos.Y &gt; WidgetWorldPos.Y <span class="hljs-keyword">and</span> thisPos.Y &lt; WidgetWorldPos.Y + WidgetWorldSize.Y * Scale)) <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- 认为触摸的是此控件</span><br>            <span class="hljs-keyword">if</span> (SubTouchItem == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>                <span class="hljs-comment">-- 没有的话直接设置</span><br>                SubTouchItem = v<br>                SubTouchItemName = k<br>                SubTouchItemStartPos = FVector2D(WidgetWorldPos.X + WidgetWorldSize.X * <span class="hljs-number">0.5</span> * Scale, WidgetWorldPos.Y + WidgetWorldSize.Y * <span class="hljs-number">0.5</span> * Scale)<br>                SubTouchParentWidget = <span class="hljs-built_in">self</span>.AllParentWidget[k]<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">-- 根据层级来获取最上层的触控层</span><br>                <span class="hljs-keyword">local</span> ChooseCanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(SubTouchItem)<br>                <span class="hljs-keyword">local</span> TouchCanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(v)<br>                <span class="hljs-keyword">if</span> (TouchCanvasSlot.ZOrder &gt; ChooseCanvasSlot.ZOrder) <span class="hljs-keyword">then</span><br>                    SubTouchItem = v<br>                    SubTouchItemName = k<br>                    SubTouchItemStartPos = FVector2D(WidgetWorldPos.X + WidgetWorldSize.X * <span class="hljs-number">0.5</span> * Scale, WidgetWorldPos.Y + WidgetWorldSize.Y * <span class="hljs-number">0.5</span> * Scale)<br>                    SubTouchParentWidget = <span class="hljs-built_in">self</span>.AllParentWidget[k]<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (SubTouchItem == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        DebugPrint(<span class="hljs-string">&quot;TouchComponent== MouseOrTouchButtonDown Error, Not Find Can Interactive Item&quot;</span>)<br>        <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.Unhandled()<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(SubTouchItem)<br>    <span class="hljs-keyword">local</span> PointerIndex = UE4.UKismetInputLibrary.PointerEvent_GetPointerIndex(InGestureEvent)<br><br>    <span class="hljs-built_in">self</span>.CurrentTouchingGeometry[PointerIndex + <span class="hljs-number">1</span>] = InGeometry<br>    <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent[PointerIndex + <span class="hljs-number">1</span>] = InGestureEvent<br><br>    <span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>] = SubTouchItem<br>    <span class="hljs-built_in">self</span>.SubTouchParentWidget[PointerIndex + <span class="hljs-number">1</span>] = SubTouchParentWidget<br>    <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] = SubTouchItemName<br>    <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>] = SubTouchItemStartPos <br><br>    <span class="hljs-built_in">self</span>.WidgetCurPos = CanvasSlot:GetPosition()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.WidgetStartPos == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.WidgetStartPos = CanvasSlot:GetPosition()<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">local</span> LimitRangeInfo = <span class="hljs-built_in">self</span>.LimitRangeParam[SubTouchItem]<br>        <span class="hljs-keyword">if</span> (LimitRangeInfo <span class="hljs-keyword">and</span> LimitRangeInfo.NeedResetPos) <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(SubTouchItem)<br>            <span class="hljs-keyword">if</span> (CanvasSlot ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>                CanvasSlot:SetPosition(<span class="hljs-built_in">self</span>.WidgetStartPos)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span> <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.Touching_Flag[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">local</span> AllDownCallBack = <span class="hljs-built_in">self</span>.AllTouchCallBack[<span class="hljs-string">&quot;Down&quot;</span>]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>(AllDownCallBack) == <span class="hljs-string">&quot;table&quot;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllDownCallBack) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> (v.Name == SubTouchItemName <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v.Value) == <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">then</span><br>                v.Value(<span class="hljs-built_in">self</span>, PointerIndex, <span class="hljs-built_in">self</span>.WidgetCurPos)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">-- 单指或两指的处理</span><br>    <span class="hljs-keyword">local</span> TotalTouchCount = <span class="hljs-built_in">self</span>:GetNowTouchPosTableLength()<br>    <span class="hljs-keyword">if</span> TotalTouchCount &lt;= <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>] = thisPos<br>        <span class="hljs-keyword">if</span> TotalTouchCount &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- 单指或者虚拟拖动拖动</span><br>            <span class="hljs-built_in">self</span>.CanLimitRange = <span class="hljs-literal">true</span><br>            <span class="hljs-built_in">self</span>.m_IsTap = <span class="hljs-literal">true</span>                 <span class="hljs-comment">-- 单指按下</span><br>            <span class="hljs-built_in">self</span>.m_HasTriggered = <span class="hljs-literal">false</span><br>            <span class="hljs-built_in">self</span>.m_DragStartPos = thisPos<br>            <span class="hljs-built_in">self</span>.Offset = UE4.USlateBlueprintLibrary.AbsoluteToLocal(InGeometry, ScreenSpacePosition) * Scale <span class="hljs-comment">--+FVector2D(120,120)</span><br>        <span class="hljs-keyword">elseif</span> TotalTouchCount == <span class="hljs-number">2</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- 多指拖动</span><br>            <span class="hljs-keyword">if</span> (SubTouchItem.PixelSeries == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>                SubTouchItem.PixelSeries = <span class="hljs-built_in">self</span>.DefaultPixelSeries<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-built_in">self</span>.CanLimitRange = <span class="hljs-literal">false</span><br>            <span class="hljs-built_in">self</span>.Offset = FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">local</span> otherPos = FVector2D(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>            <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #<span class="hljs-built_in">self</span>.NowTouchPos <span class="hljs-keyword">do</span><br>                <span class="hljs-keyword">if</span> i ~= PointerIndex + <span class="hljs-number">1</span> <span class="hljs-keyword">then</span>   <span class="hljs-comment">-- 第二指按下的位置</span><br>                    otherPos = <span class="hljs-built_in">self</span>.NowTouchPos[i]<br>                <span class="hljs-keyword">end</span><br><br>                <span class="hljs-built_in">self</span>.m_ZoomStartLength = UE4.UKismetMathLibrary.Distance2D(thisPos, otherPos)<br>                <span class="hljs-built_in">self</span>.m_IsTap = <span class="hljs-literal">false</span><br>                <span class="hljs-built_in">self</span>.m_OriginPoint = (thisPos + otherPos) / <span class="hljs-number">2</span><br>                <span class="hljs-built_in">self</span>:CalcZoomRatio(PointerIndex)<br>                <span class="hljs-built_in">self</span>.startPixelSeries = SubTouchItem.PixelSeries<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> Handled = UE4.UWidgetBlueprintLibrary.Handled()<br>        <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.CaptureMouse(Handled, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.Unhandled()<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--处理鼠标/触摸移动事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:MouseOrTouchButtonMove</span><span class="hljs-params">(InGeometry, InGestureEvent)</span></span><br>    <span class="hljs-keyword">local</span> PointerIndex = UE4.UKismetInputLibrary.PointerEvent_GetPointerIndex(InGestureEvent)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.Touching_Flag[PointerIndex + <span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> SubTouchItem = <span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">local</span> NowTime = UE4.UGameplayStatics.GetRealTimeSeconds(<span class="hljs-built_in">self</span>:GetOwningPlayer())<br>        <span class="hljs-keyword">local</span> LastHandleMoveTimeStamp = <span class="hljs-built_in">self</span>.m_LastHandleMoveTimeStamp[PointerIndex + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (LastHandleMoveTimeStamp <span class="hljs-keyword">and</span> NowTime - LastHandleMoveTimeStamp &lt;= <span class="hljs-number">0.033</span>) <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- 避免短时间内多次执行</span><br>            <span class="hljs-keyword">return</span> UIUtils.Handled<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-built_in">self</span>.m_LastHandleMoveTimeStamp[PointerIndex + <span class="hljs-number">1</span>] = NowTime<br><br>        <span class="hljs-keyword">local</span> Scale = UE4.UWidgetLayoutLibrary.GetViewportScale(<span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(SubTouchItem)<br>        <span class="hljs-keyword">local</span> ScreenSpacePosition = UE4.UKismetInputLibrary.PointerEvent_GetScreenSpacePosition(InGestureEvent)<br>        <span class="hljs-keyword">local</span> thisPos = UE4.USlateBlueprintLibrary.AbsoluteToLocal(InGeometry, ScreenSpacePosition) * Scale<br>        <span class="hljs-comment">-- local changepos = (thisPos - self.Offset)</span><br>        <span class="hljs-keyword">local</span> AllSingleMoveCallBack = <span class="hljs-built_in">self</span>.AllTouchCallBack[<span class="hljs-string">&quot;Move&quot;</span>]<br>        <span class="hljs-keyword">local</span> AllMultiMoveCallBack = <span class="hljs-built_in">self</span>.AllTouchCallBack[<span class="hljs-string">&quot;MultiMove&quot;</span>]<br><br>        <span class="hljs-built_in">self</span>.CurrentTouchingGeometry[PointerIndex + <span class="hljs-number">1</span>] = InGeometry<br>        <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent[PointerIndex + <span class="hljs-number">1</span>] = InGestureEvent<br><br>        <span class="hljs-keyword">local</span> TotalTouchCount = <span class="hljs-built_in">self</span>:GetNowTouchPosTableLength()<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">if</span> TotalTouchCount == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">--单指处理拖动</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>(AllSingleMoveCallBack) == <span class="hljs-string">&quot;table&quot;</span>) <span class="hljs-keyword">then</span><br>                    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllSingleMoveCallBack) <span class="hljs-keyword">do</span><br>                        <span class="hljs-keyword">if</span> (v.Name == <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v.Value) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">and</span> NowTime - <span class="hljs-built_in">self</span>.MultiTouchLastTimeStamp &gt;= <span class="hljs-number">0.2</span>) <span class="hljs-keyword">then</span><br>                            <span class="hljs-comment">-- 传入目前的触摸坐标，以及相对于开始的移动距离向量(注意是否需要有Scale值的影响)</span><br>                            v.Value(<span class="hljs-built_in">self</span>, TotalTouchCount, PointerIndex, <span class="hljs-built_in">self</span>.WidgetCurPos, thisPos - <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>], thisPos - <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>], thisPos)<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">end</span><br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">elseif</span> TotalTouchCount == <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">--两指处理缩放</span><br>                <span class="hljs-keyword">local</span> otherPos<br>                <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, TotalTouchCount <span class="hljs-keyword">do</span><br>                    <span class="hljs-keyword">if</span> i ~= PointerIndex + <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>                        otherPos = <span class="hljs-built_in">self</span>.NowTouchPos[i]<br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">local</span> MoveDist = UE4.UKismetMathLibrary.Distance2D(thisPos, otherPos)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>(AllMultiMoveCallBack) == <span class="hljs-string">&quot;table&quot;</span>) <span class="hljs-keyword">then</span><br>                    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllMultiMoveCallBack) <span class="hljs-keyword">do</span><br>                        <span class="hljs-keyword">if</span> (v.Name == <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v.Value) == <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">then</span><br>                            <span class="hljs-comment">-- 传入触摸的点，以及两个点之间的距离</span><br>                            v.Value(<span class="hljs-built_in">self</span>, TotalTouchCount, PointerIndex, thisPos, otherPos, MoveDist)<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">end</span><br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">elseif</span> (<span class="hljs-built_in">type</span>(AllSingleMoveCallBack) == <span class="hljs-string">&quot;table&quot;</span>) <span class="hljs-keyword">then</span><br>                    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllSingleMoveCallBack) <span class="hljs-keyword">do</span><br>                        <span class="hljs-keyword">if</span> (v.Name == <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v.Value) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">and</span> NowTime - <span class="hljs-built_in">self</span>.MultiTouchLastTimeStamp &gt;= <span class="hljs-number">0.2</span>) <span class="hljs-keyword">then</span><br>                            <span class="hljs-comment">-- 传入目前的触摸坐标，以及相对于开始的移动距离向量(注意是否需要有Scale值的影响)</span><br>                            v.Value(<span class="hljs-built_in">self</span>, TotalTouchCount, PointerIndex, <span class="hljs-built_in">self</span>.WidgetCurPos, thisPos - <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>], thisPos - <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>], thisPos)<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">end</span><br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.IsAutoAdjustByMultiTouch <span class="hljs-keyword">then</span><br>                    <span class="hljs-built_in">self</span>.CanLimitRange = <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.m_ZoomStartLength &lt;= MoveDist <span class="hljs-keyword">then</span> <span class="hljs-comment">-- 扩大</span><br>                        <span class="hljs-keyword">local</span> newPixelSeries = (MoveDist - <span class="hljs-built_in">self</span>.m_ZoomStartLength) / <span class="hljs-number">20</span><br>                        SubTouchItem.PixelSeries = <span class="hljs-built_in">self</span>.startPixelSeries + newPixelSeries<br>                        <span class="hljs-keyword">if</span> SubTouchItem.PixelSeries &gt; <span class="hljs-number">80</span> <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- 限制扩大的最大范围</span><br>                            SubTouchItem.PixelSeries = <span class="hljs-number">80</span><br>                        <span class="hljs-keyword">end</span><br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">local</span> newPixelSeries = (<span class="hljs-built_in">self</span>.m_ZoomStartLength - MoveDist) / <span class="hljs-number">20</span><br>                        SubTouchItem.PixelSeries = <span class="hljs-built_in">self</span>.startPixelSeries - newPixelSeries<br>                        <span class="hljs-keyword">if</span> SubTouchItem.PixelSeries &lt; <span class="hljs-number">30</span> <span class="hljs-keyword">then</span><br>                            SubTouchItem.PixelSeries = <span class="hljs-number">30</span><br>                        <span class="hljs-keyword">end</span><br>                    <span class="hljs-keyword">end</span><br>                    <span class="hljs-comment">-- 子页面的PixelSeries更改 可以调用自己封装的AdjustSize()来更新该控件的大小</span><br>                    <span class="hljs-keyword">if</span> (SubTouchItem.AdjustSize) <span class="hljs-keyword">then</span><br>                        SubTouchItem:AdjustSize() <br>                    <span class="hljs-keyword">end</span><br>                    <span class="hljs-built_in">self</span>:SetZoomPos(PointerIndex)<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span> <br>            <span class="hljs-comment">-- 更新触控点坐标</span><br>            <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>] = thisPos               <br>            <span class="hljs-comment">-- local lastPos = self.m_LastPosTable[PointerIndex + 1]</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.WidgetCurPos = <span class="hljs-built_in">self</span>:GetNextMovePos(thisPos - <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>], PointerIndex)<br>                CanvasSlot:SetPosition(<span class="hljs-built_in">self</span>.WidgetCurPos)<br>                <span class="hljs-built_in">self</span>.m_LastPosTable[PointerIndex + <span class="hljs-number">1</span>] = thisPos<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">return</span> UIUtils.Handled<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> UIUtils.Unhandled<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--处理鼠标、触摸抬起事件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:MouseOrTouchButtonUp</span><span class="hljs-params">(InGeometry, InGestureEvent, TargetPointerIndex)</span></span><br>    <span class="hljs-keyword">local</span> PointerIndex = TargetPointerIndex <span class="hljs-keyword">or</span> UE4.UKismetInputLibrary.PointerEvent_GetPointerIndex(InGestureEvent)<br>    <span class="hljs-keyword">local</span> SubTouchItem = <span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> (SubTouchItem == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        DebugPrint(<span class="hljs-string">&quot;TouchComponent== MouseOrTouchButtonUp, Not Find Can Interactive Item&quot;</span>, PointerIndex)<br>        <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.Unhandled()<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.m_IsTap = <span class="hljs-literal">false</span><br>    <span class="hljs-built_in">self</span>.Touching_Flag[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.m_LastHandleMoveTimeStamp[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <br>    <span class="hljs-built_in">self</span>.CurrentTouchingGeometry[PointerIndex + <span class="hljs-number">1</span>] = InGeometry<br>    <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent[PointerIndex + <span class="hljs-number">1</span>] = InGestureEvent<br>    <span class="hljs-keyword">local</span> AllUpCallBack = <span class="hljs-built_in">self</span>.AllTouchCallBack[<span class="hljs-string">&quot;Up&quot;</span>]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">type</span>(AllUpCallBack) == <span class="hljs-string">&quot;table&quot;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(AllUpCallBack) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> (v.Name == <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(v.Value) == <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">then</span><br>                <span class="hljs-comment">-- 传出当前节点坐标、目前的点击坐标、上一次图像坐标、上一次点击坐标、以及相对于开始的移动距离向量</span><br>                <span class="hljs-keyword">local</span> Scale = UE4.UWidgetLayoutLibrary.GetViewportScale(<span class="hljs-built_in">self</span>)<br>                <span class="hljs-keyword">local</span> ScreenSpacePosition = UE4.UKismetInputLibrary.PointerEvent_GetScreenSpacePosition(InGestureEvent)<br>                <span class="hljs-keyword">local</span> thisPos = UE4.USlateBlueprintLibrary.AbsoluteToLocal(InGeometry, ScreenSpacePosition) * Scale<br>                <span class="hljs-comment">-- local changepos = (thisPos - self.Offset)</span><br>                v.Value(<span class="hljs-built_in">self</span>, PointerIndex, <span class="hljs-built_in">self</span>.WidgetCurPos, <span class="hljs-built_in">self</span>.m_LastPosTable[PointerIndex + <span class="hljs-number">1</span>], <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>], thisPos - <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.NowTouchPos[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">local</span> TotalTouchCount = <span class="hljs-built_in">self</span>:GetNowTouchPosTableLength()<br>        <span class="hljs-keyword">if</span> TotalTouchCount == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.CanLimitRange <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>:LimitRange(PointerIndex)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">elseif</span> TotalTouchCount == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">self</span>.NowTouchPos) <span class="hljs-keyword">do</span><br>                <span class="hljs-keyword">if</span> (v ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>                    <span class="hljs-built_in">self</span>.m_DragStartPos = v<br>                    <span class="hljs-keyword">break</span> <br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-built_in">self</span>.MultiTouchLastTimeStamp = UE4.UGameplayStatics.GetRealTimeSeconds(<span class="hljs-built_in">self</span>:GetOwningPlayer())<br>            <span class="hljs-comment">-- self.m_DragStartPos = self.NowTouchPos[1]</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> Handled = UE4.UWidgetBlueprintLibrary.Handled()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] = <span class="hljs-literal">false</span><br>            <span class="hljs-built_in">self</span>:OnUpdatePosFlag(PointerIndex)<br>            <span class="hljs-comment">--self.UpdatePosTimerHandle = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;self, self.OnUpdatePosFlag&#125;, 0.01, true)</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.ReleaseMouseCapture(Handled)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] = <span class="hljs-literal">false</span><br>        <span class="hljs-built_in">self</span>:OnUpdatePosFlag(PointerIndex)<br>        <span class="hljs-comment">--self.UpdatePosTimerHandle = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;self, self.OnUpdatePosFlag&#125;, 0.01, true)</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">self</span>:AfterTouchItemMove(PointerIndex)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> UE4.UWidgetBlueprintLibrary.UnHandled()<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--计算缩放比例</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:CalcZoomRatio</span><span class="hljs-params">(PointerIndex)</span></span><br>    <span class="hljs-built_in">self</span>.m_OriginPoint = <span class="hljs-built_in">self</span>.m_OriginPoint + FVector2D(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">self</span>.WidgetCurPos.X), <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">self</span>.WidgetCurPos.Y))<br>    <span class="hljs-built_in">self</span>.m_LeftPointPoint = FVector2D(<span class="hljs-built_in">self</span>.BackgroundPlateOffset, <span class="hljs-built_in">self</span>.BackgroundPlateOffset)<br>    <span class="hljs-built_in">self</span>.m_RelativePos = <span class="hljs-built_in">self</span>.m_OriginPoint - <span class="hljs-built_in">self</span>.m_LeftPointPoint<br>    <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(<span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>])<br><span class="hljs-comment">--计算按下位置相对于控件长宽的位置比例</span><br>    <span class="hljs-keyword">local</span> W = CanvasSlot:GetSize().X<br>    <span class="hljs-keyword">local</span> H = CanvasSlot:GetSize().Y<br>    <span class="hljs-built_in">self</span>.m_RelativePosRatio = FVector2D(<span class="hljs-built_in">self</span>.m_RelativePos.X / W, <span class="hljs-built_in">self</span>.m_RelativePos.Y / H)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--计算设置缩放后的偏移位置</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:SetZoomPos</span><span class="hljs-params">(PointerIndex)</span></span><br>    <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(<span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">local</span> newW = CanvasSlot:GetSize().X<br>    <span class="hljs-keyword">local</span> newH = CanvasSlot:GetSize().Y<br>    <span class="hljs-built_in">self</span>.m_newRelativePos = FVector2D(newW * <span class="hljs-built_in">self</span>.m_RelativePosRatio.X, newH * <span class="hljs-built_in">self</span>.m_RelativePosRatio.Y)<br>    <span class="hljs-keyword">local</span> newPos = <span class="hljs-built_in">self</span>.WidgetCurPos - <span class="hljs-built_in">self</span>.m_newRelativePos + <span class="hljs-built_in">self</span>.m_RelativePos<br>    CanvasSlot:SetPosition(newPos)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--拖动时限制拖动范围</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:GetNextMovePos</span><span class="hljs-params">(ChangePos, PointerIndex)</span></span><br>    <span class="hljs-keyword">local</span> FinalPos = <span class="hljs-built_in">self</span>.WidgetStartPos + ChangePos<br>    <span class="hljs-keyword">local</span> LimitRangeInfo = <span class="hljs-built_in">self</span>.LimitRangeParam[<span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">if</span> (LimitRangeInfo <span class="hljs-keyword">and</span> LimitRangeInfo.Type == <span class="hljs-string">&quot;Circle&quot;</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> TwoPointDistance = UE4.UKismetMathLibrary.Distance2D(FinalPos, <span class="hljs-built_in">self</span>.WidgetStartPos)<br>        <span class="hljs-keyword">if</span> (TwoPointDistance &gt; LimitRangeInfo[<span class="hljs-string">&quot;Param&quot;</span>].Radius) <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> k = ChangePos.Y / ChangePos.X<br>            <span class="hljs-keyword">local</span> x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> (ChangePos.X &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>                <span class="hljs-comment">-- 左方移动</span><br>                x = -LimitRangeInfo[<span class="hljs-string">&quot;Param&quot;</span>].Radius / <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> + k * k) + <span class="hljs-built_in">self</span>.WidgetStartPos.X<br>                y = -k * LimitRangeInfo[<span class="hljs-string">&quot;Param&quot;</span>].Radius / <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> + k * k) + <span class="hljs-built_in">self</span>.WidgetStartPos.Y<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">-- 右方移动</span><br>                x = LimitRangeInfo[<span class="hljs-string">&quot;Param&quot;</span>].Radius / <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> + k * k) + <span class="hljs-built_in">self</span>.WidgetStartPos.X<br>                y = k * LimitRangeInfo[<span class="hljs-string">&quot;Param&quot;</span>].Radius / <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> + k * k) + <span class="hljs-built_in">self</span>.WidgetStartPos.Y<br>            <span class="hljs-keyword">end</span><br>            FinalPos.X = <span class="hljs-built_in">self</span>.WidgetStartPos.X + x<br>            FinalPos.Y = <span class="hljs-built_in">self</span>.WidgetStartPos.Y + y<br>        <span class="hljs-keyword">end</span> <br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> FinalPos<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--抬起时限制拖动范围</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:LimitRange</span><span class="hljs-params">(PointerIndex)</span></span><br>    <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(<span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">if</span> (CanvasSlot == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>.WidgetCurPos = CanvasSlot:GetPosition()<br>    <span class="hljs-keyword">local</span> LimitRangeInfo = <span class="hljs-built_in">self</span>.LimitRangeParam[<span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">if</span> (LimitRangeInfo ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">--限制范围</span><br>        <span class="hljs-keyword">local</span> UpLimitParam = LimitRangeInfo.UpLimitParam<br>        <span class="hljs-keyword">if</span> (UpLimitParam ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> IsNeedRebackX = <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.X + CanvasSlot:GetSize().X &lt; UpLimitParam.LeftMoveLen) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.X = <span class="hljs-built_in">self</span>.WidgetCurPos.X<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.X = -CanvasSlot:GetSize().X + UpLimitParam.LeftMoveLen<br>                IsNeedRebackX = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">elseif</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.X + CanvasSlot:GetSize().X &gt; UpLimitParam.RightMoveLen) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.X = <span class="hljs-built_in">self</span>.WidgetCurPos.X<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.X = -CanvasSlot:GetSize().X + UpLimitParam.RightMoveLen<br>                IsNeedRebackX = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X == <span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> IsNeedRebackX) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X = <span class="hljs-literal">false</span><br>                <span class="hljs-built_in">self</span>.TimerHandle_X = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnUpdateEdgeLerpTimer_X&#125;, <span class="hljs-number">0.02</span>, <span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">end</span><br><br>            <span class="hljs-keyword">local</span> IsNeedRebackY = <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.Y + CanvasSlot:GetSize().Y &lt; UpLimitParam.DownMoveLen) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.Y = <span class="hljs-built_in">self</span>.WidgetCurPos.Y<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.Y = -CanvasSlot:GetSize().Y + UpLimitParam.DownMoveLen<br>                IsNeedRebackY = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">elseif</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.Y + CanvasSlot:GetSize().Y &gt; UpLimitParam.UpMoveLen) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.Y = <span class="hljs-built_in">self</span>.WidgetCurPos.Y<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.Y = -CanvasSlot:GetSize().Y + UpLimitParam.UpMoveLen<br>                IsNeedRebackY = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.m_UpdateTimerFlag_Y <span class="hljs-keyword">and</span> IsNeedRebackY) == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_Y = <span class="hljs-literal">false</span><br>                <span class="hljs-built_in">self</span>.TimerHandle_Y = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnUpdateEdgeLerpTimer_Y&#125;, <span class="hljs-number">0.02</span>, <span class="hljs-literal">true</span>)<br>            <span class="hljs-keyword">end</span><br>            CanvasSlot:SetPosition(<span class="hljs-built_in">self</span>.WidgetCurPos)<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">local</span> viewport_geometry = UE4.UWidgetLayoutLibrary.GetViewportWidgetGeometry(<span class="hljs-built_in">self</span>:GetOwningPlayer())<br>            <span class="hljs-keyword">local</span> viewportlocalsize = UE4.USlateBlueprintLibrary.GetLocalSize(viewport_geometry)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.X + CanvasSlot:GetSize().X &lt; viewportlocalsize.X / <span class="hljs-number">2</span> ) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.X = <span class="hljs-built_in">self</span>.WidgetCurPos.X<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.X = -CanvasSlot:GetSize().X + viewportlocalsize.X / <span class="hljs-number">2</span> <br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>                    <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X = <span class="hljs-literal">false</span><br>                    <span class="hljs-built_in">self</span>.TimerHandle_X = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnUpdateEdgeLerpTimer_X&#125;, <span class="hljs-number">0.02</span>, <span class="hljs-literal">true</span>)<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.WidgetCurPos.Y + CanvasSlot:GetSize().Y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">self</span>.m_SavePrePos.Y = <span class="hljs-built_in">self</span>.WidgetCurPos.Y<br>                <span class="hljs-built_in">self</span>.m_SaveTarPos.Y = -CanvasSlot:GetSize().Y<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_Y == <span class="hljs-literal">true</span> <span class="hljs-keyword">then</span><br>                    <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_Y = <span class="hljs-literal">false</span><br>                    <span class="hljs-built_in">self</span>.TimerHandle_Y = UE4.UKismetSystemLibrary.K2_SetTimerDelegate(&#123;<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.OnUpdateEdgeLerpTimer_Y&#125;, <span class="hljs-number">0.02</span>, <span class="hljs-literal">true</span>)<br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>            CanvasSlot:SetPosition(<span class="hljs-built_in">self</span>.WidgetCurPos)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--X方向的拖拽回弹</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnUpdateEdgeLerpTimer_X</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.Updatetime_X = <span class="hljs-built_in">self</span>.Updatetime_X + <span class="hljs-number">0.1</span><br>    <span class="hljs-built_in">self</span>.WidgetCurPos.X = UE4.UKismetMathLibrary.Lerp(<span class="hljs-built_in">self</span>.m_SavePrePos.X, <span class="hljs-built_in">self</span>.m_SaveTarPos.X, <span class="hljs-built_in">self</span>.Updatetime_X)<br>    <span class="hljs-comment">-- self:UpdateEdgeLerp()</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.Updatetime_X &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span> <span class="hljs-comment">--超时,关闭定时器</span><br>        <span class="hljs-built_in">self</span>.Updatetime_X = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X = <span class="hljs-literal">true</span><br>        UE4.UKismetSystemLibrary.K2_ClearAndInvalidateTimerHandle(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.TimerHandle_X)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--Y方向的拖拽回弹</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnUpdateEdgeLerpTimer_Y</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">self</span>.Updatetime_Y = <span class="hljs-built_in">self</span>.Updatetime_Y + <span class="hljs-number">0.1</span><br>    <span class="hljs-built_in">self</span>.WidgetCurPos.Y = UE4.UKismetMathLibrary.Lerp(<span class="hljs-built_in">self</span>.m_SavePrePos.Y, <span class="hljs-built_in">self</span>.m_SaveTarPos.Y, <span class="hljs-built_in">self</span>.Updatetime_Y)<br>    <span class="hljs-comment">-- self:UpdateEdgeLerp()</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.Updatetime_Y &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.Updatetime_Y = <span class="hljs-number">0</span><br>        <span class="hljs-built_in">self</span>.m_UpdateTimerFlag_X = <span class="hljs-literal">true</span><br>        UE4.UKismetSystemLibrary.K2_ClearAndInvalidateTimerHandle(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.TimerHandle_Y)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--更新回弹的位置</span><br><span class="hljs-comment">-- function TouchComponent:UpdateEdgeLerp(PointerIndex)</span><br><span class="hljs-comment">--     local CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(self.SubTouchItems[PointerIndex + 1])</span><br><span class="hljs-comment">--     CanvasSlot:SetPosition(FVector2D(self.WidgetCurPos.X, self.WidgetCurPos.Y))</span><br><span class="hljs-comment">-- end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:OnUpdatePosFlag</span><span class="hljs-params">(PointerIndex)</span></span><br>    <span class="hljs-comment">-- 处理实际的控件移动结束之后</span><br>    <span class="hljs-keyword">local</span> SubTouchItem = <span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">local</span> LimitRangeInfo = <span class="hljs-built_in">self</span>.LimitRangeParam[SubTouchItem]<br>    <span class="hljs-keyword">if</span> (LimitRangeInfo <span class="hljs-keyword">and</span> LimitRangeInfo.TouchTimes == <span class="hljs-number">-1</span>) <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">self</span>.UpdatePosFlag[<span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>]] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> (LimitRangeInfo <span class="hljs-keyword">and</span> LimitRangeInfo.NeedResetPos) <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">local</span> CanvasSlot = UE4.UWidgetLayoutLibrary.SlotAsCanvasSlot(SubTouchItem)<br>        <span class="hljs-keyword">if</span> (CanvasSlot ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span><br>            CanvasSlot:SetPosition(<span class="hljs-built_in">self</span>.WidgetStartPos)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">self</span>:AfterTouchItemMove(PointerIndex)<br>    UE4.UKismetSystemLibrary.K2_ClearAndInvalidateTimerHandle(<span class="hljs-built_in">self</span>, <span class="hljs-built_in">self</span>.UpdatePosTimerHandle)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TouchComponent:AfterTouchItemMove</span><span class="hljs-params">(PointerIndex)</span></span><br>    <span class="hljs-built_in">self</span>.SubTouchItems[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.SubTouchParentWidget[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.SubTouchItemsName[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.SubTouchItemsStartPos[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span> <br>    <span class="hljs-built_in">self</span>.m_LastPosTable[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.CurrentTouchingGeometry[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br>    <span class="hljs-built_in">self</span>.CurrentTouchingGestureEvent[PointerIndex + <span class="hljs-number">1</span>] = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> TouchComponent<br><br></code></pre></td></tr></table></figure><p>然后就是我自己写的逻辑，其实这个要做的就是，再Start的时候记录起始的位置，然后再Move的时候记录move的终点，根据这个distance来算出该怎么移动，要注意Move是只要改变了就会触发，如果一直按住是不会触发，所以要自己写一个定时器来处理他一直按在一个方向不动的逻辑</p><h1 id="svn如何只更新某几个目录？"><a href="#svn如何只更新某几个目录？" class="headerlink" title="svn如何只更新某几个目录？"></a>svn如何只更新某几个目录？</h1><p>Repo-brower</p><p>然后在里面update item</p><h1 id="安卓苹果视频问题"><a href="#安卓苹果视频问题" class="headerlink" title="安卓苹果视频问题"></a>安卓苹果视频问题</h1><p>UE4底层差异的根本原因：</p><ol><li><p>Android平台：使用Java MediaPlayer + OpenGL ES，依赖应用级渲染上下文，切后台时上下文丢失</p></li><li><p>iOS平台：使用AVFoundation + Metal，系统级媒体管理，自动处理生命周期变化</p></li></ol><h1 id="从RewardId到ListView"><a href="#从RewardId到ListView" class="headerlink" title="从RewardId到ListView"></a>从RewardId到ListView</h1><p>每次都要翻然后重新写，这里直接记录一下算了，反正都是重复的步骤</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> RewardContentList = &#123;&#125;<br><span class="hljs-built_in">self</span>.List_Reward.OnCreateEmptyContent:Unbind()<br>        <span class="hljs-built_in">self</span>.List_Reward.OnCreateEmptyContent:Bind(<span class="hljs-built_in">self</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>            <span class="hljs-keyword">local</span> Content = NewObject(UIUtils.GetCommonItemContentClass())<br>            Content.Id = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> Content<br>        <span class="hljs-keyword">end</span>)<br>        <span class="hljs-keyword">local</span> RewardInfo = DataMgr.Reward[PreViewReward]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">self</span>.RewardList == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">self</span>.RewardList = &#123;&#125;<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> RewardInfo <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">local</span> RewardIds = RewardInfo.Id <span class="hljs-keyword">or</span> &#123;&#125;<br>            <span class="hljs-keyword">local</span> RewardCounts = RewardInfo.Count <span class="hljs-keyword">or</span> &#123;&#125;<br>            <span class="hljs-keyword">local</span> RewardTypes = RewardInfo.Type <span class="hljs-keyword">or</span> &#123;&#125;<br>            <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, #RewardIds <span class="hljs-keyword">do</span><br>                <span class="hljs-keyword">local</span> ItemId = RewardIds[i]<br>                <span class="hljs-keyword">local</span> Count = RewardUtils:GetCount(RewardCounts[i])<br>                <span class="hljs-keyword">local</span> Rarity = ItemUtils.GetItemRarity(ItemId, RewardTypes[i])<br>                <span class="hljs-keyword">local</span> ItemType = RewardTypes[i]<br>                <span class="hljs-keyword">local</span> Content = NewObject(UIUtils.GetCommonItemContentClass())<br>                Content.Id = ItemId<br>                Content.ItemType = ItemType<br>                Content.Count = Count<br>                Content.Rarity = Rarity<br>                Content.Icon = DataMgr[ItemType][ItemId].Icon<br>                Content.IsShowDetails = <span class="hljs-literal">true</span><br>                Content.ParentWidget = <span class="hljs-built_in">self</span><br>                <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(RewardContentList, Content)<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">for</span> _, ItemContent <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(RewardContentList) <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">self</span>.List_Reward:AddItem(ItemContent)<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-built_in">self</span>.List_Reward:RequestFillEmptyContent()<br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="如何查StoryLine（STL-的bug"><a href="#如何查StoryLine（STL-的bug" class="headerlink" title="如何查StoryLine（STL)的bug"></a>如何查StoryLine（STL)的bug</h1><p>日志，正则：StartNode|FinishNode</p><p>E:\Workgame1.0\Tools\storycreator</p><p>的Run.bat</p><p>lua的字符串</p><h1 id="如何获得ios设备类型"><a href="#如何获得ios设备类型" class="headerlink" title="如何获得ios设备类型"></a>如何获得ios设备类型</h1><p>IOSPlatformMisc.cpp</p><p>GetDefaultDeviceProfileName</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> TCHAR* <span class="hljs-title">FIOSPlatformMisc::GetDefaultDeviceProfileName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FString IOSDeviceProfileName;<br>    <span class="hljs-keyword">if</span> (IOSDeviceProfileName.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        IOSDeviceProfileName   = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;IOS&quot;</span>);<br><br>        FString DeviceIDString = <span class="hljs-built_in">GetIOSDeviceIDString</span>();<br>        FPlatformMisc::<span class="hljs-built_in">LowLevelOutputDebugStringf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Device Type: %s&quot;</span>) LINE_TERMINATOR, *DeviceIDString);<br><br>        TArray&lt;FString&gt; Mappings;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ensure</span>(GConfig-&gt;<span class="hljs-built_in">GetSection</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;IOSDeviceMappings&quot;</span>), Mappings, GDeviceProfilesIni)))<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FString&amp; MappingString: Mappings)<br>            &#123;<br>                FString MappingRegex, ProfileName;<br>                <span class="hljs-keyword">if</span> (MappingString.<span class="hljs-built_in">Split</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;=&quot;</span>), &amp;MappingRegex, &amp;ProfileName))<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-type">const</span> FRegexPattern <span class="hljs-title">RegexPattern</span><span class="hljs-params">(MappingRegex)</span></span>;<br>                    <span class="hljs-function">FRegexMatcher <span class="hljs-title">RegexMatcher</span><span class="hljs-params">(RegexPattern, *DeviceIDString)</span></span>;<br>                    <span class="hljs-keyword">if</span> (RegexMatcher.<span class="hljs-built_in">FindNext</span>())<br>                    &#123;<br>                        FPlatformMisc::<span class="hljs-built_in">LowLevelOutputDebugStringf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Matched %s as %s&quot;</span>) LINE_TERMINATOR, *MappingRegex, *ProfileName);<br>                        IOSDeviceProfileName = ProfileName;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    FPlatformMisc::<span class="hljs-built_in">LowLevelOutputDebugStringf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Invalid IOSDeviceMappings: %s&quot;</span>) LINE_TERMINATOR, *MappingString);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *IOSDeviceProfileName;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用了正则表达式来匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第385-407行的匹配逻辑</span><br>TArray&lt;FString&gt; Mappings;<br>GConfig-&gt;<span class="hljs-built_in">GetSection</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;IOSDeviceMappings&quot;</span>), Mappings, GDeviceProfilesIni);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> FString&amp; MappingString: Mappings)<br>&#123;<br>    FString MappingRegex, ProfileName;<br>    <span class="hljs-comment">// 分割配置行: &quot;iPhone14,2=iPhone13Pro&quot;</span><br>    MappingString.<span class="hljs-built_in">Split</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;=&quot;</span>), &amp;MappingRegex, &amp;ProfileName);<br>    <br>    <span class="hljs-comment">// 使用正则表达式匹配</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> FRegexPattern <span class="hljs-title">RegexPattern</span><span class="hljs-params">(MappingRegex)</span></span>;<br>    <span class="hljs-function">FRegexMatcher <span class="hljs-title">RegexMatcher</span><span class="hljs-params">(RegexPattern, *DeviceIDString)</span></span>;<br>    <br>    <span class="hljs-keyword">if</span> (RegexMatcher.<span class="hljs-built_in">FindNext</span>())<br>    &#123;<br>        <span class="hljs-comment">// 匹配成功！</span><br>        IOSDeviceProfileName = ProfileName;  <span class="hljs-comment">// &quot;iPhone13Pro&quot;</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h2><p>BaseDeviceProfiles.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[IOSDeviceMappings]</span><br><span class="hljs-comment">; iPhone 映射规则</span><br>iPhone3,<span class="hljs-section">[1-3]</span>=iPhone4<br>iPhone4,<span class="hljs-attr">1</span>=iPhone4S<br>iPhone5,<span class="hljs-section">[1-2]</span>=iPhone5<br>iPhone5,<span class="hljs-section">[3,4]</span>=iPhone5S<br>iPhone6,<span class="hljs-section">[1,2]</span>=iPhone5S<br>iPhone7,<span class="hljs-attr">1</span>=iPhone6Plus<br>iPhone7,<span class="hljs-attr">2</span>=iPhone6<br>iPhone8,<span class="hljs-section">[1,2]</span>=iPhone6S<br>iPhone8,<span class="hljs-attr">4</span>=iPhoneSE<br>iPhone9,<span class="hljs-section">[1,3]</span>=iPhone7<br>iPhone9,<span class="hljs-section">[2,4]</span>=iPhone7Plus<br>iPhone10,<span class="hljs-section">[1,4]</span>=iPhone8<br>iPhone10,<span class="hljs-section">[2,5]</span>=iPhone8Plus<br>iPhone10,<span class="hljs-section">[3,6]</span>=iPhoneX<br>iPhone11,<span class="hljs-attr">2</span>=iPhoneXS<br>iPhone11,<span class="hljs-section">[4,6]</span>=iPhoneXSMax<br>iPhone11,<span class="hljs-attr">8</span>=iPhoneXR<br>iPhone12,<span class="hljs-section">[1,3]</span>=iPhone11<br>iPhone12,<span class="hljs-section">[3,5]</span>=iPhone11Pro<br>iPhone12,<span class="hljs-attr">5</span>=iPhone11ProMax<br>iPhone12,<span class="hljs-attr">8</span>=iPhoneSE2<br><span class="hljs-comment">; iPhone 13系列</span><br>iPhone14,<span class="hljs-attr">4</span>=iPhone13mini<br>iPhone14,<span class="hljs-attr">5</span>=iPhone13<br>iPhone14,<span class="hljs-attr">2</span>=iPhone13Pro<br>iPhone14,<span class="hljs-attr">3</span>=iPhone13ProMax<br><span class="hljs-comment">; iPhone 14系列</span><br>iPhone14,<span class="hljs-attr">6</span>=iPhoneSE3<br>iPhone14,<span class="hljs-attr">7</span>=iPhone14<br>iPhone14,<span class="hljs-attr">8</span>=iPhone14Plus<br>iPhone15,<span class="hljs-attr">2</span>=iPhone14Pro<br>iPhone15,<span class="hljs-attr">3</span>=iPhone14ProMax<br><span class="hljs-comment">; iPhone 15系列</span><br>iPhone15,<span class="hljs-attr">4</span>=iPhone15<br>iPhone15,<span class="hljs-attr">5</span>=iPhone15Plus<br>iPhone16,<span class="hljs-attr">1</span>=iPhone15Pro<br>iPhone16,<span class="hljs-attr">2</span>=iPhone15ProMax<br><span class="hljs-comment">; iPhone 16系列</span><br>iPhone17,<span class="hljs-attr">1</span>=iPhone16Pro<br>iPhone17,<span class="hljs-attr">2</span>=iPhone16ProMax<br>iPhone17,<span class="hljs-attr">3</span>=iPhone16<br>iPhone17,<span class="hljs-attr">4</span>=iPhone16Plus<br><br><span class="hljs-comment">; iPad 映射规则</span><br>iPad2,<span class="hljs-section">[1-3]</span>=iPad2<br>iPad2,<span class="hljs-section">[5-7]</span>=iPadMini<br>iPad3,<span class="hljs-section">[1-3]</span>=iPad3<br>iPad3,<span class="hljs-section">[4-6]</span>=iPad4<br>iPad4,<span class="hljs-section">[1-3]</span>=iPadAir<br>iPad4,<span class="hljs-section">[4-6]</span>=iPadMini2<br>iPad4,<span class="hljs-section">[7-9]</span>=iPadMini3<br>iPad5,<span class="hljs-section">[1,2]</span>=iPadMini4<br>iPad5,<span class="hljs-section">[3,4]</span>=iPadAir2<br>iPad6,<span class="hljs-section">[3,4]</span>=iPadPro_97<br>iPad6,<span class="hljs-section">[7,8]</span>=iPadPro_129<br>iPad6,<span class="hljs-attr">11</span>=iPad5<br>iPad7,<span class="hljs-section">[1,2]</span>=iPadPro2_129<br>iPad7,<span class="hljs-section">[3,4]</span>=iPadPro105<br>iPad7,<span class="hljs-section">[5,6]</span>=iPad6<br>iPad7,<span class="hljs-attr">11</span>=iPad7<br>iPad8,<span class="hljs-section">[1-4]</span>=iPadPro11<br>iPad8,<span class="hljs-section">[5-8]</span>=iPadPro3_129<br>iPad8,<span class="hljs-attr">9</span>=iPadPro<span class="hljs-number">2_11</span><br>iPad8,<span class="hljs-attr">10</span>=iPadPro<span class="hljs-number">2_11</span><br>iPad8,<span class="hljs-attr">11</span>=iPadPro<span class="hljs-number">4_129</span><br>iPad8,<span class="hljs-attr">12</span>=iPadPro<span class="hljs-number">4_129</span><br>iPad11,<span class="hljs-section">[1,2]</span>=iPadMini5<br>iPad11,<span class="hljs-section">[3,4]</span>=iPadAir3<br>iPad11,<span class="hljs-section">[6,7]</span>=iPad8<br><br><span class="hljs-comment">; 通用降级规则（当没有匹配到具体设备时）</span><br><span class="hljs-attr">iPhone</span>=iPhone16      <span class="hljs-comment">; 未识别的iPhone → 默认为iPhone16</span><br><span class="hljs-attr">iPod</span>=iPodTouch7      <span class="hljs-comment">; 未识别的iPod → 默认为iPodTouch7</span><br><span class="hljs-attr">iPad</span>=iPad10          <span class="hljs-comment">; 未识别的iPad → 默认为iPad10</span><br><span class="hljs-attr">AppleTV</span>=AppleTV4K    <span class="hljs-comment">; 未识别的AppleTV → 默认为AppleTV4K</span><br></code></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs txt">┌─────────────────────────────────────────────────────┐<br>│  1. 启动时调用                                        │<br>│     GetDefaultDeviceProfileName()                    │<br>└────────────────┬────────────────────────────────────┘<br>                 ↓<br>┌─────────────────────────────────────────────────────┐<br>│  2. sysctlbyname(&quot;hw.machine&quot;)                       │<br>│     → &quot;iPhone14,2&quot;                                   │<br>└────────────────┬────────────────────────────────────┘<br>                 ↓<br>┌─────────────────────────────────────────────────────┐<br>│  3. 读取配置文件                                      │<br>│     BaseDeviceProfiles.ini → [IOSDeviceMappings]    │<br>└────────────────┬────────────────────────────────────┘<br>                 ↓<br>┌─────────────────────────────────────────────────────┐<br>│  4. 正则匹配                                          │<br>│     &quot;iPhone14,2&quot; 匹配 &quot;iPhone14,2=iPhone13Pro&quot;      │<br>└────────────────┬────────────────────────────────────┘<br>                 ↓<br>┌─────────────────────────────────────────────────────┐<br>│  5. 返回 Profile 名称                                │<br>│     → &quot;iPhone13Pro&quot;                                  │<br>└────────────────┬────────────────────────────────────┘<br>                 ↓<br>┌─────────────────────────────────────────────────────┐<br>│  6. 应用性能设置                                      │<br>│     [iPhone13Pro DeviceProfile] 的所有 CVars        │<br>└─────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><h2 id="为什么这个要判断一下长度？"><a href="#为什么这个要判断一下长度？" class="headerlink" title="为什么这个要判断一下长度？"></a>为什么这个要判断一下长度？</h2><p>因为statcic局部变量只创建一次，但不是每次调用时创建，这样就不用每次都走这个逻辑，可以直接返回</p><h2 id="sysctlbyname"><a href="#sysctlbyname" class="headerlink" title="sysctlbyname"></a>sysctlbyname</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这是一个</p><ul><li><p>✅ BSD系统调用（不是C++标准库函数）</p></li><li><p>✅ 操作系统API（由iOS&#x2F;macOS内核提供）</p></li><li><p>✅ 声明位置：&lt;sys&#x2F;sysctl.h&gt; 系统头文件</p></li><li><p>✅ 实现位置：libsystem_kernel.dylib 系统库</p></li><li><p>✅ 编译时：通过 .mm 文件的隐式包含自动可用</p></li></ul><p>作用是查询或设置操作系统内核的运行时参数</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sysctl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysctlbyname</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,      <span class="hljs-comment">// 要查询的参数名称</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> *oldp,            <span class="hljs-comment">// 存放返回值的缓冲区</span></span><br><span class="hljs-params">    <span class="hljs-type">size_t</span> *oldlenp,       <span class="hljs-comment">// 输入/输出：缓冲区大小</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *newp,      <span class="hljs-comment">// 要设置的新值（只读时传NULL）</span></span><br><span class="hljs-params">    <span class="hljs-type">size_t</span> newlen          <span class="hljs-comment">// 新值的长度（只读时传0）</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>所以UE这里要两次拿值，第一次拿字符串需要的大小，第二次再拿真正的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一次调用：获取长度</span><br><span class="hljs-type">size_t</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">sysctlbyname</span>(<span class="hljs-string">&quot;hw.machine&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;length, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 动态分配内存</span><br><span class="hljs-type">char</span>* buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(length);<br><br><span class="hljs-comment">// 第二次调用：获取数据</span><br><span class="hljs-built_in">sysctlbyname</span>(<span class="hljs-string">&quot;hw.machine&quot;</span>, buffer, &amp;length, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;设备: %s\n&quot;</span>, buffer);<br><br><span class="hljs-built_in">free</span>(buffer);<br></code></pre></td></tr></table></figure><h3 id="可查询的参数"><a href="#可查询的参数" class="headerlink" title="可查询的参数"></a>可查询的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ==================== 设备识别 ====================</span><br>hw.machine          <span class="hljs-comment">// &quot;iPhone14,2&quot; - 设备型号</span><br>hw.model            <span class="hljs-comment">// &quot;N71mAP&quot; - 硬件代号</span><br><br><span class="hljs-comment">// ==================== 性能相关 ====================</span><br>hw.ncpu             <span class="hljs-comment">// 6 - CPU核心数</span><br>hw.cpufrequency     <span class="hljs-comment">// 3200000000 - CPU频率</span><br>hw.memsize          <span class="hljs-comment">// 6442450944 - 总内存(字节)</span><br>hw.physmem          <span class="hljs-comment">// 实际物理内存</span><br>hw.pagesize         <span class="hljs-comment">// 16384 - 内存页大小</span><br><br><span class="hljs-comment">// ==================== 系统信息 ====================</span><br>kern.ostype         <span class="hljs-comment">// &quot;Darwin&quot; - 系统类型</span><br>kern.osrelease      <span class="hljs-comment">// &quot;21.0.0&quot; - 内核版本</span><br>kern.osversion      <span class="hljs-comment">// iOS版本</span><br>kern.boottime       <span class="hljs-comment">// 开机时间</span><br><br><span class="hljs-comment">// ==================== 电池/性能 ====================</span><br>hw.cpufrequency_max <span class="hljs-comment">// 最大CPU频率</span><br>hw.tbfrequency      <span class="hljs-comment">// Timebase频率</span><br><br><span class="hljs-comment">// ==================== 调试信息 ====================</span><br>kern.osproductversion  <span class="hljs-comment">// &quot;15.0&quot; - iOS版本号</span><br>kern.version           <span class="hljs-comment">// 完整版本字符串</span><br></code></pre></td></tr></table></figure><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://www.manpagez.com/man/3/sysctlbyname/">https://www.manpagez.com/man/3/sysctlbyname/</a></p><p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&sektion=3">https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3</a></p><h2 id="GetIOSDeviceIDString原理"><a href="#GetIOSDeviceIDString原理" class="headerlink" title="GetIOSDeviceIDString原理"></a>GetIOSDeviceIDString原理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FString <span class="hljs-title">GetIOSDeviceIDString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> FString CachedResult;<br>    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> bCached = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!bCached)<br>    &#123;<br>        <span class="hljs-comment">// get the device hardware type string length</span><br>        <span class="hljs-type">size_t</span> DeviceIDLen;<br>        <span class="hljs-built_in">sysctlbyname</span>(<span class="hljs-string">&quot;hw.machine&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;DeviceIDLen, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// get the device hardware type</span><br>        <span class="hljs-type">char</span>* DeviceID = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(DeviceIDLen);<br>        <span class="hljs-built_in">sysctlbyname</span>(<span class="hljs-string">&quot;hw.machine&quot;</span>, DeviceID, &amp;DeviceIDLen, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>        CachedResult = <span class="hljs-built_in">ANSI_TO_TCHAR</span>(DeviceID);<br>        bCached      = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-built_in">free</span>(DeviceID);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> CachedResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>防止太小缓冲区溢出，直接太大可能浪费内存，并且不优雅，而且未来ios可能返回更长</p><h1 id="鼠标滚动没有响应手柄的热切换"><a href="#鼠标滚动没有响应手柄的热切换" class="headerlink" title="鼠标滚动没有响应手柄的热切换"></a>鼠标滚动没有响应手柄的热切换</h1><p>改这个函数HandleMouseWheelOrGestureEvent</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">HandleMouseWheelOrGestureEvent</span><span class="hljs-params">(FSlateApplication&amp; SlateApp, <span class="hljs-type">const</span> FPointerEvent&amp; InWheelEvent, <span class="hljs-type">const</span> FPointerEvent* InGestureEvent)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> ECommonInputType InputType = <span class="hljs-built_in">GetInputType</span>(InWheelEvent);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsRelevantInput</span>(SlateApp, InWheelEvent, InputType))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsInputMethodBlocked</span>(InputType))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-built_in">RefreshCurrentInputMethod</span>(InputType);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="富文本的图片居中显示"><a href="#富文本的图片居中显示" class="headerlink" title="富文本的图片居中显示"></a>富文本的图片居中显示</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">        <span class="hljs-type">const</span> <span class="hljs-type">float</span> UnscaleLineHeight = MaxAboveBaseline + MaxBelowBaseline;<br><br>        <span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index &lt; OutSoftLine.<span class="hljs-built_in">Num</span>(); Index++)<br>        &#123;<br>            <span class="hljs-type">const</span> TSharedRef&lt;ILayoutBlock&gt; Block = OutSoftLine[Index];<br>            <span class="hljs-type">const</span> TSharedRef&lt;IRun&gt; Run           = Block-&gt;<span class="hljs-built_in">GetRun</span>();<br><br>            <span class="hljs-type">const</span> int16 BlockBaseline            = Run-&gt;<span class="hljs-built_in">GetBaseLine</span>(Scale);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0  <span class="hljs-comment">// ​​Vertical Alignment​​ : Bottom</span></span><br><span class="hljs-type">const</span> int16 VerticalOffset = MaxAboveBaseline - Block-&gt;<span class="hljs-built_in">GetSize</span>().Y - BlockBaseline;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// ​​Vertical Alignment​​ : Center</span></span><br>            <span class="hljs-type">const</span> int16 VerticalOffset = UnscaleLineHeight / <span class="hljs-number">2.0f</span> - Block-&gt;<span class="hljs-built_in">GetSize</span>().Y / <span class="hljs-number">2.0f</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里这个# if 0是条件编译的意思，#if 0 &#x3D; 永远为假的条件编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1    <span class="hljs-comment">// 条件为真（1 = true）</span></span><br>    <span class="hljs-comment">// 这段代码会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0    <span class="hljs-comment">// 条件为假（0 = false）</span></span><br>    <span class="hljs-comment">// 这段代码不会被编译</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这个修改的原理大概如下文章：</p><p><a href="https://zhuanlan.zhihu.com/p/27970081698">UE5富文本系列之文本图片居中显示优化 - Zzzz的文章 - 知乎</a><br>实现的效果如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250930170113903.png" alt="image-20250930170113903"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250930170121038.png" alt="image-20250930170121038"></p><h2 id="完整调用链"><a href="#完整调用链" class="headerlink" title="完整调用链"></a>完整调用链</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">蓝图/编辑器<br>    ↓<br>URichTextBlock (UMG层)<br>    ↓<br>SRichTextBlock (Slate Widget层)<br>    ↓<br>FSlateTextBlockLayout (布局缓存层)<br>    ↓<br>FTextLayout (文本布局引擎)<br>    ↓<br>CreateLineViewBlocks() ← 你看到的代码<br>    ↓<br>像素级计算（VerticalOffset）<br></code></pre></td></tr></table></figure><h2 id="第一步：创建Widget"><a href="#第一步：创建Widget" class="headerlink" title="第一步：创建Widget"></a>第一步：创建Widget</h2><h3 id="1-1蓝图创建RichTextBlock"><a href="#1-1蓝图创建RichTextBlock" class="headerlink" title="1.1蓝图创建RichTextBlock"></a>1.1蓝图创建RichTextBlock</h3><h3 id="1-2-UMG层构造"><a href="#1-2-UMG层构造" class="headerlink" title="1.2 UMG层构造"></a>1.2 UMG层构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RichTextBlock.cpp 第67行</span><br><span class="hljs-function">TSharedRef&lt;SWidget&gt; <span class="hljs-title">URichTextBlock::RebuildWidget</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">UpdateStyleData</span>();<br>    <br>    <span class="hljs-comment">// 创建装饰器（处理&lt;img&gt;、&lt;b&gt;等标签）</span><br>    TArray&lt;TSharedRef&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ITextDecorator</span>&gt;&gt; CreatedDecorators;<br>    <span class="hljs-built_in">CreateDecorators</span>(CreatedDecorators);<br>    <br>    <span class="hljs-comment">// 创建Marshaller（解析富文本标记）</span><br>    TSharedRef&lt;FRichTextLayoutMarshaller&gt; Marshaller = <br>        FRichTextLayoutMarshaller::<span class="hljs-built_in">Create</span>(<br>            <span class="hljs-built_in">CreateMarkupParser</span>(),     <span class="hljs-comment">// 解析&lt;img&gt;、&lt;b&gt;等</span><br>            <span class="hljs-built_in">CreateMarkupWriter</span>(), <br>            CreatedDecorators,        <span class="hljs-comment">// 装饰器列表</span><br>            StyleInstance.<span class="hljs-built_in">Get</span>()<br>        );<br>    <br>    <span class="hljs-comment">// 创建Slate Widget</span><br>    MyRichTextBlock =<br>        <span class="hljs-built_in">SNew</span>(SRichTextBlock)<br>            .<span class="hljs-built_in">TextStyle</span>(&amp;DefaultTextStyle)<br>            .<span class="hljs-built_in">Marshaller</span>(Marshaller);  <span class="hljs-comment">// 传入Marshaller</span><br>    <br>    <span class="hljs-keyword">return</span> MyRichTextBlock.<span class="hljs-built_in">ToSharedRef</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li><p>✅ 创建 SRichTextBlock（Slate层的实际Widget）</p></li><li><p>✅ 设置 Marshaller（富文本解析器）</p></li><li><p>✅ 绑定样式和装饰器</p></li></ul><h3 id="1-3-Slate层初始化"><a href="#1-3-Slate层初始化" class="headerlink" title="1.3 Slate层初始化"></a>1.3 Slate层初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// SRichTextBlock构造时</span><br>SRichTextBlock::<span class="hljs-built_in">SRichTextBlock</span>()<br>&#123;<br>    <span class="hljs-comment">// 创建文本布局缓存</span><br>    TextLayoutCache = <span class="hljs-built_in">MakeUnique</span>&lt;FSlateTextBlockLayout&gt;(...);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第2步：同步属性（配置阶段）"><a href="#第2步：同步属性（配置阶段）" class="headerlink" title="第2步：同步属性（配置阶段）"></a>第2步：同步属性（配置阶段）</h2><h3 id="2-1-UMG同步到Slate"><a href="#2-1-UMG同步到Slate" class="headerlink" title="2.1 UMG同步到Slate"></a>2.1 UMG同步到Slate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RichTextBlock.cpp 第84行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">URichTextBlock::SynchronizeProperties</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Super::<span class="hljs-built_in">SynchronizeProperties</span>();<br>    <br>    <span class="hljs-comment">// 设置文本内容</span><br>    MyRichTextBlock-&gt;<span class="hljs-built_in">SetText</span>(Text);<br>    <br>    <span class="hljs-comment">// 设置转换策略</span><br>    MyRichTextBlock-&gt;<span class="hljs-built_in">SetTransformPolicy</span>(TextTransformPolicy);<br>    <br>    <span class="hljs-comment">// 设置最小宽度</span><br>    MyRichTextBlock-&gt;<span class="hljs-built_in">SetMinDesiredWidth</span>(MinDesiredWidth);<br>    <br>    <span class="hljs-comment">// 同步布局属性（对齐、换行等）</span><br>    Super::<span class="hljs-built_in">SynchronizeTextLayoutProperties</span>(*MyRichTextBlock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-同步布局属性"><a href="#2-2-同步布局属性" class="headerlink" title="2.2 同步布局属性"></a>2.2 同步布局属性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TextWidgetTypes.h 第69-80行</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TWidgetType&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SynchronizeTextLayoutProperties</span><span class="hljs-params">(TWidgetType&amp; InWidget)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置对齐方式（重点！）</span><br>    InWidget.<span class="hljs-built_in">SetJustification</span>(Justification);<br>    <br>    <span class="hljs-comment">// 设置自动换行</span><br>    InWidget.<span class="hljs-built_in">SetAutoWrapText</span>(!!AutoWrapText);<br>    <br>    <span class="hljs-comment">// 设置换行宽度</span><br>    InWidget.<span class="hljs-built_in">SetWrapTextAt</span>(WrapTextAt != <span class="hljs-number">0</span> ? WrapTextAt : <span class="hljs-built_in">TAttribute</span>&lt;<span class="hljs-type">float</span>&gt;());<br>    <br>    <span class="hljs-comment">// 设置换行策略</span><br>    InWidget.<span class="hljs-built_in">SetWrappingPolicy</span>(WrappingPolicy);<br>    <br>    <span class="hljs-comment">// 设置边距</span><br>    InWidget.<span class="hljs-built_in">SetMargin</span>(Margin);<br>    <br>    <span class="hljs-comment">// 设置行高百分比</span><br>    InWidget.<span class="hljs-built_in">SetLineHeightPercentage</span>(LineHeightPercentage);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键：Justification 属性在这里传递到Slate层！</p><h2 id="第3步：渲染触发（绘制阶段）"><a href="#第3步：渲染触发（绘制阶段）" class="headerlink" title="第3步：渲染触发（绘制阶段）"></a>第3步：渲染触发（绘制阶段）</h2><h3 id="3-1-Slate渲染循环"><a href="#3-1-Slate渲染循环" class="headerlink" title="3.1 Slate渲染循环"></a>3.1 Slate渲染循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 每帧渲染时，Slate系统调用</span><br>SWidget::<span class="hljs-built_in">Paint</span>()<br>    ↓<br>SRichTextBlock::<span class="hljs-built_in">OnPaint</span>()<br></code></pre></td></tr></table></figure><h3 id="3-2-SRichTextBlock-OnPaint"><a href="#3-2-SRichTextBlock-OnPaint" class="headerlink" title="3.2 SRichTextBlock::OnPaint()"></a>3.2 SRichTextBlock::OnPaint()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// SRichTextBlock.cpp 第64行</span><br><span class="hljs-function">int32 <span class="hljs-title">SRichTextBlock::OnPaint</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> FPaintArgs&amp; Args, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> FGeometry&amp; AllottedGeometry,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> FSlateRect&amp; MyCullingRect, </span></span><br><span class="hljs-params"><span class="hljs-function">    FSlateWindowElementList&amp; OutDrawElements,</span></span><br><span class="hljs-params"><span class="hljs-function">    int32 LayerId,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> FWidgetStyle&amp; InWidgetStyle,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">bool</span> bParentEnabled)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 关键：OnPaint会触发布局更新</span><br>    LayerId = TextLayoutCache-&gt;<span class="hljs-built_in">OnPaint</span>(<br>        Args,<br>        TextBlockScaledGeometry,<br>        MyCullingRect,<br>        OutDrawElements,<br>        LayerId,<br>        InWidgetStyle,<br>        <span class="hljs-built_in">ShouldBeEnabled</span>(bParentEnabled)<br>    );<br>    <br>    <span class="hljs-keyword">return</span> LayerId;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-计算期望尺寸（可能触发布局）"><a href="#3-3-计算期望尺寸（可能触发布局）" class="headerlink" title="3.3 计算期望尺寸（可能触发布局）"></a>3.3 计算期望尺寸（可能触发布局）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// SRichTextBlock.cpp 第88行</span><br><span class="hljs-function">FVector2D <span class="hljs-title">SRichTextBlock::ComputeDesiredSize</span><span class="hljs-params">(<span class="hljs-type">float</span> LayoutScaleMultiplier)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ComputeDesiredSize也会触发布局更新</span><br>    <span class="hljs-type">const</span> FVector2D TextSize = TextLayoutCache-&gt;<span class="hljs-built_in">ComputeDesiredSize</span>(<br>        FSlateTextBlockLayout::<span class="hljs-built_in">FWidgetArgs</span>(<br>            BoundText,<br>            HighlightText,<br>            WrapTextAt,<br>            AutoWrapText,<br>            WrappingPolicy,<br>            TransformPolicy,<br>            Margin,<br>            LineHeightPercentage,<br>            Justification  <span class="hljs-comment">// ← Justification在这里传入</span><br>        ),<br>        LayoutScaleMultiplier * TextBlockScale,<br>        TextStyle<br>    ) * TextBlockScale;<br>    <br>    <span class="hljs-keyword">return</span> TextSize;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第4步：布局计算（核心阶段）"><a href="#第4步：布局计算（核心阶段）" class="headerlink" title="第4步：布局计算（核心阶段）"></a>第4步：布局计算（核心阶段）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TextLayout.cpp 第1176行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FTextLayout::UpdateLayout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">SCOPE_CYCLE_COUNTER</span>(STAT_SlateTextLayout);<br>    <br>    <span class="hljs-comment">// 清除旧的视图</span><br>    <span class="hljs-built_in">ClearView</span>();<br>    <br>    <span class="hljs-comment">// 开始布局（通知所有Run）</span><br>    <span class="hljs-built_in">BeginLayout</span>();<br>    <br>    <span class="hljs-comment">// 【核心】流式布局（计算文本换行和Block位置）</span><br>    <span class="hljs-built_in">FlowLayout</span>();<br>    <br>    <span class="hljs-comment">// 应用对齐（左/中/右对齐）</span><br>    <span class="hljs-built_in">JustifyLayout</span>();<br>    <br>    <span class="hljs-comment">// 应用边距</span><br>    <span class="hljs-built_in">MarginLayout</span>();<br>    <br>    <span class="hljs-comment">// 结束布局</span><br>    <span class="hljs-built_in">EndLayout</span>();<br>    <br>    <span class="hljs-comment">// 清除脏标记</span><br>    DirtyFlags &amp;= ~ETextLayoutDirtyState::Layout;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第5步：CreateLineViewBlocks"><a href="#第5步：CreateLineViewBlocks" class="headerlink" title="第5步：CreateLineViewBlocks()"></a>第5步：CreateLineViewBlocks()</h2><h3 id="第一次遍历计算行高"><a href="#第一次遍历计算行高" class="headerlink" title="第一次遍历计算行高"></a>第一次遍历计算行高</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TextLayout.cpp 第334-338行</span><br><span class="hljs-comment">// 遍历行中的所有Run（文本、图片等）</span><br><span class="hljs-keyword">for</span> (每个Run)<br>&#123;<br>    <span class="hljs-comment">// 获取基线（负数，翻转符号）</span><br>    <span class="hljs-type">const</span> int16 Baseline = -(Run.<span class="hljs-built_in">GetBaseLine</span>(Scale));<br>    <br>    <span class="hljs-comment">// 计算基线以上的最大高度</span><br>    MaxAboveBaseline = FMath::<span class="hljs-built_in">Max</span>(<br>        MaxAboveBaseline,<br>        (int16)(Run.<span class="hljs-built_in">GetMaxHeight</span>(Scale) - Baseline)<br>    );<br>    <br>    <span class="hljs-comment">// 计算基线以下的最大高度</span><br>    MaxBelowBaseline = FMath::<span class="hljs-built_in">Max</span>(MaxBelowBaseline, Baseline);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二次遍历计算垂直位移"><a href="#第二次遍历计算垂直位移" class="headerlink" title="第二次遍历计算垂直位移"></a>第二次遍历计算垂直位移</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TextLayout.cpp 第407-426行</span><br><span class="hljs-type">float</span> CurrentHorizontalPos = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-comment">// 【关键】计算行高</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> UnscaleLineHeight = MaxAboveBaseline + MaxBelowBaseline;  <span class="hljs-comment">// 32 + 6 = 38px</span><br><br><span class="hljs-comment">// 遍历所有Block，设置位置</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index &lt; OutSoftLine.<span class="hljs-built_in">Num</span>(); Index++)<br>&#123;<br>    <span class="hljs-type">const</span> TSharedRef&lt;ILayoutBlock&gt; Block = OutSoftLine[Index];<br>    <span class="hljs-type">const</span> TSharedRef&lt;IRun&gt; Run = Block-&gt;<span class="hljs-built_in">GetRun</span>();<br>    <br>    <span class="hljs-type">const</span> int16 BlockBaseline = Run-&gt;<span class="hljs-built_in">GetBaseLine</span>(Scale);<br>    <br>    <span class="hljs-comment">// ========================================</span><br>    <span class="hljs-comment">// 【核心计算】垂直偏移量</span><br>    <span class="hljs-comment">// ========================================</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0  <span class="hljs-comment">// 底部对齐（已禁用）</span></span><br>    <span class="hljs-type">const</span> int16 VerticalOffset = MaxAboveBaseline - Block-&gt;<span class="hljs-built_in">GetSize</span>().Y - BlockBaseline;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span>  <span class="hljs-comment">// 居中对齐（当前使用）</span></span><br>    <span class="hljs-type">const</span> int16 VerticalOffset = UnscaleLineHeight / <span class="hljs-number">2.0f</span> - Block-&gt;<span class="hljs-built_in">GetSize</span>().Y / <span class="hljs-number">2.0f</span>;<br>    <span class="hljs-comment">//                            ↑                         ↑</span><br>    <span class="hljs-comment">//                        行中心点                  Block中心点</span><br>    <span class="hljs-comment">//                        </span><br>    <span class="hljs-comment">//                        效果：Block中心 = 行中心</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-comment">// 获取字距调整</span><br>    <span class="hljs-type">const</span> int8 BlockKerning = Run-&gt;<span class="hljs-built_in">GetKerning</span>(...);<br>    <br>    <span class="hljs-comment">// 【最终设置】Block的位置</span><br>    Block-&gt;<span class="hljs-built_in">SetLocationOffset</span>(<br>        <span class="hljs-built_in">FVector2D</span>(<br>            CurrentOffset.X + CurrentHorizontalPos + BlockKerning,  <span class="hljs-comment">// X坐标</span><br>            CurrentOffset.Y + VerticalOffset                        <span class="hljs-comment">// Y坐标（垂直居中）</span><br>        )<br>    );<br>    <br>    <span class="hljs-comment">// 累加水平位置</span><br>    CurrentHorizontalPos += Block-&gt;<span class="hljs-built_in">GetSize</span>().X;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整调用栈"><a href="#完整调用栈" class="headerlink" title="完整调用栈"></a>完整调用栈</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs txt">蓝图编辑器<br>    │<br>    │ 创建Widget<br>    ▼<br>URichTextBlock::RebuildWidget()<br>    │<br>    │ 创建Slate Widget<br>    ▼<br>SRichTextBlock 构造<br>    │<br>    │ 创建布局缓存<br>    ▼<br>FSlateTextBlockLayout 创建<br>    │<br>    │ 创建文本布局引擎<br>    ▼<br>FTextLayout 创建<br>    │<br>    │ 同步属性<br>    ▼<br>URichTextBlock::SynchronizeProperties()<br>    │<br>    │ 设置Justification等属性<br>    ▼<br>SRichTextBlock::SetJustification()<br>    │<br>    │<br>    │ ═══════════ 渲染帧开始 ═══════════<br>    │<br>    │ 每帧渲染<br>    ▼<br>SRichTextBlock::OnPaint()<br>    │<br>    │ 触发布局计算<br>    ▼<br>FSlateTextBlockLayout::OnPaint()<br>    │<br>    │ 检查是否需要更新布局<br>    ▼<br>FTextLayout::UpdateLayout()<br>    │<br>    ├─→ ClearView()<br>    ├─→ BeginLayout()<br>    │<br>    ├─→ FlowLayout()<br>    │       │<br>    │       ├─→ FlowLineLayout()  ← 处理每一行<br>    │       │       │<br>    │       │       └─→ CreateLineViewBlocks()  ← 【你看到的代码】<br>    │       │               │<br>    │       │               ├─ 第1次遍历：计算 MaxAboveBaseline, MaxBelowBaseline<br>    │       │               │<br>    │       │               ├─ 计算行高：UnscaleLineHeight = MaxAboveBaseline + MaxBelowBaseline<br>    │       │               │<br>    │       │               └─ 第2次遍历：计算每个Block的 VerticalOffset<br>    │       │                   │<br>    │       │                   └─ VerticalOffset = UnscaleLineHeight/2 - BlockHeight/2<br>    │       │<br>    │       └─→ 创建 LineView（包含所有Block的位置信息）<br>    │<br>    ├─→ JustifyLayout()  ← 水平对齐（左/中/右）<br>    ├─→ MarginLayout()   ← 应用边距<br>    │<br>    └─→ EndLayout()<br>    │<br>    │ 布局完成，绘制到屏幕<br>    ▼<br>实际渲染<br></code></pre></td></tr></table></figure><h1 id="如何在蓝图绑定事件"><a href="#如何在蓝图绑定事件" class="headerlink" title="如何在蓝图绑定事件"></a>如何在蓝图绑定事件</h1><p>点一下添加关键帧，然后右键属性搞一下</p><h1 id="使用手柄A键切换输入设备会使列表捕获鼠标导致手柄卡死操作不了"><a href="#使用手柄A键切换输入设备会使列表捕获鼠标导致手柄卡死操作不了" class="headerlink" title="使用手柄A键切换输入设备会使列表捕获鼠标导致手柄卡死操作不了"></a>使用手柄A键切换输入设备会使列表捕获鼠标导致手柄卡死操作不了</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">FAnalogCursor::HandleKeyUpEvent</span><span class="hljs-params">(FSlateApplication&amp; SlateApp, <span class="hljs-type">const</span> FKeyEvent&amp; InKeyEvent)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsRelevantInput</span>(InKeyEvent))<br>    &#123;<br>        FKey Key = InKeyEvent.<span class="hljs-built_in">GetKey</span>();<br><br>        <span class="hljs-comment">// Consume the sticks input so it doesn&#x27;t effect other things</span><br>        <span class="hljs-keyword">if</span> (Key == EKeys::Gamepad_LeftStick_Right ||<br>            Key == EKeys::Gamepad_LeftStick_Left ||<br>            Key == EKeys::Gamepad_LeftStick_Up ||<br>            Key == EKeys::Gamepad_LeftStick_Down)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Bottom face button is a click</span><br>        <span class="hljs-keyword">if</span> (Key == EKeys::Virtual_Accept &amp;&amp; !InKeyEvent.<span class="hljs-built_in">IsRepeat</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (TSharedPtr&lt;FSlateUser&gt; SlateUser = SlateApp.<span class="hljs-built_in">GetUser</span>(InKeyEvent))<br>            &#123;<br>                FVector2D CurrentPosition = SlateUser-&gt;<span class="hljs-built_in">GetCursorPosition</span>();<br>                <span class="hljs-keyword">if</span> (CurrentPosition.X &lt; <span class="hljs-number">0.01f</span> &amp;&amp; CurrentPosition.Y &lt; <span class="hljs-number">0.01f</span>)<br>                &#123;<br>                    <span class="hljs-type">const</span> TSharedPtr&lt;SWindow&gt; ParentWindow = FSlateApplication::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">GetActiveTopLevelWindow</span>();<br>                    <span class="hljs-keyword">if</span> (ParentWindow.<span class="hljs-built_in">IsValid</span>())<br>                    &#123;<br>                        FVector2D WindowPosition = ParentWindow-&gt;<span class="hljs-built_in">GetPositionInScreen</span>();<br>                        FVector2D WindowSize     = ParentWindow-&gt;<span class="hljs-built_in">GetSizeInScreen</span>();<br>                        CurrentPosition.X        = WindowPosition.X + WindowSize.X * <span class="hljs-number">0.5</span>;<br>                        CurrentPosition.Y        = WindowPosition.Y + WindowSize.Y * <span class="hljs-number">0.5</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-type">const</span> <span class="hljs-type">bool</span> bIsPrimaryUser = FSlateApplication::CursorUserIndex == SlateUser-&gt;<span class="hljs-built_in">GetUserIndex</span>();<br><br>                TSet&lt;FKey&gt; EmptySet;<br>                <span class="hljs-function">FPointerEvent <span class="hljs-title">MouseEvent</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                    SlateUser-&gt;GetUserIndex(),</span></span><br><span class="hljs-params"><span class="hljs-function">                    FSlateApplication::CursorPointerIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">                    CurrentPosition,</span></span><br><span class="hljs-params"><span class="hljs-function">                    SlateUser-&gt;GetPreviousCursorPosition(),</span></span><br><span class="hljs-params"><span class="hljs-function">                    bIsPrimaryUser ? SlateApp.GetPressedMouseButtons() : EmptySet,</span></span><br><span class="hljs-params"><span class="hljs-function">                    EKeys::LeftMouseButton,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                    bIsPrimaryUser ? SlateApp.GetModifierKeys() : FModifierKeysState())</span></span>;<br><br>                <span class="hljs-keyword">return</span> SlateApp.<span class="hljs-built_in">ProcessMouseButtonUpEvent</span>(MouseEvent);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个</p><p>联机GM</p><p>gm succquestchain 100208</p>]]></content>
    
    
    <summary type="html">在二重螺旋学到了很多，杂乱无章的记录一下都干了什么</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>2024年度总结</title>
    <link href="https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-01-13T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桌游"><a href="#桌游" class="headerlink" title="桌游"></a><strong>桌游</strong></h1><p>今年桌游开的少多了，离开了北京帮之后没有稳定的每周末约局了，不过也能和咩神zzh重温一些旧毛线，还是非常有趣的，相同的游戏和不同的人玩也相当快乐，总而言之桌游的精髓就是面对面交流。</p><h2 id="合作：炸弹克星"><a href="#合作：炸弹克星" class="headerlink" title="合作：炸弹克星"></a>合作：炸弹克星</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114214049.jpg"></p><p>这两个真是不分伯仲，都是非常有趣的合作游戏，论耐玩性和人数性质上来说炸弹克星要更好一点，可以2-5人的传承式合作桌游，途中你会经历找猪鼻、互相甩锅、被迫出猫、我觉得你觉得我知道的逻辑困境，强烈推荐。但是配件有些垃圾，如果数字板件换成塑料的就耐用很多了，全是纸板让人不敢大力使用。</p><h2 id="毛线：印加宝藏"><a href="#毛线：印加宝藏" class="headerlink" title="毛线：印加宝藏"></a>毛线：印加宝藏</h2><p>玩法相当简单，每回合你都要选择逃跑或者留下，每回合翻一张牌，选择跑的人可以和一起跑的人平分目前的宝藏，逃跑可能能遇到更好的金子，当然也可能遇到灾难血本无归。</p><p>这个游戏人数相当自由，2-7个人都可以，非常简单的数学模型但也充满博弈，</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/2.jpg"></p><h2 id="美术：流画溢彩"><a href="#美术：流画溢彩" class="headerlink" title="美术：流画溢彩"></a>美术：流画溢彩</h2><p>玩法很无聊但是美术很棒，玩法是从抽到的牌里面组合成自己的一幅画，会根据画上的图标来算分，相当无聊，但是能看到自己创造一幅画的感觉非常棒，我甚至觉得这有做成电子游戏的潜力。</p><p>组图</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/1.jpg"></div><div class="group-image-wrap"><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/3.jpg"></div></div></div><h2 id="猜词：巧手猜图"><a href="#猜词：巧手猜图" class="headerlink" title="猜词：巧手猜图"></a>猜词：巧手猜图</h2><p>非常有童真趣味的一个猜词游戏，有五套道具，例如积木、绳子、木块、数字、画板，每人轮换着用道具表示自己的目标图。这个设计精妙的地方就在于，你完全可以自制一套自己的道具，甚至要猜的图也可以自己自制，比如自己和朋友出行的合照，风景图，如果做一套作为礼物送给朋友一定相当的有意义，有机会试试！</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114220029.jpg"></p><h2 id="重策：神秘大地"><a href="#重策：神秘大地" class="headerlink" title="重策：神秘大地"></a>重策：神秘大地</h2><p>说实话今年因为回广州了没什么人开重策捏，离开了北京帮真是孤独呢，既然只玩了这一个重策那就只能是你了！游戏是多维度跑分，每个种族有截然不同的跑分策略和能力，虽然没有战斗但是互相卡人也相当恶心，但我也没玩多少把就是了。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250114220144.jpg"></p><h1 id="书"><a href="#书" class="headerlink" title="书"></a><strong>书</strong></h1><p>今年看的书大多都是小说，印象较深刻的都是一些短中篇小说集，这是否说明我逐渐短平快化了…</p><h2 id="深河"><a href="#深河" class="headerlink" title="深河"></a>深河</h2><p>一群日本人的印度之旅，没心没肺的新婚夫妇；失去妻子相信她会在印度转世的中年男人；得了胃病觉得是鹦鹉替自己死去的童话作家；经历了越南战争又目睹自己战友死亡的老兵；以及寻找着神质疑自己的信仰的“异端神父”，曾经捉弄过他后来又念念不忘，有些虚无主义的美津子。每个人都怀揣着自己的秘密，其中最让人动容的就是大津，辗转多地，寻求着“洋葱”是什么，其他人来到印度之后也都十分有触动，人生意义这种东西说白了感觉是一个无法思考清楚的问题啊….</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34666637.jpg"></p><h2 id="山月记"><a href="#山月记" class="headerlink" title="山月记"></a>山月记</h2><p>zz推荐，相当有意思，日本人写的他眼里的中国神话历史鬼怪故事，不知是翻译还是原文本就如此，文字很平淡克制，读起来很舒服。第一篇同名篇就很有意思，因为欲望而变成老虎的落魄诗人；李陵这篇把各种心理描写和挣扎写的很详细；很喜欢讲沙和尚这篇，很有悉达多的感觉，迷茫的沙僧各种寻找人生的意义，见识各种哲学流派，有意思；后面这篇对西游记师徒四人的“曲解”相当耐人寻味；最后这个讲子路与孔子的看得很感人，从小就接触论语，或多或少的对孔子的各种故事有所了解，完完整整的读一遍这种带有文学色彩的小传还是蛮感人的。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34264489.jpg"></p><h2 id="世上为什么要有图书馆"><a href="#世上为什么要有图书馆" class="headerlink" title="世上为什么要有图书馆"></a>世上为什么要有图书馆</h2><p>相当精彩的纪实文学，能看到作者对于图书、文字的热爱，略微文不对题但是还是相当精彩，其实讲了作者作为一个大学老师转换成政府官员的各种见闻。前半部分讲了从零到一建一个图书馆的方方面面，后半部分讲了许多小故事。关于书也关于人，作者是热爱书的，肆无忌惮买书的欣喜令人感同身受，但是在政府工作也有许许多多的不适应和脱离实际，这些看着也蛮有意思。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34705784.jpg"></p><h2 id="妙趣横生的游戏制作之旅"><a href="#妙趣横生的游戏制作之旅" class="headerlink" title="妙趣横生的游戏制作之旅"></a>妙趣横生的游戏制作之旅</h2><p>如果你想做线性的3A剧情游戏，比如神秘海域啊，战神啊这种，那么这本书的方法论非常有用，从项目管理的各个方面讲了游戏是怎么制作的，受益匪浅，算是从制作人的角度解释了游戏制作的流程。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34314229.jpg"></p><h2 id="平滑世界和它的敌人"><a href="#平滑世界和它的敌人" class="headerlink" title="平滑世界和它的敌人"></a>平滑世界和它的敌人</h2><p>太有意思了！第一篇同名篇一开始看设定感觉一头雾水，读起来感觉能不停穿越世界的感觉画面感太有意思了，女主那种感受到视线无法集中的心情也很有意思；《零零时代科幻史》成功骗到我了，还以为是真有此事哈哈哈；《献给美亚羽的手枪》是很标准的科幻啊，“如果明天的我喝今天的我想法不同了，那么我就不是我了吗？”，关于人类意识的探讨相当有意思；《神圣铁处女》有点推理小说的意思，最后漏底很惊讶；《奇点时代》太酷了，开头给人红色大超那个世界的感觉，然后是两个人工智能精彩的对垒，人类一方进入睡梦，一方沦为ai的计算资源，各种反转；《快于光，慢于光》太适合新海诚了啊，也是那种灾难科幻背景，男主女主奋不顾身地奔向对方，非常期待能改编成动画电影。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34233946.jpg"></p><h2 id="不间断的人"><a href="#不间断的人" class="headerlink" title="不间断的人"></a>不间断的人</h2><p>越来越喜欢双雪涛了，烦躁的时候翻来看看总能让我平静下来，双雪涛真是一个很标准很工整的小说家，前面的每一个引子后面都会用到。最喜欢《刺客爱人》这一篇，很长但是每个人的故事环环相扣，非常让人有读下去的欲望；同名篇的开头就很意思，“起来听钢琴声”，周易，第二部分的ai也很有意思，但是第三部分就显得有些看不懂了，有些过于奇怪；《淑女的选择》作为插在中间的小短篇恰到好处，也非常喜欢，结局猛烈而惊奇；三个小短篇给人感觉都差不多，读起来味道是有的，最喜欢《烟花》这一篇，中间一度以为是女孩的恶作剧，然而并不是，不过结局感觉有些草率；《拳击手》这篇感觉太多隐喻了，不太喜欢。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34765667.jpg"></p><h2 id="我们生活在南京"><a href="#我们生活在南京" class="headerlink" title="我们生活在南京"></a>我们生活在南京</h2><p>竟然是网文，令人惊讶，点子是挺不错的，主角作为一个无线电爱好者竟然收到了未来的来电，于是一场跨越时代的救援就这样展开了。行文有些口语化以及频繁重复词，这也是网文的通病了。女主是一个像夏弥一样乐天派坚强的姑娘，真讨喜。剧情有一点bug，两次时间胶囊看上去是验证了，但是完全有可能是对面看到了里面的东西然后根据二十年的推演来骗他们，然而主角团都没有考虑过这个问题。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34387186.jpg"></p><h2 id="第欧根尼变奏曲"><a href="#第欧根尼变奏曲" class="headerlink" title="第欧根尼变奏曲"></a>第欧根尼变奏曲</h2><p>超级好看的短篇集，推理元素没那么强，但是很有趣，有几篇比较水，首尾都相当有意思，窥伺蓝色的蓝的叙诡惊了，反转有意思；时间就是金钱有人生遥控器的味道了，最后的感慨特别有意思；作家出道杀人事件很有意思，直接从真实杀人体会自己的构想不足让人毛骨悚然啊；恶魔党杀（怪）人事件有种看日本漫画的感觉，真搞笑；隐身的X全场最佳，如果大学真的有这么有趣的课我一定会去上！陈浩基真喜欢叙诡啊！感觉这一篇改编成什么小短片很有意思</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s32295113.jpg"></p><h1 id="观影"><a href="#观影" class="headerlink" title="观影"></a><strong>观影</strong></h1><p>今年来的观影体验是经常落泪，可能是因为太容易触景生情，经历了生离死别之后再看电影中的场景，煽情的片段总是令我无法控制地落下眼泪。</p><h2 id="好东西"><a href="#好东西" class="headerlink" title="好东西"></a>好东西</h2><p>年度最佳喜剧，虽然有被批评太过碎片化段子化，不过还是相当精彩，很喜欢听声音那段，小孩耳中惊天动地的声音，其实只是母亲做家务的声音，这段蒙太奇绝了。许多台词也让人捧腹大笑，“你读过基本上野千纸鹤？”，“你怎么打女孩就怎么打”。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2915454411.webp" alt="好东西"></p><h2 id="里斯本丸沉没"><a href="#里斯本丸沉没" class="headerlink" title="里斯本丸沉没"></a>里斯本丸沉没</h2><p>太沉重了，这大概是我第一次感受到历史的力量，看着亲历者的讲述，真的很难想象他们是经历这些悲惨的日子之后 ，为何还能这样平淡地讲出来这些事。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2912588024.webp"></p><h2 id="白色巨塔"><a href="#白色巨塔" class="headerlink" title="白色巨塔"></a>白色巨塔</h2><p>最后一集哭了一整集，纵使财前多么的不择手段，在死亡面前一切都显得微不足道，其实财前内心深处还是对医学对生命充满敬畏的，只是大环境让他扭曲了太多😭😭😭看得我真的好伤心💔</p><p>看完白色巨塔之后，逐渐认识到没有什么事情是非黑即白的，理想主义也需要现实主义来支撑，要对抗腐朽的制度，得需要身怀理想主义的人深入其中，才能逐渐改变这种制度，财前是支撑白色巨塔建成的人，是支撑每一个里间这样的人能安稳研究的基础。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2892515613.webp" alt="白い巨塔"></p><h2 id="薄荷糖"><a href="#薄荷糖" class="headerlink" title="薄荷糖"></a>薄荷糖</h2><p>倒叙的讲述结构，一个人的毁灭是一瞬间的吗？还是缓慢地多方面地演变而来的，男主大声的呼喊着我要回去，但是似乎每一个节点他都不是很如意，该如何改变呢？</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2519637549.webp" alt="박하사탕"></p><h2 id="葬送的芙莉莲"><a href="#葬送的芙莉莲" class="headerlink" title="葬送的芙莉莲"></a>葬送的芙莉莲</h2><p>我向来是很喜欢公路片的，温暖的缓慢的旅途，真让人开心呢。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/p2897218476.webp" alt="葬送のフリーレン"></p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a><strong>游戏</strong></h1><h2 id="puzzle-game：LOK-Digital"><a href="#puzzle-game：LOK-Digital" class="headerlink" title="puzzle game：LOK Digital"></a>puzzle game：LOK Digital</h2><p>怪兽远征制作组的新作，依旧是高质量的puzzle game，游戏的主要玩法是连线一笔画，需要逐渐的探寻不同咒语的效果</p><h2 id="肉鸽：Genome-Guardian"><a href="#肉鸽：Genome-Guardian" class="headerlink" title="肉鸽：Genome Guardian"></a>肉鸽：Genome Guardian</h2><p>设计相当扎实的肉鸽弹幕设计游戏，你将扮演一个细胞，不断升级自己的武器，挺过一波又一波的关卡，听起来平平无奇，但是他的设计和主题融合的非常精妙。你升级武器的过程是获得不同的遗传因子，分别是ATCG，这个又对应武器的射速、射程、威力和范围，不同的枪就是不同遗传因子的组合，所以在解锁武器的时候就非常有期待感，同时这些武器又非常地符合直觉，比如AAAA，攻速的极致就变成了加特林，CCCC，射程的机制就变成了一个激光炮。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230649042.png" alt="丰富的武器系统"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230714360.png" alt="丰富的武器系统"></p><p>游戏还有一点非常棒的是局外养成，你每次刷了一局之后都有相当丰富的局外养成可以点，这就非常有刷感，我觉得这对于一个现代的rougelite游戏非常重要，你需要给玩家逐渐变强的感觉，不仅是自己技术的提升，也要有属性的加成，当然必须要精确控制好这个数值的度，要让玩家一次能看到提升，但是又不能太繁重，同时你也要局内足够有趣，才能让玩家不是只为了刷东西而玩。这一点做的很好的还有星界战士。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120230810905.png"></p><p>其他还有一些小细节，比如敌人也是ATCG组成的， 会根据这个有不同的特性，还可以给每个武器上buff，会和自己的子弹有相当奇异的丰富（类似</p><p><strong>辐射谷物语</strong></p><p>一款缝合怪游戏，缝了星露谷和肉鸽，相当有创新的缝合，分为白天探险打怪收集种子和废料，晚上守卫家园和种菜，不过游戏的教程有点弱，很多东西不知道有什么用。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120233238871.png"></p><h2 id="最佳创意：动物井"><a href="#最佳创意：动物井" class="headerlink" title="最佳创意：动物井"></a>最佳创意：动物井</h2><p>今年独立游戏的真正神中神，解谜类型的银河恶魔城，一开始玩的有点云里雾里，没有任何教程，规则本身就变成了谜题的一种，很有吹哥的味道，道具的用途也需要玩家去观察，试错，寻找，联想。</p><p>游戏设计的教科书，每个机制的关卡都非常自然的教会了你简单到复杂的过程，并且机制和机制之间融合的非常融洽，比如溜溜球和老鼠，弹弹圈和飞盘，谜题设计的相当有趣，真的难以想象这么一款游戏只有33MB，请原谅我夸都不知道怎么夸了，总之玩就对了。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/800"></p><p><strong>Leap Year</strong></p><p>一跳就会死的平台跳跃游戏，点子相当精妙，非常喜欢这种知识锁的设定，你的一切能力一开始就告诉你了，但是你没法学习到所以你无法通过这些道路，核心点子是跳跃的高度不同会导致不同的性质，比如反弹，穿地甚至重力翻转，最后要反着重新走一遍所有的路实在是太惊艳了！唯一的缺点就是流程太短了，不过考虑到要设计一条完全重复的路确实需要考虑。</p><p>玩了leap year之后发现这个相当神奇的制作组，袜子社，对他们的制作模式感到非常敬佩，往往是一两周就出一个小游戏，美术和音乐非常魔性，但是机制都非常有趣，也试了好多个，都非常有意思，之前也出过一个爆款，stack land，期待他们能做出更长的作品。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120232351042.png"></p><h2 id="AVG：灵视异闻FILE23-本所七大不可思议"><a href="#AVG：灵视异闻FILE23-本所七大不可思议" class="headerlink" title="AVG：灵视异闻FILE23 本所七大不可思议"></a>AVG：灵视异闻FILE23 本所七大不可思议</h2><p>剧透预警！！！</p><p>相同紧凑的一款avg，开局贼恐怖，因为能自由转视角然后开局略微jump scare让我序章玩的战战兢兢的；中间的故事部分也不错，你将扮演不同的主角共同解决复活秘术的危机，很有428的感觉，同时推进来推动故事，各种伏笔都回收了，虽然推理元素和时间跳跃元素没那么强但是也相当有意思；结局更加是让人眼前一亮。</p><p>值得一提的是游戏有三处meta元素，挺创新的啊，分别是声音，存档和自己的名字，声音那里让人吃瘪笑死了，存档很感动，名字那里也相当的有意思啊，好玩！</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/s34516771.jpg"></p><p><strong>尘埃终须落定</strong></p><p>比较有意识的推理小游戏，通过摆放不同人的叙述顺序来还原真相，需要认真推理才能想明白，蛮有趣的。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120233646410.png"></p><h2 id="party-game：Astro-Duel2"><a href="#party-game：Astro-Duel2" class="headerlink" title="party game：Astro Duel2"></a>party game：Astro Duel2</h2><p>epic送的小游戏，完成度相当高的同屏共斗小游戏，可以2-4人游玩，操纵的主角可以在飞船和船员中间切换，操纵飞船互殴的感觉真的太符合我小时候梦想的游戏了。操纵手感很棒，动作机制非常丰富：冲刺、弹反、拼刀、下砍；同时拥有许多机制不同的地图，每个地图有可以破坏的区域；还有不同类型的飞船，钻头、重型和平衡性；</p><p>可以观看我和陈医的<a href="https://www.bilibili.com/video/BV1Lr421t7Kt/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">欢乐录播</a>，真是欢乐的时光~</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/astreal%20duel22.gif"></p><p><strong>Samurai Gunn2</strong></p><p>这个游戏的画风也非常棒，每个人物有特殊的技能，但是跳跃的手感有点飘，而且没有中文，只能纯拼刀，玩起来没有astro duel那么刺激。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120214200715.png"></p><p><strong>TowerFall</strong></p><p>蔚蓝制作组的新作，可以看到许多蔚蓝的影子，酒店关的刺，随音乐跳动的砖块，跳跃手感自然是很优秀的，不过</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250120214342733.png" alt="image-20250120214342733"></p><p><strong>一些碎碎念</strong></p><p>说实话2024蛮坎坷的，工作不是很顺利，一度产生了对自己的怀疑，也有些迷茫，当然我还是觉得自己是有passion的，只是不知道如何发展。所幸目前是又能重新出发了，2025年得更认真一点了，无论是工作上还是体验娱乐上。</p>]]></content>
    
    
    <summary type="html">经典大杂烩碎碎念</summary>
    
    
    
    <category term="随笔" scheme="https://rorschachandbat.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>games104学习笔记</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/games104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/games104%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-01-09T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><strong>面临的挑战</strong></p><p>玩家行为是不可控的，要和gameplay互动；实时性；真实性（Motion Matching）</p><h2 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h2><p><strong>精灵动画（Sprite）</strong>：一帧一帧循环播放</p><p><strong>Live2D</strong></p><p>把每个图元都分隔，然后各种拉伸的时候可以做出各种动作</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173000363.png"></p><p>每一个部位生成一个图元来控制，非常直观的动画系统，简单又生动</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110163825295.png"></p><h2 id="3D动画分类"><a href="#3D动画分类" class="headerlink" title="3D动画分类"></a>3D动画分类</h2><p>基于层次的刚体动画，是一个树形结构，但是可能会穿帮，因为只操纵骨骼会互相穿插有可能。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110165402649.png"></p><p>顶点动画，存offerset的texture和法向的texture，然后根据帧数来计算，可以做一些布料或者流体什么的</p><p><strong>蒙皮动画</strong></p><p><strong>基于物理的动画</strong>：衣料、布娃娃系统、IK（反向动力学）</p><h2 id="蒙皮动画"><a href="#蒙皮动画" class="headerlink" title="蒙皮动画"></a>蒙皮动画</h2><p>蒙皮动画步骤</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110170653403.png"></p><p>坐标系的转换，要理解怎么变化的，乘旋转和平移矩阵，每一个骨骼都有自己的Local Space，并且会是一个一直传递相乘的矩阵（正向运动学），比如手指要一直乘各个手臂</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110170946080.png"></p><p>骨骼树的起点是胯部（脊椎的最后一块骨头）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171338432.png"></p><p>可能会加入一些额外的骨骼，比如什么眼球啊，翅膀啊，斗篷，武器，绑定节点（人骑在马上）这些都是用骨骼来驱动的</p><p>为了更好地计算移速、离地高度，会加一个root</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171929544.png"></p><p>四足动物的位置如下：</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110171955248.png"></p><h2 id="3D旋转数学基础"><a href="#3D旋转数学基础" class="headerlink" title="3D旋转数学基础"></a>3D旋转数学基础</h2><p><strong>2d旋转</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110172921112.png"></p><p><strong>3D旋转</strong></p><p>可以证明任何旋转都可以用xyz旋转等价，也就是欧拉角</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173332296.png"></p><p>但是欧拉角是有很多问题的，首先他顺序乘的不同会导致结果不同</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110173510295.png"></p><p>其次欧拉角会有锁死的情况，比如y轴转了90度，这时x轴和z轴是同轴了，那么就两个的旋转等于只有一个旋转了，造成退化的情况。</p><p>非常难插值</p><p>传递的时候不能直接相乘</p><p>并且很难绕着一个任意的轴来旋转</p><p><strong>四元数</strong></p><p>这时候就要用到四元数（Quaternion）了</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110175428592.png"></p><p>没太听懂，到时候仔细研究一下四元数吧</p><p><a href="https://www.bilibili.com/video/BV1SW411y7W1/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">四元数的可视化</a></p><h2 id="关节与蒙皮"><a href="#关节与蒙皮" class="headerlink" title="关节与蒙皮"></a>关节与蒙皮</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250110235935822.png"></p><p>MJm，是从root上一步一步累计的transform矩阵，记住要乘一个自己绑定的时候的逆，然后可能还要乘一个骨骼到世界坐标的transform，一般编程的时候会把这个逆直接存储下来。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111000422109.png"></p><p>因为动画的帧数不够，所以需要插值，NLERP，然后可能要满足最短路径，这样才能看起来比较自然一点，夹角小的时候用NLERP，大的时候用SLEPR</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001302077.png"></p><h2 id="动画压缩"><a href="#动画压缩" class="headerlink" title="动画压缩"></a>动画压缩</h2><p>动画一个帧就三十个pose，然后几十个骨骼，每个都要存旋转位移scale，这种时候就需要压缩，因为很多时候他们的数据是不变的</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001647296.png"></p><p>首先不变的值直接干掉，然后可以用keyframe插值，如果插值造成的误差没超过阈值，那么就可以接受。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111001908597.png"></p><p>直接线性插值会对旋转矩阵会比较差，可以用catmull-rom spline</p><p>如果浮点数的范围是有限的，可以转成定点数，归一数压缩一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111002200716.png"></p><p>如果避免error累积，防止出现动画飘来飘去的情况？要更换计算error的方式，直接比较矩阵函数和插值之后的差值其实不太直观，最好的是visual error，但是又不可能真的直接算，所以会在每个joint拿两个垂直的点，然后来计算这个前后的差值。敏感的可以给大一点。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111002713988.png"></p><h2 id="动画制作流程（DCC）"><a href="#动画制作流程（DCC）" class="headerlink" title="动画制作流程（DCC）"></a>动画制作流程（DCC）</h2><p>先用低模做，但是在关节地方会多加一点mesh</p><p><strong>骨骼绑定</strong></p><p><strong>Skinning</strong></p><p>一般自动计算权重，但是也可能要手动调整一下</p><p><strong>动画制作</strong></p><p><strong>Exporting</strong></p><p>要注意跳跃的时候root可能会变化，</p><h2 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h2><p>两个动作之间插值，比如走到跑，weight根据速度来变化，要保证两个动作的时间是一样的，这样才能确定是哪一帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111091311695.png"></p><h2 id="混合空间（Blending-Space）"><a href="#混合空间（Blending-Space）" class="headerlink" title="混合空间（Blending Space）"></a>混合空间（Blending Space）</h2><p>2d空间中，动作不是一维的，所以有可能有些地方动作密（因为觉得这里需要更细腻的表现），然后插值的时候，不可能把全部动作都插值，这时候就需要用到delaunay三角化，其实也就是把每三个点都连成三角形，然后你插值的时候判断是在哪个三角形里面，只插值这最近的三角形的动作。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111092138796.png"></p><p>鼓掌可以有一个mask，某些动作只应用到上半身</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111092612627.png"></p><p><strong>Additive Blending</strong></p><p>混合之后再叠加一个blend，比如旋转，可以做一直朝着一个地方点头</p><h2 id="动画状态机（Action-State-Machine）"><a href="#动画状态机（Action-State-Machine）" class="headerlink" title="动画状态机（Action State Machine）"></a>动画状态机（Action State Machine）</h2><p>每一个状态也可以是一个动画状态空间</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100048688.png"></p><p>一般还可以是多层状态机，分开独立控制</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100201347.png"></p><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>定义控制变量，暴露给gameplay系统，让他们来改变，然后通过这些变量来选择当前树该选择哪个节点</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100545330.png"></p><p>也可以通过事件来控制，比如切枪（从步枪变成火箭筒）</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/skeletal-mesh-animation-system-in-unreal-engine?application_version=5.4">UE骨架动画文档</a></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111100825429.png"></p><h2 id="Inverse-Kinematics-IK反向动力学"><a href="#Inverse-Kinematics-IK反向动力学" class="headerlink" title="Inverse Kinematics(IK反向动力学)"></a>Inverse Kinematics(IK反向动力学)</h2><p>ik可能是多解的，所以这时候需要一个指定朝向，相当于再多加一个平面</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111101948230.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102021279.png"></p><p>如果不止两个，有多个关节，该怎么解？（解有无穷多种可能）</p><p>首先要判断解空间，考虑最大和最小，并且还有考虑关节的约束度</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102213306.png"></p><p><strong>CCD</strong>，不断地翻滚骨头，循环到目标</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111102609241.png"></p><p><strong>FABRIK</strong></p><p>把末端直接放在终点，这时候那个骨头会突出去，然后把这个作为下一个的起点，最后迭代过去会导致root也有偏差，这时候再backward一遍，把root拉过去，然后一直这样forward和backward迭代，设置一个error误差。</p><p><strong>多目标约束</strong>怎么办？共同的节点发生变化，可以用雅可比矩阵+逼近的方式。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111111624550.png" alt="一些其他的IK技术"></p><h2 id="面部动画"><a href="#面部动画" class="headerlink" title="面部动画"></a>面部动画</h2><p>Facical Action Code System</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111112344279.png" alt="46个基础表情"></p><p>存的是顶点动画，每一个node相对于自然状态的delta，morph target animation</p><p>也有些使用骨骼动画，捏脸，眼球，这些需要。</p><p>2d的话也可以直接用uv texture</p><h2 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h2><p>Source Character-&gt;Target Character</p><p>Source Animation-&gt;Target Animation</p><p>重定向的时候存的是相对旋转、scale和位移</p><p>要根据腰线的高度等比例放缩一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111113632285.png"></p><p>如果还不行就得用IK</p><p>有些时候，如果骨骼数量不一样怎么办？简单的办法就是把数量不一样的地方，按照数量的差异，做一个插值，4-&gt;3就是0.3，0.7，然后把插值找到的位置直接认为是少的那个骨骼的终点位置。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E9%AA%A8%E9%AA%BC%E6%8F%92%E5%80%BC.gif"></p><p>也存在一些问题，比如自身穿模，或者没达到效果，因为有些动作是有语义的，比如鼓掌没合手，可以加一些约束</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E9%97%AE%E9%A2%98.gif"></p><h1 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h1><h1 id="Gameplay框架"><a href="#Gameplay框架" class="headerlink" title="Gameplay框架"></a>Gameplay框架</h1><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>一般是用<strong>观察者模式</strong>，需要定义以下三个东西</p><p><strong>Event Definition</strong></p><p>有一个enum和parament，要做到可拓展，能实时修改</p><p><strong>Callback Registration</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111124936819.png"></p><p>要考虑事件和回调的线程安全性问题，比如有可能你invoke的时候那个对象已经被销毁了</p><p>可以用强引用，保证invoke的的对象一定不被销毁；或这软引用，使用之前先判断是否已经被销毁了。</p><p><strong>Event Dispatching</strong></p><p>派发，如果来一个事件就直接派发，可能会产生堵塞、或者可能发生链式反应，事件一直会有。</p><p>一般会实现一个消息队列，把一帧到来的事件全部收集好，然后下一帧统一执行。</p><p>要实现序列化和反序列化，以及Ring buffer，这样就不用重复申请和释放内存，好处是不会崩，顶多是那一瞬间卡一下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/ringbuffer.gif" alt="ringbuffer"></p><p>不同的类型要分批分发</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111145922323.png"></p><p>也会有问题，比如有些事件就需要即时发生；以及delay会一直累积</p><h2 id="游戏逻辑和脚本系统"><a href="#游戏逻辑和脚本系统" class="headerlink" title="游戏逻辑和脚本系统"></a>游戏逻辑和脚本系统</h2><p>热更新所以得用脚本语言？</p><p>GO的管理靠谁来管理？一般是脚本，因为很多跟逻辑相关，一般是靠GC</p><p>如果本身对象没有那么多，比如单机游戏，更加注重ai动画，那么就直接引擎来管理</p><p>解释性语言可能会比较慢，可以用JIT（一边执行一边编译）</p><h2 id="可视化脚本"><a href="#可视化脚本" class="headerlink" title="可视化脚本"></a>可视化脚本</h2><p>面向设计师，让他们免于管理生命周期。可视化脚本也要实现编程语言的那些共同的要素。</p><p><strong>变量</strong>：类型和作用域（管脚不一样，同颜色对同颜色就可以了）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250111164800906.png"></p><p><strong>语句和表达式</strong></p><p><strong>Control Flow</strong></p><p><strong>函数</strong>：input，body和return</p><p><strong>类</strong>：蓝图本身就是一个类</p><p><strong>debug</strong>：直接可视化一步一步走</p><h2 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h2><p><strong>Character</strong></p><p>各种复杂的状态</p><p><strong>Control</strong></p><p>处理各种输入设备</p><p>细节很多，比如会自动锁定，反馈，多态的输入</p><p><strong>Camera</strong></p><p>不能穿墙</p><p>Camera Effect</p><p>Cmmera Manager:会有很多不同视角的相机</p><h2 id="寻路（Navigation）"><a href="#寻路（Navigation）" class="headerlink" title="寻路（Navigation）"></a>寻路（Navigation）</h2><p>地图的表达；寻路；path smoothing</p><h3 id="表达的不同形式"><a href="#表达的不同形式" class="headerlink" title="表达的不同形式"></a>表达的不同形式</h3><p><strong>路点网络</strong></p><p>类似地铁，但是每次地图变化也改变路网的图，而且npc很容易往中间走</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112094034081.png"></p><p><strong>Grid</strong></p><p>障碍物可以自动更新，类似于光栅化的方式；</p><p>存储空间可能比较浪费；而且很难表达3d的层叠结构（桥上桥下）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/%E5%AF%BB%E8%B7%AF.gif" alt="动态更新"></p><p><strong>寻路网格（Navigation Mesh）</strong></p><p>需要用凸三多边形</p><p>寻路比较快，内存占用比较低。</p><p>生成比较复杂，且不支持3d空间</p><p><strong>八叉树</strong></p><p>可以表达3d空间</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112100838253.png"></p><h3 id="寻路算法"><a href="#寻路算法" class="headerlink" title="寻路算法"></a>寻路算法</h3><p>其实不管什么表达方式连接点都可以变成一张图</p><p><strong>dfs</strong></p><p><strong>bfs</strong></p><p><strong>Dijkstra算法</strong></p><p><strong>Astar</strong></p><p>navmesh里面直接用多边形相交边的中点的欧拉距离</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112102944686.png"></p><h3 id="Path-Smoothing"><a href="#Path-Smoothing" class="headerlink" title="Path Smoothing"></a>Path Smoothing</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112103423743.png"></p><p><strong>funnel算法</strong></p><p>从几何理解比较简单</p><ol><li>创建沿 A* 路径的portal（多边形交线）列表。确保每个portal的点相对于起点以相同的方式存储。您需要知道某个点是在起点的左侧还是右侧。</li><li>创建一个由三个点组成的“漏斗”：角色的起始位置（顶点）、portal的右侧和portal的左侧。</li><li>交替更新funnel的左右两侧，每次都使其变窄</li><li>当funnel的两侧交叉时，请注意不要更新新漏斗的顶点，并将其存储为平滑路径的一部分。</li></ol><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/Funnel-Algorithm.png" alt="Funnel-Algorithm"></p><p>假如创建的funnel里面直接包含了终点，那么直接连过去就行</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112105406114.png"></p><h3 id="Navmesh-Generation"><a href="#Navmesh-Generation" class="headerlink" title="Navmesh Generation"></a>Navmesh Generation</h3><p><strong>voxelization（体素化）</strong></p><p>先体素化，然后标记出能通行的区域（通过高度差距），然后用洪水算法，从一个最深的点开始判断哪些是可达的，然后再根据这个生成多边形</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112110114138.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112105958036.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250112110056936.png"></p><p>还可以给navmesh添加flag，比如水陆地，来实现复杂的寻路算法，习性不同的怪物会走不同的路，一般是直接在地图上放flag然后映射到navmesh上面。</p><p>tile：大的meshmp可以分隔成多个小的tilie，因为实际游戏中map可能会变</p><h2 id="转向系统"><a href="#转向系统" class="headerlink" title="转向系统"></a>转向系统</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113145756701.png"></p><p>需要更自然，先加速再匀速然后减速</p><h2 id="群体模拟"><a href="#群体模拟" class="headerlink" title="群体模拟"></a>群体模拟</h2><p>微观的方法，定义每个个体的规则</p><p>鱼群效果：远离、接近和跟随</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113153524365.png"></p><p>宏观</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113153730001.png"></p><p>两者结合，比如说蜂群，多个结合成一个小团体，有一个大趋势，然后团体内部每个个体有自己的规则</p><p>如何避免碰撞？</p><p>直接加斥力or方向场</p><p><strong>RVO</strong></p><p>计算别人的速度向量是否在自己的路径上，如果在路径上就各自调整速度向量</p><h2 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h2><p><strong>自身信息</strong></p><p>位置、HP</p><p>地形信息：寻路、战术信息、可交互物体、掩护点</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113155904232.png"></p><p>动态数据：影响力图，动态寻路数据、视线图、游戏中的object（它身上的各种信息）</p><p>视觉感知、听觉感知</p><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113161310624.png"></p><p>状态太多就不好处理，可以分层，但是不太好飞线</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113161458366.png"></p><h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h3><p><strong>Sequence</strong></p><p>所有子节点依次执行，每个都要执行</p><p><strong>Selector</strong></p><p>一直试，直到某个节点成功完成</p><p><strong>Parallel</strong></p><p>同时执行所有节点</p><p>比如一边走向目标一边开枪</p><p><strong>Decorator</strong></p><p>有各种判断条件，以及loop，time这种</p><p><strong>Blackboard</strong></p><p>行为树的各个节点直接互相通信，存储一些变量</p><p>没有目标，只是遇到情况就来判断做什么</p><h3 id="层次任务网络（HTN）"><a href="#层次任务网络（HTN）" class="headerlink" title="层次任务网络（HTN）"></a>层次任务网络（HTN）</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224202070.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224616620.png"></p><p>首先要定义task：primitive task（原子性任务），要有前置条件，动作和产生影响（effect）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113224904756.png" alt="解毒"></p><p>复合任务：会有多个条件，根据优先级哪个满足做哪个，类似行为树的selector，method也可以是复合行为，类似行为树的sequence。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225317501.png" alt="两种选择"></p><p><strong>HTN Domain</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225410417.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250113225428214.png" alt="简单小怪逻辑"></p><p><strong>Planning</strong></p><p>根据world state的各种propety，来选择做哪个method，计划的时候根据当前的world state来做假设，拷贝一份，但是会假设能做的action都能成功，这里是有可能会有问题的。</p><p><strong>Replan</strong></p><p>计划失败了需要计划</p><p>会更快，plan会有长期影响</p><p>行为是不可预测的，会对本身world state有状态变化</p><h3 id="目标导向行为规划（GOAP）"><a href="#目标导向行为规划（GOAP）" class="headerlink" title="目标导向行为规划（GOAP）"></a>目标导向行为规划（GOAP）</h3><p>多了一个目标集，HTN里面只是写在了注释里面</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114101310541.png"></p><p>goal会有precondition和目标state</p><p>Action加了一个cost，比如路径的远近，风险，这个需要策划凭借经验来填</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114102906359.png"></p><p>state满足的情况下，cost要尽可能地小</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250114104334074.png"></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h1 id="面向数据编程和任务系统"><a href="#面向数据编程和任务系统" class="headerlink" title="面向数据编程和任务系统"></a>面向数据编程和任务系统</h1><h1 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h1><h1 id="Nanite"><a href="#Nanite" class="headerlink" title="Nanite"></a>Nanite</h1>]]></content>
    
    
    <summary type="html">提纲挈领地了解一下游戏引擎的方方面面，希望能看完~</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>【UE官方培训】Sequence相关</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/</id>
    <published>2025-01-06T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.194Z</updated>
    
    <content type="html"><![CDATA[<p>动画</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107192455758.png"></p><p>MAYA导出FBX有许多需要注意的地方</p><p>模型的旋转，采样率</p><p>MAYA中起始帧需要是0</p><p>UE动画曲线默认是线性，MAYA是曲线，这个得改，不然时间数值对不上</p><p>如果不想改MAYA的这个曲线，就得增加UE的采样率（缺点是会增加内存）</p><p>UE动画数学是单精度浮点数，但是MAYA是双精度浮点数..</p><p>UE会自动压缩，可以关闭或者采用压缩破坏最小的选项</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107233622228.png"></p><p><strong>最佳实践</strong>总结如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234310586.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234405315.png"></p><p><strong>具体分类</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234511264.png"></p><p>Live Link插件</p><p>可以实时更新动画数据，达到所见即所得的工作体验。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234724416.png"></p><p>Sequence其实就是时间和变量的对应，组织方式如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108093831342.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113220499.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113227088.png"></p><p>用场（levelSequence）、次（take）来管理不同的Sequence</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113508355.png"></p><ul><li>长期存在的，总是会被镜头拍到的，比如建筑、地形（可理解为静态模型），这种最好是可控制对象绑定在Sequence里面，如果是一些特定时间在存在的，可以直接变成可生成对象。</li><li>毛发可以先预先浏览，再导入精确的</li><li>如何管理可见性：1.关卡可见性轨道 2.蓝图里面有函数和事件可以卸载和加载关卡，缺点是不够直观 3.世界分区，将整个关卡放在一个大的关卡，可以自动加载和卸载</li><li>白模和资产制作可以并行制作，因为资源都是引用，后期再替换就可以了</li><li><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108115515103.png"></li></ul><p>如何用c++ Add Track？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加一个新的 Track</span><br><span class="hljs-function">FMovieSceneTrack* <span class="hljs-title">AddNewTrack</span><span class="hljs-params">(ULevelSequence* Sequence, UClass* TrackClass, FName TrackName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取 MovieScene</span><br>    UMovieScene* MovieScene = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>();<br>    <br>    <span class="hljs-comment">// 创建新的 Track</span><br>    FMovieSceneTrackMetaData MetaData;<br>    MetaData.DisplayName = FText::<span class="hljs-built_in">FromName</span>(TrackName);<br>    <br>    FMovieSceneTrack* NewTrack = MovieScene-&gt;<span class="hljs-built_in">AddTrack</span>(TrackClass, MetaData);<br>    <br>    <span class="hljs-keyword">return</span> NewTrack;<br>&#125;<br><br><span class="hljs-comment">// 使用示例 - 添加一个 Transform Track</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformTrack</span><span class="hljs-params">(ULevelSequence* Sequence, AActor* TargetActor)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 确保序列和Actor都有效</span><br>    <span class="hljs-keyword">if</span> (!Sequence || !TargetActor)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Transform Track</span><br>    FMovieSceneTrack* TransformTrack = <span class="hljs-built_in">AddNewTrack</span>(<br>        Sequence, <br>        UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(),<br>        <span class="hljs-built_in">FName</span>(*FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;%s Transform&quot;</span>), *TargetActor-&gt;<span class="hljs-built_in">GetName</span>()))<br>    );<br><br>    <span class="hljs-comment">// 绑定 Actor</span><br>    FGuid ObjectBinding = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddPossessable</span>(<br>        TargetActor-&gt;<span class="hljs-built_in">GetActorLabel</span>(), <br>        TargetActor-&gt;<span class="hljs-built_in">GetClass</span>()<br>    );<br>    <br>    <span class="hljs-comment">// 将 Track 添加到绑定对象</span><br>    Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddTrack</span>(UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(), ObjectBinding);<br>&#125;<br></code></pre></td></tr></table></figure><p>常见的 Track 类型包括:</p><p>UMovieScene3DTransformTrack - 变换轨道</p><p>UMovieSceneFloatTrack - 浮点值轨道</p><p>UMovieSceneEventTrack - 事件轨道</p><p>UMovieSceneAudioTrack - 音频轨道</p><p>UMovieSceneCameraAnimTrack - 相机动画轨道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加关键帧示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformKeyframe</span><span class="hljs-params">(UMovieScene3DTransformTrack* TransformTrack, FFrameNumber TimeFrame, FTransform Transform)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (UMovieScene3DTransformSection* Section = <span class="hljs-built_in">Cast</span>&lt;UMovieScene3DTransformSection&gt;(TransformTrack-&gt;<span class="hljs-built_in">CreateNewSection</span>()))<br>    &#123;<br>        TransformTrack-&gt;<span class="hljs-built_in">AddSection</span>(*Section);<br>        Section-&gt;<span class="hljs-built_in">AddKey</span>(TimeFrame, Transform);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Sequence相关</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>【UE官方培训】UE渲染管线介绍</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-05T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.198Z</updated>
    
    <content type="html"><![CDATA[<p>【[官方培训]01-实时渲染基础上 | 陈拓 Epic】 <a href="https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&amp;vd_source=5d07d04eb2516df147034367e7af6fd2</a></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106223718712.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224045881.png"></p><h1 id="渲染前准备"><a href="#渲染前准备" class="headerlink" title="渲染前准备"></a>渲染前准备</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224513490.png"></p><p>会有多个线程在跑，游戏线程、渲染线程和GPU线程，这样流水线的走，如果比较理想，就是稳定30帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224728083.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224816969.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224858383.png"></p><p><strong>距离</strong></p><p>距离阈值(Desired Max draw distance)</p><p>如果不想对每一个物体都设置这个距离，可以用Cull Distance Volume，包围的东西都会应用culling，可以设置size和distance，是一个数组，比如0-500size的东西应用一个culling，500-10000的又应用一个culling</p><p>如果想某些不被剔除可以用Never distance Cull，或者勾掉那个volume</p><p><strong>视锥</strong></p><p>这个很好理解，也就是在相机里面才会渲染</p><p>可以用FreezeRendering来跳出观察</p><p>ToggleDebugCamera</p><p><strong>预计算可见性</strong></p><p>Precomputed Visibility Volume</p><p>然后得编译一下，Compile-&gt;Precompute Static Visibility</p><p>要用这个得在Setting里面开启Precompute Visibility</p><p><strong>遮挡剔除</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106233936337.png"></p><h1 id="几何体渲染"><a href="#几何体渲染" class="headerlink" title="几何体渲染"></a>几何体渲染</h1><p>通过以上的步骤，可以拿到该被渲染的物体列表，但是如果直接渲染，会造成一些像素重复绘制，所以需要找出哪些模型应该先被渲染。</p><p>Early Z：GPU驱动会在执行像素着色器前先检查改点深度，提前跳过不符合条件的像素。为了利用这个特性，可以开启Prepass，提前把深度写入buffer里面，可以加快速度。</p><p>Drawcall：绘制拥有相同属性的一组多边形。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235242724.png"></p><p>不同的材质会不同的drawcall（*2是因为有earlyz）</p><p>切换材质影响性能开销，GPU渲染时，引擎会根据材质对物体进行排序，相同材质的会在同一个批次里绘制。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235428006.png"></p><p>stat RHI命令可以查看drawcall数量</p><p>drawcall数量比三角形数量更影响性能。</p><p>引擎有一些基础的drawcall开销</p><p>降低drawcall方法：</p><p><strong>模型合并（Merge Actor）</strong>，但是有副作用：</p><p>遮挡检测性能更差（因为合批模型会变大）</p><p>计算碰撞性能更差（合并之后更大）</p><p>占用更大内存</p><p><strong>Modular Meshes</strong></p><p><strong>Instanceing</strong>（只针对相同模型 ）</p><p><strong>Level Of Detail(LOD)和HLOD</strong></p><p>降低模型面数</p><p>合并模型假如有多个材质还是会多个drawcaal，可以考虑合并材质</p><p>调试可以用Render Doc插件，来看详细的DrawCall信息</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000456448.png"></p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><h3 id="VertexShader"><a href="#VertexShader" class="headerlink" title="VertexShader"></a>VertexShader</h3><p>1.坐标转换（局部空间-&gt;世界空间-&gt;投影空间）</p><p>2.顶点着色</p><p>3.应用世界坐标偏移（WPO）：鸟、水体、飘动的草（<strong>顶点动画</strong>）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000703048.png" alt="image-20250107000703048"></p><p>VS并不直接修改模型，只是视觉上的效果，CPU无法察觉VS的修改，所以物理和碰撞都不会发生变化。</p><p>动画越复杂、顶点越多性能越慢</p><p>对远距离的物体应该禁用顶点动画（反正也看不到）</p><p>对高精度的模型应该应用简单的VS</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001225370.png"></p><h1 id="光栅化和G-Buffer"><a href="#光栅化和G-Buffer" class="headerlink" title="光栅化和G-Buffer"></a>光栅化和G-Buffer</h1><p>经过这些之后，可以得到每个顶点在屏幕上的坐标</p><p>因为硬件问题，计算一个像素还需要计算周边2*2的像素，所以会造成overShading</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001502973.png"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001803628.png"></p><p>因为法向是归一化，所以只需要知道两个就够了</p><p>采用mipmap，会让内存变大1.3倍（一直1&#x2F;4)，但是会清晰很多(远处的物体也能平均取到)</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002050255.png"></p><h1 id="像素着色器和材质"><a href="#像素着色器和材质" class="headerlink" title="像素着色器和材质"></a>像素着色器和材质</h1><p>Pixel shader，实现光照、雾这些效果</p><p>UE里面会有一个连线的材质器，然后会自动转成不同平台的shader语言嵌入进去</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002941208.png"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>反射捕获</strong></p><p>Reflection Capture</p><p>cubemap，预先计算，但是不太准确，而且分辨率会影响反射效果</p><p><strong>屏幕空间反射</strong></p><p>默认开启，准确，有噪点，只会反射能看到的物体（根据G-Buffer算出来的）</p><p><strong>平面反射</strong></p><p>Planar Reflection</p><p>适合需要精确反射的表面（镜子）</p><p>其实就是相机换了一个位置，重新渲染了一遍，所以比较损耗性能，但是比较精确。</p><p>Lumen</p><p>RT Reflection</p><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093512026.png"></p><h2 id="静态光照"><a href="#静态光照" class="headerlink" title="静态光照"></a>静态光照</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093736129.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093830617.png"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250107094207091.png"></p><p>UE里面生成lightmap用lightmass</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107100807363.png"></p><h2 id="动态光照"><a href="#动态光照" class="headerlink" title="动态光照"></a>动态光照</h2><h3 id="动态阴影"><a href="#动态阴影" class="headerlink" title="动态阴影"></a>动态阴影</h3><p><strong>常规动态阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107102137758.png"></p><p>以光的视角作为摄像机渲染，能看到的就会被点亮 </p><p>把需要渲染的物体在光源的矩阵下转换，然后计算深度，如果前面有东西挡住了，就说这里是阴影</p><p><strong>级联阴影</strong></p><p>因为普通的阴影只有一张map，级联阴影就是分隔了多个视锥，然后叠加</p><p><strong>逐对象阴影</strong></p><p>固定光源，对每个对象都生成阴影</p><p><strong>距离场阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107170233535.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174700602.png"></p><h2 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h2><p>UE5全新的全局光照，有一些新特性</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174936082.png"></p><p>Color Bleeding：物品本身颜色对周围光照的影响</p><p>Soft indirect shadow:间接软阴影，当前帧和前几帧的混合</p><h1 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h1><p>延迟渲染难以处理半透明材质，可以考虑在前向渲染管线渲染</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183709373.png"></p><h1 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183752385.png"></p><p>自带的效果，Post Process Volume（可以设置为无限大）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107184011328.png"></p><h1 id="实时Ray-Tracing"><a href="#实时Ray-Tracing" class="headerlink" title="实时Ray Tracing"></a>实时Ray Tracing</h1><h1 id="性能调试"><a href="#性能调试" class="headerlink" title="性能调试"></a>性能调试</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107185002691.png"></p>]]></content>
    
    
    <summary type="html">UE的渲染管线，比较概括</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Ts语法相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-29T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:01.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TS基础写法"><a href="#TS基础写法" class="headerlink" title="TS基础写法"></a>TS基础写法</h1><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">PlayStateCheckHandle</span>: <span class="hljs-title class_">TimerHandle</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>|表示联合类型，表示既可以是TimerHandle也可以是undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Proto</span><span class="hljs-attr">_Nodes</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">IProto_NodeInfo</span> &#125;;<br></code></pre></td></tr></table></figure><p> 表示一个索引签名（index signature），用于定义一个对象类型，其中键（key）是字符串类型，而值（value）是 <code>Aki.Protocol.IProto_NodeInfo</code> 类型</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长参数</p><p>…args</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">first: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First argument is <span class="hljs-subst">$&#123;first&#125;</span>`</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);  <span class="hljs-comment">// 输出: First argument is 1, hello, world, !</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，函数内部创建的局部变量确实可以返回并在函数外部被直接修改，但这通常适用于可变类型（mutable types），如对象（包括 <code>Map</code>、<code>Set</code>、数组等）和函数。对于不可变类型（immutable types），如原始数据类型（数字、字符串、布尔值等），则不能直接修改。</p><p><strong>可变类型：</strong></p><p>当函数返回一个可变类型的值时，实际上返回的是这个值的引用（reference）。因此，通过这个引用所做的任何修改都会反映到原始对象上。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">复制function createObject() &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-keyword">prop</span>: 1 &#125;;<br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回对象的引用</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = createObject();<br>myObj.<span class="hljs-keyword">prop</span> = 2; <span class="hljs-comment">// 直接修改了 createObject 函数内部创建的对象</span><br>console.<span class="hljs-built_in">log</span>(myObj.<span class="hljs-keyword">prop</span>); <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><p>这个是因为看的时候看到一段对我来说比较吊诡的代码，在一个私有函数创建了一个map(nodes)，直接set到了另一个map(NodesGroupByStatus)里面，但是直接返回nodes，在另一个函数里面可以直接修改，后面查了才知道，ts如果返回maps这种可修改的变量相当于返回的是引用，所以就是改的原始的nodes</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">AddNodeGroup</span>(<span class="hljs-attr">group</span>: <span class="hljs-title class_">ENodeGroup</span>): <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt;();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">NodesGroupByStatus</span>!.<span class="hljs-title function_">set</span>(group, nodes);<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">AddNodeToStatusGroup</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TBehaviorNode</span>, <span class="hljs-attr">newStatus</span>: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">Proto_NodeStatus</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> groupId = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetGroupIdByStatus</span>(newStatus);<br>    <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetNodesByGroupId</span>(groupId);<br>    <span class="hljs-keyword">if</span> (!nodes) &#123;<br>        nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">AddNodeGroup</span>(groupId);<br>    &#125;<br><br>    nodes.<span class="hljs-title function_">set</span>(node.<span class="hljs-property">NodeId</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>继承extends</p><p><strong>super关键字</strong></p><ol><li><strong>调用父类构造函数</strong>：当你定义一个子类时，如果需要调用其父类的构造函数，可以使用 <code>super()</code>。这是必须的步骤，因为子类的实例在JavaScript&#x2F;TypeScript中总是通过父类的构造函数创建的。</li><li><strong>访问父类成员</strong>：<code>super</code> 也可以用来访问父类中定义的属性和方法，这在你想要扩展或重写父类成员时非常有用。</li><li><strong>访问父类的静态成员</strong>：使用 <code>super</code> 关键字，也可以访问父类的静态属性或方法</li><li><strong>在构造函数中</strong>：在构造函数中使用 <code>super</code> 必须作为第一条语句，因为子类实例的创建是基于父类构造函数的。</li><li><strong>在派生类的静态方法中</strong>：在静态方法中使用 <code>super</code> 来访问父类的静态成员。</li><li><strong>在派生类的方法中</strong>：在非静态方法中使用 <code>super</code> 来访问父类的非静态成员。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>1.基础泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 不使用泛型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnString</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnNumber</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型</span><br><span class="hljs-keyword">function</span> returnItem&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> str = returnItem&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 类型为 string</span><br><span class="hljs-keyword">const</span> num = returnItem&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 类型为 number</span><br><span class="hljs-keyword">const</span> bool = <span class="hljs-title function_">returnItem</span>(<span class="hljs-literal">true</span>);            <span class="hljs-comment">// 类型推断为 boolean</span><br></code></pre></td></tr></table></figure><p>2.泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义一个泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">value</span>: T;<br>    <span class="hljs-title function_">getValue</span>(): T;<br>&#125;<br><br><span class="hljs-comment">// 实现泛型接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">number</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBox</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">const</span> numberBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberBox</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>3.泛型约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用extends关键字约束泛型类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasLength</span> &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> logLength&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HasLength</span>&gt;(<span class="hljs-attr">value</span>: T): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">// 可以使用的类型</span><br><span class="hljs-title function_">logLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>);          <span class="hljs-comment">// 字符串有length属性</span><br><span class="hljs-title function_">logLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);       <span class="hljs-comment">// 数组有length属性</span><br><span class="hljs-title function_">logLength</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> &#125;);   <span class="hljs-comment">// 对象有length属性</span><br><br><span class="hljs-comment">// 会报错，因为number没有length属性</span><br><span class="hljs-comment">// logLength(42);  // Error</span><br></code></pre></td></tr></table></figure><p>4.多个类型参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 键值对映射</span><br><span class="hljs-keyword">function</span> getPair&lt;K, V&gt;(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): &#123; <span class="hljs-attr">key</span>: K; <span class="hljs-attr">value</span>: V &#125; &#123;<br>    <span class="hljs-keyword">return</span> &#123; key, value &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> pair1 = getPair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">const</span> pair2 = <span class="hljs-title function_">getPair</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);  <span class="hljs-comment">// 类型推断</span><br></code></pre></td></tr></table></figure><p>5.泛型类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStorage</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: T[] = [];<br><br>    <span class="hljs-title function_">addItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br><br>    <span class="hljs-title function_">removeItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">indexOf</span>(item);<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">getItems</span>(): T[] &#123;<br>        <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> textStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [&quot;Hello&quot;, &quot;World&quot;]</span><br><br><span class="hljs-keyword">const</span> numberStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">10</span>);<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [10, 20]</span><br></code></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>一开始看这个OnUpdate的时候非常懵逼</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">OnUpdate</span>(<span class="hljs-attr">newUpdate</span>: $Undefinable&lt;$Delegate&lt;<span class="hljs-function">(<span class="hljs-params">InProgress: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt;) : $Undefinable&lt;<span class="hljs-title class_">LTweener</span>&gt;;    <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnTick</span>(<span class="hljs-attr">deltaTime</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> tween = <span class="hljs-variable language_">this</span>.<span class="hljs-property">TextPlayTweenComp</span>!.<span class="hljs-title class_">GetPlayTween</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">LGUIPlayTween_Int</span>;<br>        <span class="hljs-keyword">const</span> tweener = tween?.<span class="hljs-title class_">GetTweener</span>();<br>        <span class="hljs-keyword">if</span> (tweener) &#123;<br>            tweener.<span class="hljs-title class_">OnUpdate</span>(<br>                <span class="hljs-title function_">toManualReleaseDelegate</span>((<span class="hljs-attr">progress</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">const</span> pro = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(progress * (tween.<span class="hljs-property">to</span> - tween.<span class="hljs-property">from</span>)) + tween.<span class="hljs-property">from</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> &lt; pro) &#123;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> = pro;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Text</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span>));<br>                    &#125;<br>                &#125;),<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>类型断言，有点类似其他语言的类型转换，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>const id &#x3D; a ? b : c;</p><p>条件 ? 表达式1 : 表达式2</p><ul><li>如果 <code>条件</code>（在这里是变量 <code>a</code>）为真（truthy），那么整个表达式的结果是 <code>表达式1</code>（在这里是变量 <code>b</code>）。</li><li>如果 <code>条件</code> 为假（falsy），那么结果是 <code>表达式2</code>（在这里是变量 <code>c</code>）。</li></ul><h3 id="x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</h3><ol><li><strong>严格等于 (<code>===</code>)</strong>:<ul><li><code>===</code> 是严格等于运算符，它比较两个值是否完全相等，包括它们的类型。</li><li>如果两个操作数的类型不同，<code>===</code> 返回 <code>false</code>。</li><li>只有当两个操作数的类型和值都相同时，<code>===</code> 才返回 <code>true</code>。</li></ul></li><li><strong>等于 (<code>==</code>)</strong>:<ul><li><code>==</code> 是等于运算符，它比较两个值是否等价。</li><li>如果操作数的类型不同，JavaScript 会进行类型转换，然后再比较它们的值。</li><li><code>==</code> 会根据需要将操作数转换为数字或字符串，然后进行比较。</li></ul></li><li>!&#x3D;&#x3D;</li></ol><p>​不相等，但是不会进行类型转换</p><h3 id="和"><a href="#和" class="headerlink" title="?.和!."></a>?.和!.</h3><p><code>!</code> 被称为非空断言操作符，它用来告诉 TypeScript 编译器，某个位置的值不应该为 <code>null</code> 或 <code>undefined</code>。</p><p>?.是一种语法糖， 如果多层访问中间有null或者undefined就会返回undefined，不用自己再另写类型检查</p><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>表示调用这个对象或者参数的时候这个参数可选</p><h3 id="-1"><a href="#-1" class="headerlink" title="??"></a>??</h3><p>逻辑运算符，用于返回两个操作数中第一个非空值（non-nullish value），或者在两个操作数都为空值（null 或 undefined）时返回右侧的操作数。</p><h1 id="UE4容器使用"><a href="#UE4容器使用" class="headerlink" title="UE4容器使用"></a>UE4容器使用</h1><h2 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/">TArray：虚幻引擎中的数组 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h3 id="创建和填充"><a href="#创建和填充" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建</span><br>TArray&lt;int32&gt; IntArray;<br><br><span class="hljs-comment">// 填充</span><br>IntArray.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 等价于下面</span><br><span class="hljs-comment">// IntArray = [10, 10, 10, 10, 10]</span><br><br><span class="hljs-comment">// 在末尾增加用Add或者Emplace</span><br><span class="hljs-comment">// Add会创建一个新实例，Emplace不会</span><br><br>TArray&lt;FString&gt; StrArr;<br>StrArr.<span class="hljs-built_in">Add</span>    (<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>StrArr.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;]</span><br><br><span class="hljs-comment">// 利用 Append 可一次性添加其他 TArray 中的多个元素</span><br><br>FString Arr[] = &#123; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;of&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Tomorrow&quot;</span>) &#125;;<br>StrArr.<span class="hljs-built_in">Append</span>(Arr, <span class="hljs-built_in">ARRAY_COUNT</span>(Arr));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;]</span><br><br><span class="hljs-comment">// 仅在尚不存在等值元素时， AddUnique 才会向容器添加新元素。</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;,&quot;!&quot;]</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr is unchanged as &quot;!&quot; is already an element</span><br><br><span class="hljs-comment">// Insert</span><br><br>StrArr.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Brave&quot;</span>), <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// SetNum,如新数量大于当前数量，则使用元素类型的默认构造函数新建元素</span><br><span class="hljs-comment">// 如新数量小于当前数量， SetNum 将移除元素。</span><br><br><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ranged-for</span><br>FString JoinedStr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; Str :StrArr)<br>&#123;<br>    JoinedStr+=Str;<br>&#125;<br><br><span class="hljs-comment">// 直接for循环</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index != StrArr.<span class="hljs-built_in">Num</span>(); ++Index)<br>&#123;<br>    JoinedStr += StrArr[Index];<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 数组迭代器:CreateIterator读写；CreateConstIterator只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> It = StrArr.<span class="hljs-built_in">CreateConstIterator</span>();It;++It)<br>&#123;<br>    JoinedStr += *It;<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Sort，基于快排</span><br><span class="hljs-comment">// HeapSort，堆排序</span><br><span class="hljs-comment">// StableSort，基于归并排序，可以保证等值元素的相对顺序，上面两个无法保证</span><br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Num，查询数量</span><br><br><span class="hljs-comment">// GetData,返回指针元素</span><br><br><span class="hljs-comment">// Contains，查询是否包含特定元素</span><br><br><span class="hljs-comment">// ContainsByPredicate,可自己写规则</span><br><br><span class="hljs-type">bool</span> bHello   = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-type">bool</span> bGoodbye = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>));<br><span class="hljs-comment">// bHello   == true</span><br><span class="hljs-comment">// bGoodbye == false</span><br><br><span class="hljs-type">bool</span> bLen5 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">5</span>;<br>&#125;);<br><span class="hljs-type">bool</span> bLen6 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">6</span>;<br>&#125;);<br><span class="hljs-comment">// bLen5 == true</span><br><span class="hljs-comment">// bLen6 == false</span><br><br><span class="hljs-comment">// Find，返回找到的第一个元素的索引</span><br><span class="hljs-comment">// FindLast,范围找到的最后一个元素的索引</span><br>int32 IndexLast;<br><span class="hljs-keyword">if</span> (StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>), IndexLast))<br>&#123;<br>    <span class="hljs-comment">// IndexLast == 3, because there aren&#x27;t any duplicates</span><br>&#125;<br><br><span class="hljs-comment">// 上面时返回布尔值，也可以直接返回索引，未找到时INDEX_NONE</span><br>int32 Index2     = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexLast2 = StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexNone  = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><span class="hljs-comment">// Index2     == 3</span><br><span class="hljs-comment">// IndexLast2 == 3</span><br><span class="hljs-comment">// IndexNone  == INDEX_NONE</span><br><br><span class="hljs-comment">// IndexOfByKey</span><br><span class="hljs-comment">// IndexOfByPredicate</span><br><br><span class="hljs-comment">// FilterByPredicate可以直接找到匹配的元素数组</span><br><span class="hljs-keyword">auto</span> Filter = StrArray.<span class="hljs-built_in">FilterByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> !Str.<span class="hljs-built_in">IsEmpty</span>() &amp;&amp; Str[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&#x27;M&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除所有提供元素等值的元素</span><br><span class="hljs-comment">// RemoveSingle,移除首个匹配元素</span><br><span class="hljs-comment">// RemoveAt，移除特定位置元素</span><br><span class="hljs-comment">// RemoveAll,可以自己定义规则</span><br><br><br><span class="hljs-comment">// 如果不需要保证排序，可以用下面的来加快速度</span><br><span class="hljs-comment">// RemoveSwap,RemoveAtSwap,RemoveAllSwap</span><br><br><span class="hljs-comment">// Empty 清空</span><br></code></pre></td></tr></table></figure><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// +=，串联</span><br><br><span class="hljs-comment">// MoveTemp，移动语义，清空源数组</span><br>ValArr3 = <span class="hljs-built_in">MoveTemp</span>(ValArr4);<br><span class="hljs-comment">// ValArr3 == [5,2,3,1,2,3]</span><br><span class="hljs-comment">// ValArr4 == []</span><br><br><span class="hljs-comment">// == 和 != 进行比较，必须排序和数量都一样</span><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h2 id="TMap"><a href="#TMap" class="headerlink" title="TMap"></a>TMap</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">TMap | 虚幻引擎4.27文档 (unrealengine.com)</a></p><p>TMap键不能重复，TMultiMap键不唯一</p><h3 id="创建和填充-1"><a href="#创建和填充-1" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TMap&lt;int32, FString&gt; FruiMap;<br><br><span class="hljs-comment">// 填充都一样，但是要是填重复的键会覆盖之前的值</span><br><br></code></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>类似TArrays，不过迭代元素是TPair</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains来查询是否包含特定键</span><br><br><span class="hljs-comment">// Find，失败返回null</span><br><br><span class="hljs-comment">// FindOrAdd，不存在该键会新创建一个元素</span><br><br><span class="hljs-comment">// FindRef，没找到会返回默认值，不会创建新元素</span><br><br>FString&amp; Ref7 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// Ref7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;</span><br><span class="hljs-comment">// ]</span><br>FString&amp; Ref8 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// Ref8     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br>FString Val7 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">7</span>);<br>FString Val6 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// Val7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// Val6     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// FindKey，按值查找</span><br></code></pre></td></tr></table></figure><h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除对应键的元素</span><br>FruitMap.<span class="hljs-built_in">Remove</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// FindAndRemoveChecked，移除元素并返回该值</span><br>FString Removed7 = FruitMap.<span class="hljs-built_in">FindAndRemoveChecked</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// RemoveAndCopyValue 函数的作用与 Remove 相似，不同点是会将已移除元素的值复制到引用参数</span><br>FString Removed;<br><span class="hljs-type">bool</span> bFound2 = FruitMap.<span class="hljs-built_in">RemoveAndCopyValue</span>(<span class="hljs-number">2</span>, Removed);<br><br><span class="hljs-comment">// Empty和Reset，清空</span><br></code></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KeySort或者ValueSort</span><br>FruitMap.<span class="hljs-built_in">KeySort</span>([](int32 A, int32 B) &#123;<br>    <span class="hljs-keyword">return</span> A &gt; B; <span class="hljs-comment">// sort keys in reverse</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h3><p>有复制和移动语义</p><h3 id="Slack-1"><a href="#Slack-1" class="headerlink" title="Slack"></a>Slack</h3><h3 id="KeyFuncs"><a href="#KeyFuncs" class="headerlink" title="KeyFuncs"></a>KeyFuncs</h3><h2 id="TSet"><a href="#TSet" class="headerlink" title="TSet"></a>TSet</h2><h1 id="UE4回调"><a href="#UE4回调" class="headerlink" title="UE4回调"></a>UE4回调</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/">委托 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate - 知乎 (zhihu.com)</a></p><p>UE支持三种委托：单点委托，组播委托（事件），动态委托</p><h3 id="单点委托"><a href="#单点委托" class="headerlink" title="单点委托"></a>单点委托</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><h3 id="动态委托"><a href="#动态委托" class="headerlink" title="动态委托"></a>动态委托</h3><h1 id="UE4对象函数"><a href="#UE4对象函数" class="headerlink" title="UE4对象函数"></a>UE4对象函数</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Functions/">UFunctions | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h1 id="UE4引用"><a href="#UE4引用" class="headerlink" title="UE4引用"></a>UE4引用</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/ReferencingAssets/">引用资源 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/ReferenceAssets/">引用 Actor | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnLhvL7EdoiVzOhE8P2cjTCh">UE引用类型说明 - 飞书云文档 (feishu.cn)</a></p><p>引用分为两种，硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载；软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。</p><p>一种是通过UPROPERTY</p><p><strong>直接属性引用</strong></p><p>通过设置变量的UPROPERTY直接在编辑器设置对应资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** construction start sound stinger */</span><br><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Building)<br><br>USoundCue* ConstructionStartStinger;<br></code></pre></td></tr></table></figure><p><strong>构造时引用</strong></p><p>构造时加载对应资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/** gray health bar texture */</span><br><br><span class="hljs-constructor">UPROPERTY()</span><br><br><span class="hljs-keyword">class</span> UTexture2D* BarFillTexture;<br><br>AStrategyHUD::<span class="hljs-constructor">AStrategyHUD(<span class="hljs-params">const</span> FObjectInitializer&amp; ObjectInitializer)</span> :<br>    <span class="hljs-constructor">Super(ObjectInitializer)</span><br>&#123;<br>    static ConstructorHelpers::FObjectFinder&lt;UTexture2D&gt; <span class="hljs-constructor">BarFillObj(TEXT(<span class="hljs-string">&quot;/Game/UI/HUD/BarFill&quot;</span>)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>BarFillTexture = BarFillObj.Object;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>一种是用字符串来引用，如果UObject已经加载就用FindObject&lt;&gt;()，没有加载就使用LoadObject&lt;&gt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AFunctionalTest* TestToRun = <span class="hljs-built_in">FindObject</span>&lt;AFunctionalTest&gt;(TestsOuter, *TestName);<br>GridTexture = <span class="hljs-built_in">LoadObject</span>&lt;UTexture2D&gt;(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/EngineMaterials/DefaultWhiteGrid.DefaultWhiteGrid&quot;</span>), <span class="hljs-literal">NULL</span>, LOAD_None, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h1 id="UE4FName"><a href="#UE4FName" class="headerlink" title="UE4FName"></a>UE4FName</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/">FName | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p>在 <strong>内容浏览器</strong> 中为新资源命名时，变更动态材质实例中的参数或访问骨骼网格体中的一块骨骼时需要使用 <strong>FNames</strong> 。 FName 通过一个轻型系统使用字符串。在此系统中，特定字符串即使会被重复使用，在数据表中也只存储一次。</p><p>FNames 不区分大小写。它们为不可变，无法被操作。FNames 的存储系统和静态特性决定了通过键进行 FNames 的查找和访问速度较快。 FName 子系统的另一个功能是使用散列表为 FName 转换提供快速字符串。</p><p>FNames 不区分大小写，作为索引组合存储在唯一字符串和实例编号的表格中。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName TestName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Test&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FMame到FString</span><br>TestString = TestName.<span class="hljs-built_in">ToSring</span>();<br><br><span class="hljs-comment">// FName到FText</span><br>TestText = FText::<span class="hljs-built_in">FromName</span>(TestName);<br><br><span class="hljs-comment">// Fstring和FText到Fname都不可靠，因为FName不区分大小写</span><br><br><span class="hljs-comment">// FString到FName</span><br>TestName = <span class="hljs-built_in">FName</span>(*TextString);<br><br><span class="hljs-comment">// FText无法直接到FName</span><br></code></pre></td></tr></table></figure><p>对比是否相同直接比较索引的数值，不用执行字符串的对比</p><h1 id="TS和Lua有什么区别"><a href="#TS和Lua有什么区别" class="headerlink" title="TS和Lua有什么区别"></a>TS和Lua有什么区别</h1><h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><p>优点：</p><p>1.静态类型系统</p><ul><li><p>在编译时进行类型检查</p></li><li><p>可以提前发现潜在错误</p></li><li><p>提供更好的代码提示和自动完成</p></li></ul><p>2.面向对象特性</p><ul><li><p>支持类、接口、泛型等现代OOP特性</p></li><li><p>继承和多态的实现更加完整</p></li></ul><p>3.JavaScript生态系统</p><ul><li><p>可以直接使用JavaScript的所有库和框架</p></li><li><p>与现代前端开发工具链完美集成</p></li><li><p>庞大的npm生态系统</p></li></ul><p>4.工具支持</p><ul><li><p>优秀的IDE支持（VS Code等）</p></li><li><p>强大的重构工具</p></li><li><p>详细的文档和类型定义</p></li></ul><p>缺点：</p><p>1.编译开销</p><ul><li><p>需要编译成JavaScript才能运行</p></li><li><p>构建过程可能较慢</p></li></ul><p>2.学习曲线</p><ul><li><p>类型系统较复杂</p></li><li><p>需要理解装饰器、泛型等概念</p></li></ul><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>1.轻量级</p><ul><li><p>解释器小巧（约200KB）</p></li><li><p>启动快速，内存占用少</p></li><li><p>易于嵌入其他程序</p></li></ul><p>2.性能</p><ul><li><p>LuaJIT提供极高的执行效率</p></li><li><p>垃圾回收效率高</p></li></ul><p>3.简单易学</p><ul><li><p>语法简洁清晰</p></li><li><p>核心概念少</p></li><li><p>学习曲线平缓</p></li></ul><p>4.嵌入性</p><ul><li><p>广泛用于游戏开发</p></li><li><p>适合作为脚本语言嵌入应用</p></li><li><p>容易与C&#x2F;C++集成</p></li></ul><p>缺点：</p><p>1.标准库较小</p><ul><li><p>内置功能相对有限</p></li><li><p>需要依赖第三方库实现复杂功能</p></li></ul><p>2.生态系统</p><ul><li><p>相比现代语言，生态系统较小</p></li><li><p>工具链不如主流语言完善</p></li></ul><p>3.面向对象支持</p><ul><li><p>没有原生的类支持</p></li><li><p>需要通过元表模拟OOP特性</p></li></ul><h1 id="不同类型变量"><a href="#不同类型变量" class="headerlink" title="不同类型变量"></a>不同类型变量</h1><p>值类型（按值传递）：</p><p>number</p><p>string</p><p>boolean</p><p>undefined</p><p>null</p><p>symbol</p><p>引用类型（按引用传递）：</p><p>Object</p><p>Array</p><p>Function</p><p>Date</p><p>RegExp</p><p>Map</p><p>Set</p><p>类实例</p>]]></content>
    
    
    <summary type="html">Ts的一些语法</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua的闭包</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:01.788Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/358423900">构建Lua解释器Part11：Upvalue - Manistein的文章 - 知乎</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-number">10</span>  <span class="hljs-comment">-- x是一个局部变量</span><br>    <br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment">-- x在这里就是一个upvalue</span><br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">return</span> inner<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> fn = outer()<br>fn()  <span class="hljs-comment">-- 输出10</span><br></code></pre></td></tr></table></figure><ol><li><p>x 是 outer 函数的局部变量，inner 函数引用了 x</p></li><li><p>x 对于 inner 来说就是一个 upvalue</p></li><li><p>Lua 会特殊处理这个 x，使其在 outer 函数结束后仍然存活</p></li></ol>]]></content>
    
    
    <summary type="html">lua中闭包的使用</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-unity多线程原理相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:01.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity协程（Coroutine）原理详解"><a href="#Unity协程（Coroutine）原理详解" class="headerlink" title="Unity协程（Coroutine）原理详解"></a>Unity协程（Coroutine）原理详解</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>协程本质上是一个迭代器（Iterator），它利用了C#的迭代器模式和yield关键字。它不是真正的多线程，而是一种特殊的程序执行方式。</p><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><p>1.暂停和恢复</p><ul><li><p>当遇到yield语句时，协程会保存当前的执行状态</p></li><li><p>将控制权返回给Unity的主循环</p></li><li><p>在适当的时机恢复执行</p></li></ul><p>2.状态机</p><ul><li><p>编译器会将协程方法转换为一个状态机</p></li><li><p>每个yield语句对应一个状态</p></li><li><p>恢复执行时从上次的状态继续</p></li></ul><h2 id="2-执行时机"><a href="#2-执行时机" class="headerlink" title="2. 执行时机"></a>2. 执行时机</h2><p>Unity的执行循环：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Update循环：<br><span class="hljs-number">1.</span> Input Events<br><span class="hljs-number">2.</span> Update()<br><span class="hljs-number">3.</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> 的协程<br><span class="hljs-number">4.</span> <span class="hljs-function">Late <span class="hljs-title">Update</span>()</span><br><span class="hljs-function">5. 渲染</span><br></code></pre></td></tr></table></figure><p>不同yield指令的执行时机：</p><ul><li><p>yield return null - 下一帧Update之前</p></li><li><p>yield return new WaitForFixedUpdate() - 下一次物理更新时</p></li><li><p>yield return new WaitForEndOfFrame() - 当前帧渲染完成后</p></li><li><p>yield return new WaitForSeconds() - 基于Time.time计时</p></li></ul><h2 id="3-内部实现机制"><a href="#3-内部实现机制" class="headerlink" title="3. 内部实现机制"></a>3. 内部实现机制</h2><h3 id="状态机转换"><a href="#状态机转换" class="headerlink" title="状态机转换"></a>状态机转换</h3><p>当你写一个协程时：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">MyCoroutine</span>()</span> <br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会这样转换成类似的状态机</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-title">MyCoroutine</span>&gt;<span class="hljs-title">d__1</span> : <span class="hljs-title">IEnumerator</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">object</span> current;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MyCoroutine&gt;d__1(<span class="hljs-built_in">int</span> state) <br>    &#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> <br>    &#123;<br>        <span class="hljs-keyword">switch</span> (state) <br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>                current = <span class="hljs-keyword">new</span> WaitForSeconds(<span class="hljs-number">1f</span>);<br>                state = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>                state = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-literal">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current <br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> current; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h2><h3 id="协程的内存分配："><a href="#协程的内存分配：" class="headerlink" title="协程的内存分配："></a>协程的内存分配：</h3><p>1.状态机对象</p><ul><li><p>每次启动协程时创建</p></li><li><p>包含局部变量和执行状态</p></li></ul><p>2.YieldInstruction对象</p><ul><li><p>每个yield return语句可能创建新对象</p></li><li><p>可以通过缓存减少分配</p></li></ul><h3 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h3><p>1.创建：StartCoroutine调用时</p><p>2.运行：Unity主循环中调度</p><p>3.销毁：</p><ul><li><p>协程完成时</p></li><li><p>手动停止时</p></li><li><p>MonoBehaviour禁用时</p></li></ul><h2 id="5-调度机制"><a href="#5-调度机制" class="headerlink" title="5. 调度机制"></a>5. 调度机制</h2><p>Unity的协程调度器：</p><p>1.维护一个活动协程列表</p><p>2.每帧检查需要执行的协程</p><p>3.根据YieldInstruction类型决定执行时机</p><p>4.调用MoveNext()推进协程状态</p><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><p>1.Update前的协程</p><p>2.Update</p><p>3.Update后的协程</p><p>4.LateUpdate</p><p>5.帧结束时的协程</p><h2 id="6-限制和注意事项"><a href="#6-限制和注意事项" class="headerlink" title="6. 限制和注意事项"></a>6. 限制和注意事项</h2><h3 id="技术限制："><a href="#技术限制：" class="headerlink" title="技术限制："></a>技术限制：</h3><p>1.单线程执行</p><ul><li><p>所有协程在主线程运行</p></li><li><p>不能进行真正的并行处理</p></li></ul><p>2.状态保存</p><ul><li><p>只能保存基本的执行状态</p></li><li><p>不保存完整的调用栈</p></li></ul><p>3.异常处理</p><ul><li><p>try-catch块跨越yield语句时可能失效</p></li><li><p>需要特殊的错误处理机制</p></li></ul><h3 id="性能考虑："><a href="#性能考虑：" class="headerlink" title="性能考虑："></a>性能考虑：</h3><p>1.内存开销</p><ul><li><p>每个活动协程占用内存</p></li><li><p>yield指令可能产生垃圾回收</p></li></ul><p>2.CPU开销</p><ul><li><p>协程调度有额外开销</p></li><li><p>过多活动协程会影响性能</p></li></ul><h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>1.适合用协程的情况：</p><ul><li><p>需要随时间推移的操作</p></li><li><p>等待特定条件</p></li><li><p>分帧执行大量工作</p></li></ul><p>2.不适合用协程的情况：</p><ul><li><p>CPU密集型计算</p></li><li><p>需要真正并行的操作</p></li><li><p>关键性能代码</p></li></ul><h3 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h3><p>1.重用YieldInstruction对象</p><p>2.适当分批处理</p><p>3.及时清理不需要的协程</p><p>4.避免过多嵌套</p><p>理解协程的这些原理，可以帮助我们更好地使用它，避免常见陷阱，并在适当的场景选择它作为解决方案。</p>]]></content>
    
    
    <summary type="html">面经-unity多线程原理相关</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>动作游戏的方方面面</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.473Z</updated>
    
    <content type="html"><![CDATA[<p>动作游戏系统设计</p><p>镜头选型，运动系统，输入模块，战斗能力。</p><h1 id="战斗系统？"><a href="#战斗系统？" class="headerlink" title="战斗系统？"></a>战斗系统？</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>好的攻击方式应该兼具优点和缺点，比如范围大那么久伤害低，伤害高但是攻速慢，或者需要某些特定的资源，或者具有冷却时间</p><p>攻速其实是动画的帧动画</p><p>前摇，判定和后摇</p><p>动画取消</p><p>范围：吸附的范围</p><p>不同的按键组合是不同的攻击方式，当然也可以是和位置不同而变化，比如背刺之类的。</p><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><p>一定顺序，准确时机可以打出不同的连招</p><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><p>防御或者闪避</p><p>弹反和招架：有可能过于强大，让整个游戏都变成了等待</p><p>可以增加弹反惩罚，或者限制弹反次数，或者降低弹反收益：比如只是单纯地给一点子弹时间。</p><p>当然你也要防止你的玩家完全不防御，防止让他一直压制敌人，比如给怪加体力条，体力条没了才能僵直，或者让他面对很多个怪物。</p><p>好的动作游戏，应该鼓励玩家在攻击和防守之间积极地变换。</p><h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><p>敌人的进攻应该有明显的提示，比如画面之类的。</p><p>并且最好不要设计成单一武器才能杀死的敌人 </p><p>如何鼓励玩家进攻多样而不是复读？</p><p>连击有特殊动画，或者直接设计连击分数（比如鬼泣或者猎天使魔女），还有受伤掉分</p><p>如果程序检测到玩家复读某一招，可以相对应地用表现得不一样，这些可以给玩家他适应了你的打法一样（街霸的ai也有类似的感觉，可以学习）</p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>巨大的前摇+飞速的打击动作+判定帧短暂的暂停+后摇缓慢的回复</p><p>刀光特效</p><p>震动屏幕</p><p>爽快的音效</p><h1 id="打击感-1"><a href="#打击感-1" class="headerlink" title="打击感"></a>打击感</h1><p><a href="https://www.bilibili.com/video/BV1g741157RC/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【暖风游戏厅】打击感是如何炼成的</a> </p><p>攻击角色击中被击角色的瞬间，游戏给玩家的反馈所形成的的体验。</p><p>打击感是击中的瞬间，手感是玩家输入的瞬间</p><p>被击动作、特效、静止帧、音效和振动</p><h2 id="被击动作"><a href="#被击动作" class="headerlink" title="被击动作"></a>被击动作</h2><p>首先是攻击动作和被击动作要匹配，方向和力度。</p><p>被击动作需要播放地够快。</p><p>如果是一个很大的boss，可以考虑做局部肢体的抖动。对骨骼施加物理力，然后和动作进行融合，这样做不会让被击方停止动作，一举两得。</p><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><p>最重要的功能是告诉玩家自己的攻击击中了，必须及时，准确和明显。</p><p>两种比较常见的，爆炸和飙血。前者是拳脚或者钝器（街霸），后者是利器（血缘）</p><h2 id="静止帧"><a href="#静止帧" class="headerlink" title="静止帧"></a>静止帧</h2><p>用来模拟现实打击中的顿滞感，拳头和钝器会慢一点，利器会快一点。也和敌人属性有关，比如穿了厚重的铠甲就会慢一点，破衣服就快一点。</p><p>全局或者局部</p><p>全局是整个游戏都暂停，局部是只用双方暂停。</p><p>战神利用了ik（反向动力学）来制作静止帧，斧子在击中敌人的一瞬间会卡肉，然后手臂会继续运动，直到一定程度才会完成打击动作。</p><h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><p>依旧是合适和及时，不同属性不同力度要对应。</p><h2 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h2><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>打击感是一瞬间的信息和力度，要专注这一瞬间的反馈。</p><p>命中</p><p>信息：信息要准确，丰富有层次</p><p>强度：强度要有对比，要有层次和疏密，最重要的是符合直觉</p><p>连招开启的卡肉，就像街霸里的确认一样，用来告诉你你可以开始爽快的连招了</p><p>第一法则：“0延迟”的即时反馈 </p><p>第二法则：制造预期，让玩家有所期待 </p><p>第三法则：符合预期，回应玩家的期待 </p><p>第四法则：简洁：明了清晰，弱化不必要的 </p><p>第五法则：夸张：强化重要的 </p><p>第六法则：回味：让玩家有时间和机会回味，延长令玩家愉悦的感觉 </p><p>第七法则：拟真：真实感的模拟（如果你不知道从什么地方开始，那么就向大自然和实际生活学习）</p><h1 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h1><p>重点是解决一下三个问题：</p><p><strong>如何让玩家探索战胜敌人的方式？</strong></p><p>敌人的形象设计；攻击提示；仇恨范围；攻击欲望；连招系统；战斗策略；指令输入；能力限制一级敌我对等程度；对峙突围能力……</p><p><strong>如何让玩家不断磨练自己的技术</strong></p><p>角色的成长策略；获胜的条件；游戏综合速度；不同情绪切换；基础物理法则；战场结构；纵向层次；角色能力提升曲线与自我技术革新……</p><p><strong>如何让玩家不会轻易放弃？</strong></p><p>游戏的核心挑战；次要挑战；游戏整体难度；死亡机制与死亡惩罚；角色的容错率；玩家的学习曲线；玩家操纵角色的综合能力……</p><h1 id="难度曲线"><a href="#难度曲线" class="headerlink" title="难度曲线"></a>难度曲线</h1><p>确保每一种类型的玩家都有自己的乐趣所在，初学者，玩家和大师</p><h1 id="进阶循环"><a href="#进阶循环" class="headerlink" title="进阶循环"></a>进阶循环</h1><h1 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h1><p><strong>Camera</strong></p><p>第三人称、第一人称、越肩（战神）、俯视角、横版</p><p><strong>Character</strong></p><p>移动方式和相机要相关，越肩就是要固定方向，第三人称的话可以转头，但是也可以锁定怪物</p><p><strong>Control</strong></p><h1 id="动作切换系统"><a href="#动作切换系统" class="headerlink" title="动作切换系统"></a>动作切换系统</h1><p><a href="https://zhuanlan.zhihu.com/p/663335854">动作游戏中的动作切换系统这么做就对了 - 猴与花果山的文章 - 知乎</a></p><h1 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Frame</span>&#123;<br><span class="hljs-keyword">public</span> frameId:<span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">public</span> clips:Array&lt;Clip&gt;; <span class="hljs-comment">//每一帧依然会是多个clip</span><br><span class="hljs-keyword">public</span> hitBox:Array&lt;Rect&gt;;<span class="hljs-comment">//碰撞框，动作游戏会有进攻、挨揍、防御等碰撞框，当然很可能都是空数组，比如角色死了的时候</span><br><br><span class="hljs-comment">//在这一帧，哪些frameId的动作可以成为下一帧cancel掉这个动作</span><br><span class="hljs-comment">//比如街霸的重拳接升龙，他不是等重拳全放完了，然后升龙从头来叫重拳接升龙</span><br><span class="hljs-comment">//而是从重拳的第x帧之后，直接切换到升龙的第y帧开始继续</span><br><span class="hljs-keyword">public</span> cancelableAction:Array&lt;<span class="hljs-built_in">string</span>&gt;; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="连招系统代码设计"><a href="#连招系统代码设计" class="headerlink" title="连招系统代码设计"></a>连招系统代码设计</h1><p><a href="https://www.zhihu.com/question/26760255/answer/56856767">游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 白井功名的回答 - 知乎</a></p><p><strong>1，在无法把握全部动作的前提下，把握好人物每个动作衔接过程中的着力点</strong></p><p><strong>2，适当地通过特效、光影等弥补动作上可能存在的不足</strong></p><p><strong>3，嗯之前忘了说，但是也许是最重要的一点：在做连招的过程中保持与美术的沟通，单个动作方面可能他是专家但连招的整体还是需要你们共同完成</strong></p><p>游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 猴与花果山的回答 - 知乎<br><a href="https://www.zhihu.com/question/26760255/answer/57075589">https://www.zhihu.com/question/26760255/answer/57075589</a></p>]]></content>
    
    
    <summary type="html">总结一下一个好的动作游戏的方方面面</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua高性能编程</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:01.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h1><p>在代码运行前，Lua会把源码预编译成一种中间码，类似于Java的虚拟机。这种格式然后会通过C的解释器进行解释，整个过程其实就是通过一个while循环，里面有很多的switch…case语句，一个case对应一条指令来解析。</p><p>自Lua 5.0之后，Lua采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多250个寄存器，因为栈的长度是用8个比特表示的。</p><p>有了这么多的寄存器，Lua的预编译器能把所有的local变量储存在其中。这就使得Lua在获取local变量时其效率十分的高。</p><h2 id="使用local引用global变量"><a href="#使用local引用global变量" class="headerlink" title="使用local引用global变量"></a>使用local引用global变量</h2><p>Lua对本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">局部变量</a>的访问是一个O(1)的操作（等价于一个数组地址+偏移），而global变量的获取需要一次<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=hash%E6%9F%A5%E6%89%BE&zhida_source=entity">hash查找</a>。local比global快很多（特别是在计算比较简单时，hash查找的开销反而是大头），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了本地local变量以外，upvalue的访问也比global快很多（访问上一层upvalue，等价于一次间接跳转之后再访问上一层函数的局部变量，基本还是一个O(1)的开销），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="使用local缓存table查找结果"><a href="#使用local缓存table查找结果" class="headerlink" title="使用local缓存table查找结果"></a>使用local缓存table查找结果</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="3R原则"><a href="#3R原则" class="headerlink" title="3R原则"></a>3R原则</h1><h2 id="Reducing"><a href="#Reducing" class="headerlink" title="Reducing"></a>Reducing</h2><p>避免创建新对象和节约内存</p><h3 id="把table变成数组"><a href="#把table变成数组" class="headerlink" title="把table变成数组"></a>把table变成数组</h3><h3 id="把常量对象的创建放在循环的外面"><a href="#把常量对象的创建放在循环的外面" class="headerlink" title="把常量对象的创建放在循环的外面"></a>把常量对象的创建放在循环的外面</h3><p>xxxxxxxxxx void Awake(){    objects &#x3D; new List<Transform>();}​void CreateObject(){    Transform t &#x3D; Instantiatie(prefab);    t.loactionPosition &#x3D; Random.insideUnitSphere * 5f;    t.locationRotation &#x3D; Random.rotation;    t.localScale &#x3D; Vector3.one * Random.Range(0.1f, 1f);    objects.Add(t);}c#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125; <span class="hljs-comment">--unnecessary redeclare</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span> <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">--这里每次循环会创建一个匿名函数对象</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">local</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fun2) <span class="hljs-comment">--重用循环外定义的func2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Reusing"><a href="#Reusing" class="headerlink" title="Reusing"></a>Reusing</h2><h3 id="复用对象"><a href="#复用对象" class="headerlink" title="复用对象"></a>复用对象</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123; year = i, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;) <span class="hljs-comment">--每次循环创建一个表</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> aux = &#123; year = <span class="hljs-literal">nil</span>, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    aux.year = i <span class="hljs-comment">-- 重用循环外定义的aux</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(aux)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Recycling"><a href="#Recycling" class="headerlink" title="Recycling"></a>Recycling</h2><h3 id="避免GC对象的创建"><a href="#避免GC对象的创建" class="headerlink" title="避免GC对象的创建"></a>避免GC对象的创建</h3><p>string有intenalize管理的开销，table需要开辟内存，lua中所有的function都是闭包，创建开销也不低，此外它们都会增加gc的开销。</p><h3 id="传参时避免构造table"><a href="#传参时避免构造table" class="headerlink" title="传参时避免构造table"></a>传参时避免构造table</h3><p>参数的数量不多时，尽量用独立的变量传递参数，而非构造一个table。</p><h2 id="宿主语言接口调用"><a href="#宿主语言接口调用" class="headerlink" title="宿主语言接口调用"></a>宿主语言接口调用</h2><p>尽量在lua内部完成计算，调用宿主语言接口会带来明显的上下文切换开销，如果不是一个复杂的计算过程，不值的浪费这个开销。</p><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n的整数键，其他的所有键都储存在哈希部分中。</p><p>哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。</p><p>当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。</p><h2 id="创建table时初始化数据"><a href="#创建table时初始化数据" class="headerlink" title="创建table时初始化数据"></a>创建table时初始化数据</h2><p>为了减少不必要的内存开销，table在创建时不会分配任何额外内存，早期几个元素的插入都必然导致rehash操作，这个特性对小table的创建影响特别显著，创建时一并指定初始化数据可以避免rehash的开销。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>t[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>t[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br> <br><span class="hljs-comment">-- good: 200% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="高效的遍历"><a href="#高效的遍历" class="headerlink" title="高效的遍历*"></a>高效的遍历*</h2><p>paris和iparis有函数调用的开销，因此效率不高。在性能敏感的场合，最好缓存table的size，然后使用for loop。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- pairs: 3.078 (217%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">--- ipairs: 3.344 (236%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,x do: 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,#atable do 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,atable_length do: 1.562 (110%)</span><br><span class="hljs-keyword">local</span> length = #a<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,length <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的插入"><a href="#高效的插入" class="headerlink" title="高效的插入*"></a>高效的插入*</h2><p>table.insert有函数调用的开销，因此性能不高。在性能敏感的场合，最好缓存table的size，然后指定下标赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table.insert: 1.250 (727%)</span><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    tinsert(a,i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[i]: 0.172 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[i]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[#a+1]=x: 0.453 (263%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[count++]=x: 0.203 (118%)</span><br><span class="hljs-keyword">local</span> count = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    d[count]=i<br>    count=count+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的unpack"><a href="#高效的unpack" class="headerlink" title="高效的unpack*"></a>高效的unpack*</h2><p>性能敏感的场合不要使用unpack，选择手动展开。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- with [ ]: 0.485 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>],a[<span class="hljs-number">4</span>] )<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- unpack(): 1.093 (225%)</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">unpack</span>(a) )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="array或者hash"><a href="#array或者hash" class="headerlink" title="array或者hash*"></a><a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=array&zhida_source=entity">array</a>或者hash*</h2><p>table有array和hash两部分存储，一般来讲array的存储开销要比hash小一些，访问速度也比hash查找要快，可能的话尽量选array。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 使用hash，内存开销最大 400%</span><br>polyline = &#123;<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">18.3</span>&#125;,<br>  &#123;x= <span class="hljs-number">15.0</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>&#125;  <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 使用数组，内存开销降低 250%</span><br>polyline = &#123;<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">98.5</span> &#125;,<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">18.3</span> &#125;,<br>  &#123; <span class="hljs-number">15.0</span>, <span class="hljs-number">98.5</span> &#125;,<br>  ...<br>&#125; <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 还可以进一步减少table本身的内存开销，只3个table 100%</span><br>polyline = &#123;<br>  x = &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">10.3</span>, <span class="hljs-number">15.0</span>, ... &#125;,<br>  y = &#123; <span class="hljs-number">98.5</span>, <span class="hljs-number">18.3</span>, <span class="hljs-number">98.5</span>, ... &#125;<br>&#125; <span class="hljs-comment">--(tables used: 3)</span><br></code></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。</p><p>所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为Lua需要去查找比较一遍。</p><p>第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变得十分高效。例如在Perl中，$x &#x3D; $y，会将$y的buffer整个的复制到$x的buffer中，当字符串很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。</p><p>但是只保存引用会降低在字符串连接时的速度。在Perl中，$s &#x3D; $s . ‘x’和$s .&#x3D; ‘x’的效率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插入到$x的buffer末尾。</p><p>由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。</p><h2 id="缓存字符串"><a href="#缓存字符串" class="headerlink" title="缓存字符串"></a>缓存字符串</h2><p>避免在运行时构造字符串，尽量缓存那些常量字符串。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>大字符串的拼接，使用table.concat。</p><p>在lua中可以用table来模拟buffer</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">30000</span> <span class="hljs-keyword">do</span><br>    t[#t+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">end</span><br>s = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="语言之外的东西"><a href="#语言之外的东西" class="headerlink" title="语言之外的东西"></a>语言之外的东西</h1><p>使用<a href="http://luajit.org/">LuaJIT</a>，LuaJIT可以使你在不修改代码的情况下获得平均约5倍的加速。查看LuaJIT在<a href="http://luajit.org/performance_x86.html">x86&#x2F;x64下的性能提升比</a>。</p><p>第二、将瓶颈部分用C&#x2F;C++来写。因为Lua和C的天生近亲关系，使得Lua和C可以混合编程。但是C和Lua之间的通讯会抵消掉一部分C带来的优势。</p>]]></content>
    
    
    <summary type="html">关于如何写Lua高性能编程的一些建议</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于蓝图的多人游戏玩法设计</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.220Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18Y41187vo/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2021]与众乐乐 - 基于蓝图的多人游戏玩法设计 | Epic Games 何骞</a> </p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221120244763.png"></p><p>复制Replication</p>]]></content>
    
    
    <summary type="html">一个关于如何用蓝图开发多人游戏的演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>UE蓝图开发最佳实践</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.394Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1oG411M7Y6/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2022]蓝图开发最佳实践 | Epic 何骞</a> </p><h1 id="命名相关"><a href="#命名相关" class="headerlink" title="命名相关"></a>命名相关</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000001964.png"></p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000142710.png"></p><p>减少冗余信息</p><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000236767.png"></p><h1 id="蓝图如何保持整洁"><a href="#蓝图如何保持整洁" class="headerlink" title="蓝图如何保持整洁"></a>蓝图如何保持整洁</h1><h2 id="避免过长的蓝图逻辑，屏幕长度有限"><a href="#避免过长的蓝图逻辑，屏幕长度有限" class="headerlink" title="避免过长的蓝图逻辑，屏幕长度有限"></a>避免过长的蓝图逻辑，屏幕长度有限</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000410021.png"></p><h2 id="事件左对齐"><a href="#事件左对齐" class="headerlink" title="事件左对齐"></a>事件左对齐</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000501706.png"></p><p>保证更改逻辑的时候不会改错</p><h2 id="通过Re-route来减少连线"><a href="#通过Re-route来减少连线" class="headerlink" title="通过Re-route来减少连线"></a>通过Re-route来减少连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000527244.png"></p><h2 id="避免错乱事件连线"><a href="#避免错乱事件连线" class="headerlink" title="避免错乱事件连线"></a>避免错乱事件连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000700985.png"></p><p>不要想到一个事件就立马create出来</p><h2 id="重用Getter或者Pure节点"><a href="#重用Getter或者Pure节点" class="headerlink" title="重用Getter或者Pure节点"></a>重用Getter或者Pure节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000813646.png"></p><h2 id="清晰的返回节点"><a href="#清晰的返回节点" class="headerlink" title="清晰的返回节点"></a>清晰的返回节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000841491.png"></p><p>越复杂的函数为什么return，为什么early return需要写清楚</p><h2 id="Select节点"><a href="#Select节点" class="headerlink" title="Select节点"></a>Select节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000918576.png"></p><p>Text替代String</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000954247.png"></p><h1 id="蓝图注释规则"><a href="#蓝图注释规则" class="headerlink" title="蓝图注释规则"></a>蓝图注释规则</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001053596.png"></p><h2 id="分不同的颜色，规则不一样"><a href="#分不同的颜色，规则不一样" class="headerlink" title="分不同的颜色，规则不一样"></a>分不同的颜色，规则不一样</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001141232.png"></p><h2 id="注释的细节"><a href="#注释的细节" class="headerlink" title="注释的细节"></a>注释的细节</h2><p><strong>每个事件都编写注释</strong></p><p><strong>Sequence的每一段都写注释</strong></p><p>把长的拆分成sequence也可以做</p><p><strong>为复杂的逻辑写注释</strong></p><p><strong>为复杂的函数返回写注释</strong></p><h1 id="如何创建稳固更新的生产线？"><a href="#如何创建稳固更新的生产线？" class="headerlink" title="如何创建稳固更新的生产线？"></a>如何创建稳固更新的生产线？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001347062.png"></p><p>不是一开始就设计好，而是在项目进行到一定阶段在解耦。</p><p>不要复制黏贴，而是作为抽离成function</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>每次冷启动，可以通过log（Unreal Inside）来观察哪里加载的久。</p><p>以及每次添加新节点的时间</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>减少不必要的Cast，特别是复杂蓝图类的cast</strong>。</p><p><strong>用Gameplay Tag和blueprint Interface</strong></p><p><strong>活用命名空间</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002004041.png"></p><p>可以规定某个蓝图这是哪种玩法会用到的，这样就可以减少加载</p><p><strong>减少Hard Reference</strong></p><p>因为每个hard Reference都会加载在内存里面，会影响包体大小，考虑用Tag或者Soft Reference来替换</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002514037.png"></p><p>一个比较好的方式是，脚本语言不去改蓝图function的实现，然后划分好哪些变量会修改，这样也可以作为一个新的category来分类</p><h2 id="蓝图审核"><a href="#蓝图审核" class="headerlink" title="蓝图审核"></a>蓝图审核</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002854518.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002937518.png"></p><p>可以持续更新一个Best Practice文档</p><h1 id="编辑器拓展"><a href="#编辑器拓展" class="headerlink" title="编辑器拓展"></a>编辑器拓展</h1><p>Assest Action Utility（这里没太听懂，到时候学习一下）</p><h1 id="如何平衡蓝图和C-？"><a href="#如何平衡蓝图和C-？" class="headerlink" title="如何平衡蓝图和C++？"></a>如何平衡蓝图和C++？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221003705495.png"></p><p><strong>不用过早优化</strong></p><p>因为变化可能很快</p><p><strong>有安全性问题的时候可以考虑转</strong></p><p>比如拿的很多信息不是在本地，而是要通过服务器来request，这种可能放在C++核心类比较好</p><p><strong>直接重定向</strong></p><p>在C++里面写一个<strong>MigrateProperty</strong>这样一个函数，可以把哪些变量，CDO准确的转化过来</p>]]></content>
    
    
    <summary type="html">一个关于如何有效率地编写蓝图演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-垃圾回收</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2024-12-17T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>也是采用标记清除的方式，会从根出发，标记所有</p><h2 id="根节点是什么？"><a href="#根节点是什么？" class="headerlink" title="根节点是什么？"></a>根节点是什么？</h2><p><strong>1. 静态字段</strong></p><p><strong>2. MonoBehaviour实例</strong></p><p><strong>3. ScriptableObject实例</strong></p><p><strong>4. 场景中的GameObject</strong></p><p><strong>5. 全局引用</strong></p><p><strong>6. 资源引用</strong></p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，主要分为以下几步：</p><ul><li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；</li><li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。</li><li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。</li></ul><p>堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。</p><h2 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h2><p>当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ul><li>GC会检查堆内存上的每个存储变量；</li><li>对每个变量会检测其引用是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为可回收；</li><li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li></ul><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h2 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h2><p>主要有三个操作会触发垃圾回收：</p><ul><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ul><h2 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a><strong>降低GC的影响的方法</strong></h2><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>基于此，我们可以采用三种策略：</p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。</li><li>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响</li></ul><h2 id="降低GC的具体方法"><a href="#降低GC的具体方法" class="headerlink" title="降低GC的具体方法"></a>降低GC的具体方法</h2><h3 id="减少内存垃圾"><a href="#减少内存垃圾" class="headerlink" title="减少内存垃圾"></a>减少内存垃圾</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>比如循环不要每次都创建新的数组，而是提前创建好</p><h4 id="不要在频分调用的函数里面使用堆内存分配"><a href="#不要在频分调用的函数里面使用堆内存分配" class="headerlink" title="不要在频分调用的函数里面使用堆内存分配"></a>不要在频分调用的函数里面使用堆内存分配</h4><p>比如tick和update里面不要分配内存，而是在之前就创建好，或者通过定时器或者脏标记的方法来改进</p><h4 id="减少链表"><a href="#减少链表" class="headerlink" title="减少链表"></a>减少链表</h4><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>减少内存的释放和创建次数</p><h3 id="造成不必要内存的分配的情况"><a href="#造成不必要内存的分配的情况" class="headerlink" title="造成不必要内存的分配的情况"></a>造成不必要内存的分配的情况</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在c#里面字符串不是值类型而是引用，而且值无法改变，所以改变值会直接创建一个新的值</p><p>　1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p><p>　　2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。</p><p>　　3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>比如说迭代器会产生新的数组（可以通过缓存来解决），调用GameObject.name 或者 GameObject.tag也会有内存垃圾，因为会犯乎一个字符串</p><h4 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h4><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。最好避免。</p><p>比如这种</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> cost = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">string</span> displayString = String.Format(<span class="hljs-string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost);<br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>6.5之前的版本会因为迭代器有内存垃圾</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>比如把对象里面的string拆出来，这样就不用频繁地在GC里面类型检查</p><h3 id="定时执行GC"><a href="#定时执行GC" class="headerlink" title="定时执行GC"></a>定时执行GC</h3><p>比如过场的时候主动调用GC操作</p><h1 id="UE"><a href="#UE" class="headerlink" title="UE"></a>UE</h1><p>也是标记清除</p><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p><a href="https://zhuanlan.zhihu.com/p/133939450">Lua GC机制分析与理解-上 - 小破孩不会编程序的文章 - 知乎</a></p><h2 id="gc的思想"><a href="#gc的思想" class="headerlink" title="gc的思想"></a>gc的思想</h2><p>会遍历所有对象，标记颜色，那些不可达的就是需要gc的对象，又分为双色和三色，双色就是不能中断，三色可以中断，但是实现复杂，</p><h2 id="何时会触发gc？"><a href="#何时会触发gc？" class="headerlink" title="何时会触发gc？"></a>何时会触发gc？</h2><p>分为两种，一种是自动触发</p><p>在以下代码中，使用 luaC_checkGC 检查 gc 阈值 GCdebt ，当 GCdebt 大于0 时，执行 gc<br>1、创建新数据时 string, thread, userdata, table, closure<br>3、语法解析时<br>4、错误发生时<br>5、字符串拼接时 concat<br>6、栈增长时</p><p>一种是手动触发</p><p>使用 lua API：<br>collectgarbage “step”<br>collectgarbage “collect”</p><h2 id="lua-怎么判定数据可达？"><a href="#lua-怎么判定数据可达？" class="headerlink" title="lua 怎么判定数据可达？"></a>lua 怎么判定数据可达？</h2><p>从 GC根集合（root set） 可访问的对象：<br>gc root set包含三部分：<br>1、主协程 g-&gt;mainthread，其栈记录了当前用到的所有对象<br>2、注册表 g-&gt;l_registry，包含了全局table(_G)，记录了全局变量和全局模块，还包括已加载的模块表 package.loaded<br>3、全局元表 g-&gt;mt，每种数据类型各一个，预留9个，暂时只有table和string的实现，效果如io模块的f:read()和 string模块的s:len()</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>程序是无法推断哪些东西是需要回收的，比如说在数组里的元素，虽然我们不用他了，但是数组还在引用，那么lua就无法自动回收它，这时候就需要弱引用表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p><p>1、导致引用计数+1的情况</p><p>对象被创建，例如a&#x3D;23</p><p>对象被引用，例如b&#x3D;a</p><p>对象被作为参数，传入到一个函数中，例如func(a)</p><p>对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>2、导致引用计数-1的情况</p><p>对象的别名被显式销毁，例如del a</p><p>对象的别名被赋予新的对象，例如a&#x3D;24</p><p>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</p><p>对象所在的容器被销毁，或从容器中删除对象</p><h2 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h2><p>针对循环引用这个问题，比如有两个对象互相引用了对方，当外界没有对他们有任何引用，也就是说他们各自的引用计数都只有1的时候，如果可以识别出这个循环引用，把它们属于循环的计数减掉的话，就可以看到他们的真实引用计数了。基于这样一种考虑，有一种方法，比如从对象A出发，沿着引用寻找到对象B，把对象B的引用计数减去1；然后沿着B对A的引用回到A，把A的引用计数减1，这样就可以把这层循环引用关系给去掉了。</p><p>不过这么做还有一个考虑不周的地方。假如A对B的引用是单向的， 在到达B之前我不知道B是否也引用了A，这样子先给B减1的话就会使得B称为不可达的对象了。为了解决这个问题，python中常常把内存块一分为二，将一部分用于保存真的引用计数，另一部分拿来做为一个引用计数的副本，在这个副本上做一些实验。比如在副本中维护两张链表，一张里面放不可被回收的对象合集，另一张里面放被标记为可以被回收（计数经过上面所说的操作减为0）的对象，然后再到后者中找一些被前者表中一些对象直接或间接单向引用的对象，把这些移动到前面的表里面。这样就可以让不应该被回收的对象不会被回收，应该被回收的对象都被回收了。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h2><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环境的编程中，对于变量在内存中的创建&#x2F;销毁，总有频繁和不那么频繁的。比如任何程序中总有生命周期是全局的、部分的变量。<br>Python将所有的对象分为0，1，2三代；<br>所有的新建对象都是0代对象；<br>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p><p>他们gc的频率不同，这样可以提高性能</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - allen的文章 - 知乎</a></p><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>如果要自己写一个内存泄漏，可以考虑在new和malloc里面记录内存。</p><p>调试可以用数据断点来操作。</p><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><h2 id="避免内存碎片"><a href="#避免内存碎片" class="headerlink" title="避免内存碎片"></a>避免内存碎片</h2><ol><li>使用内存池（Memory Pool）</li></ol><p>预先分配一大块内存，并在其中管理小块内存的分配和释放。这样可以减少频繁的动态内存分配和释放带来的碎片。</p><p>内存池可以根据对象的大小进行分区，确保相同大小的对象使用相同的内存块。</p><ol start="2"><li>对象重用：</li></ol><p>尽量重用对象，避免频繁的创建和销毁。可以使用对象池（Object Pool）来管理可重用的对象。</p><p>对象池可以在游戏中常用的对象（如子弹、敌人等）中使用，减少内存分配和释放的次数。</p><ol start="3"><li>合理的内存分配策略：</li></ol><p>使用合适的内存分配器，选择适合应用场景的分配策略（如分配器的对齐方式、分配大小等）。</p><p>避免频繁的小块内存分配，尽量使用较大的内存块进行分配。</p><ol start="4"><li>合并空闲块：</li></ol><p>在释放内存时，检查相邻的空闲块并合并它们，以减少外部碎片。</p><p>许多内存分配器会自动处理合并空闲块的逻辑。</p><ol start="5"><li>使用智能指针：</li></ol><p>在 C++ 中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）来管理内存，减少内存泄漏和碎片的可能性。</p><h2 id="解决内存碎片"><a href="#解决内存碎片" class="headerlink" title="解决内存碎片"></a>解决内存碎片</h2><ol><li>内存整理（Compaction）：</li></ol><p>在某些情况下，可以通过内存整理来解决外部碎片。内存整理的过程是将活动对象移动到内存的一端，释放出连续的空闲内存块。</p><p>这种方法在实时系统中可能不适用，因为它可能导致停顿。</p><ol start="2"><li>使用更高效的内存分配器：</li></ol><p>如果发现当前的内存分配器导致了严重的内存碎片，可以考虑使用其他内存分配器（如 jemalloc、tcmalloc 等），这些分配器在处理碎片方面通常更高效。</p><ol start="3"><li>监控和分析内存使用：</li></ol><p>使用内存分析工具（如 Valgrind、Visual Studio 的内存分析工具等）监控内存使用情况，识别和解决内存碎片问题。</p><p>定期检查和分析内存使用情况，及时发现和解决潜在的内存碎片问题。</p><ol start="4"><li>重启应用程序：</li></ol><p>在某些情况下，重启应用程序可以清除内存碎片，尤其是在长时间运行的应用程序中。</p>]]></content>
    
    
    <summary type="html">垃圾回收可能会问到的一切东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-UE相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:01.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE最基础的五个类是什么"><a href="#UE最基础的五个类是什么" class="headerlink" title="UE最基础的五个类是什么"></a>UE最基础的五个类是什么</h1><ol><li>GameMode是整个关卡的控制器，用来编写整个关卡的<a href="https://zhida.zhihu.com/search?content_id=212792905&content_type=Article&match_order=1&q=%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&zhida_source=entity">业务逻辑</a>；</li><li>GameState是整个关卡的状态，用来存储整个关卡的游戏数据；</li><li>DefaultPawn是玩家角色，若是角色扮演类游戏则就是在游戏场景中看到的角色实体；</li><li>PlayerController是玩家的控制器，用来编写和玩家相关的控制逻辑；</li><li>PlayerState是玩家的状态，用来存储和玩家相关的状态数据。</li></ol><h1 id="FName和FString"><a href="#FName和FString" class="headerlink" title="FName和FString"></a>FName和FString</h1><p>① <strong>FName：</strong>着重于表示<strong>名称</strong>，<strong>不区分大小写</strong>，<strong>不可更改</strong>，引擎中的资源名称都是FName类型，通过一个轻型系统重复使用字符串，FName创建时会根据内容创建一个<a href="https://zhida.zhihu.com/search?content_id=178876897&content_type=Article&match_order=1&q=Hash%E5%80%BC&zhida_source=entity">Hash值</a>，且同样的内容只会存储一次。通过Hash值在进行FName的查找和访问时速度较快，而在比较的时，也不需要比较字符串内容，直接比较Hash值来区分不同FName字符串。</p><p>另外两种字符串<strong>到FName的转换</strong>（特别注意的是，<strong>FText不能直接转换到FName</strong>，可<strong>先转换为FString</strong>，再转换为FName）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br> <br><span class="hljs-comment">// FString 转 FName：不可靠，丢失大小写信息</span><br>FName name1 = <span class="hljs-built_in">FName</span>(*str);<br><br>FString strFromTxt = txt.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 先转 FString，再转 FName：不可靠，丢失大小写信息，丢失本地化信息可能导致语言转换的潜在风险</span><br>FName name2 = <span class="hljs-built_in">FName</span>(*strFromTxt);<br></code></pre></td></tr></table></figure><p>② <strong>FString：</strong>最接近std::string，着重在于<strong>字符串的操作</strong>，提供了大量对字符串的操作接口，是<strong>三者中唯一可修改的字符串类型</strong>，也正因如此，FString对比其它两种字符串来说<strong>消耗更高</strong>，<strong>性能更低</strong>。</p><p>另外两种字符串<strong>到FString的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br><br><span class="hljs-comment">// FName 转 FString：可靠</span><br>FString str1 = name.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 转 FString：不可靠，丢失本地化信息可能导致语言转换的潜在风险</span><br>FString str2 = txt.<span class="hljs-built_in">ToString</span>();<br></code></pre></td></tr></table></figure><p>③ <strong>FText：</strong>着重在于<strong>显示与本地化</strong>，显示可理解玩家能直接看到的信息，本地化即多语言的处理，<strong>不可更改</strong>。相较于另外两种类型，FText会更加的臃肿，但提供了优秀的本地化功能。</p><p>另外两种字符串<strong>到FText的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br><br><span class="hljs-comment">// FString 转 FText：可靠</span><br>FText txt1 = FText::<span class="hljs-built_in">FromString</span>(str);<br><span class="hljs-comment">// FName 转 FText：可靠</span><br>FText txt2 = FText::<span class="hljs-built_in">FromName</span>(name);<br></code></pre></td></tr></table></figure><h1 id="软引用和硬引用"><a href="#软引用和硬引用" class="headerlink" title="软引用和硬引用"></a>软引用和硬引用</h1><p>加载的步骤</p><h1 id="Actor如何实现一个借口类"><a href="#Actor如何实现一个借口类" class="headerlink" title="Actor如何实现一个借口类?"></a>Actor如何实现一个借口类?</h1><h1 id="UE4反射机制"><a href="#UE4反射机制" class="headerlink" title="UE4反射机制"></a>UE4反射机制</h1><p>UHT</p><p><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a></p><p><a href="https://blog.csdn.net/duan19920101/article/details/127557454">C++反射机制</a></p><h1 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/v2-49e75fce0ea89e5dced9f3f8994fb6ce_1440w.jpg" alt="img"></p><p>作者：一勾大师<br>链接：<a href="https://zhuanlan.zhihu.com/p/308217207">https://zhuanlan.zhihu.com/p/308217207</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>UE4中创建Actor的方法主要有如下几种：<strong>从磁盘加载</strong>，<strong>Play In Editor（简称PIE）</strong>，<strong>SpawnActor动态生成</strong>和<strong>延迟生成。</strong>下面对不同形式的actor加载进行介绍</p><p><strong>从磁盘加载</strong></p><p>已位于关卡中的 Actor 使用此路径，如 LoadMap 发生时、或 AddToWorld（从流关卡或子关卡）被调用时，一般是提前搭好的场景中资源的加载方式。</p><ol><li>包&#x2F;关卡中的 Actor 从磁盘中进行加载。</li><li><strong>PostLoad</strong> - 在<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%BA%8F%E5%88%97%E5%8C%96&zhida_source=entity">序列化</a> Actor 从磁盘加载完成后被调用。在此处可执行自定义版本化和修复操作。PostLoad 与 <strong>PostActorCreated</strong> 互斥。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="Play-in-Editor"><a href="#Play-in-Editor" class="headerlink" title="Play in Editor"></a><strong>Play in Editor</strong></h2><p>Play in Editor 路径与 Load from Disk 十分相似，然而 Actor 却并非从磁盘中加载，而是从编辑器中复制而来，一般是在Debug时资源的加载方式。</p><ol><li><strong>PostDuplicate</strong> 被调用。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h2><p>这是生成（实例）Actor 时的路径。在实际工程中一般是通过SpawnActor等函数加载的资源</p><ol><li><strong>SpawnActor</strong> 被调用。</li><li><strong>PostSpawnInitialize</strong></li><li><strong>PostActorCreated</strong> - 创建后即被生成的 Actor 调用，构建函数类行为在此发生。PostActorCreated 与 PostLoad 互斥。</li><li><strong>ExecuteConstruction</strong>：</li></ol><ul><li><strong>OnConstruction</strong> - Actor 的构建。蓝图 Actor 的组件在此处创建，蓝图变量在此处初始化</li></ul><p>5.<strong>PostActorConstruction</strong>：</p><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>6.<strong>OnActorSpawned</strong> 在 UWorld 上播放。</p><p>7.<strong>BeginPlay</strong> 被调用。</p><h2 id="延迟生成"><a href="#延迟生成" class="headerlink" title="延迟生成"></a><strong>延迟生成</strong></h2><p>将任意属性设为”Expose on Spawn”即可延迟 Actor 的生成。</p><ol><li><strong>SpawnActorDeferred</strong> - 生成程序化 Actor，在蓝图构建脚本之前进行额外设置。</li><li>SpawnActor 中的所有操作发生；PostActorCreated 之后发生以下操作：</li></ol><ul><li>通过一个有效但不完整的 Actor 实例设置&#x2F;调用多个”<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0&zhida_source=entity">初始化函数</a>“。</li><li><strong>FinishSpawningActor</strong> -调用后对 Actor 进行最终化，在 Spawn Actor 行中选取 ExecuteConstruction。</li></ul><p><strong>生命周期的结束</strong></p><p>尽管生成方式有比较大的区别，上述几种生成方法的结束流程却都一样。</p><p><strong>Destroy</strong> - 游戏在 Actor 需要被移除时手动调用，但游戏进程仍在继续。Actor 被标记为等待销毁并从关卡的 Actor 阵列中移除。</p><p><strong>EndPlay</strong> - 在数个地方调用，保证 Actor 的生命走向终点。在游戏过程中，如包含流关卡的 Actor 被卸载，Destroy 将发射此项和关卡过渡。调用 EndPlay 的全部情形：</p><ul><li>对 Destroy 显式调用。</li><li>Play in Editor 终结。</li><li>关卡过渡（无缝行程或加载地图）。 包含 Actor 的流关卡被卸载。</li><li>Actor 的生命期已过。</li><li>应用程序关闭（全部 Actor 被销毁）。</li></ul><p>无论这些情形出现的方式如何，Actor 都将被标记为 RF_PendingKill，因此在下个垃圾回收周期中它将被解除分配。此外，可以考虑使用更整洁的 <code>FWeakObjectPtr&lt;AActor&gt;</code> 代替手动检查”等待销毁”。</p><p><strong>OnDestroy</strong> - 这是对 Destroy 的旧有反应。也许应该将这里的所有内容移到 EndPlay，因为它被关卡过渡和其他游戏清理函数调用。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><p>一个对象被标记待销毁的一段时间后，垃圾回收会将其从内存中实际移除，释放其使用的资源。</p><p>在对象的销毁过程中，以下函数将被调用：</p><ol><li><strong>BeginDestroy</strong> - 对象可利用此机会释放内存并处理其他<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&zhida_source=entity">多线程</a>资源（即为图像线程代理对象）。与销毁相关的大多数游戏性功能理应在 <code>EndPlay</code> 中更早地被处理。</li><li><strong>IsReadyForFinishDestroy</strong> - 垃圾回收过程将调用此函数，以确定对象是否可被永久解除分配。返回 <code>false</code>，此函数即可延迟对象的实际销毁，直到下一个垃圾回收过程。</li><li><strong>FinishDestroy</strong> - 最后对象将被销毁，这是释放内部数据结构的另一个机会。这是<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE&zhida_source=entity">内存释放</a>前的最后一次调用。</li></ol><h1 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zhuanlan.zhihu.com/p/149392857">UFUNCTION&#x2F;UPROPERTY&#x2F;UCLASS</a></p><p> 反射系统是可以选择加入的。你需要给暴露给反射系统的类型或属性添加注解，这样Unreal Header Tool (UHT)就会在编译工程的时候利用那些信息生成特定的代码。</p><p><strong>标记</strong></p><p>为了标记一个头文件包含反射类型，需要在文件顶部添加一个特殊的include文件。该文件必须放在#include的最后，这让UHT知道它需要考虑这个文件，并且在反射系统的实现里也是需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileName.generated.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>你现在可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()来在头文件中注解不同的类型以及成员变量。每一个宏都会出现在类型或者成员变量的前面，并且可以包含额外的修饰符关键字。</p><p>C++是没法直接通过函数名来调用的，因为存的都是地址，但是在蓝图里面可以，这就用到了反射机制</p><h2 id="常用的有哪些"><a href="#常用的有哪些" class="headerlink" title="常用的有哪些"></a>常用的有哪些</h2><p><a href="https://blog.csdn.net/ttod/article/details/136396379">简述UE中的UFUNCTION宏和UPROPERTY宏常用属性</a></p><p>UFunction</p><table><thead><tr><th><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></th><th>在蓝图编辑工具中显示时指定函数的类别。使用 | 运算符定义嵌套类别。</th></tr></thead><tbody><tr><td><code>Client</code></td><td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>CustomThunk</code></td><td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td></tr><tr><td><code>Exec</code></td><td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td></tr><tr><td><code>NetMulticast</code></td><td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td></tr><tr><td><code>Reliable</code></td><td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>SealedEvent</code></td><td>无法在子类中覆盖此函数。<code>SealedEvent</code>关键词只能用于事件。对于非事件函数，请将它们声明为<code>static</code>或<code>final</code>，以密封它们。</td></tr><tr><td><code>ServiceRequest</code></td><td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>ServiceResponse</code></td><td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>Server</code></td><td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>Unreliable</code></td><td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>WithValidation</code></td><td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td></tr></tbody></table><p>UProperty</p><table><thead><tr><th><code>AdvancedDisplay</code></th><th>属性将被放置在其出现的任意面板的高级（下拉）部分中。</th></tr></thead><tbody><tr><td><code>AssetRegistrySearchable</code></td><td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td></tr><tr><td><code>BlueprintAssignable</code></td><td>只能与组播委托共用。公开属性在蓝图中指定。</td></tr><tr><td><code>BlueprintAuthorityOnly</code></td><td>此属性必须为一个组播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td></tr><tr><td><code>BlueprintCallable</code></td><td>仅用于组播委托。应公开属性在蓝图代码中调用。</td></tr><tr><td><code>BlueprintGetter=GetterFunctionName</code></td><td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>BlueprintReadOnly</code></td><td>此属性可由蓝图读取，但不能被修改。此说明符与 <code>BlueprintReadWrite</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintReadWrite</code></td><td>可从蓝图读取或写入此属性。此说明符与 <code>BlueprintReadOnly</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintSetter=SetterFunctionName</code></td><td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td></tr><tr><td><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></td><td>指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td></tr><tr><td><code>Config</code></td><td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>DuplicateTransient</code></td><td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td></tr><tr><td><code>EditAnywhere</code></td><td>说明此属性可通过属性窗口在原型和实例上进行编辑。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditDefaultsOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditFixedSize</code></td><td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td></tr><tr><td><code>EditInline</code></td><td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td></tr><tr><td><code>EditInstanceOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>Export</code></td><td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td></tr><tr><td><code>GlobalConfig</code></td><td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>Instanced</code></td><td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td></tr><tr><td><code>Interp</code></td><td>说明值可随时间由Sequencer中的一个轨道驱动。</td></tr><tr><td><code>Localized</code></td><td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td></tr><tr><td><code>Native</code></td><td>属性为本地：C++代码负责对其进行序列化并公开到<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-object-handling?application_version=4.27#garbagecollection">垃圾回收</a>。</td></tr><tr><td><code>NoClear</code></td><td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td></tr><tr><td><code>NoExport</code></td><td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td></tr><tr><td><code>NonPIEDuplicateTransient</code></td><td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td></tr><tr><td><code>NonTransactional</code></td><td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td></tr><tr><td><code>NotReplicated</code></td><td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td></tr><tr><td><code>Replicated</code></td><td>属性应随网络进行复制。</td></tr><tr><td><code>ReplicatedUsing=FunctionName</code></td><td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td></tr><tr><td><code>RepRetry</code></td><td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td></tr><tr><td><code>SaveGame</code></td><td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td></tr><tr><td><code>SerializeText</code></td><td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td></tr><tr><td><code>SkipSerialization</code></td><td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>SimpleDisplay</code></td><td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开“高级”部分即可见。</td></tr><tr><td><code>TextExportTransient</code></td><td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>Transient</code></td><td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td></tr><tr><td><code>VisibleAnywhere</code></td><td>说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</td></tr><tr><td><code>VisibleDefaultsOnly</code></td><td>说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr><tr><td><code>VisibleInstanceOnly</code></td><td>说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr></tbody></table><h1 id="PUERTS"><a href="#PUERTS" class="headerlink" title="PUERTS"></a>PUERTS</h1><p><strong>puerts的本质</strong></p><p>puerts的本质是：</p><ul><li>在（UE）引擎提供了JavaScript虚拟机环境</li><li>让TypeScript&#x2F;JavaScript能够和引擎交互，或者说能调用C++或者蓝图API，也能被C++或者蓝图调用到</li></ul><p>js虚拟机实现了js语言，但js语言本身基本什么都干不了，它能做的事情取决于宿主环境给它添加的api，比如浏览器在js环境添加了dom操作api，于是浏览器里的js可以编写动态页面的逻辑，比如nodejs添加异步网络（io）api，于是nodejs里的js能用来编写web服务器。</p><p>puerts里js的宿主环境是游戏引擎，又添加了哪些api呢？</p><p>首先，puerts默认导入了<strong>所有</strong>反射api。换句话在UE蓝图里能调用的引擎API，在Typescript&#x2F;JavaScript环境都可以调用，如果用Typescript，正确引入了声明文件到工程中，这些api会有提示。</p><p>其次对于非反射api，手工封装成反射后蓝图也能访问，这点在typescript同样适用，而且puerts还额外支持《基于模板的静态绑定》，按文档声明一下在typescript即可调用。</p><p>在puerts里，要实现一项游戏编程任务，先想下这任务在C++或者蓝图里如何实现，然后在typescript调用同样的api去实现。</p><p>puerts并未重定义引擎，只是定义了ts和引擎相互调用的规则。puerts的demo也倾向于演示这些规则，而不是做一个游戏。</p><h1 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h1><p><a href="https://zhuanlan.zhihu.com/p/434028533">【UE5】给Landscape加一点料-地形篇（零）-前前言 - 徐凯鸣的文章 - 知乎</a></p><p><a href="https://www.youtube.com/watch?v=MRNFcywkUSA&list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3&index=3">Procedural Landmass Generation Youtube</a></p><p>地形编辑</p><p>Houdini</p><h1 id="自定义编辑器FAssetEditorToolkit"><a href="#自定义编辑器FAssetEditorToolkit" class="headerlink" title="自定义编辑器FAssetEditorToolkit"></a>自定义编辑器FAssetEditorToolkit</h1><h3 id="3-1-InitCustomAssetEditor方法："><a href="#3-1-InitCustomAssetEditor方法：" class="headerlink" title="3.1 InitCustomAssetEditor方法："></a><strong>3.1 InitCustomAssetEditor方法：</strong></h3><p>在此方法中，主要分为两个内容：<br><strong>① 初始化编辑器布局，可以使用以下步骤：</strong></p><ol><li>通过创建适当类的实例并设置其属性来定义自定义 FLayout、菜单和工具栏。</li><li>自定义 Slate 窗口现在将绑定到 TabManager，并使用自定义 FLayout、菜单和工具栏显示资产编辑器。</li></ol><p><strong>② 调用父类方法InitAssetEditor将自定义 Slate 窗口绑定到 TabManager。</strong></p><h3 id="3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法："><a href="#3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法：" class="headerlink" title="3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法："></a>3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法：</h3><p>+ 我们首先需要知道，Tab(SDockTab)是引擎定义的一个控件类，每一个Tab都是可以被关闭或打开的SWidget.Tab类型的窗口右上角包含一个关闭按钮。窗口内则可以包含自定义显示的各种Slate内容。</p><p>+ 我们打开编辑器时，就会根据Layout布局加载对应的Tab控件，并显示其中的内容，即Tab装入的子控件(Child Slate)。</p><p>+ 在此方法中，最重要的是调用TabManager对象，TabManager类主要用于管理编辑器中的布局，创建Tab对象。在类中我们需要定义一个FName类型的TabID变量，用于在该方法中指示一个Slate窗口。我们需要通过调用TabManager的方法RegisterTabSpawner绑定TabID和Slate，用于后续定义Slate控件的显示。</p><h3 id="3-3-SpawnTab-CustomWidget方法"><a href="#3-3-SpawnTab-CustomWidget方法" class="headerlink" title="3.3 SpawnTab_CustomWidget方法"></a>3.3 SpawnTab_CustomWidget方法</h3><p>在此方法中，将会创建并返回一个SWidget实例。<br>而RegistorTabSpawner方法通过调用TabManager的接口，将该Slate控件实例注册，与TabID进行绑定，并能够在InitCustomAssetEditor方法中添加到布局Flayout中被显示出来。<br>我们不仅可以创建简单的Slate控件（如SButton、IDetailsViews）,也可以创建较为复杂的窗口，如SEditorViewport(3D预览窗口)、SGraphEditor(可以连接复杂自定义的节点<a href="https://zhida.zhihu.com/search?content_id=222180537&content_type=Article&match_order=1&q=%E5%9B%BE%E8%A1%A8%E7%B3%BB%E7%BB%9F&zhida_source=entity">图表系统</a>)等内容，并将其添加到我们的自定义编辑器中。<br>在本文实例中，我在该方法中创建了一个最简单的Slate类SButton。</p><h1 id="模拟云"><a href="#模拟云" class="headerlink" title="模拟云"></a>模拟云</h1><p>Worley Noise</p><p>在空间中随机随便放点，然后计算最近的点的距离，为了连续，把这个的点放八个地方</p><h1 id="虚幻渲染编程"><a href="#虚幻渲染编程" class="headerlink" title="虚幻渲染编程"></a>虚幻渲染编程</h1><p><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻4渲染编程专题概述及目录 - YivanLee的文章 - 知乎</a></p><h1 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h1><p><a href="https://zhuanlan.zhihu.com/p/486808688">【Unreal】虚幻GAS系统快速入门 - LunarMaxim的文章 - 知乎</a></p><p><a href="https://github.com/DriedMachine/GASDocumentation5.3_CN">GAS Document中文翻译</a></p><h2 id="包括什么东西"><a href="#包括什么东西" class="headerlink" title="包括什么东西"></a>包括什么东西</h2><p>GAS主要包含以下内容：</p><ul><li>Who:ASC(Ability System Component) 主要组件，由C++编写，代码里有很多方法是蓝图未实现的。</li><li>How:GA(Gameplay Abilities) 角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI</li><li>What:AS(Attribute Set) 角色身上<strong>可以用float表示的属性</strong>，如生命值、体力值、魔力值等，有BaseValue和CurrentValue，方便回滚</li><li>Change:GE(Gameplay Effects) 用于<strong>修改属性</strong>，如增加50移动速度10s；还能配合GA实现更多玩法</li><li>Visual:GC(Gameplay Cues) 播放特效、音效等</li><li>If:Tag:用来分类，底层是FName，用.来分隔</li><li>Async：Task：如果想要异步的做一些东西，比如做完技能播一个蒙太奇，可以用这个来搞</li><li>Send：Event:ASC之间通信</li></ul><h2 id="做冷却"><a href="#做冷却" class="headerlink" title="做冷却"></a>做冷却</h2><p>角色在启动的时候可以保存一个specAbility，然后拿一个他的handle。</p><p>比如我想实现一个技能的冷却，其实就是做一个GE，然后这个GE启动的时候挂上在人物身上挂一个cooldown的tag，这个tag是有一个duration的，然后释放技能的时候加一个条件，有这个tag的时候无法释放，在ASC上面有一个Activation Blocked Tags，在里面加上刚刚搞的那个tag</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://zhuanlan.zhihu.com/p/463272214">【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南 - 水曜日鸡的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/38881269">《Exploring in UE4》多线程机制详解[原理分析] - Jerish的文章 - 知乎</a></p><h2 id="FRunnable"><a href="#FRunnable" class="headerlink" title="FRunnable"></a>FRunnable</h2><p>创建一个继承自FRunnable的类，把这个类要执行的任务分发给其他线程去执行。</p><p><img src="https://picx.zhimg.com/v2-21dde7f72b7b87f9133b60ab9190e5b5_r.jpg" alt="img"></p><h2 id="AsyncTask系统"><a href="#AsyncTask系统" class="headerlink" title="AsyncTask系统"></a>AsyncTask系统</h2><h2 id="TaskGraph系统"><a href="#TaskGraph系统" class="headerlink" title="TaskGraph系统"></a>TaskGraph系统</h2><p>Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个<a href="https://zhida.zhihu.com/search?content_id=7702163&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&zhida_source=entity">多线程任务</a>，指定各个任务之间的依赖关系，按照该关系来依次处理任务。具体的实现方式网上也有很多案例，这里先给出UE4Wiki的教程链接：</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>《Exploring in UE4》关于网络同步的理解与思考[概念理解] - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34721113">https://zhuanlan.zhihu.com/p/34721113</a></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>要将一个函数声明为 RPC，您只需将 <code>Server</code>、<code>Client</code> 或 <code>NetMulticast</code> 关键字添加到 <code>UFUNCTION</code> 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UFUNCTION</span>( Client )<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientRPCFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>《Exploring in UE4》RootMotion详解【原理分析】 - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/74554876">https://zhuanlan.zhihu.com/p/74554876</a></p><h1 id="DS-专用服务器"><a href="#DS-专用服务器" class="headerlink" title="DS 专用服务器"></a>DS 专用服务器</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/networking-overview-for-unreal-engine#%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">网络概述官方文档</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://www.bilibili.com/video/BV1mP4y1R7UR/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【[UOD2022]虚幻DS的机遇与挑战 | 晶核 刘豪</a> </p><p>NetworkPrediction</p><h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241220222047918.png" alt="image-20241220222047918"></p><p>等级低只同步自己</p><p>把宠物，npc全放在逻辑服，不用同步</p><p>大世界网格小，副本网格范围大</p><p>摄像机背后的actor同步频率低</p><p>不移动的时候降低同步频率</p><p>把不需要同步的属性清理掉。</p><p>使用pushModel，手动标记哪些属性需要更新，这样就不需要同步所有的信息</p><h3 id="物理计算优化"><a href="#物理计算优化" class="headerlink" title="物理计算优化"></a>物理计算优化</h3><p>服务器剔除角色身上所有的装饰器组件</p><p>服务器关闭动画计算，只有业务需要具体坐标时才计算。</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="如何关闭滚动条的显示？"><a href="#如何关闭滚动条的显示？" class="headerlink" title="如何关闭滚动条的显示？"></a>如何关闭滚动条的显示？</h3><p>调用方法<strong>SetScrollBarVisibility</strong>。参数是<a href="https://link.zhihu.com/?target=https://docs.unrealengine.com/en-US/API/Runtime/UMG/Components/ESlateVisibility/index.html">ESlateVisiblity</a>，设成<strong>Collapsed</strong>即可。</p>]]></content>
    
    
    <summary type="html">UE知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>试玩的一些推箱子游戏记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/</id>
    <published>2024-12-12T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.515Z</updated>
    
    <content type="html"><![CDATA[<p>记录试玩的一些推箱子的idea，希望自己以后也能做出这种puzzle</p><h1 id="箱子联动"><a href="#箱子联动" class="headerlink" title="箱子联动"></a>箱子联动</h1><p>两个双重箱子会联动，并且推墙也会联动</p><p><a href="https://moonsoup.itch.io/sea-snake-safari">https://moonsoup.itch.io/sea-snake-safari</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121116554.png" alt="image-20241117121116554"></p><h1 id="组合箱子"><a href="#组合箱子" class="headerlink" title="组合箱子"></a>组合箱子</h1><p>需要通过拼接箱子的四个边来解谜，而且还能进入箱子里面来实现一些很有意思的操作</p><p><a href="https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09">https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121232954.png" alt="image-20241117121232954"></p><h1 id="推箱子点亮房间"><a href="#推箱子点亮房间" class="headerlink" title="推箱子点亮房间"></a>推箱子点亮房间</h1><p><a href="https://theconspiracy.itch.io/single-screen-scream">https://theconspiracy.itch.io/single-screen-scream</a></p><p>是一个迷宫类的游戏，把箱子推到对应的上面会点亮某个房间的地图，你需要自己画一下这个地图的结构，并且来搞</p><p>代码点评：他的代码太粗暴，每一个level都写了对应的操作，或许这个不太适合用这个编辑器来做，直接用引擎来写会更加简洁，不过创意不错</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121317837.png" alt="image-20241117121317837"></p><h1 id="改变关卡然后再推箱子"><a href="#改变关卡然后再推箱子" class="headerlink" title="改变关卡然后再推箱子"></a>改变关卡然后再推箱子</h1><h2 id="任意的位置"><a href="#任意的位置" class="headerlink" title="任意的位置"></a>任意的位置</h2><p><a href="https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3">https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3</a></p><p>需要先规定步数把关卡的墙壁消除，然后再推箱子，这个引擎竟然还可以这样有先后顺序，非常神奇啊，等等研究一下是怎么搞的， 相当牛逼啊</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117124647189.png" alt="image-20241117124647189"></p><h2 id="变身成铲子来改变，位置是有限的"><a href="#变身成铲子来改变，位置是有限的" class="headerlink" title="变身成铲子来改变，位置是有限的"></a>变身成铲子来改变，位置是有限的</h2><p><a href="https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea">https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea</a></p><p>这个需要捡起铲子来改变地形，会有不同，和自由的不太一样，设计思路也不太一样</p><p>他这个代码也很简单，因为他的规则集很统一，写的很好这个代码，三百行就搞定了</p><p>还讲了个小故事，不赖</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118232458914.png" alt="image-20241118232458914"></p><h2 id="场景中的物体也可以自己编辑"><a href="#场景中的物体也可以自己编辑" class="headerlink" title="场景中的物体也可以自己编辑"></a>场景中的物体也可以自己编辑</h2><p><a href="https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0">https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0</a></p><p>比如这一关是如何把这个小点搞出来</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118235755770.png" alt="image-20241118235755770"></p><h2 id="推箱子本身会改变路"><a href="#推箱子本身会改变路" class="headerlink" title="推箱子本身会改变路"></a>推箱子本身会改变路</h2><p><a href="https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab">https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab</a></p><p>箱子本身是一条以自身为中心的十字路，推箱子会改变主人公能走的位置，要通过这个推完成目标</p><p>关卡有点少，只有四关</p><p>一边推一边思考路的过程还是挺有趣的，要考虑的东西有点意思</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085156436.png" alt="image-20241119085156436"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119083807340.png" alt="image-20241119083807340"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084051277.png" alt="image-20241119084051277"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084505536.png" alt="image-20241119084505536"></p><h1 id="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"><a href="#改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径" class="headerlink" title="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"></a>改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径</h1><p><a href="https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337">https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337</a></p><p>会变成像素的数字，这个是可以走的路，蛮有意思</p><p>如果你吃的一瞬间路变没了，你也会死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119100230326.png" alt="image-20241119100230326"></p><h1 id="会连接在一起的箱子，而且中间的线也会挡住东西"><a href="#会连接在一起的箱子，而且中间的线也会挡住东西" class="headerlink" title="会连接在一起的箱子，而且中间的线也会挡住东西"></a>会连接在一起的箱子，而且中间的线也会挡住东西</h1><p>有点拓扑结构的意思</p><p><a href="https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0">https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117155008183.png" alt="image-20241117155008183"></p><h1 id="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"><a href="#推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物" class="headerlink" title="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"></a>推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物</h1><p><a href="https://notaninart.itch.io/pushing-u">https://notaninart.itch.io/pushing-u</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117163406595.png" alt="image-20241117163406595"></p><h1 id="箱子连接，但是本身自己也可以变成箱子，也可以解冻"><a href="#箱子连接，但是本身自己也可以变成箱子，也可以解冻" class="headerlink" title="箱子连接，但是本身自己也可以变成箱子，也可以解冻"></a>箱子连接，但是本身自己也可以变成箱子，也可以解冻</h1><p><a href="https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29">https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29</a></p><p>非常巧妙，自己可以被冰冻变成箱子，也可以解冻，很地狱笑话，被冰冻才能上飞机，太幽默了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118155250549.png" alt="image-20241118155250549"></p><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h1><p><a href="https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259">https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259</a></p><p>推动国际象棋的棋子，目标是走到对面的皇后位置，不能走到能被吃的位置，但是可以推动棋子可以把推动的棋子给杀了。</p><p>感觉可以做一个中国象棋版的来尝试复刻一下</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117221156115.png" alt="image-20241117221156115"></p><h1 id="有步数限制的推箱子"><a href="#有步数限制的推箱子" class="headerlink" title="有步数限制的推箱子"></a>有步数限制的推箱子</h1><p><a href="https://galactical.itch.io/at-the-hedges-of-time">https://galactical.itch.io/at-the-hedges-of-time</a></p><p>很好理解，也很简单的创意，一个trick的点是箱子不会随着自己回退</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118145646564.png" alt="image-20241118145646564"></p><h1 id="箱子本身是一个能和周围互动的装置"><a href="#箱子本身是一个能和周围互动的装置" class="headerlink" title="箱子本身是一个能和周围互动的装置"></a>箱子本身是一个能和周围互动的装置</h1><p><a href="https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5">https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5</a></p><p>按下开关之后箱子会动，会把自己往什么某个方向推，碰撞体积也会发生改变，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118171505291.png" alt="image-20241118171505291"></p><p>其实有些关设计的挺有意思的，因为你需要反复来回来利用本身他之后弹开的位置来占住那个开关，然后再去推，这样其实有一种联动的感觉，后面感觉会有那种一下联动好几个然后按顺序搞的感觉，感觉很有意思</p><h1 id="保龄球推箱子"><a href="#保龄球推箱子" class="headerlink" title="保龄球推箱子"></a>保龄球推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9">https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9</a></p><p>推的目标箱子推一次会一直往前滚，所以需要用生成的反射东西来组装好路径来搞，设计的比较简单，但是还是挺有意思的，和我们做的反射光的游戏甚至有点像，他里面有一分为二，还有生成东西的道具</p><p>但是他的关卡太简单了，不够多</p><p>而且他这个能推很多次，如果做成只推一次，会好很多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118201017238.png" alt="image-20241118201017238"></p><p>他的还有一个机制是遇到已经放好的花朵会导致提前停下，或许就是因为这一点所以他没有做一击通关，这样难度会很高</p><h1 id="不能自己往上的推箱子"><a href="#不能自己往上的推箱子" class="headerlink" title="不能自己往上的推箱子"></a>不能自己往上的推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb">https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb</a></p><p>因为主角是一个落叶，所以做了往上方向的限制，只能通过喷泉来往上，这种限制也蛮有意思的。但是可以同时推多个箱子，也要利用这个。</p><p>还有一个机制，在水里的话就可以往上推，可以借助水的浮力，比如这一关就是这样</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118234135382.png" alt="image-20241118234135382"></p><h1 id="推箱子和一笔画？"><a href="#推箱子和一笔画？" class="headerlink" title="推箱子和一笔画？"></a>推箱子和一笔画？</h1><p><a href="https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729">https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729</a></p><p>规则很简单，往某个地方推会朝那个方向生成一个箱子，目标是把所有的红色都占满</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085545410.png" alt="image-20241119085545410"></p><h1 id="箱子的状态会被改变（火）"><a href="#箱子的状态会被改变（火）" class="headerlink" title="箱子的状态会被改变（火）"></a>箱子的状态会被改变（火）</h1><p><a href="https://rosden.itch.io/theflames">https://rosden.itch.io/theflames</a></p><p>被火烧了会有几个状态，中间有四步移动的机会，这时候不会完全变成灰烬，还可以被推，可以用来填补空洞；之后会变成灰烬，不能被推动，也不会挡路（第一关就是教你这个，不挡路）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119092837131.png" alt="image-20241119092837131"></p>]]></content>
    
    
    <summary type="html">itch许多类推箱子游戏的游玩记录，总结一下他们的创意</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>我的独立游戏作品合集</title>
    <link href="https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/"/>
    <id>https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/</id>
    <published>2024-10-27T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:03.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完美世界GameJam"><a href="#完美世界GameJam" class="headerlink" title="完美世界GameJam"></a>完美世界GameJam</h1><p>开发日期：2024.3.15</p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a></p><p>一个关于骰子的肉鸽游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"></a></p><h1 id="2024CigaGamejam"><a href="#2024CigaGamejam" class="headerlink" title="2024CigaGamejam"></a>2024CigaGamejam</h1><p>主题：有限与无限</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">试玩连接</a></p><p>一个关于1v3的不对成派对游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"></a></p><h1 id="2024下半年Booom"><a href="#2024下半年Booom" class="headerlink" title="2024下半年Booom"></a>2024下半年Booom</h1><p>主题：change_,not change _</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">试玩连接</a></p><p>一个类似卡坦岛的生存游戏，美术不错</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"></a></p><h1 id="2024TapTapGameJam"><a href="#2024TapTapGameJam" class="headerlink" title="2024TapTapGameJam"></a>2024TapTapGameJam</h1><p>主题：light</p><p>开发日期：2024.10.25-11.1</p><p><a href="https://rorschachandbat.itch.io/lightpuzzle">试玩连接</a></p><p>一个关于光线解密的游戏，尝试着用ai+godot开发，完成度不错，关卡设计的很有意思</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"></a></p>]]></content>
    
    
    <summary type="html">放一个合集，欢迎大家试玩</summary>
    
    
    
    <category term="随笔" scheme="https://rorschachandbat.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>落井下食开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-02T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p class="note note-primary">为了避免危险，你需要派遣伙伴们去合适的地方，它们会帮助你，□□食物，应对晚上的客人。 夜晚来临时，客人们会依次到来，你只需要提供它们需要的食物，它们就会满意的离开。</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png" alt="img"></a></p><h1 id="Luban导表工具"><a href="#Luban导表工具" class="headerlink" title="Luban导表工具"></a>Luban导表工具</h1><p>这次的项目需要填数据的地方非常多，有了上次做肉鸽小游戏的教训，决定搜寻一下有无更加好用的导表工具，最终找到了luban工具，算是比较方便好用的实现方案。</p><p><a href="https://github.com/focus-creative-games/luban">官方链接</a></p><p>作为一个需要大量配表的游戏，最理想的情况是，策划端只需要用excel就可以搞定，程序端也不需要编写处理db的代码，导表工具会自动生成相应的代码。</p><p>具体的例子直接看文档大概能看的明白，当然也有一些实现的非常草率的地方，</p><p>1.无法动态修改数据，就只能重新创建一个一模一样的结构体，因为他自己生成的结构式是read only的，无法实现修改，感觉这个也是可以细想怎么优雅实现的。</p><p>2.没有加数据校验功能，后期策划在编写的时候会出现填错的情况。</p><p>3.excel表无法实现比较复杂的数据结构。</p><h1 id="JKFrame"><a href="#JKFrame" class="headerlink" title="JKFrame"></a>JKFrame</h1><p><a href="http://www.yfjoker.com/JKFrame/">JKFrame使用手册</a></p><p>本次09老师使用了JKFrame作为编程框架，使用起来比较方便，相当于多了一些库，直接用事件系统和ui系统都很方便，以后也可以多用这个框架尝试。</p><h1 id="六边形地图设计"><a href="#六边形地图设计" class="headerlink" title="六边形地图设计"></a>六边形地图设计</h1><p>六边形地图不能直接用二维坐标来表示，并且因为本次项目不需要动态生成，所以就直接在ui上硬编码了整个地图，感觉更加正常的做法是用tilemap，但是因为时间紧迫所以全部都用ui来做了，之后这里可以研究一下如何更优雅的实现这种六边形地图。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png" alt="坐标参考"></a></p><p>坐标参考</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png" alt="demo图"></a></p><p>demo图</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png" alt="最后的成品"></a></p><p>最后的成品</p><p><a href="https://www.redblobgames.com/grids/hexagons/">六边形地图理论基础</a></p><p><a href="https://indienova.com/u/npc233/blogread/11298">六边形地图坐标距离计算（直接看结论版）</a></p><p>计算距离，像这样的坐标体系，有x,y,z三个维度，x,y,z的和始终是0，我们称之为cube坐标，距离计算公式是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br><br>TS<br>diatance=<span class="hljs-built_in">max</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))<br><br>TS<br>func <span class="hljs-built_in">posDistance</span>(pos1,pos2):<br>    <span class="hljs-selector-tag">var</span> cubePos1=<span class="hljs-built_in">getCubePosFromPos</span>(pos1)<br>    <span class="hljs-selector-tag">var</span> cubePos2=<span class="hljs-built_in">getCubePosFromPos</span>(pos2)<br>    <span class="hljs-selector-tag">var</span> distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br>    return distance<br><br>CPP<br></code></pre></td></tr></table></figure><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这次项目作为一个ui游戏，简单的使用了MV框架，前期实现整体游戏循环的过程很快，到后面开始拼ui的时候其实有很大的沟通失误，缺少一个统筹规划工作量的人，来预估这个完成的时间。我自己心目中的完成时间点和实际的完全不一样，比如说地图，到了最后几天才分配给我做，我本以为是第二个周末就能完成的事情，我觉得09花了太多的时间来重构代码，并且重构之后也没经过测试，这个风险非常大，我个人认为应该先保证所有功能都完备了再进行重构的工作，不然卡在这里也无法进行下一步的推进。</p><p>其实这又是一个沟通问题，如果没有一个责任人站出来，那么我就会倾向于摆烂，并且祈祷或者默认其他人能完成，这就导致了我们最后ui和玩法上还有很多bug没修完，如果倒数第二个周末就有人站出来规划好预计的时间，或许最后交上去的结果会好很多。</p><h2 id="测试以及策划功能优先级问题"><a href="#测试以及策划功能优先级问题" class="headerlink" title="测试以及策划功能优先级问题"></a>测试以及策划功能优先级问题</h2><p>再来讲讲测试的问题，理想的情况是做完一个功能就马上有人来验收，并且这个人是知道所有的功能细节，这样是效率最高的测试方法，所以要么是程序自测，要么是策划验收，如果再找一个测试来验收就还需要和他沟通具体的细节。</p><p>但是中期出现的问题是，队伍策划需要干的事情实在<strong>太多了</strong>，既要设计玩法，还要调整数值，还要设计ui，还要验收功能。但是这些事情我认为应该是有优先级的，应该是要保证完成游戏完整性而服务，也就是设计ui和验收功能为更优先，因为这些都是会影响其他人的工作流的，一旦这个地方卡住了，其他人就要<strong>等待这里完成</strong>，会陷入到无事可干，并且必须要完成好最终确定的游戏，才能开始跑游戏测试数值。</p><p>而关于数值设计，既然我们已经分离开了数据和玩法，大可之后再根据测试的反馈来更改数值，数值设计应该也是需要有一套<strong>方法论</strong>的，这个是需要思考学习的。</p><h2 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h2><p>在前期的设计阶段，我总是觉得已有的玩法过于简单，能够一眼望穿，所以提出了很多想要增加策略性的建议，比如增加道具种类，地图增加走格子玩法，白天从三个动物变成牌组的形式，但其实最后做下来，看玩家的反馈已经足够复杂。我开始意识到我走入了一个非常大的误区，作为开发者，对于自己的游戏当然足够熟悉，所以总是会觉得过于简单，而失去了站在旁观者来审视游戏复杂度的能力，很容易把游戏玩法膨胀得很难。当然，这也和我前面提到的<strong>快速测试并且验证思路</strong>有关，总是因为我们没有快速验证的过程，所以会让我有这种恐慌。</p><h2 id="主题和音乐和美术"><a href="#主题和音乐和美术" class="headerlink" title="主题和音乐和美术"></a>主题和音乐和美术</h2><p>这次游戏的另一个教训是有关于游戏的其他方面，我总是太过于在于游戏机制的设计，但是忽略了其他人看中的部分，比如主题、美术和音乐的统一性，ui设计的合理性，还是提到的一点，每个人对于jam最终作品的想象不一样，我所追求的是一个好玩的东西。但是可能其他人更愿意的是一个完整的作品，一个从机制到主题到美术音乐统一并且完整的作品，那就必然牺牲一部分有趣度的考量，而</p><p>这点以后要改进的是，和别人一开始就要沟通清楚<strong>自己的愿景</strong>，这样才能共同朝着一个方向努力。</p><h1 id="获得的一些灵感"><a href="#获得的一些灵感" class="headerlink" title="获得的一些灵感"></a>获得的一些灵感</h1><p><strong>西西弗斯</strong><br>糯米团子，做一个自动放置小游戏，不过是翻山，讽刺一下西西弗这个意象。</p><p><strong>todolist直接改的模拟经营</strong><br>模拟经营，但是像babaisyou一样，目标是可以根据自己的东西来拖动的，比如需要10个肉直接变成需要10个草。</p><p><strong>放置挂机+自走棋</strong></p><p>白天放置挂机拿资源，晚上自走棋战斗，更加纯粹简单的快乐。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次作品的完整性还是相当高的，作为一个三周的作品美术音乐音效玩法都非常融洽，给自己朋友家人试玩也是相当开心，作为自己第一个完整度这么高的作品也是相当开心了。真的相当感谢队友们的付出，队友们都非常给力，性格也相当nice，沟通起来都非常舒服，感谢队友的配合，学到了很多，希望以后能再次合作。</p><h1 id="还需要研究的问题"><a href="#还需要研究的问题" class="headerlink" title="还需要研究的问题"></a>还需要研究的问题</h1><p>1.六边形地图如何优雅实现</p><p>2.导表的问题</p><p>3.学习数值设计方法论</p><p>4.如何导网页端游戏</p>]]></content>
    
    
    <summary type="html">2024下半年Booom参赛作品</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2025-11-04T16:15:02.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png" alt="image-20240901211645122"></a></p><p>image-20240901211645122</p><p>游戏玩法是1v3的不平衡对抗，每局游戏开始前每个人都会随机到一个关于自身能力的一个buff和一个debuff（比如跳跃次数增加和奔跑速度变慢），人类方的</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>这次比赛的主题是limited and limitless，所以我一开始想的是，给玩家可以自由调控自己的任何能力值，比如奔跑速度，跳跃高度，跳跃次数，冲刺距离……但是你加了一方面的buff，就要选择另一个其他的debuff，然后设计一系列的关卡，看你如何通过你的搭配来最快的过关。这个核心规则比较简单但是变化也相当多，不过被否定了，理由是1.在这种现场试玩做这种一次性的解密游戏很容易让游戏失去游戏性，因为别人看一次就知道怎么玩了，2.可能没有那么多时间来设计关卡。所以他们最后还是决定做一个party game。</p><h1 id="Corgi引擎"><a href="#Corgi引擎" class="headerlink" title="Corgi引擎"></a>Corgi引擎</h1><p><a href="https://corgi-engine-docs.moremountains.com/">corgi引擎文档</a></p><p>先说下corigi引擎的优点，有非常多已经实现的平台跳跃功能，包括丰富的平台，以及人物不同的能力（飞翔，滑翔背包，冲刺），这些都是以</p><h1 id="编码思路和组件思维"><a href="#编码思路和组件思维" class="headerlink" title="编码思路和组件思维"></a>编码思路和组件思维</h1><h1 id="水面shader"><a href="#水面shader" class="headerlink" title="水面shader"></a>水面shader</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png" alt="一开始的效果"></a></p><p>一开始的效果</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png" alt="加了水面shader的效果"></a></p><p>加了水面shader的效果</p><p>一开始的加一个镜面反射和流动水的效果，就好看许多</p><h1 id="测试暴露的问题"><a href="#测试暴露的问题" class="headerlink" title="测试暴露的问题"></a>测试暴露的问题</h1><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>最理想的情况是策划来进行这个关卡的设计，但因为这次的策划是一个比较新手的人，到了最后也没能成功下载unity，并且也没有任何设计关卡的经验，所以只能由我自己来拼一个关卡了。</p><p>我的设计思路是观看我最喜欢的partygame，move or die的一些地图，然后再摆出目前能实现的平台：长条，斜坡，弹跳蘑菇，下落方块，（和mod里面差的也就是一个传送门）当然corgi里面还实现了很多其他平台效果但是都因为我们缺少美术就没有做了，根据</p><h2 id="跳跃手感"><a href="#跳跃手感" class="headerlink" title="跳跃手感"></a>跳跃手感</h2><p>作为一个平台跳跃，跳跃手感是至关重要的，一个很重要的标准是，就算没有任何的关卡，没有任何的剧情，你只需要操控着你的角色跑一下挑一下，如果你觉得很畅快那就是一个好的手感，</p><p>关于手感有许多很好的视频，</p><p><a href="https://www.bilibili.com/video/BV1M441197sr/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【游戏制作工具箱】《蔚蓝》的手感为何迷人？</a></p><p><a href="https://www.bilibili.com/video/BV15C411r7Ju/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【GMTK|中英字幕】马里奥跳跃的秘密</a></p><p>事实上corgi游戏里面已经对跳跃的参数给了很多自由的参数，比如</p><h2 id="试玩的插曲"><a href="#试玩的插曲" class="headerlink" title="试玩的插曲"></a>试玩的插曲</h2><p>线下试玩非常有趣，遇到了一个非常精通平台跳跃的玩家，蔚蓝打通c面的那种，我和他1v1打了许久，一开始我想着让一下他，不要打消他的热情，但是再玩了几把之后我发现是他是真的很强，所以索性放开了跟他玩，但是他还是偶尔能赢，不过由于某些关卡设计和机制设计，让他随机到了只能跳一次就基本赢不了，所以我索性在给他开放了冲刺的功能，让他</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>corgi引擎</p><h2 id="体量"><a href="#体量" class="headerlink" title="体量"></a>体量</h2><p>人手还是不够，这次光是画好人物和boss就已经差不多了，关卡的布置只能自己来搞了，所以做的不是特别好。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计问题也有很多，比如一开始说到的只能四个人玩，导致在现场体验的时候很难凑到四个人，这点还是致命伤啊。</p>]]></content>
    
    
    <summary type="html">2024CigaGamejam</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
</feed>
