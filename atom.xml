<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R</title>
  
  
  <link href="https://rorschachandbat.github.io/atom.xml" rel="self"/>
  
  <link href="https://rorschachandbat.github.io/"/>
  <updated>2025-01-09T16:25:38.264Z</updated>
  <id>https://rorschachandbat.github.io/</id>
  
  <author>
    <name>R</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【UE官方培训】Sequence相关</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91Sequence%E7%9B%B8%E5%85%B3/</id>
    <published>2025-01-06T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.264Z</updated>
    
    <content type="html"><![CDATA[<p>动画</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107192455758.png"></p><p>MAYA导出FBX有许多需要注意的地方</p><p>模型的旋转，采样率</p><p>MAYA中起始帧需要是0</p><p>UE动画曲线默认是线性，MAYA是曲线，这个得改，不然时间数值对不上</p><p>如果不想改MAYA的这个曲线，就得增加UE的采样率（缺点是会增加内存）</p><p>UE动画数学是单精度浮点数，但是MAYA是双精度浮点数..</p><p>UE会自动压缩，可以关闭或者采用压缩破坏最小的选项</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107233622228.png"></p><p><strong>最佳实践</strong>总结如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234310586.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234405315.png"></p><p><strong>具体分类</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234511264.png"></p><p>Live Link插件</p><p>可以实时更新动画数据，达到所见即所得的工作体验。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107234724416.png"></p><p>Sequence其实就是时间和变量的对应，组织方式如下</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108093831342.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113220499.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113227088.png"></p><p>用场（levelSequence）、次（take）来管理不同的Sequence</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108113508355.png"></p><ul><li>长期存在的，总是会被镜头拍到的，比如建筑、地形（可理解为静态模型），这种最好是可控制对象绑定在Sequence里面，如果是一些特定时间在存在的，可以直接变成可生成对象。</li><li>毛发可以先预先浏览，再导入精确的</li><li>如何管理可见性：1.关卡可见性轨道 2.蓝图里面有函数和事件可以卸载和加载关卡，缺点是不够直观 3.世界分区，将整个关卡放在一个大的关卡，可以自动加载和卸载</li><li>白模和资产制作可以并行制作，因为资源都是引用，后期再替换就可以了</li><li><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250108115515103.png"></li></ul><p>如何用c++ Add Track？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加一个新的 Track</span><br><span class="hljs-function">FMovieSceneTrack* <span class="hljs-title">AddNewTrack</span><span class="hljs-params">(ULevelSequence* Sequence, UClass* TrackClass, FName TrackName)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取 MovieScene</span><br>    UMovieScene* MovieScene = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>();<br>    <br>    <span class="hljs-comment">// 创建新的 Track</span><br>    FMovieSceneTrackMetaData MetaData;<br>    MetaData.DisplayName = FText::<span class="hljs-built_in">FromName</span>(TrackName);<br>    <br>    FMovieSceneTrack* NewTrack = MovieScene-&gt;<span class="hljs-built_in">AddTrack</span>(TrackClass, MetaData);<br>    <br>    <span class="hljs-keyword">return</span> NewTrack;<br>&#125;<br><br><span class="hljs-comment">// 使用示例 - 添加一个 Transform Track</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformTrack</span><span class="hljs-params">(ULevelSequence* Sequence, AActor* TargetActor)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 确保序列和Actor都有效</span><br>    <span class="hljs-keyword">if</span> (!Sequence || !TargetActor)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Transform Track</span><br>    FMovieSceneTrack* TransformTrack = <span class="hljs-built_in">AddNewTrack</span>(<br>        Sequence, <br>        UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(),<br>        <span class="hljs-built_in">FName</span>(*FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;%s Transform&quot;</span>), *TargetActor-&gt;<span class="hljs-built_in">GetName</span>()))<br>    );<br><br>    <span class="hljs-comment">// 绑定 Actor</span><br>    FGuid ObjectBinding = Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddPossessable</span>(<br>        TargetActor-&gt;<span class="hljs-built_in">GetActorLabel</span>(), <br>        TargetActor-&gt;<span class="hljs-built_in">GetClass</span>()<br>    );<br>    <br>    <span class="hljs-comment">// 将 Track 添加到绑定对象</span><br>    Sequence-&gt;<span class="hljs-built_in">GetMovieScene</span>()-&gt;<span class="hljs-built_in">AddTrack</span>(UMovieScene3DTransformTrack::<span class="hljs-built_in">StaticClass</span>(), ObjectBinding);<br>&#125;<br></code></pre></td></tr></table></figure><p>常见的 Track 类型包括:</p><p>UMovieScene3DTransformTrack - 变换轨道</p><p>UMovieSceneFloatTrack - 浮点值轨道</p><p>UMovieSceneEventTrack - 事件轨道</p><p>UMovieSceneAudioTrack - 音频轨道</p><p>UMovieSceneCameraAnimTrack - 相机动画轨道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加关键帧示例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddTransformKeyframe</span><span class="hljs-params">(UMovieScene3DTransformTrack* TransformTrack, FFrameNumber TimeFrame, FTransform Transform)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (UMovieScene3DTransformSection* Section = <span class="hljs-built_in">Cast</span>&lt;UMovieScene3DTransformSection&gt;(TransformTrack-&gt;<span class="hljs-built_in">CreateNewSection</span>()))<br>    &#123;<br>        TransformTrack-&gt;<span class="hljs-built_in">AddSection</span>(*Section);<br>        Section-&gt;<span class="hljs-built_in">AddKey</span>(TimeFrame, Transform);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Sequence相关</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>【UE官方培训】UE渲染管线介绍</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90UE%E5%AE%98%E6%96%B9%E5%9F%B9%E8%AE%AD%E3%80%91UE%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-05T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.265Z</updated>
    
    <content type="html"><![CDATA[<p>【[官方培训]01-实时渲染基础上 | 陈拓 Epic】 <a href="https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">https://www.bilibili.com/video/BV1Tt4y1H7kQ/?share_source=copy_web&amp;vd_source=5d07d04eb2516df147034367e7af6fd2</a></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106223718712.png" alt="image-20250106223718712"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224045881.png" alt="image-20250106224045881"></p><h1 id="渲染前准备"><a href="#渲染前准备" class="headerlink" title="渲染前准备"></a>渲染前准备</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224513490.png" alt="image-20250106224513490"></p><p>会有多个线程在跑，游戏线程、渲染线程和GPU线程，这样流水线的走，如果比较理想，就是稳定30帧</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224728083.png" alt="image-20250106224728083"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224816969.png" alt="image-20250106224816969"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106224858383.png" alt="image-20250106224858383"></p><p><strong>距离</strong></p><p>距离阈值(Desired Max draw distance)</p><p>如果不想对每一个物体都设置这个距离，可以用Cull Distance Volume，包围的东西都会应用culling，可以设置size和distance，是一个数组，比如0-500size的东西应用一个culling，500-10000的又应用一个culling</p><p>如果想某些不被剔除可以用Never distance Cull，或者勾掉那个volume</p><p><strong>视锥</strong></p><p>这个很好理解，也就是在相机里面才会渲染</p><p>可以用FreezeRendering来跳出观察</p><p>ToggleDebugCamera</p><p><strong>预计算可见性</strong></p><p>Precomputed Visibility Volume</p><p>然后得编译一下，Compile-&gt;Precompute Static Visibility</p><p>要用这个得在Setting里面开启Precompute Visibility</p><p><strong>遮挡剔除</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106233936337.png" alt="image-20250106233936337"></p><h1 id="几何体渲染"><a href="#几何体渲染" class="headerlink" title="几何体渲染"></a>几何体渲染</h1><p>通过以上的步骤，可以拿到该被渲染的物体列表，但是如果直接渲染，会造成一些像素重复绘制，所以需要找出哪些模型应该先被渲染。</p><p>Early Z：GPU驱动会在执行像素着色器前先检查改点深度，提前跳过不符合条件的像素。为了利用这个特性，可以开启Prepass，提前把深度写入buffer里面，可以加快速度。</p><p>Drawcall：绘制拥有相同属性的一组多边形。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235242724.png" alt="image-20250106235242724"></p><p>不同的材质会不同的drawcall（*2是因为有earlyz）</p><p>切换材质影响性能开销，GPU渲染时，引擎会根据材质对物体进行排序，相同材质的会在同一个批次里绘制。</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250106235428006.png" alt="image-20250106235428006"></p><p>stat RHI命令可以查看drawcall数量</p><p>drawcall数量比三角形数量更影响性能。</p><p>引擎有一些基础的drawcall开销</p><p>降低drawcall方法：</p><p><strong>模型合并（Merge Actor）</strong>，但是有副作用：</p><p>遮挡检测性能更差（因为合批模型会变大）</p><p>计算碰撞性能更差（合并之后更大）</p><p>占用更大内存</p><p><strong>Modular Meshes</strong></p><p><strong>Instanceing</strong>（只针对相同模型 ）</p><p><strong>Level Of Detail(LOD)和HLOD</strong></p><p>降低模型面数</p><p>合并模型假如有多个材质还是会多个drawcaal，可以考虑合并材质</p><p>调试可以用Render Doc插件，来看详细的DrawCall信息</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000456448.png" alt="image-20250107000456448"></p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><h3 id="VertexShader"><a href="#VertexShader" class="headerlink" title="VertexShader"></a>VertexShader</h3><p>1.坐标转换（局部空间-&gt;世界空间-&gt;投影空间）</p><p>2.顶点着色</p><p>3.应用世界坐标偏移（WPO）：鸟、水体、飘动的草（<strong>顶点动画</strong>）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107000703048.png" alt="image-20250107000703048"></p><p>VS并不直接修改模型，只是视觉上的效果，CPU无法察觉VS的修改，所以物理和碰撞都不会发生变化。</p><p>动画越复杂、顶点越多性能越慢</p><p>对远距离的物体应该禁用顶点动画（反正也看不到）</p><p>对高精度的模型应该应用简单的VS</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001225370.png" alt="image-20250107001225370"></p><h1 id="光栅化和G-Buffer"><a href="#光栅化和G-Buffer" class="headerlink" title="光栅化和G-Buffer"></a>光栅化和G-Buffer</h1><p>经过这些之后，可以得到每个顶点在屏幕上的坐标</p><p>因为硬件问题，计算一个像素还需要计算周边2*2的像素，所以会造成overShading</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001502973.png" alt="image-20250107001502973"></p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107001803628.png" alt="image-20250107001803628"></p><p>因为法向是归一化，所以只需要知道两个就够了</p><p>采用mipmap，会让内存变大1.3倍（一直1&#x2F;4)，但是会清晰很多(远处的物体也能平均取到)</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002050255.png" alt="image-20250107002050255"></p><h1 id="像素着色器和材质"><a href="#像素着色器和材质" class="headerlink" title="像素着色器和材质"></a>像素着色器和材质</h1><p>Pixel shader，实现光照、雾这些效果</p><p>UE里面会有一个连线的材质器，然后会自动转成不同平台的shader语言嵌入进去</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107002941208.png" alt="image-20250107002941208"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>反射捕获</strong></p><p>Reflection Capture</p><p>cubemap，预先计算，但是不太准确，而且分辨率会影响反射效果</p><p><strong>屏幕空间反射</strong></p><p>默认开启，准确，有噪点，只会反射能看到的物体（根据G-Buffer算出来的）</p><p><strong>平面反射</strong></p><p>Planar Reflection</p><p>适合需要精确反射的表面（镜子）</p><p>其实就是相机换了一个位置，重新渲染了一遍，所以比较损耗性能，但是比较精确。</p><p>Lumen</p><p>RT Reflection</p><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093512026.png" alt="image-20250107093512026"></p><h2 id="静态光照"><a href="#静态光照" class="headerlink" title="静态光照"></a>静态光照</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093736129.png" alt="image-20250107093736129"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107093830617.png" alt="image-20250107093830617"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250107094207091.png" alt="image-20250107094207091"></p><p>UE里面生成lightmap用lightmass</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107100807363.png"></p><h2 id="动态光照"><a href="#动态光照" class="headerlink" title="动态光照"></a>动态光照</h2><h3 id="动态阴影"><a href="#动态阴影" class="headerlink" title="动态阴影"></a>动态阴影</h3><p><strong>常规动态阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107102137758.png"></p><p>以光的视角作为摄像机渲染，能看到的就会被点亮 </p><p>把需要渲染的物体在光源的矩阵下转换，然后计算深度，如果前面有东西挡住了，就说这里是阴影</p><p><strong>级联阴影</strong></p><p>因为普通的阴影只有一张map，级联阴影就是分隔了多个视锥，然后叠加</p><p><strong>逐对象阴影</strong></p><p>固定光源，对每个对象都生成阴影</p><p><strong>距离场阴影</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107170233535.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174700602.png"></p><h2 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h2><p>UE5全新的全局光照，有一些新特性</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107174936082.png"></p><p>Color Bleeding：物品本身颜色对周围光照的影响</p><p>Soft indirect shadow:间接软阴影，当前帧和前几帧的混合</p><h1 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h1><p>延迟渲染难以处理半透明材质，可以考虑在前向渲染管线渲染</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183709373.png"></p><h1 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107183752385.png"></p><p>自带的效果，Post Process Volume（可以设置为无限大）</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107184011328.png"></p><h1 id="实时Ray-Tracing"><a href="#实时Ray-Tracing" class="headerlink" title="实时Ray Tracing"></a>实时Ray Tracing</h1><h1 id="性能调试"><a href="#性能调试" class="headerlink" title="性能调试"></a>性能调试</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20250107185002691.png"></p>]]></content>
    
    
    <summary type="html">UE的渲染管线，比较概括</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Ts语法相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Ts%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-29T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TS基础写法"><a href="#TS基础写法" class="headerlink" title="TS基础写法"></a>TS基础写法</h1><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">PlayStateCheckHandle</span>: <span class="hljs-title class_">TimerHandle</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>|表示联合类型，表示既可以是TimerHandle也可以是undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Proto</span><span class="hljs-attr">_Nodes</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">IProto_NodeInfo</span> &#125;;<br></code></pre></td></tr></table></figure><p> 表示一个索引签名（index signature），用于定义一个对象类型，其中键（key）是字符串类型，而值（value）是 <code>Aki.Protocol.IProto_NodeInfo</code> 类型</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长参数</p><p>…args</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">first: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First argument is <span class="hljs-subst">$&#123;first&#125;</span>`</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);  <span class="hljs-comment">// 输出: First argument is 1, hello, world, !</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，函数内部创建的局部变量确实可以返回并在函数外部被直接修改，但这通常适用于可变类型（mutable types），如对象（包括 <code>Map</code>、<code>Set</code>、数组等）和函数。对于不可变类型（immutable types），如原始数据类型（数字、字符串、布尔值等），则不能直接修改。</p><p><strong>可变类型：</strong></p><p>当函数返回一个可变类型的值时，实际上返回的是这个值的引用（reference）。因此，通过这个引用所做的任何修改都会反映到原始对象上。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">复制function createObject() &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-keyword">prop</span>: 1 &#125;;<br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回对象的引用</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = createObject();<br>myObj.<span class="hljs-keyword">prop</span> = 2; <span class="hljs-comment">// 直接修改了 createObject 函数内部创建的对象</span><br>console.<span class="hljs-built_in">log</span>(myObj.<span class="hljs-keyword">prop</span>); <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><p>这个是因为看的时候看到一段对我来说比较吊诡的代码，在一个私有函数创建了一个map(nodes)，直接set到了另一个map(NodesGroupByStatus)里面，但是直接返回nodes，在另一个函数里面可以直接修改，后面查了才知道，ts如果返回maps这种可修改的变量相当于返回的是引用，所以就是改的原始的nodes</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">AddNodeGroup</span>(<span class="hljs-attr">group</span>: <span class="hljs-title class_">ENodeGroup</span>): <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt;();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">NodesGroupByStatus</span>!.<span class="hljs-title function_">set</span>(group, nodes);<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">AddNodeToStatusGroup</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TBehaviorNode</span>, <span class="hljs-attr">newStatus</span>: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">Proto_NodeStatus</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> groupId = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetGroupIdByStatus</span>(newStatus);<br>    <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetNodesByGroupId</span>(groupId);<br>    <span class="hljs-keyword">if</span> (!nodes) &#123;<br>        nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">AddNodeGroup</span>(groupId);<br>    &#125;<br><br>    nodes.<span class="hljs-title function_">set</span>(node.<span class="hljs-property">NodeId</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>继承extends</p><p><strong>super关键字</strong></p><ol><li><strong>调用父类构造函数</strong>：当你定义一个子类时，如果需要调用其父类的构造函数，可以使用 <code>super()</code>。这是必须的步骤，因为子类的实例在JavaScript&#x2F;TypeScript中总是通过父类的构造函数创建的。</li><li><strong>访问父类成员</strong>：<code>super</code> 也可以用来访问父类中定义的属性和方法，这在你想要扩展或重写父类成员时非常有用。</li><li><strong>访问父类的静态成员</strong>：使用 <code>super</code> 关键字，也可以访问父类的静态属性或方法</li><li><strong>在构造函数中</strong>：在构造函数中使用 <code>super</code> 必须作为第一条语句，因为子类实例的创建是基于父类构造函数的。</li><li><strong>在派生类的静态方法中</strong>：在静态方法中使用 <code>super</code> 来访问父类的静态成员。</li><li><strong>在派生类的方法中</strong>：在非静态方法中使用 <code>super</code> 来访问父类的非静态成员。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>1.基础泛型函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 不使用泛型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnString</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">returnNumber</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型</span><br><span class="hljs-keyword">function</span> returnItem&lt;T&gt;(<span class="hljs-attr">value</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> str = returnItem&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 类型为 string</span><br><span class="hljs-keyword">const</span> num = returnItem&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 类型为 number</span><br><span class="hljs-keyword">const</span> bool = <span class="hljs-title function_">returnItem</span>(<span class="hljs-literal">true</span>);            <span class="hljs-comment">// 类型推断为 boolean</span><br></code></pre></td></tr></table></figure><p>2.泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义一个泛型接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-attr">value</span>: T;<br>    <span class="hljs-title function_">getValue</span>(): T;<br>&#125;<br><br><span class="hljs-comment">// 实现泛型接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;<span class="hljs-built_in">number</span>&gt; &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> value: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">getValue</span>(): <span class="hljs-built_in">number</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> stringBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBox</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">const</span> numberBox = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberBox</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>3.泛型约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 使用extends关键字约束泛型类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">HasLength</span> &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> logLength&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HasLength</span>&gt;(<span class="hljs-attr">value</span>: T): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">// 可以使用的类型</span><br><span class="hljs-title function_">logLength</span>(<span class="hljs-string">&quot;Hello&quot;</span>);          <span class="hljs-comment">// 字符串有length属性</span><br><span class="hljs-title function_">logLength</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);       <span class="hljs-comment">// 数组有length属性</span><br><span class="hljs-title function_">logLength</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">10</span> &#125;);   <span class="hljs-comment">// 对象有length属性</span><br><br><span class="hljs-comment">// 会报错，因为number没有length属性</span><br><span class="hljs-comment">// logLength(42);  // Error</span><br></code></pre></td></tr></table></figure><p>4.多个类型参数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 键值对映射</span><br><span class="hljs-keyword">function</span> getPair&lt;K, V&gt;(<span class="hljs-attr">key</span>: K, <span class="hljs-attr">value</span>: V): &#123; <span class="hljs-attr">key</span>: K; <span class="hljs-attr">value</span>: V &#125; &#123;<br>    <span class="hljs-keyword">return</span> &#123; key, value &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> pair1 = getPair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-keyword">const</span> pair2 = <span class="hljs-title function_">getPair</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);  <span class="hljs-comment">// 类型推断</span><br></code></pre></td></tr></table></figure><p>5.泛型类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStorage</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: T[] = [];<br><br>    <span class="hljs-title function_">addItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">push</span>(item);<br>    &#125;<br><br>    <span class="hljs-title function_">removeItem</span>(<span class="hljs-params">item: T</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">indexOf</span>(item);<br>        <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">getItems</span>(): T[] &#123;<br>        <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">const</span> textStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">string</span>&gt;();<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>textStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [&quot;Hello&quot;, &quot;World&quot;]</span><br><br><span class="hljs-keyword">const</span> numberStorage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataStorage</span>&lt;<span class="hljs-built_in">number</span>&gt;();<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">10</span>);<br>numberStorage.<span class="hljs-title function_">addItem</span>(<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberStorage.<span class="hljs-title function_">getItems</span>());  <span class="hljs-comment">// [10, 20]</span><br></code></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>一开始看这个OnUpdate的时候非常懵逼</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">OnUpdate</span>(<span class="hljs-attr">newUpdate</span>: $Undefinable&lt;$Delegate&lt;<span class="hljs-function">(<span class="hljs-params">InProgress: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt;) : $Undefinable&lt;<span class="hljs-title class_">LTweener</span>&gt;;    <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnTick</span>(<span class="hljs-attr">deltaTime</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> tween = <span class="hljs-variable language_">this</span>.<span class="hljs-property">TextPlayTweenComp</span>!.<span class="hljs-title class_">GetPlayTween</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">LGUIPlayTween_Int</span>;<br>        <span class="hljs-keyword">const</span> tweener = tween?.<span class="hljs-title class_">GetTweener</span>();<br>        <span class="hljs-keyword">if</span> (tweener) &#123;<br>            tweener.<span class="hljs-title class_">OnUpdate</span>(<br>                <span class="hljs-title function_">toManualReleaseDelegate</span>((<span class="hljs-attr">progress</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">const</span> pro = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(progress * (tween.<span class="hljs-property">to</span> - tween.<span class="hljs-property">from</span>)) + tween.<span class="hljs-property">from</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> &lt; pro) &#123;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> = pro;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Text</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span>));<br>                    &#125;<br>                &#125;),<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>类型断言，有点类似其他语言的类型转换，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>const id &#x3D; a ? b : c;</p><p>条件 ? 表达式1 : 表达式2</p><ul><li>如果 <code>条件</code>（在这里是变量 <code>a</code>）为真（truthy），那么整个表达式的结果是 <code>表达式1</code>（在这里是变量 <code>b</code>）。</li><li>如果 <code>条件</code> 为假（falsy），那么结果是 <code>表达式2</code>（在这里是变量 <code>c</code>）。</li></ul><h3 id="x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</h3><ol><li><strong>严格等于 (<code>===</code>)</strong>:<ul><li><code>===</code> 是严格等于运算符，它比较两个值是否完全相等，包括它们的类型。</li><li>如果两个操作数的类型不同，<code>===</code> 返回 <code>false</code>。</li><li>只有当两个操作数的类型和值都相同时，<code>===</code> 才返回 <code>true</code>。</li></ul></li><li><strong>等于 (<code>==</code>)</strong>:<ul><li><code>==</code> 是等于运算符，它比较两个值是否等价。</li><li>如果操作数的类型不同，JavaScript 会进行类型转换，然后再比较它们的值。</li><li><code>==</code> 会根据需要将操作数转换为数字或字符串，然后进行比较。</li></ul></li><li>!&#x3D;&#x3D;</li></ol><p>​不相等，但是不会进行类型转换</p><h3 id="和"><a href="#和" class="headerlink" title="?.和!."></a>?.和!.</h3><p><code>!</code> 被称为非空断言操作符，它用来告诉 TypeScript 编译器，某个位置的值不应该为 <code>null</code> 或 <code>undefined</code>。</p><p>?.是一种语法糖， 如果多层访问中间有null或者undefined就会返回undefined，不用自己再另写类型检查</p><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>表示调用这个对象或者参数的时候这个参数可选</p><h3 id="-1"><a href="#-1" class="headerlink" title="??"></a>??</h3><p>逻辑运算符，用于返回两个操作数中第一个非空值（non-nullish value），或者在两个操作数都为空值（null 或 undefined）时返回右侧的操作数。</p><h1 id="UE4容器使用"><a href="#UE4容器使用" class="headerlink" title="UE4容器使用"></a>UE4容器使用</h1><h2 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/">TArray：虚幻引擎中的数组 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h3 id="创建和填充"><a href="#创建和填充" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建</span><br>TArray&lt;int32&gt; IntArray;<br><br><span class="hljs-comment">// 填充</span><br>IntArray.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 等价于下面</span><br><span class="hljs-comment">// IntArray = [10, 10, 10, 10, 10]</span><br><br><span class="hljs-comment">// 在末尾增加用Add或者Emplace</span><br><span class="hljs-comment">// Add会创建一个新实例，Emplace不会</span><br><br>TArray&lt;FString&gt; StrArr;<br>StrArr.<span class="hljs-built_in">Add</span>    (<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>StrArr.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;]</span><br><br><span class="hljs-comment">// 利用 Append 可一次性添加其他 TArray 中的多个元素</span><br><br>FString Arr[] = &#123; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;of&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Tomorrow&quot;</span>) &#125;;<br>StrArr.<span class="hljs-built_in">Append</span>(Arr, <span class="hljs-built_in">ARRAY_COUNT</span>(Arr));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;]</span><br><br><span class="hljs-comment">// 仅在尚不存在等值元素时， AddUnique 才会向容器添加新元素。</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;,&quot;!&quot;]</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr is unchanged as &quot;!&quot; is already an element</span><br><br><span class="hljs-comment">// Insert</span><br><br>StrArr.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Brave&quot;</span>), <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// SetNum,如新数量大于当前数量，则使用元素类型的默认构造函数新建元素</span><br><span class="hljs-comment">// 如新数量小于当前数量， SetNum 将移除元素。</span><br><br><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ranged-for</span><br>FString JoinedStr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; Str :StrArr)<br>&#123;<br>    JoinedStr+=Str;<br>&#125;<br><br><span class="hljs-comment">// 直接for循环</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index != StrArr.<span class="hljs-built_in">Num</span>(); ++Index)<br>&#123;<br>    JoinedStr += StrArr[Index];<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 数组迭代器:CreateIterator读写；CreateConstIterator只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> It = StrArr.<span class="hljs-built_in">CreateConstIterator</span>();It;++It)<br>&#123;<br>    JoinedStr += *It;<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Sort，基于快排</span><br><span class="hljs-comment">// HeapSort，堆排序</span><br><span class="hljs-comment">// StableSort，基于归并排序，可以保证等值元素的相对顺序，上面两个无法保证</span><br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Num，查询数量</span><br><br><span class="hljs-comment">// GetData,返回指针元素</span><br><br><span class="hljs-comment">// Contains，查询是否包含特定元素</span><br><br><span class="hljs-comment">// ContainsByPredicate,可自己写规则</span><br><br><span class="hljs-type">bool</span> bHello   = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-type">bool</span> bGoodbye = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>));<br><span class="hljs-comment">// bHello   == true</span><br><span class="hljs-comment">// bGoodbye == false</span><br><br><span class="hljs-type">bool</span> bLen5 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">5</span>;<br>&#125;);<br><span class="hljs-type">bool</span> bLen6 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">6</span>;<br>&#125;);<br><span class="hljs-comment">// bLen5 == true</span><br><span class="hljs-comment">// bLen6 == false</span><br><br><span class="hljs-comment">// Find，返回找到的第一个元素的索引</span><br><span class="hljs-comment">// FindLast,范围找到的最后一个元素的索引</span><br>int32 IndexLast;<br><span class="hljs-keyword">if</span> (StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>), IndexLast))<br>&#123;<br>    <span class="hljs-comment">// IndexLast == 3, because there aren&#x27;t any duplicates</span><br>&#125;<br><br><span class="hljs-comment">// 上面时返回布尔值，也可以直接返回索引，未找到时INDEX_NONE</span><br>int32 Index2     = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexLast2 = StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexNone  = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><span class="hljs-comment">// Index2     == 3</span><br><span class="hljs-comment">// IndexLast2 == 3</span><br><span class="hljs-comment">// IndexNone  == INDEX_NONE</span><br><br><span class="hljs-comment">// IndexOfByKey</span><br><span class="hljs-comment">// IndexOfByPredicate</span><br><br><span class="hljs-comment">// FilterByPredicate可以直接找到匹配的元素数组</span><br><span class="hljs-keyword">auto</span> Filter = StrArray.<span class="hljs-built_in">FilterByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> !Str.<span class="hljs-built_in">IsEmpty</span>() &amp;&amp; Str[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&#x27;M&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除所有提供元素等值的元素</span><br><span class="hljs-comment">// RemoveSingle,移除首个匹配元素</span><br><span class="hljs-comment">// RemoveAt，移除特定位置元素</span><br><span class="hljs-comment">// RemoveAll,可以自己定义规则</span><br><br><br><span class="hljs-comment">// 如果不需要保证排序，可以用下面的来加快速度</span><br><span class="hljs-comment">// RemoveSwap,RemoveAtSwap,RemoveAllSwap</span><br><br><span class="hljs-comment">// Empty 清空</span><br></code></pre></td></tr></table></figure><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// +=，串联</span><br><br><span class="hljs-comment">// MoveTemp，移动语义，清空源数组</span><br>ValArr3 = <span class="hljs-built_in">MoveTemp</span>(ValArr4);<br><span class="hljs-comment">// ValArr3 == [5,2,3,1,2,3]</span><br><span class="hljs-comment">// ValArr4 == []</span><br><br><span class="hljs-comment">// == 和 != 进行比较，必须排序和数量都一样</span><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h2 id="TMap"><a href="#TMap" class="headerlink" title="TMap"></a>TMap</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">TMap | 虚幻引擎4.27文档 (unrealengine.com)</a></p><p>TMap键不能重复，TMultiMap键不唯一</p><h3 id="创建和填充-1"><a href="#创建和填充-1" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TMap&lt;int32, FString&gt; FruiMap;<br><br><span class="hljs-comment">// 填充都一样，但是要是填重复的键会覆盖之前的值</span><br><br></code></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>类似TArrays，不过迭代元素是TPair</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains来查询是否包含特定键</span><br><br><span class="hljs-comment">// Find，失败返回null</span><br><br><span class="hljs-comment">// FindOrAdd，不存在该键会新创建一个元素</span><br><br><span class="hljs-comment">// FindRef，没找到会返回默认值，不会创建新元素</span><br><br>FString&amp; Ref7 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// Ref7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;</span><br><span class="hljs-comment">// ]</span><br>FString&amp; Ref8 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// Ref8     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br>FString Val7 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">7</span>);<br>FString Val6 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// Val7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// Val6     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// FindKey，按值查找</span><br></code></pre></td></tr></table></figure><h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除对应键的元素</span><br>FruitMap.<span class="hljs-built_in">Remove</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// FindAndRemoveChecked，移除元素并返回该值</span><br>FString Removed7 = FruitMap.<span class="hljs-built_in">FindAndRemoveChecked</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// RemoveAndCopyValue 函数的作用与 Remove 相似，不同点是会将已移除元素的值复制到引用参数</span><br>FString Removed;<br><span class="hljs-type">bool</span> bFound2 = FruitMap.<span class="hljs-built_in">RemoveAndCopyValue</span>(<span class="hljs-number">2</span>, Removed);<br><br><span class="hljs-comment">// Empty和Reset，清空</span><br></code></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KeySort或者ValueSort</span><br>FruitMap.<span class="hljs-built_in">KeySort</span>([](int32 A, int32 B) &#123;<br>    <span class="hljs-keyword">return</span> A &gt; B; <span class="hljs-comment">// sort keys in reverse</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h3><p>有复制和移动语义</p><h3 id="Slack-1"><a href="#Slack-1" class="headerlink" title="Slack"></a>Slack</h3><h3 id="KeyFuncs"><a href="#KeyFuncs" class="headerlink" title="KeyFuncs"></a>KeyFuncs</h3><h2 id="TSet"><a href="#TSet" class="headerlink" title="TSet"></a>TSet</h2><h1 id="UE4回调"><a href="#UE4回调" class="headerlink" title="UE4回调"></a>UE4回调</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/">委托 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate - 知乎 (zhihu.com)</a></p><p>UE支持三种委托：单点委托，组播委托（事件），动态委托</p><h3 id="单点委托"><a href="#单点委托" class="headerlink" title="单点委托"></a>单点委托</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><h3 id="动态委托"><a href="#动态委托" class="headerlink" title="动态委托"></a>动态委托</h3><h1 id="UE4对象函数"><a href="#UE4对象函数" class="headerlink" title="UE4对象函数"></a>UE4对象函数</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Functions/">UFunctions | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h1 id="UE4引用"><a href="#UE4引用" class="headerlink" title="UE4引用"></a>UE4引用</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/ReferencingAssets/">引用资源 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/ReferenceAssets/">引用 Actor | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnLhvL7EdoiVzOhE8P2cjTCh">UE引用类型说明 - 飞书云文档 (feishu.cn)</a></p><p>引用分为两种，硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载；软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。</p><p>一种是通过UPROPERTY</p><p><strong>直接属性引用</strong></p><p>通过设置变量的UPROPERTY直接在编辑器设置对应资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** construction start sound stinger */</span><br><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Building)<br><br>USoundCue* ConstructionStartStinger;<br></code></pre></td></tr></table></figure><p><strong>构造时引用</strong></p><p>构造时加载对应资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/** gray health bar texture */</span><br><br><span class="hljs-constructor">UPROPERTY()</span><br><br><span class="hljs-keyword">class</span> UTexture2D* BarFillTexture;<br><br>AStrategyHUD::<span class="hljs-constructor">AStrategyHUD(<span class="hljs-params">const</span> FObjectInitializer&amp; ObjectInitializer)</span> :<br>    <span class="hljs-constructor">Super(ObjectInitializer)</span><br>&#123;<br>    static ConstructorHelpers::FObjectFinder&lt;UTexture2D&gt; <span class="hljs-constructor">BarFillObj(TEXT(<span class="hljs-string">&quot;/Game/UI/HUD/BarFill&quot;</span>)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>BarFillTexture = BarFillObj.Object;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>一种是用字符串来引用，如果UObject已经加载就用FindObject&lt;&gt;()，没有加载就使用LoadObject&lt;&gt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AFunctionalTest* TestToRun = <span class="hljs-built_in">FindObject</span>&lt;AFunctionalTest&gt;(TestsOuter, *TestName);<br>GridTexture = <span class="hljs-built_in">LoadObject</span>&lt;UTexture2D&gt;(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/EngineMaterials/DefaultWhiteGrid.DefaultWhiteGrid&quot;</span>), <span class="hljs-literal">NULL</span>, LOAD_None, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h1 id="UE4FName"><a href="#UE4FName" class="headerlink" title="UE4FName"></a>UE4FName</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/">FName | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p>在 <strong>内容浏览器</strong> 中为新资源命名时，变更动态材质实例中的参数或访问骨骼网格体中的一块骨骼时需要使用 <strong>FNames</strong> 。 FName 通过一个轻型系统使用字符串。在此系统中，特定字符串即使会被重复使用，在数据表中也只存储一次。</p><p>FNames 不区分大小写。它们为不可变，无法被操作。FNames 的存储系统和静态特性决定了通过键进行 FNames 的查找和访问速度较快。 FName 子系统的另一个功能是使用散列表为 FName 转换提供快速字符串。</p><p>FNames 不区分大小写，作为索引组合存储在唯一字符串和实例编号的表格中。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName TestName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Test&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FMame到FString</span><br>TestString = TestName.<span class="hljs-built_in">ToSring</span>();<br><br><span class="hljs-comment">// FName到FText</span><br>TestText = FText::<span class="hljs-built_in">FromName</span>(TestName);<br><br><span class="hljs-comment">// Fstring和FText到Fname都不可靠，因为FName不区分大小写</span><br><br><span class="hljs-comment">// FString到FName</span><br>TestName = <span class="hljs-built_in">FName</span>(*TextString);<br><br><span class="hljs-comment">// FText无法直接到FName</span><br></code></pre></td></tr></table></figure><p>对比是否相同直接比较索引的数值，不用执行字符串的对比</p><h1 id="TS和Lua有什么区别"><a href="#TS和Lua有什么区别" class="headerlink" title="TS和Lua有什么区别"></a>TS和Lua有什么区别</h1><h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><p>优点：</p><p>1.静态类型系统</p><ul><li><p>在编译时进行类型检查</p></li><li><p>可以提前发现潜在错误</p></li><li><p>提供更好的代码提示和自动完成</p></li></ul><p>2.面向对象特性</p><ul><li><p>支持类、接口、泛型等现代OOP特性</p></li><li><p>继承和多态的实现更加完整</p></li></ul><p>3.JavaScript生态系统</p><ul><li><p>可以直接使用JavaScript的所有库和框架</p></li><li><p>与现代前端开发工具链完美集成</p></li><li><p>庞大的npm生态系统</p></li></ul><p>4.工具支持</p><ul><li><p>优秀的IDE支持（VS Code等）</p></li><li><p>强大的重构工具</p></li><li><p>详细的文档和类型定义</p></li></ul><p>缺点：</p><p>1.编译开销</p><ul><li><p>需要编译成JavaScript才能运行</p></li><li><p>构建过程可能较慢</p></li></ul><p>2.学习曲线</p><ul><li><p>类型系统较复杂</p></li><li><p>需要理解装饰器、泛型等概念</p></li></ul><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>1.轻量级</p><ul><li><p>解释器小巧（约200KB）</p></li><li><p>启动快速，内存占用少</p></li><li><p>易于嵌入其他程序</p></li></ul><p>2.性能</p><ul><li><p>LuaJIT提供极高的执行效率</p></li><li><p>垃圾回收效率高</p></li></ul><p>3.简单易学</p><ul><li><p>语法简洁清晰</p></li><li><p>核心概念少</p></li><li><p>学习曲线平缓</p></li></ul><p>4.嵌入性</p><ul><li><p>广泛用于游戏开发</p></li><li><p>适合作为脚本语言嵌入应用</p></li><li><p>容易与C&#x2F;C++集成</p></li></ul><p>缺点：</p><p>1.标准库较小</p><ul><li><p>内置功能相对有限</p></li><li><p>需要依赖第三方库实现复杂功能</p></li></ul><p>2.生态系统</p><ul><li><p>相比现代语言，生态系统较小</p></li><li><p>工具链不如主流语言完善</p></li></ul><p>3.面向对象支持</p><ul><li><p>没有原生的类支持</p></li><li><p>需要通过元表模拟OOP特性</p></li></ul><h1 id="不同类型变量"><a href="#不同类型变量" class="headerlink" title="不同类型变量"></a>不同类型变量</h1><p>值类型（按值传递）：</p><p>number</p><p>string</p><p>boolean</p><p>undefined</p><p>null</p><p>symbol</p><p>引用类型（按引用传递）：</p><p>Object</p><p>Array</p><p>Function</p><p>Date</p><p>RegExp</p><p>Map</p><p>Set</p><p>类实例</p>]]></content>
    
    
    <summary type="html">Ts的一些语法</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua的闭包</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E7%9A%84%E9%97%AD%E5%8C%85/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.083Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/358423900">构建Lua解释器Part11：Upvalue - Manistein的文章 - 知乎</a></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-number">10</span>  <span class="hljs-comment">-- x是一个局部变量</span><br>    <br>    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment">-- x在这里就是一个upvalue</span><br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-keyword">return</span> inner<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> fn = outer()<br>fn()  <span class="hljs-comment">-- 输出10</span><br></code></pre></td></tr></table></figure><ol><li><p>x 是 outer 函数的局部变量，inner 函数引用了 x</p></li><li><p>x 对于 inner 来说就是一个 upvalue</p></li><li><p>Lua 会特殊处理这个 x，使其在 outer 函数结束后仍然存活</p></li></ol>]]></content>
    
    
    <summary type="html">lua中闭包的使用</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-unity多线程原理相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-unity%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-24T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity协程（Coroutine）原理详解"><a href="#Unity协程（Coroutine）原理详解" class="headerlink" title="Unity协程（Coroutine）原理详解"></a>Unity协程（Coroutine）原理详解</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p>协程本质上是一个迭代器（Iterator），它利用了C#的迭代器模式和yield关键字。它不是真正的多线程，而是一种特殊的程序执行方式。</p><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><p>1.暂停和恢复</p><ul><li><p>当遇到yield语句时，协程会保存当前的执行状态</p></li><li><p>将控制权返回给Unity的主循环</p></li><li><p>在适当的时机恢复执行</p></li></ul><p>2.状态机</p><ul><li><p>编译器会将协程方法转换为一个状态机</p></li><li><p>每个yield语句对应一个状态</p></li><li><p>恢复执行时从上次的状态继续</p></li></ul><h2 id="2-执行时机"><a href="#2-执行时机" class="headerlink" title="2. 执行时机"></a>2. 执行时机</h2><p>Unity的执行循环：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Update循环：<br><span class="hljs-number">1.</span> Input Events<br><span class="hljs-number">2.</span> Update()<br><span class="hljs-number">3.</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> 的协程<br><span class="hljs-number">4.</span> <span class="hljs-function">Late <span class="hljs-title">Update</span>()</span><br><span class="hljs-function">5. 渲染</span><br></code></pre></td></tr></table></figure><p>不同yield指令的执行时机：</p><ul><li><p>yield return null - 下一帧Update之前</p></li><li><p>yield return new WaitForFixedUpdate() - 下一次物理更新时</p></li><li><p>yield return new WaitForEndOfFrame() - 当前帧渲染完成后</p></li><li><p>yield return new WaitForSeconds() - 基于Time.time计时</p></li></ul><h2 id="3-内部实现机制"><a href="#3-内部实现机制" class="headerlink" title="3. 内部实现机制"></a>3. 内部实现机制</h2><h3 id="状态机转换"><a href="#状态机转换" class="headerlink" title="状态机转换"></a>状态机转换</h3><p>当你写一个协程时：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">MyCoroutine</span>()</span> <br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会这样转换成类似的状态机</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-title">MyCoroutine</span>&gt;<span class="hljs-title">d__1</span> : <span class="hljs-title">IEnumerator</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">object</span> current;<br>    <br>    <span class="hljs-keyword">public</span> &lt;MyCoroutine&gt;d__1(<span class="hljs-built_in">int</span> state) <br>    &#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span> <br>    &#123;<br>        <span class="hljs-keyword">switch</span> (state) <br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                Debug.Log(<span class="hljs-string">&quot;Start&quot;</span>);<br>                current = <span class="hljs-keyword">new</span> WaitForSeconds(<span class="hljs-number">1f</span>);<br>                state = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Debug.Log(<span class="hljs-string">&quot;End&quot;</span>);<br>                state = <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-literal">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current <br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> current; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4. 内存管理"></a>4. 内存管理</h2><h3 id="协程的内存分配："><a href="#协程的内存分配：" class="headerlink" title="协程的内存分配："></a>协程的内存分配：</h3><p>1.状态机对象</p><ul><li><p>每次启动协程时创建</p></li><li><p>包含局部变量和执行状态</p></li></ul><p>2.YieldInstruction对象</p><ul><li><p>每个yield return语句可能创建新对象</p></li><li><p>可以通过缓存减少分配</p></li></ul><h3 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h3><p>1.创建：StartCoroutine调用时</p><p>2.运行：Unity主循环中调度</p><p>3.销毁：</p><ul><li><p>协程完成时</p></li><li><p>手动停止时</p></li><li><p>MonoBehaviour禁用时</p></li></ul><h2 id="5-调度机制"><a href="#5-调度机制" class="headerlink" title="5. 调度机制"></a>5. 调度机制</h2><p>Unity的协程调度器：</p><p>1.维护一个活动协程列表</p><p>2.每帧检查需要执行的协程</p><p>3.根据YieldInstruction类型决定执行时机</p><p>4.调用MoveNext()推进协程状态</p><h3 id="优先级："><a href="#优先级：" class="headerlink" title="优先级："></a>优先级：</h3><p>1.Update前的协程</p><p>2.Update</p><p>3.Update后的协程</p><p>4.LateUpdate</p><p>5.帧结束时的协程</p><h2 id="6-限制和注意事项"><a href="#6-限制和注意事项" class="headerlink" title="6. 限制和注意事项"></a>6. 限制和注意事项</h2><h3 id="技术限制："><a href="#技术限制：" class="headerlink" title="技术限制："></a>技术限制：</h3><p>1.单线程执行</p><ul><li><p>所有协程在主线程运行</p></li><li><p>不能进行真正的并行处理</p></li></ul><p>2.状态保存</p><ul><li><p>只能保存基本的执行状态</p></li><li><p>不保存完整的调用栈</p></li></ul><p>3.异常处理</p><ul><li><p>try-catch块跨越yield语句时可能失效</p></li><li><p>需要特殊的错误处理机制</p></li></ul><h3 id="性能考虑："><a href="#性能考虑：" class="headerlink" title="性能考虑："></a>性能考虑：</h3><p>1.内存开销</p><ul><li><p>每个活动协程占用内存</p></li><li><p>yield指令可能产生垃圾回收</p></li></ul><p>2.CPU开销</p><ul><li><p>协程调度有额外开销</p></li><li><p>过多活动协程会影响性能</p></li></ul><h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>1.适合用协程的情况：</p><ul><li><p>需要随时间推移的操作</p></li><li><p>等待特定条件</p></li><li><p>分帧执行大量工作</p></li></ul><p>2.不适合用协程的情况：</p><ul><li><p>CPU密集型计算</p></li><li><p>需要真正并行的操作</p></li><li><p>关键性能代码</p></li></ul><h3 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h3><p>1.重用YieldInstruction对象</p><p>2.适当分批处理</p><p>3.及时清理不需要的协程</p><p>4.避免过多嵌套</p><p>理解协程的这些原理，可以帮助我们更好地使用它，避免常见陷阱，并在适当的场景选择它作为解决方案。</p>]]></content>
    
    
    <summary type="html">面经-unity多线程原理相关</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>动作游戏的方方面面</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:39.513Z</updated>
    
    <content type="html"><![CDATA[<p>动作游戏系统设计</p><p>镜头选型，运动系统，输入模块，战斗能力。</p><h1 id="战斗系统？"><a href="#战斗系统？" class="headerlink" title="战斗系统？"></a>战斗系统？</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>好的攻击方式应该兼具优点和缺点，比如范围大那么久伤害低，伤害高但是攻速慢，或者需要某些特定的资源，或者具有冷却时间</p><p>攻速其实是动画的帧动画</p><p>前摇，判定和后摇</p><p>动画取消</p><p>范围：吸附的范围</p><p>不同的按键组合是不同的攻击方式，当然也可以是和位置不同而变化，比如背刺之类的。</p><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><p>一定顺序，准确时机可以打出不同的连招</p><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><p>防御或者闪避</p><p>弹反和招架：有可能过于强大，让整个游戏都变成了等待</p><p>可以增加弹反惩罚，或者限制弹反次数，或者降低弹反收益：比如只是单纯地给一点子弹时间。</p><p>当然你也要防止你的玩家完全不防御，防止让他一直压制敌人，比如给怪加体力条，体力条没了才能僵直，或者让他面对很多个怪物。</p><p>好的动作游戏，应该鼓励玩家在攻击和防守之间积极地变换。</p><h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><p>敌人的进攻应该有明显的提示，比如画面之类的。</p><p>并且最好不要设计成单一武器才能杀死的敌人 </p><p>如何鼓励玩家进攻多样而不是复读？</p><p>连击有特殊动画，或者直接设计连击分数（比如鬼泣或者猎天使魔女），还有受伤掉分</p><p>如果程序检测到玩家复读某一招，可以相对应地用表现得不一样，这些可以给玩家他适应了你的打法一样（街霸的ai也有类似的感觉，可以学习）</p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>巨大的前摇+飞速的打击动作+判定帧短暂的暂停+后摇缓慢的回复</p><p>刀光特效</p><p>震动屏幕</p><p>爽快的音效</p><h1 id="打击感-1"><a href="#打击感-1" class="headerlink" title="打击感"></a>打击感</h1><p><a href="https://www.bilibili.com/video/BV1g741157RC/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【暖风游戏厅】打击感是如何炼成的</a> </p><p>攻击角色击中被击角色的瞬间，游戏给玩家的反馈所形成的的体验。</p><p>打击感是击中的瞬间，手感是玩家输入的瞬间</p><p>被击动作、特效、静止帧、音效和振动</p><h2 id="被击动作"><a href="#被击动作" class="headerlink" title="被击动作"></a>被击动作</h2><p>首先是攻击动作和被击动作要匹配，方向和力度。</p><p>被击动作需要播放地够快。</p><p>如果是一个很大的boss，可以考虑做局部肢体的抖动。对骨骼施加物理力，然后和动作进行融合，这样做不会让被击方停止动作，一举两得。</p><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><p>最重要的功能是告诉玩家自己的攻击击中了，必须及时，准确和明显。</p><p>两种比较常见的，爆炸和飙血。前者是拳脚或者钝器（街霸），后者是利器（血缘）</p><h2 id="静止帧"><a href="#静止帧" class="headerlink" title="静止帧"></a>静止帧</h2><p>用来模拟现实打击中的顿滞感，拳头和钝器会慢一点，利器会快一点。也和敌人属性有关，比如穿了厚重的铠甲就会慢一点，破衣服就快一点。</p><p>全局或者局部</p><p>全局是整个游戏都暂停，局部是只用双方暂停。</p><p>战神利用了ik（反向动力学）来制作静止帧，斧子在击中敌人的一瞬间会卡肉，然后手臂会继续运动，直到一定程度才会完成打击动作。</p><h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><p>依旧是合适和及时，不同属性不同力度要对应。</p><h2 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h2><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>打击感是一瞬间的信息和力度，要专注这一瞬间的反馈。</p><p>命中</p><p>信息：信息要准确，丰富有层次</p><p>强度：强度要有对比，要有层次和疏密，最重要的是符合直觉</p><p>连招开启的卡肉，就像街霸里的确认一样，用来告诉你你可以开始爽快的连招了</p><p>第一法则：“0延迟”的即时反馈 </p><p>第二法则：制造预期，让玩家有所期待 </p><p>第三法则：符合预期，回应玩家的期待 </p><p>第四法则：简洁：明了清晰，弱化不必要的 </p><p>第五法则：夸张：强化重要的 </p><p>第六法则：回味：让玩家有时间和机会回味，延长令玩家愉悦的感觉 </p><p>第七法则：拟真：真实感的模拟（如果你不知道从什么地方开始，那么就向大自然和实际生活学习）</p><h1 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h1><p>重点是解决一下三个问题：</p><p><strong>如何让玩家探索战胜敌人的方式？</strong></p><p>敌人的形象设计；攻击提示；仇恨范围；攻击欲望；连招系统；战斗策略；指令输入；能力限制一级敌我对等程度；对峙突围能力……</p><p><strong>如何让玩家不断磨练自己的技术</strong></p><p>角色的成长策略；获胜的条件；游戏综合速度；不同情绪切换；基础物理法则；战场结构；纵向层次；角色能力提升曲线与自我技术革新……</p><p><strong>如何让玩家不会轻易放弃？</strong></p><p>游戏的核心挑战；次要挑战；游戏整体难度；死亡机制与死亡惩罚；角色的容错率；玩家的学习曲线；玩家操纵角色的综合能力……</p><h1 id="难度曲线"><a href="#难度曲线" class="headerlink" title="难度曲线"></a>难度曲线</h1><p>确保每一种类型的玩家都有自己的乐趣所在，初学者，玩家和大师</p><h1 id="进阶循环"><a href="#进阶循环" class="headerlink" title="进阶循环"></a>进阶循环</h1><h1 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h1><p><strong>Camera</strong></p><p>第三人称、第一人称、越肩（战神）、俯视角、横版</p><p><strong>Character</strong></p><p>移动方式和相机要相关，越肩就是要固定方向，第三人称的话可以转头，但是也可以锁定怪物</p><p><strong>Control</strong></p><h1 id="动作切换系统"><a href="#动作切换系统" class="headerlink" title="动作切换系统"></a>动作切换系统</h1><p><a href="https://zhuanlan.zhihu.com/p/663335854">动作游戏中的动作切换系统这么做就对了 - 猴与花果山的文章 - 知乎</a></p><h1 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Frame</span>&#123;<br><span class="hljs-keyword">public</span> frameId:<span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">public</span> clips:Array&lt;Clip&gt;; <span class="hljs-comment">//每一帧依然会是多个clip</span><br><span class="hljs-keyword">public</span> hitBox:Array&lt;Rect&gt;;<span class="hljs-comment">//碰撞框，动作游戏会有进攻、挨揍、防御等碰撞框，当然很可能都是空数组，比如角色死了的时候</span><br><br><span class="hljs-comment">//在这一帧，哪些frameId的动作可以成为下一帧cancel掉这个动作</span><br><span class="hljs-comment">//比如街霸的重拳接升龙，他不是等重拳全放完了，然后升龙从头来叫重拳接升龙</span><br><span class="hljs-comment">//而是从重拳的第x帧之后，直接切换到升龙的第y帧开始继续</span><br><span class="hljs-keyword">public</span> cancelableAction:Array&lt;<span class="hljs-built_in">string</span>&gt;; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="连招系统代码设计"><a href="#连招系统代码设计" class="headerlink" title="连招系统代码设计"></a>连招系统代码设计</h1><p><a href="https://www.zhihu.com/question/26760255/answer/56856767">游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 白井功名的回答 - 知乎</a></p><p><strong>1，在无法把握全部动作的前提下，把握好人物每个动作衔接过程中的着力点</strong></p><p><strong>2，适当地通过特效、光影等弥补动作上可能存在的不足</strong></p><p><strong>3，嗯之前忘了说，但是也许是最重要的一点：在做连招的过程中保持与美术的沟通，单个动作方面可能他是专家但连招的整体还是需要你们共同完成</strong></p><p>游戏的连招动作是怎么设计的？代码上又是怎样实现的？ - 猴与花果山的回答 - 知乎<br><a href="https://www.zhihu.com/question/26760255/answer/57075589">https://www.zhihu.com/question/26760255/answer/57075589</a></p>]]></content>
    
    
    <summary type="html">总结一下一个好的动作游戏的方方面面</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua高性能编程</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h1><p>在代码运行前，Lua会把源码预编译成一种中间码，类似于Java的虚拟机。这种格式然后会通过C的解释器进行解释，整个过程其实就是通过一个while循环，里面有很多的switch…case语句，一个case对应一条指令来解析。</p><p>自Lua 5.0之后，Lua采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多250个寄存器，因为栈的长度是用8个比特表示的。</p><p>有了这么多的寄存器，Lua的预编译器能把所有的local变量储存在其中。这就使得Lua在获取local变量时其效率十分的高。</p><h2 id="使用local引用global变量"><a href="#使用local引用global变量" class="headerlink" title="使用local引用global变量"></a>使用local引用global变量</h2><p>Lua对本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">局部变量</a>的访问是一个O(1)的操作（等价于一个数组地址+偏移），而global变量的获取需要一次<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=hash%E6%9F%A5%E6%89%BE&zhida_source=entity">hash查找</a>。local比global快很多（特别是在计算比较简单时，hash查找的开销反而是大头），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了本地local变量以外，upvalue的访问也比global快很多（访问上一层upvalue，等价于一次间接跳转之后再访问上一层函数的局部变量，基本还是一个O(1)的开销），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="使用local缓存table查找结果"><a href="#使用local缓存table查找结果" class="headerlink" title="使用local缓存table查找结果"></a>使用local缓存table查找结果</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="3R原则"><a href="#3R原则" class="headerlink" title="3R原则"></a>3R原则</h1><h2 id="Reducing"><a href="#Reducing" class="headerlink" title="Reducing"></a>Reducing</h2><p>避免创建新对象和节约内存</p><h3 id="把table变成数组"><a href="#把table变成数组" class="headerlink" title="把table变成数组"></a>把table变成数组</h3><h3 id="把常量对象的创建放在循环的外面"><a href="#把常量对象的创建放在循环的外面" class="headerlink" title="把常量对象的创建放在循环的外面"></a>把常量对象的创建放在循环的外面</h3><p>xxxxxxxxxx void Awake(){    objects &#x3D; new List<Transform>();}​void CreateObject(){    Transform t &#x3D; Instantiatie(prefab);    t.loactionPosition &#x3D; Random.insideUnitSphere * 5f;    t.locationRotation &#x3D; Random.rotation;    t.localScale &#x3D; Vector3.one * Random.Range(0.1f, 1f);    objects.Add(t);}c#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125; <span class="hljs-comment">--unnecessary redeclare</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span> <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">--这里每次循环会创建一个匿名函数对象</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">local</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fun2) <span class="hljs-comment">--重用循环外定义的func2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Reusing"><a href="#Reusing" class="headerlink" title="Reusing"></a>Reusing</h2><h3 id="复用对象"><a href="#复用对象" class="headerlink" title="复用对象"></a>复用对象</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123; year = i, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;) <span class="hljs-comment">--每次循环创建一个表</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> aux = &#123; year = <span class="hljs-literal">nil</span>, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    aux.year = i <span class="hljs-comment">-- 重用循环外定义的aux</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(aux)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Recycling"><a href="#Recycling" class="headerlink" title="Recycling"></a>Recycling</h2><h3 id="避免GC对象的创建"><a href="#避免GC对象的创建" class="headerlink" title="避免GC对象的创建"></a>避免GC对象的创建</h3><p>string有intenalize管理的开销，table需要开辟内存，lua中所有的function都是闭包，创建开销也不低，此外它们都会增加gc的开销。</p><h3 id="传参时避免构造table"><a href="#传参时避免构造table" class="headerlink" title="传参时避免构造table"></a>传参时避免构造table</h3><p>参数的数量不多时，尽量用独立的变量传递参数，而非构造一个table。</p><h2 id="宿主语言接口调用"><a href="#宿主语言接口调用" class="headerlink" title="宿主语言接口调用"></a>宿主语言接口调用</h2><p>尽量在lua内部完成计算，调用宿主语言接口会带来明显的上下文切换开销，如果不是一个复杂的计算过程，不值的浪费这个开销。</p><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n的整数键，其他的所有键都储存在哈希部分中。</p><p>哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。</p><p>当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。</p><h2 id="创建table时初始化数据"><a href="#创建table时初始化数据" class="headerlink" title="创建table时初始化数据"></a>创建table时初始化数据</h2><p>为了减少不必要的内存开销，table在创建时不会分配任何额外内存，早期几个元素的插入都必然导致rehash操作，这个特性对小table的创建影响特别显著，创建时一并指定初始化数据可以避免rehash的开销。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>t[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>t[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br> <br><span class="hljs-comment">-- good: 200% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="高效的遍历"><a href="#高效的遍历" class="headerlink" title="高效的遍历*"></a>高效的遍历*</h2><p>paris和iparis有函数调用的开销，因此效率不高。在性能敏感的场合，最好缓存table的size，然后使用for loop。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- pairs: 3.078 (217%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">--- ipairs: 3.344 (236%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,x do: 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,#atable do 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,atable_length do: 1.562 (110%)</span><br><span class="hljs-keyword">local</span> length = #a<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,length <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的插入"><a href="#高效的插入" class="headerlink" title="高效的插入*"></a>高效的插入*</h2><p>table.insert有函数调用的开销，因此性能不高。在性能敏感的场合，最好缓存table的size，然后指定下标赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table.insert: 1.250 (727%)</span><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    tinsert(a,i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[i]: 0.172 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[i]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[#a+1]=x: 0.453 (263%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[count++]=x: 0.203 (118%)</span><br><span class="hljs-keyword">local</span> count = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    d[count]=i<br>    count=count+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的unpack"><a href="#高效的unpack" class="headerlink" title="高效的unpack*"></a>高效的unpack*</h2><p>性能敏感的场合不要使用unpack，选择手动展开。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- with [ ]: 0.485 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>],a[<span class="hljs-number">4</span>] )<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- unpack(): 1.093 (225%)</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">unpack</span>(a) )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="array或者hash"><a href="#array或者hash" class="headerlink" title="array或者hash*"></a><a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=array&zhida_source=entity">array</a>或者hash*</h2><p>table有array和hash两部分存储，一般来讲array的存储开销要比hash小一些，访问速度也比hash查找要快，可能的话尽量选array。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 使用hash，内存开销最大 400%</span><br>polyline = &#123;<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">18.3</span>&#125;,<br>  &#123;x= <span class="hljs-number">15.0</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>&#125;  <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 使用数组，内存开销降低 250%</span><br>polyline = &#123;<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">98.5</span> &#125;,<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">18.3</span> &#125;,<br>  &#123; <span class="hljs-number">15.0</span>, <span class="hljs-number">98.5</span> &#125;,<br>  ...<br>&#125; <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 还可以进一步减少table本身的内存开销，只3个table 100%</span><br>polyline = &#123;<br>  x = &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">10.3</span>, <span class="hljs-number">15.0</span>, ... &#125;,<br>  y = &#123; <span class="hljs-number">98.5</span>, <span class="hljs-number">18.3</span>, <span class="hljs-number">98.5</span>, ... &#125;<br>&#125; <span class="hljs-comment">--(tables used: 3)</span><br></code></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。</p><p>所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为Lua需要去查找比较一遍。</p><p>第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变得十分高效。例如在Perl中，$x &#x3D; $y，会将$y的buffer整个的复制到$x的buffer中，当字符串很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。</p><p>但是只保存引用会降低在字符串连接时的速度。在Perl中，$s &#x3D; $s . ‘x’和$s .&#x3D; ‘x’的效率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插入到$x的buffer末尾。</p><p>由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。</p><h2 id="缓存字符串"><a href="#缓存字符串" class="headerlink" title="缓存字符串"></a>缓存字符串</h2><p>避免在运行时构造字符串，尽量缓存那些常量字符串。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>大字符串的拼接，使用table.concat。</p><p>在lua中可以用table来模拟buffer</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">30000</span> <span class="hljs-keyword">do</span><br>    t[#t+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">end</span><br>s = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="语言之外的东西"><a href="#语言之外的东西" class="headerlink" title="语言之外的东西"></a>语言之外的东西</h1><p>使用<a href="http://luajit.org/">LuaJIT</a>，LuaJIT可以使你在不修改代码的情况下获得平均约5倍的加速。查看LuaJIT在<a href="http://luajit.org/performance_x86.html">x86&#x2F;x64下的性能提升比</a>。</p><p>第二、将瓶颈部分用C&#x2F;C++来写。因为Lua和C的天生近亲关系，使得Lua和C可以混合编程。但是C和Lua之间的通讯会抵消掉一部分C带来的优势。</p>]]></content>
    
    
    <summary type="html">关于如何写Lua高性能编程的一些建议</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于蓝图的多人游戏玩法设计</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.266Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18Y41187vo/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2021]与众乐乐 - 基于蓝图的多人游戏玩法设计 | Epic Games 何骞</a> </p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221120244763.png"></p><p>复制Replication</p>]]></content>
    
    
    <summary type="html">一个关于如何用蓝图开发多人游戏的演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>UE蓝图开发最佳实践</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.598Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1oG411M7Y6/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2022]蓝图开发最佳实践 | Epic 何骞</a> </p><h1 id="命名相关"><a href="#命名相关" class="headerlink" title="命名相关"></a>命名相关</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000001964.png"></p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000142710.png"></p><p>减少冗余信息</p><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000236767.png"></p><h1 id="蓝图如何保持整洁"><a href="#蓝图如何保持整洁" class="headerlink" title="蓝图如何保持整洁"></a>蓝图如何保持整洁</h1><h2 id="避免过长的蓝图逻辑，屏幕长度有限"><a href="#避免过长的蓝图逻辑，屏幕长度有限" class="headerlink" title="避免过长的蓝图逻辑，屏幕长度有限"></a>避免过长的蓝图逻辑，屏幕长度有限</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000410021.png"></p><h2 id="事件左对齐"><a href="#事件左对齐" class="headerlink" title="事件左对齐"></a>事件左对齐</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000501706.png"></p><p>保证更改逻辑的时候不会改错</p><h2 id="通过Re-route来减少连线"><a href="#通过Re-route来减少连线" class="headerlink" title="通过Re-route来减少连线"></a>通过Re-route来减少连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000527244.png"></p><h2 id="避免错乱事件连线"><a href="#避免错乱事件连线" class="headerlink" title="避免错乱事件连线"></a>避免错乱事件连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000700985.png"></p><p>不要想到一个事件就立马create出来</p><h2 id="重用Getter或者Pure节点"><a href="#重用Getter或者Pure节点" class="headerlink" title="重用Getter或者Pure节点"></a>重用Getter或者Pure节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000813646.png"></p><h2 id="清晰的返回节点"><a href="#清晰的返回节点" class="headerlink" title="清晰的返回节点"></a>清晰的返回节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000841491.png"></p><p>越复杂的函数为什么return，为什么early return需要写清楚</p><h2 id="Select节点"><a href="#Select节点" class="headerlink" title="Select节点"></a>Select节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000918576.png"></p><p>Text替代String</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000954247.png"></p><h1 id="蓝图注释规则"><a href="#蓝图注释规则" class="headerlink" title="蓝图注释规则"></a>蓝图注释规则</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001053596.png"></p><h2 id="分不同的颜色，规则不一样"><a href="#分不同的颜色，规则不一样" class="headerlink" title="分不同的颜色，规则不一样"></a>分不同的颜色，规则不一样</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001141232.png"></p><h2 id="注释的细节"><a href="#注释的细节" class="headerlink" title="注释的细节"></a>注释的细节</h2><p><strong>每个事件都编写注释</strong></p><p><strong>Sequence的每一段都写注释</strong></p><p>把长的拆分成sequence也可以做</p><p><strong>为复杂的逻辑写注释</strong></p><p><strong>为复杂的函数返回写注释</strong></p><h1 id="如何创建稳固更新的生产线？"><a href="#如何创建稳固更新的生产线？" class="headerlink" title="如何创建稳固更新的生产线？"></a>如何创建稳固更新的生产线？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001347062.png"></p><p>不是一开始就设计好，而是在项目进行到一定阶段在解耦。</p><p>不要复制黏贴，而是作为抽离成function</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>每次冷启动，可以通过log（Unreal Inside）来观察哪里加载的久。</p><p>以及每次添加新节点的时间</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>减少不必要的Cast，特别是复杂蓝图类的cast</strong>。</p><p><strong>用Gameplay Tag和blueprint Interface</strong></p><p><strong>活用命名空间</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002004041.png"></p><p>可以规定某个蓝图这是哪种玩法会用到的，这样就可以减少加载</p><p><strong>减少Hard Reference</strong></p><p>因为每个hard Reference都会加载在内存里面，会影响包体大小，考虑用Tag或者Soft Reference来替换</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002514037.png"></p><p>一个比较好的方式是，脚本语言不去改蓝图function的实现，然后划分好哪些变量会修改，这样也可以作为一个新的category来分类</p><h2 id="蓝图审核"><a href="#蓝图审核" class="headerlink" title="蓝图审核"></a>蓝图审核</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002854518.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002937518.png"></p><p>可以持续更新一个Best Practice文档</p><h1 id="编辑器拓展"><a href="#编辑器拓展" class="headerlink" title="编辑器拓展"></a>编辑器拓展</h1><p>Assest Action Utility（这里没太听懂，到时候学习一下）</p><h1 id="如何平衡蓝图和C-？"><a href="#如何平衡蓝图和C-？" class="headerlink" title="如何平衡蓝图和C++？"></a>如何平衡蓝图和C++？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221003705495.png"></p><p><strong>不用过早优化</strong></p><p>因为变化可能很快</p><p><strong>有安全性问题的时候可以考虑转</strong></p><p>比如拿的很多信息不是在本地，而是要通过服务器来request，这种可能放在C++核心类比较好</p><p><strong>直接重定向</strong></p><p>在C++里面写一个<strong>MigrateProperty</strong>这样一个函数，可以把哪些变量，CDO准确的转化过来</p>]]></content>
    
    
    <summary type="html">一个关于如何有效率地编写蓝图演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-垃圾回收</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2024-12-17T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>也是采用标记清除的方式，会从根出发，标记所有</p><h2 id="根节点是什么？"><a href="#根节点是什么？" class="headerlink" title="根节点是什么？"></a>根节点是什么？</h2><p><strong>1. 静态字段</strong></p><p><strong>2. MonoBehaviour实例</strong></p><p><strong>3. ScriptableObject实例</strong></p><p><strong>4. 场景中的GameObject</strong></p><p><strong>5. 全局引用</strong></p><p><strong>6. 资源引用</strong></p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，主要分为以下几步：</p><ul><li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；</li><li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。</li><li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。</li></ul><p>堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。</p><h2 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h2><p>当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ul><li>GC会检查堆内存上的每个存储变量；</li><li>对每个变量会检测其引用是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为可回收；</li><li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li></ul><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h2 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h2><p>主要有三个操作会触发垃圾回收：</p><ul><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ul><h2 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a><strong>降低GC的影响的方法</strong></h2><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>基于此，我们可以采用三种策略：</p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。</li><li>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响</li></ul><h2 id="降低GC的具体方法"><a href="#降低GC的具体方法" class="headerlink" title="降低GC的具体方法"></a>降低GC的具体方法</h2><h3 id="减少内存垃圾"><a href="#减少内存垃圾" class="headerlink" title="减少内存垃圾"></a>减少内存垃圾</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>比如循环不要每次都创建新的数组，而是提前创建好</p><h4 id="不要在频分调用的函数里面使用堆内存分配"><a href="#不要在频分调用的函数里面使用堆内存分配" class="headerlink" title="不要在频分调用的函数里面使用堆内存分配"></a>不要在频分调用的函数里面使用堆内存分配</h4><p>比如tick和update里面不要分配内存，而是在之前就创建好，或者通过定时器或者脏标记的方法来改进</p><h4 id="减少链表"><a href="#减少链表" class="headerlink" title="减少链表"></a>减少链表</h4><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>减少内存的释放和创建次数</p><h3 id="造成不必要内存的分配的情况"><a href="#造成不必要内存的分配的情况" class="headerlink" title="造成不必要内存的分配的情况"></a>造成不必要内存的分配的情况</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在c#里面字符串不是值类型而是引用，而且值无法改变，所以改变值会直接创建一个新的值</p><p>　1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p><p>　　2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。</p><p>　　3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>比如说迭代器会产生新的数组（可以通过缓存来解决），调用GameObject.name 或者 GameObject.tag也会有内存垃圾，因为会犯乎一个字符串</p><h4 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h4><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。最好避免。</p><p>比如这种</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> cost = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">string</span> displayString = String.Format(<span class="hljs-string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost);<br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>6.5之前的版本会因为迭代器有内存垃圾</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>比如把对象里面的string拆出来，这样就不用频繁地在GC里面类型检查</p><h3 id="定时执行GC"><a href="#定时执行GC" class="headerlink" title="定时执行GC"></a>定时执行GC</h3><p>比如过场的时候主动调用GC操作</p><h1 id="UE"><a href="#UE" class="headerlink" title="UE"></a>UE</h1><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p><a href="https://zhuanlan.zhihu.com/p/133939450">Lua GC机制分析与理解-上 - 小破孩不会编程序的文章 - 知乎</a></p><h2 id="gc的思想"><a href="#gc的思想" class="headerlink" title="gc的思想"></a>gc的思想</h2><p>会遍历所有对象，标记颜色，那些不可达的就是需要gc的对象，又分为双色和三色，双色就是不能中断，三色可以中断，但是实现复杂，</p><h2 id="何时会触发gc？"><a href="#何时会触发gc？" class="headerlink" title="何时会触发gc？"></a>何时会触发gc？</h2><p>分为两种，一种是自动触发</p><p>在以下代码中，使用 luaC_checkGC 检查 gc 阈值 GCdebt ，当 GCdebt 大于0 时，执行 gc<br>1、创建新数据时 string, thread, userdata, table, closure<br>3、语法解析时<br>4、错误发生时<br>5、字符串拼接时 concat<br>6、栈增长时</p><p>一种是手动触发</p><p>使用 lua API：<br>collectgarbage “step”<br>collectgarbage “collect”</p><h2 id="lua-怎么判定数据可达？"><a href="#lua-怎么判定数据可达？" class="headerlink" title="lua 怎么判定数据可达？"></a>lua 怎么判定数据可达？</h2><p>从 GC根集合（root set） 可访问的对象：<br>gc root set包含三部分：<br>1、主协程 g-&gt;mainthread，其栈记录了当前用到的所有对象<br>2、注册表 g-&gt;l_registry，包含了全局table(_G)，记录了全局变量和全局模块，还包括已加载的模块表 package.loaded<br>3、全局元表 g-&gt;mt，每种数据类型各一个，预留9个，暂时只有table和string的实现，效果如io模块的f:read()和 string模块的s:len()</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>程序是无法推断哪些东西是需要回收的，比如说在数组里的元素，虽然我们不用他了，但是数组还在引用，那么lua就无法自动回收它，这时候就需要弱引用表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p><p>1、导致引用计数+1的情况</p><p>对象被创建，例如a&#x3D;23</p><p>对象被引用，例如b&#x3D;a</p><p>对象被作为参数，传入到一个函数中，例如func(a)</p><p>对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>2、导致引用计数-1的情况</p><p>对象的别名被显式销毁，例如del a</p><p>对象的别名被赋予新的对象，例如a&#x3D;24</p><p>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</p><p>对象所在的容器被销毁，或从容器中删除对象</p><h2 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h2><p>针对循环引用这个问题，比如有两个对象互相引用了对方，当外界没有对他们有任何引用，也就是说他们各自的引用计数都只有1的时候，如果可以识别出这个循环引用，把它们属于循环的计数减掉的话，就可以看到他们的真实引用计数了。基于这样一种考虑，有一种方法，比如从对象A出发，沿着引用寻找到对象B，把对象B的引用计数减去1；然后沿着B对A的引用回到A，把A的引用计数减1，这样就可以把这层循环引用关系给去掉了。</p><p>不过这么做还有一个考虑不周的地方。假如A对B的引用是单向的， 在到达B之前我不知道B是否也引用了A，这样子先给B减1的话就会使得B称为不可达的对象了。为了解决这个问题，python中常常把内存块一分为二，将一部分用于保存真的引用计数，另一部分拿来做为一个引用计数的副本，在这个副本上做一些实验。比如在副本中维护两张链表，一张里面放不可被回收的对象合集，另一张里面放被标记为可以被回收（计数经过上面所说的操作减为0）的对象，然后再到后者中找一些被前者表中一些对象直接或间接单向引用的对象，把这些移动到前面的表里面。这样就可以让不应该被回收的对象不会被回收，应该被回收的对象都被回收了。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h2><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环境的编程中，对于变量在内存中的创建&#x2F;销毁，总有频繁和不那么频繁的。比如任何程序中总有生命周期是全局的、部分的变量。<br>Python将所有的对象分为0，1，2三代；<br>所有的新建对象都是0代对象；<br>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p><p>他们gc的频率不同，这样可以提高性能</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - allen的文章 - 知乎</a></p><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p><p>如果要自己写一个内存泄漏，可以考虑在new和malloc里面记录内存。</p><p>调试可以用数据断点来操作。</p><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><h2 id="避免内存碎片"><a href="#避免内存碎片" class="headerlink" title="避免内存碎片"></a>避免内存碎片</h2><ol><li>使用内存池（Memory Pool）</li></ol><p>预先分配一大块内存，并在其中管理小块内存的分配和释放。这样可以减少频繁的动态内存分配和释放带来的碎片。</p><p>内存池可以根据对象的大小进行分区，确保相同大小的对象使用相同的内存块。</p><ol start="2"><li>对象重用：</li></ol><p>尽量重用对象，避免频繁的创建和销毁。可以使用对象池（Object Pool）来管理可重用的对象。</p><p>对象池可以在游戏中常用的对象（如子弹、敌人等）中使用，减少内存分配和释放的次数。</p><ol start="3"><li>合理的内存分配策略：</li></ol><p>使用合适的内存分配器，选择适合应用场景的分配策略（如分配器的对齐方式、分配大小等）。</p><p>避免频繁的小块内存分配，尽量使用较大的内存块进行分配。</p><ol start="4"><li>合并空闲块：</li></ol><p>在释放内存时，检查相邻的空闲块并合并它们，以减少外部碎片。</p><p>许多内存分配器会自动处理合并空闲块的逻辑。</p><ol start="5"><li>使用智能指针：</li></ol><p>在 C++ 中，使用智能指针（如 std::shared_ptr 和 std::unique_ptr）来管理内存，减少内存泄漏和碎片的可能性。</p><h2 id="解决内存碎片"><a href="#解决内存碎片" class="headerlink" title="解决内存碎片"></a>解决内存碎片</h2><ol><li>内存整理（Compaction）：</li></ol><p>在某些情况下，可以通过内存整理来解决外部碎片。内存整理的过程是将活动对象移动到内存的一端，释放出连续的空闲内存块。</p><p>这种方法在实时系统中可能不适用，因为它可能导致停顿。</p><ol start="2"><li>使用更高效的内存分配器：</li></ol><p>如果发现当前的内存分配器导致了严重的内存碎片，可以考虑使用其他内存分配器（如 jemalloc、tcmalloc 等），这些分配器在处理碎片方面通常更高效。</p><ol start="3"><li>监控和分析内存使用：</li></ol><p>使用内存分析工具（如 Valgrind、Visual Studio 的内存分析工具等）监控内存使用情况，识别和解决内存碎片问题。</p><p>定期检查和分析内存使用情况，及时发现和解决潜在的内存碎片问题。</p><ol start="4"><li>重启应用程序：</li></ol><p>在某些情况下，重启应用程序可以清除内存碎片，尤其是在长时间运行的应用程序中。</p>]]></content>
    
    
    <summary type="html">垃圾回收可能会问到的一切东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-UE相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE最基础的五个类是什么"><a href="#UE最基础的五个类是什么" class="headerlink" title="UE最基础的五个类是什么"></a>UE最基础的五个类是什么</h1><ol><li>GameMode是整个关卡的控制器，用来编写整个关卡的<a href="https://zhida.zhihu.com/search?content_id=212792905&content_type=Article&match_order=1&q=%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&zhida_source=entity">业务逻辑</a>；</li><li>GameState是整个关卡的状态，用来存储整个关卡的游戏数据；</li><li>DefaultPawn是玩家角色，若是角色扮演类游戏则就是在游戏场景中看到的角色实体；</li><li>PlayerController是玩家的控制器，用来编写和玩家相关的控制逻辑；</li><li>PlayerState是玩家的状态，用来存储和玩家相关的状态数据。</li></ol><h1 id="FName和FString"><a href="#FName和FString" class="headerlink" title="FName和FString"></a>FName和FString</h1><p>① <strong>FName：</strong>着重于表示<strong>名称</strong>，<strong>不区分大小写</strong>，<strong>不可更改</strong>，引擎中的资源名称都是FName类型，通过一个轻型系统重复使用字符串，FName创建时会根据内容创建一个<a href="https://zhida.zhihu.com/search?content_id=178876897&content_type=Article&match_order=1&q=Hash%E5%80%BC&zhida_source=entity">Hash值</a>，且同样的内容只会存储一次。通过Hash值在进行FName的查找和访问时速度较快，而在比较的时，也不需要比较字符串内容，直接比较Hash值来区分不同FName字符串。</p><p>另外两种字符串<strong>到FName的转换</strong>（特别注意的是，<strong>FText不能直接转换到FName</strong>，可<strong>先转换为FString</strong>，再转换为FName）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br> <br><span class="hljs-comment">// FString 转 FName：不可靠，丢失大小写信息</span><br>FName name1 = <span class="hljs-built_in">FName</span>(*str);<br><br>FString strFromTxt = txt.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 先转 FString，再转 FName：不可靠，丢失大小写信息，丢失本地化信息可能导致语言转换的潜在风险</span><br>FName name2 = <span class="hljs-built_in">FName</span>(*strFromTxt);<br></code></pre></td></tr></table></figure><p>② <strong>FString：</strong>最接近std::string，着重在于<strong>字符串的操作</strong>，提供了大量对字符串的操作接口，是<strong>三者中唯一可修改的字符串类型</strong>，也正因如此，FString对比其它两种字符串来说<strong>消耗更高</strong>，<strong>性能更低</strong>。</p><p>另外两种字符串<strong>到FString的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br><br><span class="hljs-comment">// FName 转 FString：可靠</span><br>FString str1 = name.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 转 FString：不可靠，丢失本地化信息可能导致语言转换的潜在风险</span><br>FString str2 = txt.<span class="hljs-built_in">ToString</span>();<br></code></pre></td></tr></table></figure><p>③ <strong>FText：</strong>着重在于<strong>显示与本地化</strong>，显示可理解玩家能直接看到的信息，本地化即多语言的处理，<strong>不可更改</strong>。相较于另外两种类型，FText会更加的臃肿，但提供了优秀的本地化功能。</p><p>另外两种字符串<strong>到FText的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br><br><span class="hljs-comment">// FString 转 FText：可靠</span><br>FText txt1 = FText::<span class="hljs-built_in">FromString</span>(str);<br><span class="hljs-comment">// FName 转 FText：可靠</span><br>FText txt2 = FText::<span class="hljs-built_in">FromName</span>(name);<br></code></pre></td></tr></table></figure><h1 id="软引用和硬引用"><a href="#软引用和硬引用" class="headerlink" title="软引用和硬引用"></a>软引用和硬引用</h1><p>加载的步骤</p><h1 id="Actor如何实现一个借口类"><a href="#Actor如何实现一个借口类" class="headerlink" title="Actor如何实现一个借口类?"></a>Actor如何实现一个借口类?</h1><h1 id="UE4反射机制"><a href="#UE4反射机制" class="headerlink" title="UE4反射机制"></a>UE4反射机制</h1><p>UHT</p><p><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a></p><p><a href="https://blog.csdn.net/duan19920101/article/details/127557454">C++反射机制</a></p><h1 id="Actor生命周期"><a href="#Actor生命周期" class="headerlink" title="Actor生命周期"></a>Actor生命周期</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/v2-49e75fce0ea89e5dced9f3f8994fb6ce_1440w.jpg" alt="img"></p><p>作者：一勾大师<br>链接：<a href="https://zhuanlan.zhihu.com/p/308217207">https://zhuanlan.zhihu.com/p/308217207</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>UE4中创建Actor的方法主要有如下几种：<strong>从磁盘加载</strong>，<strong>Play In Editor（简称PIE）</strong>，<strong>SpawnActor动态生成</strong>和<strong>延迟生成。</strong>下面对不同形式的actor加载进行介绍</p><p><strong>从磁盘加载</strong></p><p>已位于关卡中的 Actor 使用此路径，如 LoadMap 发生时、或 AddToWorld（从流关卡或子关卡）被调用时，一般是提前搭好的场景中资源的加载方式。</p><ol><li>包&#x2F;关卡中的 Actor 从磁盘中进行加载。</li><li><strong>PostLoad</strong> - 在<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%BA%8F%E5%88%97%E5%8C%96&zhida_source=entity">序列化</a> Actor 从磁盘加载完成后被调用。在此处可执行自定义版本化和修复操作。PostLoad 与 <strong>PostActorCreated</strong> 互斥。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="Play-in-Editor"><a href="#Play-in-Editor" class="headerlink" title="Play in Editor"></a><strong>Play in Editor</strong></h2><p>Play in Editor 路径与 Load from Disk 十分相似，然而 Actor 却并非从磁盘中加载，而是从编辑器中复制而来，一般是在Debug时资源的加载方式。</p><ol><li><strong>PostDuplicate</strong> 被调用。</li><li><strong>InitializeActorsForPlay</strong></li><li>为未初始化的 Actor 执行 <strong>RouteActorInitialize</strong>（包含Stream Level的加载）</li></ol><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>5.<strong>BeginPlay</strong> - 关卡开始后调用。</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h2><p>这是生成（实例）Actor 时的路径。在实际工程中一般是通过SpawnActor等函数加载的资源</p><ol><li><strong>SpawnActor</strong> 被调用。</li><li><strong>PostSpawnInitialize</strong></li><li><strong>PostActorCreated</strong> - 创建后即被生成的 Actor 调用，构建函数类行为在此发生。PostActorCreated 与 PostLoad 互斥。</li><li><strong>ExecuteConstruction</strong>：</li></ol><ul><li><strong>OnConstruction</strong> - Actor 的构建。蓝图 Actor 的组件在此处创建，蓝图变量在此处初始化</li></ul><p>5.<strong>PostActorConstruction</strong>：</p><ul><li><strong>PreInitializeComponents</strong> - 在 Actor 的组件上调用 InitializeComponent 之前进行调用。</li><li><strong>InitializeComponent</strong> - Actor 上定义的每个组件的创建辅助函数。</li><li><strong>PostInitializeComponents</strong> - Actor 的组件初始化后调用。</li></ul><p>6.<strong>OnActorSpawned</strong> 在 UWorld 上播放。</p><p>7.<strong>BeginPlay</strong> 被调用。</p><h2 id="延迟生成"><a href="#延迟生成" class="headerlink" title="延迟生成"></a><strong>延迟生成</strong></h2><p>将任意属性设为”Expose on Spawn”即可延迟 Actor 的生成。</p><ol><li><strong>SpawnActorDeferred</strong> - 生成程序化 Actor，在蓝图构建脚本之前进行额外设置。</li><li>SpawnActor 中的所有操作发生；PostActorCreated 之后发生以下操作：</li></ol><ul><li>通过一个有效但不完整的 Actor 实例设置&#x2F;调用多个”<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0&zhida_source=entity">初始化函数</a>“。</li><li><strong>FinishSpawningActor</strong> -调用后对 Actor 进行最终化，在 Spawn Actor 行中选取 ExecuteConstruction。</li></ul><p><strong>生命周期的结束</strong></p><p>尽管生成方式有比较大的区别，上述几种生成方法的结束流程却都一样。</p><p><strong>Destroy</strong> - 游戏在 Actor 需要被移除时手动调用，但游戏进程仍在继续。Actor 被标记为等待销毁并从关卡的 Actor 阵列中移除。</p><p><strong>EndPlay</strong> - 在数个地方调用，保证 Actor 的生命走向终点。在游戏过程中，如包含流关卡的 Actor 被卸载，Destroy 将发射此项和关卡过渡。调用 EndPlay 的全部情形：</p><ul><li>对 Destroy 显式调用。</li><li>Play in Editor 终结。</li><li>关卡过渡（无缝行程或加载地图）。 包含 Actor 的流关卡被卸载。</li><li>Actor 的生命期已过。</li><li>应用程序关闭（全部 Actor 被销毁）。</li></ul><p>无论这些情形出现的方式如何，Actor 都将被标记为 RF_PendingKill，因此在下个垃圾回收周期中它将被解除分配。此外，可以考虑使用更整洁的 <code>FWeakObjectPtr&lt;AActor&gt;</code> 代替手动检查”等待销毁”。</p><p><strong>OnDestroy</strong> - 这是对 Destroy 的旧有反应。也许应该将这里的所有内容移到 EndPlay，因为它被关卡过渡和其他游戏清理函数调用。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><p>一个对象被标记待销毁的一段时间后，垃圾回收会将其从内存中实际移除，释放其使用的资源。</p><p>在对象的销毁过程中，以下函数将被调用：</p><ol><li><strong>BeginDestroy</strong> - 对象可利用此机会释放内存并处理其他<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&zhida_source=entity">多线程</a>资源（即为图像线程代理对象）。与销毁相关的大多数游戏性功能理应在 <code>EndPlay</code> 中更早地被处理。</li><li><strong>IsReadyForFinishDestroy</strong> - 垃圾回收过程将调用此函数，以确定对象是否可被永久解除分配。返回 <code>false</code>，此函数即可延迟对象的实际销毁，直到下一个垃圾回收过程。</li><li><strong>FinishDestroy</strong> - 最后对象将被销毁，这是释放内部数据结构的另一个机会。这是<a href="https://zhida.zhihu.com/search?content_id=156621886&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE&zhida_source=entity">内存释放</a>前的最后一次调用。</li></ol><h1 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zhuanlan.zhihu.com/p/149392857">UFUNCTION&#x2F;UPROPERTY&#x2F;UCLASS</a></p><p> 反射系统是可以选择加入的。你需要给暴露给反射系统的类型或属性添加注解，这样Unreal Header Tool (UHT)就会在编译工程的时候利用那些信息生成特定的代码。</p><p><strong>标记</strong></p><p>为了标记一个头文件包含反射类型，需要在文件顶部添加一个特殊的include文件。该文件必须放在#include的最后，这让UHT知道它需要考虑这个文件，并且在反射系统的实现里也是需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileName.generated.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>你现在可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()来在头文件中注解不同的类型以及成员变量。每一个宏都会出现在类型或者成员变量的前面，并且可以包含额外的修饰符关键字。</p><p>C++是没法直接通过函数名来调用的，因为存的都是地址，但是在蓝图里面可以，这就用到了反射机制</p><h2 id="常用的有哪些"><a href="#常用的有哪些" class="headerlink" title="常用的有哪些"></a>常用的有哪些</h2><p><a href="https://blog.csdn.net/ttod/article/details/136396379">简述UE中的UFUNCTION宏和UPROPERTY宏常用属性</a></p><p>UFunction</p><table><thead><tr><th><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></th><th>在蓝图编辑工具中显示时指定函数的类别。使用 | 运算符定义嵌套类别。</th></tr></thead><tbody><tr><td><code>Client</code></td><td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>CustomThunk</code></td><td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td></tr><tr><td><code>Exec</code></td><td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td></tr><tr><td><code>NetMulticast</code></td><td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td></tr><tr><td><code>Reliable</code></td><td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>SealedEvent</code></td><td>无法在子类中覆盖此函数。<code>SealedEvent</code>关键词只能用于事件。对于非事件函数，请将它们声明为<code>static</code>或<code>final</code>，以密封它们。</td></tr><tr><td><code>ServiceRequest</code></td><td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>ServiceResponse</code></td><td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>Server</code></td><td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>Unreliable</code></td><td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>WithValidation</code></td><td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td></tr></tbody></table><p>UProperty</p><table><thead><tr><th><code>AdvancedDisplay</code></th><th>属性将被放置在其出现的任意面板的高级（下拉）部分中。</th></tr></thead><tbody><tr><td><code>AssetRegistrySearchable</code></td><td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td></tr><tr><td><code>BlueprintAssignable</code></td><td>只能与组播委托共用。公开属性在蓝图中指定。</td></tr><tr><td><code>BlueprintAuthorityOnly</code></td><td>此属性必须为一个组播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td></tr><tr><td><code>BlueprintCallable</code></td><td>仅用于组播委托。应公开属性在蓝图代码中调用。</td></tr><tr><td><code>BlueprintGetter=GetterFunctionName</code></td><td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>BlueprintReadOnly</code></td><td>此属性可由蓝图读取，但不能被修改。此说明符与 <code>BlueprintReadWrite</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintReadWrite</code></td><td>可从蓝图读取或写入此属性。此说明符与 <code>BlueprintReadOnly</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintSetter=SetterFunctionName</code></td><td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td></tr><tr><td><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></td><td>指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td></tr><tr><td><code>Config</code></td><td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>DuplicateTransient</code></td><td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td></tr><tr><td><code>EditAnywhere</code></td><td>说明此属性可通过属性窗口在原型和实例上进行编辑。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditDefaultsOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditFixedSize</code></td><td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td></tr><tr><td><code>EditInline</code></td><td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td></tr><tr><td><code>EditInstanceOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>Export</code></td><td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td></tr><tr><td><code>GlobalConfig</code></td><td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>Instanced</code></td><td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td></tr><tr><td><code>Interp</code></td><td>说明值可随时间由Sequencer中的一个轨道驱动。</td></tr><tr><td><code>Localized</code></td><td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td></tr><tr><td><code>Native</code></td><td>属性为本地：C++代码负责对其进行序列化并公开到<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-object-handling?application_version=4.27#garbagecollection">垃圾回收</a>。</td></tr><tr><td><code>NoClear</code></td><td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td></tr><tr><td><code>NoExport</code></td><td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td></tr><tr><td><code>NonPIEDuplicateTransient</code></td><td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td></tr><tr><td><code>NonTransactional</code></td><td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td></tr><tr><td><code>NotReplicated</code></td><td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td></tr><tr><td><code>Replicated</code></td><td>属性应随网络进行复制。</td></tr><tr><td><code>ReplicatedUsing=FunctionName</code></td><td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td></tr><tr><td><code>RepRetry</code></td><td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td></tr><tr><td><code>SaveGame</code></td><td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td></tr><tr><td><code>SerializeText</code></td><td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td></tr><tr><td><code>SkipSerialization</code></td><td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>SimpleDisplay</code></td><td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开“高级”部分即可见。</td></tr><tr><td><code>TextExportTransient</code></td><td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>Transient</code></td><td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td></tr><tr><td><code>VisibleAnywhere</code></td><td>说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</td></tr><tr><td><code>VisibleDefaultsOnly</code></td><td>说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr><tr><td><code>VisibleInstanceOnly</code></td><td>说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr></tbody></table><h1 id="PUERTS"><a href="#PUERTS" class="headerlink" title="PUERTS"></a>PUERTS</h1><p><strong>puerts的本质</strong></p><p>puerts的本质是：</p><ul><li>在（UE）引擎提供了JavaScript虚拟机环境</li><li>让TypeScript&#x2F;JavaScript能够和引擎交互，或者说能调用C++或者蓝图API，也能被C++或者蓝图调用到</li></ul><p>js虚拟机实现了js语言，但js语言本身基本什么都干不了，它能做的事情取决于宿主环境给它添加的api，比如浏览器在js环境添加了dom操作api，于是浏览器里的js可以编写动态页面的逻辑，比如nodejs添加异步网络（io）api，于是nodejs里的js能用来编写web服务器。</p><p>puerts里js的宿主环境是游戏引擎，又添加了哪些api呢？</p><p>首先，puerts默认导入了<strong>所有</strong>反射api。换句话在UE蓝图里能调用的引擎API，在Typescript&#x2F;JavaScript环境都可以调用，如果用Typescript，正确引入了声明文件到工程中，这些api会有提示。</p><p>其次对于非反射api，手工封装成反射后蓝图也能访问，这点在typescript同样适用，而且puerts还额外支持《基于模板的静态绑定》，按文档声明一下在typescript即可调用。</p><p>在puerts里，要实现一项游戏编程任务，先想下这任务在C++或者蓝图里如何实现，然后在typescript调用同样的api去实现。</p><p>puerts并未重定义引擎，只是定义了ts和引擎相互调用的规则。puerts的demo也倾向于演示这些规则，而不是做一个游戏。</p><h1 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h1><p><a href="https://zhuanlan.zhihu.com/p/434028533">【UE5】给Landscape加一点料-地形篇（零）-前前言 - 徐凯鸣的文章 - 知乎</a></p><p><a href="https://www.youtube.com/watch?v=MRNFcywkUSA&list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3&index=3">Procedural Landmass Generation Youtube</a></p><p>地形编辑</p><p>Houdini</p><h1 id="自定义编辑器FAssetEditorToolkit"><a href="#自定义编辑器FAssetEditorToolkit" class="headerlink" title="自定义编辑器FAssetEditorToolkit"></a>自定义编辑器FAssetEditorToolkit</h1><h3 id="3-1-InitCustomAssetEditor方法："><a href="#3-1-InitCustomAssetEditor方法：" class="headerlink" title="3.1 InitCustomAssetEditor方法："></a><strong>3.1 InitCustomAssetEditor方法：</strong></h3><p>在此方法中，主要分为两个内容：<br><strong>① 初始化编辑器布局，可以使用以下步骤：</strong></p><ol><li>通过创建适当类的实例并设置其属性来定义自定义 FLayout、菜单和工具栏。</li><li>自定义 Slate 窗口现在将绑定到 TabManager，并使用自定义 FLayout、菜单和工具栏显示资产编辑器。</li></ol><p><strong>② 调用父类方法InitAssetEditor将自定义 Slate 窗口绑定到 TabManager。</strong></p><h3 id="3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法："><a href="#3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法：" class="headerlink" title="3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法："></a>3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法：</h3><p>+ 我们首先需要知道，Tab(SDockTab)是引擎定义的一个控件类，每一个Tab都是可以被关闭或打开的SWidget.Tab类型的窗口右上角包含一个关闭按钮。窗口内则可以包含自定义显示的各种Slate内容。</p><p>+ 我们打开编辑器时，就会根据Layout布局加载对应的Tab控件，并显示其中的内容，即Tab装入的子控件(Child Slate)。</p><p>+ 在此方法中，最重要的是调用TabManager对象，TabManager类主要用于管理编辑器中的布局，创建Tab对象。在类中我们需要定义一个FName类型的TabID变量，用于在该方法中指示一个Slate窗口。我们需要通过调用TabManager的方法RegisterTabSpawner绑定TabID和Slate，用于后续定义Slate控件的显示。</p><h3 id="3-3-SpawnTab-CustomWidget方法"><a href="#3-3-SpawnTab-CustomWidget方法" class="headerlink" title="3.3 SpawnTab_CustomWidget方法"></a>3.3 SpawnTab_CustomWidget方法</h3><p>在此方法中，将会创建并返回一个SWidget实例。<br>而RegistorTabSpawner方法通过调用TabManager的接口，将该Slate控件实例注册，与TabID进行绑定，并能够在InitCustomAssetEditor方法中添加到布局Flayout中被显示出来。<br>我们不仅可以创建简单的Slate控件（如SButton、IDetailsViews）,也可以创建较为复杂的窗口，如SEditorViewport(3D预览窗口)、SGraphEditor(可以连接复杂自定义的节点<a href="https://zhida.zhihu.com/search?content_id=222180537&content_type=Article&match_order=1&q=%E5%9B%BE%E8%A1%A8%E7%B3%BB%E7%BB%9F&zhida_source=entity">图表系统</a>)等内容，并将其添加到我们的自定义编辑器中。<br>在本文实例中，我在该方法中创建了一个最简单的Slate类SButton。</p><h1 id="模拟云"><a href="#模拟云" class="headerlink" title="模拟云"></a>模拟云</h1><p>Worley Noise</p><p>在空间中随机随便放点，然后计算最近的点的距离，为了连续，把这个的点放八个地方</p><h1 id="虚幻渲染编程"><a href="#虚幻渲染编程" class="headerlink" title="虚幻渲染编程"></a>虚幻渲染编程</h1><p><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻4渲染编程专题概述及目录 - YivanLee的文章 - 知乎</a></p><h1 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h1><p><a href="https://zhuanlan.zhihu.com/p/486808688">【Unreal】虚幻GAS系统快速入门 - LunarMaxim的文章 - 知乎</a></p><p><a href="https://github.com/DriedMachine/GASDocumentation5.3_CN">GAS Document中文翻译</a></p><h2 id="包括什么东西"><a href="#包括什么东西" class="headerlink" title="包括什么东西"></a>包括什么东西</h2><p>GAS主要包含以下内容：</p><ul><li>Who:ASC(Ability System Component) 主要组件，由C++编写，代码里有很多方法是蓝图未实现的。</li><li>How:GA(Gameplay Abilities) 角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI</li><li>What:AS(Attribute Set) 角色身上<strong>可以用float表示的属性</strong>，如生命值、体力值、魔力值等，有BaseValue和CurrentValue，方便回滚</li><li>Change:GE(Gameplay Effects) 用于<strong>修改属性</strong>，如增加50移动速度10s；还能配合GA实现更多玩法</li><li>Visual:GC(Gameplay Cues) 播放特效、音效等</li><li>If:Tag:用来分类，底层是FName，用.来分隔</li><li>Async：Task：如果想要异步的做一些东西，比如做完技能播一个蒙太奇，可以用这个来搞</li><li>Send：Event:ASC之间通信</li></ul><h2 id="做冷却"><a href="#做冷却" class="headerlink" title="做冷却"></a>做冷却</h2><p>角色在启动的时候可以保存一个specAbility，然后拿一个他的handle。</p><p>比如我想实现一个技能的冷却，其实就是做一个GE，然后这个GE启动的时候挂上在人物身上挂一个cooldown的tag，这个tag是有一个duration的，然后释放技能的时候加一个条件，有这个tag的时候无法释放，在ASC上面有一个Activation Blocked Tags，在里面加上刚刚搞的那个tag</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://zhuanlan.zhihu.com/p/463272214">【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南 - 水曜日鸡的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/38881269">《Exploring in UE4》多线程机制详解[原理分析] - Jerish的文章 - 知乎</a></p><h2 id="FRunnable"><a href="#FRunnable" class="headerlink" title="FRunnable"></a>FRunnable</h2><p>创建一个继承自FRunnable的类，把这个类要执行的任务分发给其他线程去执行。</p><p><img src="https://picx.zhimg.com/v2-21dde7f72b7b87f9133b60ab9190e5b5_r.jpg" alt="img"></p><h2 id="AsyncTask系统"><a href="#AsyncTask系统" class="headerlink" title="AsyncTask系统"></a>AsyncTask系统</h2><h2 id="TaskGraph系统"><a href="#TaskGraph系统" class="headerlink" title="TaskGraph系统"></a>TaskGraph系统</h2><p>Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个<a href="https://zhida.zhihu.com/search?content_id=7702163&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&zhida_source=entity">多线程任务</a>，指定各个任务之间的依赖关系，按照该关系来依次处理任务。具体的实现方式网上也有很多案例，这里先给出UE4Wiki的教程链接：</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>《Exploring in UE4》关于网络同步的理解与思考[概念理解] - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34721113">https://zhuanlan.zhihu.com/p/34721113</a></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>要将一个函数声明为 RPC，您只需将 <code>Server</code>、<code>Client</code> 或 <code>NetMulticast</code> 关键字添加到 <code>UFUNCTION</code> 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UFUNCTION</span>( Client )<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientRPCFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>《Exploring in UE4》RootMotion详解【原理分析】 - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/74554876">https://zhuanlan.zhihu.com/p/74554876</a></p><h1 id="DS-专用服务器"><a href="#DS-专用服务器" class="headerlink" title="DS 专用服务器"></a>DS 专用服务器</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/networking-overview-for-unreal-engine#%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">网络概述官方文档</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://www.bilibili.com/video/BV1mP4y1R7UR/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【[UOD2022]虚幻DS的机遇与挑战 | 晶核 刘豪</a> </p><p>NetworkPrediction</p><h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241220222047918.png" alt="image-20241220222047918"></p><p>等级低只同步自己</p><p>把宠物，npc全放在逻辑服，不用同步</p><p>大世界网格小，副本网格范围大</p><p>摄像机背后的actor同步频率低</p><p>不移动的时候降低同步频率</p><p>把不需要同步的属性清理掉。</p><p>使用pushModel，手动标记哪些属性需要更新，这样就不需要同步所有的信息</p><h3 id="物理计算优化"><a href="#物理计算优化" class="headerlink" title="物理计算优化"></a>物理计算优化</h3><p>服务器剔除角色身上所有的装饰器组件</p><p>服务器关闭动画计算，只有业务需要具体坐标时才计算。</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="如何关闭滚动条的显示？"><a href="#如何关闭滚动条的显示？" class="headerlink" title="如何关闭滚动条的显示？"></a>如何关闭滚动条的显示？</h3><p>调用方法<strong>SetScrollBarVisibility</strong>。参数是<a href="https://link.zhihu.com/?target=https://docs.unrealengine.com/en-US/API/Runtime/UMG/Components/ESlateVisibility/index.html">ESlateVisiblity</a>，设成<strong>Collapsed</strong>即可。</p>]]></content>
    
    
    <summary type="html">UE知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>试玩的一些推箱子游戏记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/</id>
    <published>2024-12-12T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:39.971Z</updated>
    
    <content type="html"><![CDATA[<p>记录试玩的一些推箱子的idea，希望自己以后也能做出这种puzzle</p><h1 id="箱子联动"><a href="#箱子联动" class="headerlink" title="箱子联动"></a>箱子联动</h1><p>两个双重箱子会联动，并且推墙也会联动</p><p><a href="https://moonsoup.itch.io/sea-snake-safari">https://moonsoup.itch.io/sea-snake-safari</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121116554.png" alt="image-20241117121116554"></p><h1 id="组合箱子"><a href="#组合箱子" class="headerlink" title="组合箱子"></a>组合箱子</h1><p>需要通过拼接箱子的四个边来解谜，而且还能进入箱子里面来实现一些很有意思的操作</p><p><a href="https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09">https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121232954.png" alt="image-20241117121232954"></p><h1 id="推箱子点亮房间"><a href="#推箱子点亮房间" class="headerlink" title="推箱子点亮房间"></a>推箱子点亮房间</h1><p><a href="https://theconspiracy.itch.io/single-screen-scream">https://theconspiracy.itch.io/single-screen-scream</a></p><p>是一个迷宫类的游戏，把箱子推到对应的上面会点亮某个房间的地图，你需要自己画一下这个地图的结构，并且来搞</p><p>代码点评：他的代码太粗暴，每一个level都写了对应的操作，或许这个不太适合用这个编辑器来做，直接用引擎来写会更加简洁，不过创意不错</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121317837.png" alt="image-20241117121317837"></p><h1 id="改变关卡然后再推箱子"><a href="#改变关卡然后再推箱子" class="headerlink" title="改变关卡然后再推箱子"></a>改变关卡然后再推箱子</h1><h2 id="任意的位置"><a href="#任意的位置" class="headerlink" title="任意的位置"></a>任意的位置</h2><p><a href="https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3">https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3</a></p><p>需要先规定步数把关卡的墙壁消除，然后再推箱子，这个引擎竟然还可以这样有先后顺序，非常神奇啊，等等研究一下是怎么搞的， 相当牛逼啊</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117124647189.png" alt="image-20241117124647189"></p><h2 id="变身成铲子来改变，位置是有限的"><a href="#变身成铲子来改变，位置是有限的" class="headerlink" title="变身成铲子来改变，位置是有限的"></a>变身成铲子来改变，位置是有限的</h2><p><a href="https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea">https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea</a></p><p>这个需要捡起铲子来改变地形，会有不同，和自由的不太一样，设计思路也不太一样</p><p>他这个代码也很简单，因为他的规则集很统一，写的很好这个代码，三百行就搞定了</p><p>还讲了个小故事，不赖</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118232458914.png" alt="image-20241118232458914"></p><h2 id="场景中的物体也可以自己编辑"><a href="#场景中的物体也可以自己编辑" class="headerlink" title="场景中的物体也可以自己编辑"></a>场景中的物体也可以自己编辑</h2><p><a href="https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0">https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0</a></p><p>比如这一关是如何把这个小点搞出来</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118235755770.png" alt="image-20241118235755770"></p><h2 id="推箱子本身会改变路"><a href="#推箱子本身会改变路" class="headerlink" title="推箱子本身会改变路"></a>推箱子本身会改变路</h2><p><a href="https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab">https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab</a></p><p>箱子本身是一条以自身为中心的十字路，推箱子会改变主人公能走的位置，要通过这个推完成目标</p><p>关卡有点少，只有四关</p><p>一边推一边思考路的过程还是挺有趣的，要考虑的东西有点意思</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085156436.png" alt="image-20241119085156436"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119083807340.png" alt="image-20241119083807340"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084051277.png" alt="image-20241119084051277"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084505536.png" alt="image-20241119084505536"></p><h1 id="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"><a href="#改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径" class="headerlink" title="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"></a>改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径</h1><p><a href="https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337">https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337</a></p><p>会变成像素的数字，这个是可以走的路，蛮有意思</p><p>如果你吃的一瞬间路变没了，你也会死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119100230326.png" alt="image-20241119100230326"></p><h1 id="会连接在一起的箱子，而且中间的线也会挡住东西"><a href="#会连接在一起的箱子，而且中间的线也会挡住东西" class="headerlink" title="会连接在一起的箱子，而且中间的线也会挡住东西"></a>会连接在一起的箱子，而且中间的线也会挡住东西</h1><p>有点拓扑结构的意思</p><p><a href="https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0">https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117155008183.png" alt="image-20241117155008183"></p><h1 id="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"><a href="#推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物" class="headerlink" title="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"></a>推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物</h1><p><a href="https://notaninart.itch.io/pushing-u">https://notaninart.itch.io/pushing-u</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117163406595.png" alt="image-20241117163406595"></p><h1 id="箱子连接，但是本身自己也可以变成箱子，也可以解冻"><a href="#箱子连接，但是本身自己也可以变成箱子，也可以解冻" class="headerlink" title="箱子连接，但是本身自己也可以变成箱子，也可以解冻"></a>箱子连接，但是本身自己也可以变成箱子，也可以解冻</h1><p><a href="https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29">https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29</a></p><p>非常巧妙，自己可以被冰冻变成箱子，也可以解冻，很地狱笑话，被冰冻才能上飞机，太幽默了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118155250549.png" alt="image-20241118155250549"></p><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h1><p><a href="https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259">https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259</a></p><p>推动国际象棋的棋子，目标是走到对面的皇后位置，不能走到能被吃的位置，但是可以推动棋子可以把推动的棋子给杀了。</p><p>感觉可以做一个中国象棋版的来尝试复刻一下</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117221156115.png" alt="image-20241117221156115"></p><h1 id="有步数限制的推箱子"><a href="#有步数限制的推箱子" class="headerlink" title="有步数限制的推箱子"></a>有步数限制的推箱子</h1><p><a href="https://galactical.itch.io/at-the-hedges-of-time">https://galactical.itch.io/at-the-hedges-of-time</a></p><p>很好理解，也很简单的创意，一个trick的点是箱子不会随着自己回退</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118145646564.png" alt="image-20241118145646564"></p><h1 id="箱子本身是一个能和周围互动的装置"><a href="#箱子本身是一个能和周围互动的装置" class="headerlink" title="箱子本身是一个能和周围互动的装置"></a>箱子本身是一个能和周围互动的装置</h1><p><a href="https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5">https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5</a></p><p>按下开关之后箱子会动，会把自己往什么某个方向推，碰撞体积也会发生改变，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118171505291.png" alt="image-20241118171505291"></p><p>其实有些关设计的挺有意思的，因为你需要反复来回来利用本身他之后弹开的位置来占住那个开关，然后再去推，这样其实有一种联动的感觉，后面感觉会有那种一下联动好几个然后按顺序搞的感觉，感觉很有意思</p><h1 id="保龄球推箱子"><a href="#保龄球推箱子" class="headerlink" title="保龄球推箱子"></a>保龄球推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9">https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9</a></p><p>推的目标箱子推一次会一直往前滚，所以需要用生成的反射东西来组装好路径来搞，设计的比较简单，但是还是挺有意思的，和我们做的反射光的游戏甚至有点像，他里面有一分为二，还有生成东西的道具</p><p>但是他的关卡太简单了，不够多</p><p>而且他这个能推很多次，如果做成只推一次，会好很多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118201017238.png" alt="image-20241118201017238"></p><p>他的还有一个机制是遇到已经放好的花朵会导致提前停下，或许就是因为这一点所以他没有做一击通关，这样难度会很高</p><h1 id="不能自己往上的推箱子"><a href="#不能自己往上的推箱子" class="headerlink" title="不能自己往上的推箱子"></a>不能自己往上的推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb">https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb</a></p><p>因为主角是一个落叶，所以做了往上方向的限制，只能通过喷泉来往上，这种限制也蛮有意思的。但是可以同时推多个箱子，也要利用这个。</p><p>还有一个机制，在水里的话就可以往上推，可以借助水的浮力，比如这一关就是这样</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118234135382.png" alt="image-20241118234135382"></p><h1 id="推箱子和一笔画？"><a href="#推箱子和一笔画？" class="headerlink" title="推箱子和一笔画？"></a>推箱子和一笔画？</h1><p><a href="https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729">https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729</a></p><p>规则很简单，往某个地方推会朝那个方向生成一个箱子，目标是把所有的红色都占满</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085545410.png" alt="image-20241119085545410"></p><h1 id="箱子的状态会被改变（火）"><a href="#箱子的状态会被改变（火）" class="headerlink" title="箱子的状态会被改变（火）"></a>箱子的状态会被改变（火）</h1><p><a href="https://rosden.itch.io/theflames">https://rosden.itch.io/theflames</a></p><p>被火烧了会有几个状态，中间有四步移动的机会，这时候不会完全变成灰烬，还可以被推，可以用来填补空洞；之后会变成灰烬，不能被推动，也不会挡路（第一关就是教你这个，不挡路）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119092837131.png" alt="image-20241119092837131"></p>]]></content>
    
    
    <summary type="html">itch许多类推箱子游戏的游玩记录，总结一下他们的创意</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>我的独立游戏作品合集</title>
    <link href="https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/"/>
    <id>https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/</id>
    <published>2024-10-27T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:41.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完美世界GameJam"><a href="#完美世界GameJam" class="headerlink" title="完美世界GameJam"></a>完美世界GameJam</h1><p>开发日期：2024.3.15</p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a></p><p>一个关于骰子的肉鸽游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"></a></p><h1 id="2024CigaGamejam"><a href="#2024CigaGamejam" class="headerlink" title="2024CigaGamejam"></a>2024CigaGamejam</h1><p>主题：有限与无限</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">试玩连接</a></p><p>一个关于1v3的不对成派对游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"></a></p><h1 id="2024下半年Booom"><a href="#2024下半年Booom" class="headerlink" title="2024下半年Booom"></a>2024下半年Booom</h1><p>主题：change_,not change _</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">试玩连接</a></p><p>一个类似卡坦岛的生存游戏，美术不错</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"></a></p><h1 id="2024TapTapGameJam"><a href="#2024TapTapGameJam" class="headerlink" title="2024TapTapGameJam"></a>2024TapTapGameJam</h1><p>主题：light</p><p>开发日期：2024.10.25-11.1</p><p><a href="https://rorschachandbat.itch.io/lightpuzzle">试玩连接</a></p><p>一个关于光线解密的游戏，尝试着用ai+godot开发，完成度不错，关卡设计的很有意思</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"></a></p>]]></content>
    
    
    <summary type="html">放一个合集，欢迎大家试玩</summary>
    
    
    
    <category term="随笔" scheme="https://rorschachandbat.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>落井下食开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-02T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p class="note note-primary">为了避免危险，你需要派遣伙伴们去合适的地方，它们会帮助你，□□食物，应对晚上的客人。 夜晚来临时，客人们会依次到来，你只需要提供它们需要的食物，它们就会满意的离开。</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png" alt="img"></a></p><h1 id="Luban导表工具"><a href="#Luban导表工具" class="headerlink" title="Luban导表工具"></a>Luban导表工具</h1><p>这次的项目需要填数据的地方非常多，有了上次做肉鸽小游戏的教训，决定搜寻一下有无更加好用的导表工具，最终找到了luban工具，算是比较方便好用的实现方案。</p><p><a href="https://github.com/focus-creative-games/luban">官方链接</a></p><p>作为一个需要大量配表的游戏，最理想的情况是，策划端只需要用excel就可以搞定，程序端也不需要编写处理db的代码，导表工具会自动生成相应的代码。</p><p>具体的例子直接看文档大概能看的明白，当然也有一些实现的非常草率的地方，</p><p>1.无法动态修改数据，就只能重新创建一个一模一样的结构体，因为他自己生成的结构式是read only的，无法实现修改，感觉这个也是可以细想怎么优雅实现的。</p><p>2.没有加数据校验功能，后期策划在编写的时候会出现填错的情况。</p><p>3.excel表无法实现比较复杂的数据结构。</p><h1 id="JKFrame"><a href="#JKFrame" class="headerlink" title="JKFrame"></a>JKFrame</h1><p><a href="http://www.yfjoker.com/JKFrame/">JKFrame使用手册</a></p><p>本次09老师使用了JKFrame作为编程框架，使用起来比较方便，相当于多了一些库，直接用事件系统和ui系统都很方便，以后也可以多用这个框架尝试。</p><h1 id="六边形地图设计"><a href="#六边形地图设计" class="headerlink" title="六边形地图设计"></a>六边形地图设计</h1><p>六边形地图不能直接用二维坐标来表示，并且因为本次项目不需要动态生成，所以就直接在ui上硬编码了整个地图，感觉更加正常的做法是用tilemap，但是因为时间紧迫所以全部都用ui来做了，之后这里可以研究一下如何更优雅的实现这种六边形地图。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png" alt="坐标参考"></a></p><p>坐标参考</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png" alt="demo图"></a></p><p>demo图</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png" alt="最后的成品"></a></p><p>最后的成品</p><p><a href="https://www.redblobgames.com/grids/hexagons/">六边形地图理论基础</a></p><p><a href="https://indienova.com/u/npc233/blogread/11298">六边形地图坐标距离计算（直接看结论版）</a></p><p>计算距离，像这样的坐标体系，有x,y,z三个维度，x,y,z的和始终是0，我们称之为cube坐标，距离计算公式是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br><br>TS<br>diatance=<span class="hljs-built_in">max</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))<br><br>TS<br>func <span class="hljs-built_in">posDistance</span>(pos1,pos2):<br>    <span class="hljs-selector-tag">var</span> cubePos1=<span class="hljs-built_in">getCubePosFromPos</span>(pos1)<br>    <span class="hljs-selector-tag">var</span> cubePos2=<span class="hljs-built_in">getCubePosFromPos</span>(pos2)<br>    <span class="hljs-selector-tag">var</span> distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br>    return distance<br><br>CPP<br></code></pre></td></tr></table></figure><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这次项目作为一个ui游戏，简单的使用了MV框架，前期实现整体游戏循环的过程很快，到后面开始拼ui的时候其实有很大的沟通失误，缺少一个统筹规划工作量的人，来预估这个完成的时间。我自己心目中的完成时间点和实际的完全不一样，比如说地图，到了最后几天才分配给我做，我本以为是第二个周末就能完成的事情，我觉得09花了太多的时间来重构代码，并且重构之后也没经过测试，这个风险非常大，我个人认为应该先保证所有功能都完备了再进行重构的工作，不然卡在这里也无法进行下一步的推进。</p><p>其实这又是一个沟通问题，如果没有一个责任人站出来，那么我就会倾向于摆烂，并且祈祷或者默认其他人能完成，这就导致了我们最后ui和玩法上还有很多bug没修完，如果倒数第二个周末就有人站出来规划好预计的时间，或许最后交上去的结果会好很多。</p><h2 id="测试以及策划功能优先级问题"><a href="#测试以及策划功能优先级问题" class="headerlink" title="测试以及策划功能优先级问题"></a>测试以及策划功能优先级问题</h2><p>再来讲讲测试的问题，理想的情况是做完一个功能就马上有人来验收，并且这个人是知道所有的功能细节，这样是效率最高的测试方法，所以要么是程序自测，要么是策划验收，如果再找一个测试来验收就还需要和他沟通具体的细节。</p><p>但是中期出现的问题是，队伍策划需要干的事情实在<strong>太多了</strong>，既要设计玩法，还要调整数值，还要设计ui，还要验收功能。但是这些事情我认为应该是有优先级的，应该是要保证完成游戏完整性而服务，也就是设计ui和验收功能为更优先，因为这些都是会影响其他人的工作流的，一旦这个地方卡住了，其他人就要<strong>等待这里完成</strong>，会陷入到无事可干，并且必须要完成好最终确定的游戏，才能开始跑游戏测试数值。</p><p>而关于数值设计，既然我们已经分离开了数据和玩法，大可之后再根据测试的反馈来更改数值，数值设计应该也是需要有一套<strong>方法论</strong>的，这个是需要思考学习的。</p><h2 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h2><p>在前期的设计阶段，我总是觉得已有的玩法过于简单，能够一眼望穿，所以提出了很多想要增加策略性的建议，比如增加道具种类，地图增加走格子玩法，白天从三个动物变成牌组的形式，但其实最后做下来，看玩家的反馈已经足够复杂。我开始意识到我走入了一个非常大的误区，作为开发者，对于自己的游戏当然足够熟悉，所以总是会觉得过于简单，而失去了站在旁观者来审视游戏复杂度的能力，很容易把游戏玩法膨胀得很难。当然，这也和我前面提到的<strong>快速测试并且验证思路</strong>有关，总是因为我们没有快速验证的过程，所以会让我有这种恐慌。</p><h2 id="主题和音乐和美术"><a href="#主题和音乐和美术" class="headerlink" title="主题和音乐和美术"></a>主题和音乐和美术</h2><p>这次游戏的另一个教训是有关于游戏的其他方面，我总是太过于在于游戏机制的设计，但是忽略了其他人看中的部分，比如主题、美术和音乐的统一性，ui设计的合理性，还是提到的一点，每个人对于jam最终作品的想象不一样，我所追求的是一个好玩的东西。但是可能其他人更愿意的是一个完整的作品，一个从机制到主题到美术音乐统一并且完整的作品，那就必然牺牲一部分有趣度的考量，而</p><p>这点以后要改进的是，和别人一开始就要沟通清楚<strong>自己的愿景</strong>，这样才能共同朝着一个方向努力。</p><h1 id="获得的一些灵感"><a href="#获得的一些灵感" class="headerlink" title="获得的一些灵感"></a>获得的一些灵感</h1><p><strong>西西弗斯</strong><br>糯米团子，做一个自动放置小游戏，不过是翻山，讽刺一下西西弗这个意象。</p><p><strong>todolist直接改的模拟经营</strong><br>模拟经营，但是像babaisyou一样，目标是可以根据自己的东西来拖动的，比如需要10个肉直接变成需要10个草。</p><p><strong>放置挂机+自走棋</strong></p><p>白天放置挂机拿资源，晚上自走棋战斗，更加纯粹简单的快乐。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次作品的完整性还是相当高的，作为一个三周的作品美术音乐音效玩法都非常融洽，给自己朋友家人试玩也是相当开心，作为自己第一个完整度这么高的作品也是相当开心了。真的相当感谢队友们的付出，队友们都非常给力，性格也相当nice，沟通起来都非常舒服，感谢队友的配合，学到了很多，希望以后能再次合作。</p><h1 id="还需要研究的问题"><a href="#还需要研究的问题" class="headerlink" title="还需要研究的问题"></a>还需要研究的问题</h1><p>1.六边形地图如何优雅实现</p><p>2.导表的问题</p><p>3.学习数值设计方法论</p><p>4.如何导网页端游戏</p>]]></content>
    
    
    <summary type="html">2024下半年Booom参赛作品</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png" alt="image-20240901211645122"></a></p><p>image-20240901211645122</p><p>游戏玩法是1v3的不平衡对抗，每局游戏开始前每个人都会随机到一个关于自身能力的一个buff和一个debuff（比如跳跃次数增加和奔跑速度变慢），人类方的</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>这次比赛的主题是limited and limitless，所以我一开始想的是，给玩家可以自由调控自己的任何能力值，比如奔跑速度，跳跃高度，跳跃次数，冲刺距离……但是你加了一方面的buff，就要选择另一个其他的debuff，然后设计一系列的关卡，看你如何通过你的搭配来最快的过关。这个核心规则比较简单但是变化也相当多，不过被否定了，理由是1.在这种现场试玩做这种一次性的解密游戏很容易让游戏失去游戏性，因为别人看一次就知道怎么玩了，2.可能没有那么多时间来设计关卡。所以他们最后还是决定做一个party game。</p><h1 id="Corgi引擎"><a href="#Corgi引擎" class="headerlink" title="Corgi引擎"></a>Corgi引擎</h1><p><a href="https://corgi-engine-docs.moremountains.com/">corgi引擎文档</a></p><p>先说下corigi引擎的优点，有非常多已经实现的平台跳跃功能，包括丰富的平台，以及人物不同的能力（飞翔，滑翔背包，冲刺），这些都是以</p><h1 id="编码思路和组件思维"><a href="#编码思路和组件思维" class="headerlink" title="编码思路和组件思维"></a>编码思路和组件思维</h1><h1 id="水面shader"><a href="#水面shader" class="headerlink" title="水面shader"></a>水面shader</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png" alt="一开始的效果"></a></p><p>一开始的效果</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png" alt="加了水面shader的效果"></a></p><p>加了水面shader的效果</p><p>一开始的加一个镜面反射和流动水的效果，就好看许多</p><h1 id="测试暴露的问题"><a href="#测试暴露的问题" class="headerlink" title="测试暴露的问题"></a>测试暴露的问题</h1><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>最理想的情况是策划来进行这个关卡的设计，但因为这次的策划是一个比较新手的人，到了最后也没能成功下载unity，并且也没有任何设计关卡的经验，所以只能由我自己来拼一个关卡了。</p><p>我的设计思路是观看我最喜欢的partygame，move or die的一些地图，然后再摆出目前能实现的平台：长条，斜坡，弹跳蘑菇，下落方块，（和mod里面差的也就是一个传送门）当然corgi里面还实现了很多其他平台效果但是都因为我们缺少美术就没有做了，根据</p><h2 id="跳跃手感"><a href="#跳跃手感" class="headerlink" title="跳跃手感"></a>跳跃手感</h2><p>作为一个平台跳跃，跳跃手感是至关重要的，一个很重要的标准是，就算没有任何的关卡，没有任何的剧情，你只需要操控着你的角色跑一下挑一下，如果你觉得很畅快那就是一个好的手感，</p><p>关于手感有许多很好的视频，</p><p><a href="https://www.bilibili.com/video/BV1M441197sr/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【游戏制作工具箱】《蔚蓝》的手感为何迷人？</a></p><p><a href="https://www.bilibili.com/video/BV15C411r7Ju/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【GMTK|中英字幕】马里奥跳跃的秘密</a></p><p>事实上corgi游戏里面已经对跳跃的参数给了很多自由的参数，比如</p><h2 id="试玩的插曲"><a href="#试玩的插曲" class="headerlink" title="试玩的插曲"></a>试玩的插曲</h2><p>线下试玩非常有趣，遇到了一个非常精通平台跳跃的玩家，蔚蓝打通c面的那种，我和他1v1打了许久，一开始我想着让一下他，不要打消他的热情，但是再玩了几把之后我发现是他是真的很强，所以索性放开了跟他玩，但是他还是偶尔能赢，不过由于某些关卡设计和机制设计，让他随机到了只能跳一次就基本赢不了，所以我索性在给他开放了冲刺的功能，让他</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>corgi引擎</p><h2 id="体量"><a href="#体量" class="headerlink" title="体量"></a>体量</h2><p>人手还是不够，这次光是画好人物和boss就已经差不多了，关卡的布置只能自己来搞了，所以做的不是特别好。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计问题也有很多，比如一开始说到的只能四个人玩，导致在现场体验的时候很难凑到四个人，这点还是致命伤啊。</p>]]></content>
    
    
    <summary type="html">2024CigaGamejam</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-08-31T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"></a></p><p>首先简单介绍一下游戏玩法，你和boss会轮流骰两个骰子，你需要选择是分开触发骰子还是合成触发，比如扔到4和6，你可以选择触发4扇区和6扇区，也可以选择只触发10扇区，每个扇区的牌有主动效果和被动效果，自己回合触发的是主动效果，boss回合触发的被动效果，当然每个回合还可以买牌，所以是一个需要你控制概率的肉鸽游戏。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"></a></p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a>(温馨提示，此版本未经过任何的数值调整，平衡和体验都及其不成熟)</p><h1 id="灵感和讨论过程"><a href="#灵感和讨论过程" class="headerlink" title="灵感和讨论过程"></a>灵感和讨论过程</h1><p>本次gamejam的主题是做你想做的游戏，并且也不要求你做出一个可玩的游戏，你做出关于游戏的ppt就能算完成。由此可见完美这次压根就不是想做一个jam，而是抱着一种想要偷你点子给公司赚钱的目的，所以我们索性就做一个自己想玩的游戏算了。</p><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h1 id="技能设计"><a href="#技能设计" class="headerlink" title="技能设计"></a>技能设计</h1><h1 id="dotween"><a href="#dotween" class="headerlink" title="dotween"></a>dotween</h1><h1 id="桌游转电子游戏的痛点和思考"><a href="#桌游转电子游戏的痛点和思考" class="headerlink" title="桌游转电子游戏的痛点和思考"></a>桌游转电子游戏的痛点和思考</h1><p>桌游的乐趣和电子游戏的乐趣非常难转换，桌游的乐趣在于与人互动，虽然也有很多自闭刷分的游戏，但是也是要与人交互的，他要求人与人之间是平等的决策思路，而单机游戏如果简单的转换成打boss，那就会变得很不一样，相当难转换，这就是为什么很多桌游的机制不能用在电子游戏上来，当然这个是一个值得持续思考的问题。</p><h1 id="题外话和八卦"><a href="#题外话和八卦" class="headerlink" title="题外话和八卦"></a>题外话和八卦</h1><p>非常可笑的是，做完jam的第二周，我就被通知优化了，真是唏嘘啊。</p>]]></content>
    
    
    <summary type="html">在完美的最后一舞</summary>
    
    
    
    <category term="游戏锐评" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>UE引擎LGUI框架记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.262Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注册事件的写法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在EventDefine.ts里添加对应的枚举和interface</span><br><br><span class="hljs-title class_">GuideGroupOpening</span>, <span class="hljs-comment">//引导组打开</span><br>    <br>[<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideFocusNeedUiTabView</span>]: <span class="hljs-function">(<span class="hljs-params">stepInfo: GuideStepInfo, focusConf: GuideFocusNew</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>        <br><span class="hljs-comment">// 在对应的Controller的OnAddEvents和OnRemoveEvents添加</span><br>        <br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Add</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Remove</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><br><br><span class="hljs-comment">// 在对应的Model代码添加触发器</span><br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Emit</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Owner</span>!.<span class="hljs-property">Id</span>, isPreExecute);<br></code></pre></td></tr></table></figure><h1 id="LGUI在TS中的绑定写法"><a href="#LGUI在TS中的绑定写法" class="headerlink" title="LGUI在TS中的绑定写法"></a>LGUI在TS中的绑定写法</h1><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>prefab会有一个LGUIComponentsRegistry组件，定义了引用的顺序，例如：</p><p><img src="C:\Users\jiangliyong\AppData\Roaming\Typora\typora-user-images\image-20240619141651430.png" alt="image-20240619141651430"></p><p>然后在OnRegisterComponen方法里面按照熟悉绑定即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">ButtonMask</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextName</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextureBg</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UITexture</span>],<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p><a href="https://kurogame.feishu.cn/wiki/LR2lwhGmci2wxGk0ISPcCp9Enwf">‌⁠‬‌‬‬‬﻿‬﻿‌‌‍‌‬﻿﻿‬⁠‍﻿LGUI设计说明文档 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcn93vYNH8Hduj3SAJaSPuG8f">‌﻿﻿‍⁠⁠‬‬﻿‬﻿‍‬‬‌‍﻿‌‌‌Ts Ui框架说明 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/JicQw8apsiUMXukKIhacLdNInYf">‌⁠‌‬﻿‬‍﻿‌⁠‍‌⁠﻿⁠﻿‌‌⁠‌⁠‌‌‍‬‍‌﻿业务UI框架重构 - 飞书云文档 (feishu.cn)</a></p><p>一些关键的基类：ComponentAction（所有UI类和UIBehavior类的共同最终基类，实现了一套带状态的生命周期调度和可重载接口）、UIPanelBase（提供给小UI，即界面中的格子、小界面等继承，拥有丰富的UI相关操作能力）、UIViewBase（提供给界面继承，它本身也继承自UIPanelBase，在其上扩展了动画、场景、事件、读取UI配置表的能力），继承关系ComponentAction-&gt;UIPanelBase-&gt;UIViewBase</p><p>UiPanelBase.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">ComponentRegisterInfos</span>: <span class="hljs-title class_">TComponentsRegisterInfo</span>[] = [];<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">BtnBindInfo</span>: <span class="hljs-title class_">TBtnBindInfo</span>[] = []; <span class="hljs-comment">//所有按钮绑定事件的定义</span><br><br><span class="hljs-comment">// 重写OnRegisterComponent方法</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CgTextureBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CaptionText</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnAuto</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIItem</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnHide</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        ];<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>生命周期函数（带Async是异步版本）</p><p>OnRegisterComponent：绑定具体界面定义的enum里面的控件。</p><p>OnAddEventListener：添加ui事件监听，按钮啥的</p><p>控件相关的api在UIItem.d.ts里面</p><p>比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetButton</span>(<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>)!.<span class="hljs-property">RootUIComp</span>.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="预制体中组件的显示与隐藏"><a href="#预制体中组件的显示与隐藏" class="headerlink" title="预制体中组件的显示与隐藏"></a>预制体中组件的显示与隐藏</h1><p>SetUIActive</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetItem</span>(<span class="hljs-title class_">ETutorialsPopupComponents</span>.<span class="hljs-property">PnlBottom</span>)!.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="UI动画调用"><a href="#UI动画调用" class="headerlink" title="UI动画调用"></a>UI动画调用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelSequencePlayer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">RootItem</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Start&#x27;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Loop&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="游戏中LGUI层级结构"><a href="#游戏中LGUI层级结构" class="headerlink" title="游戏中LGUI层级结构"></a>游戏中LGUI层级结构</h1><p><a href="https://kurogame.feishu.cn/wiki/wikcntd0SV4OAJV1fG3Md9LxpHV">‌‍‍‌⁠‌﻿⁠‌﻿‬⁠﻿⁠‍‬⁠‌‌‌‍﻿‌‍‌⁠﻿UI层级节点描述文档，包含容器逻辑实现规则 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnNqg8wjO5u8dNApZbfzoJMe">屏幕空间UI层级说明 - 飞书云文档 (feishu.cn)</a></p><h2 id="Hud层"><a href="#Hud层" class="headerlink" title="Hud层"></a>Hud层</h2><p>交互和剧情界面旁白</p><h2 id="Normal层"><a href="#Normal层" class="headerlink" title="Normal层"></a>Normal层</h2><p>常规系统界面，只显示最表面的界面</p><h2 id="NormalMask层"><a href="#NormalMask层" class="headerlink" title="NormalMask层"></a>NormalMask层</h2><p>Normal层的点击阻挡遮罩</p><h2 id="Pop层"><a href="#Pop层" class="headerlink" title="Pop层"></a>Pop层</h2><p>可交互弹窗</p><h2 id="Float层"><a href="#Float层" class="headerlink" title="Float层"></a>Float层</h2><p>飘字和提示</p><h2 id="NetWork层"><a href="#NetWork层" class="headerlink" title="NetWork层"></a>NetWork层</h2><p>网络提示相关的ui</p><h2 id="Mark层"><a href="#Mark层" class="headerlink" title="Mark层"></a>Mark层</h2><p>以上所有层的点击阻挡遮罩</p><h2 id="Pool层"><a href="#Pool层" class="headerlink" title="Pool层"></a>Pool层</h2><p>对象池界面，优化性能使用</p><h1 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h1><p>使用AudioSystem</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">const LOOP_DIGITAL_SCREEN = <span class="hljs-string">&#x27;play_ui_digital_screen&#x27;</span><span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.PostEvent(LOOP_DIGITAL_SCREEN)<span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.ExecuteAction(LOOP_DIGITAL_SCREEN, UE.EAudioActionType.Stop)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="修改某一个组件的具体参数"><a href="#修改某一个组件的具体参数" class="headerlink" title="修改某一个组件的具体参数"></a>修改某一个组件的具体参数</h1><p>使用SetCustomMaterialScalarParameter，这里要用到FName</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> factor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-title class_">FName</span>(<span class="hljs-string">&#x27;factor&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetCustomMaterialScalarParameter</span>(<br>            factor,<br>            <span class="hljs-title class_">ModelManager</span>.<span class="hljs-property">DigitalScreenModel</span>?.<span class="hljs-property">TextFactor</span> ?? <span class="hljs-number">0.2</span>,<br>        );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UE引擎LGUI框架记录</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>鸣潮体验报告</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:40.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h1><p>经过这一个月的体验，优点和缺点都挺明显的，一度也非常上头，优点就是战斗机制，动作，以及声骸系统比较有趣，缺点就是有一些玩法的手感和设计体验可以改进，以下是一些具体的讲述。</p><h1 id="战斗"><a href="#战斗" class="headerlink" title="战斗"></a>战斗</h1><h2 id="动作系统设计"><a href="#动作系统设计" class="headerlink" title="动作系统设计"></a>动作系统设计</h2><p>战斗的深度还是比较丰富的，有闪避，拼刀，普攻，重击，声骸技能，小技能，大招，换人技能，绳索，跳跃，而且基本所有动作都可以取消，这就给动作系统延伸了很多深度，给了玩家很多进阶技巧的可能，比如跳跃：比如各种换人使用声骸技能无限上天或者一路冲过去不落地，这都是非常有意思的技巧，我觉得官方甚至可以在大地图上放一些只能通过这些特殊技巧才能到达的地点，然后放一些小奖励，作为彩蛋来奖励掌握了这些深度技巧的玩家，类似马里奥奥德赛会在一个非常难跳上去的地方放一堆金币。</p><p>又比如战斗的时候卡延奏技能来打破怪物的拼刀圈，这是非常爽的，有一瞬间打出高伤害的快感。</p><h2 id="战斗模式"><a href="#战斗模式" class="headerlink" title="战斗模式"></a>战斗模式</h2><p>不同的模式侧重点不一样，比如深塔要求速通，可能连招拉怪就比较固定，讲究效率；全息挑战有一种魂类的感觉，一板一眼不能乱吃一招；肉鸽要求策略搭配，随机的快乐。这些战斗模式可以满足不同玩家的需求，</p><h3 id="深塔挑战"><a href="#深塔挑战" class="headerlink" title="深塔挑战"></a>深塔挑战</h3><p>限时挑战</p><h3 id="大boss挑战"><a href="#大boss挑战" class="headerlink" title="大boss挑战"></a>大boss挑战</h3><p>这个主要是通过增加数值来增加玩家的失误惩罚，但是血太厚了也有点无力感，毕竟也有限时的要求，感觉可以把限时给去掉，让人有刮死的可能</p><h3 id="肉鸽"><a href="#肉鸽" class="headerlink" title="肉鸽"></a>肉鸽</h3><p>我非常喜欢肉鸽模式，套路成型之后非常有一种割草的爽感，其中的乌龟套盾流更是相当的爽，只要能拿到满血加攻击力暴击这个buff就能无脑割草。</p><p>目前的肉鸽模式中，有两个build的方向，一个是凑词条来解锁开局带的声骸的技能上限，一个是选buff来产生combo，个人认为前者build起来后比较爽， 无论是化身无冠者战斗还是乌龟套盾都很快乐，但是后者的buff有点过于平淡普通了，大多是简单的加伤害暴击这些数值上的buff，非常简单粗暴，希望接下来可以出一些机制上的buff，这样可以加深肉鸽的策略深度。</p><p>还有一点的话是否可以开启无尽模式，让大家来多爽一下构建好的build。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>游戏整体的开图比较偏向于强引导，前期的各种boss都是通过支线任务引导见面的，支线任务有些太套路化了， 每次结束都是打一个新的boss，毫无新鲜感，而且这也破坏了玩家自主探索地图的过程。</p><p>另外一个破坏探索感的点是，打开地图可以直接看到所有的塔和传送点，或许这是因为出于剧情和难度考虑，不过对于我来说，因为地图上的传送点完全可以在地图上预览到，这就完全失去了开图的乐趣。并且也让地图设计的动线流程，引导全部失去了作用。</p><p>我的开图体验就是标一个还没开的点，然后直直的跑过去，途中如果有正好的宝箱会开一下，但是不会在意其他东西，然后面对着全部打开的地图，就失去了逛街的欲望；或许是不是可以让玩家自己选择游戏模式，可以把未知的传送点和塔设置为隐藏，这样或许能达到我一开始玩塞尔达的那种体验，追着高高的塔去探索，只知道一个大致的方向，然后中途被各种有趣的东西吸引，结果越走越远，越走越分叉，当然这也要求地图上的东西足够有趣，</p><h1 id="任务-amp-剧情"><a href="#任务-amp-剧情" class="headerlink" title="任务&amp;剧情"></a>任务&amp;剧情</h1><p>我觉得加了直接跳过有点破坏体验，中间有很多支线任务我都是直接全部跳过剧情，然后前往下一个点按一下f，或者打一下怪，游戏变成了一个大大的to-do list，并且显示十分枯燥，真就变成了一只在斯金纳箱的小白鼠，一直不停的跳过跳过只为了最后的奖励。</p><p>所以我觉得加剧情梗概或者快进是一个非常重要的功能，既能让玩家感受到剧情也能减负。或者可以考虑做一个galgame里面常见的历史对话，让玩家可以自己读跳过的对话。</p><h1 id="养成玩法"><a href="#养成玩法" class="headerlink" title="养成玩法"></a>养成玩法</h1><p>能养成的丰富度还是有的，人物等级，人物命座，武器等级，人物技能，声骸等级，声骸初始属性，声骸升级词条；其中声骸相关的是刷的重点，不过声骸的刷要从能稳定出金才开始，也就是大概数据坞18级（记不太清了），所以前三十级升声骸比较亏，因为无法把别的词条转移。</p><p>除了声骸是赌博玩法之外其他都是看得见的积累，这一点相对来说比较没那么坑，但是后续的数值养成是否会深度不够？不过这个方面我也不太懂。</p><h1 id="解谜和小玩法"><a href="#解谜和小玩法" class="headerlink" title="解谜和小玩法"></a>解谜和小玩法</h1><h2 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h2><p>这个玩法比较有趣，一笔画，其实可以借鉴一下the witness或者mini metro这些一笔画游戏，可以把这个趣味性做的更有深度。</p><h2 id="2d玩法"><a href="#2d玩法" class="headerlink" title="2d玩法"></a>2d玩法</h2><p>凌阳任务有一段转变成2d的玩法，这一段挺有意思，但是跳跃和冲刺的手感有点打磨不够好，跳起来感觉轻飘飘的，冲刺的速度没有明显加速，似乎是直接把3d里面的跳跃和冲刺参数直接拿过来，而且似乎没有土狼时间，所以导致跑起来手感很奇怪。</p><p>我觉得2d玩法挺有意思的，一开始3d转2d的时候非常有意思，之后如果有想法可以多做一些这种关卡和解谜，参考fez和马里奥奥德赛。</p><h2 id="找金币跑酷"><a href="#找金币跑酷" class="headerlink" title="找金币跑酷"></a>找金币跑酷</h2><p>每次遇到这个玩法我都无法收集完全部的金币，体验比较差，能否能在玩法开始前拉一个远镜头，告诉玩家大概得路线是怎样的，或者对于一些比较长的路线做一个预览图，告诉玩家路线。可以参考马里奥奥德赛里面的金币收集小玩法，还有一个</p><h2 id="声骸玩法"><a href="#声骸玩法" class="headerlink" title="声骸玩法"></a>声骸玩法</h2><p>变身成声骸跑酷还是比较有意思的，很有马里奥奥德赛里面附身变身的快乐，不过做的玩法有好有坏，以下是简单点评。</p><h3 id="蝴蝶"><a href="#蝴蝶" class="headerlink" title="蝴蝶"></a>蝴蝶</h3><p>这个玩法在电脑上体验一开始上手有点反逻辑，因为从wasd控制方向直接变成了鼠标完全控制方向，键盘仅仅用于加减速，而且某些移动靶想要完美通过的接口确实比较难。不过这个思路是挺有趣的，相对的变身成河豚跑酷就好很多。</p><h3 id="河豚"><a href="#河豚" class="headerlink" title="河豚"></a>河豚</h3><p>这个操作感就好一点，并且喷水加速的感觉很有奥德赛里面的变身成墨鱼喷水加速飞天的感觉，所以玩起来很快乐。</p><h3 id="鸟追逐战"><a href="#鸟追逐战" class="headerlink" title="鸟追逐战"></a>鸟追逐战</h3><p>一开始知道支线能变身鸟飞来作战非常期待，但是实际玩起来有点失望， 因为不用自己控制方法，只需要点击左键攻击和放大招就完事了，少了一点操纵感，如果未来还要类似的可以考虑增加玩家的操作维度。</p><h3 id="蜥蜴烧荆棘"><a href="#蜥蜴烧荆棘" class="headerlink" title="蜥蜴烧荆棘"></a>蜥蜴烧荆棘</h3><p>我记得一开始遇到一个荆棘挡路的时候，下意识地用了蜥蜴喷火的声骸技能，结果真的烧起来了，这个一开始见到还是比较经验的，颇有塞尔达点火射箭然后解谜过关的感觉，但是后面很多次我想继续重复这个知识，结果只能用旁边的爆炸球来解决眼前的荆棘，这个体验有点不好。</p><h3 id="未来可能"><a href="#未来可能" class="headerlink" title="未来可能"></a>未来可能</h3><p>未来是否有可能在大世界里加入更多声骸玩法，类似帕鲁，或者奥德赛这样直接变身声骸赶路，或者做一些特定解谜，然后把跑酷玩法手感优化。</p><h3 id="3d限时跑酷"><a href="#3d限时跑酷" class="headerlink" title="3d限时跑酷"></a>3d限时跑酷</h3><h2 id="音游"><a href="#音游" class="headerlink" title="音游"></a>音游</h2><p>手机上体验有一个反直觉的点，我一开始以为可以直接按中间的下落界面来操作，类似节奏大师，但是结果只有右下角的按钮才能响应操作，很奇怪，期待之后能做出更多音游玩法。</p><h2 id="控物填满拼图"><a href="#控物填满拼图" class="headerlink" title="控物填满拼图"></a>控物填满拼图</h2><p>这个玩法不太行， 主要是因为控物的操作太复杂了，首先这不是一个一眼能看出的谜题，所以就需要比较多的试错，传统的拼图puzzle一般是直接用鼠标拖动，这样试错起来就很简单，但是大世界里面采用控物来拼图，不仅要求对准，而且旋转和放下的操作也很缓慢，所以就很容易让人很暴躁，可以考虑简化操作。这个玩法的两个，打通光路和拼石头都比较体验不好。</p><p>其实控物这个操作还是挺有意思，但是操作感太差了，我一开始下意识以为能像王国之泪那样调整远近啊，旋转啊这样，但是其实并没有做到，希望未来可以改进，或许可以加入更多相关的解谜玩法。</p>]]></content>
    
    
    <summary type="html">鸣潮体验报告</summary>
    
    
    
    <category term="游戏锐评" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Unity相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/</id>
    <published>2024-04-11T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:37.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/20201004160417460.png"></p><p><strong>1、静态构造函数</strong><br>当程序集被加载的时候就被调用了，如果你的unity处于编辑状态时，此时你保存一个脚本（从而迫使重新编译），静态构造函数会立即被调用，因为unity加载了DLL。并且它将不会再次运行，永远只会执行一次，unity运行时，是不会再次执行了！在一个已部署的游戏上，这个构造器将会在unity加载过程的早期被调用！</p><p><strong>2、Awake</strong><br>只会被调用一次，在Start方法之前被调用！ 主要用于字段值的初始化工作，禁用脚本，创建游戏对象，或者 Resources.Load(Prefab) 对象</p><p><strong>3、Start</strong><br>只执行一次，在Awake方法执行结束后执行，但在Update方法执行前执行， 主要用于程序UI的初始化操作，比如获取游戏对象或者组件</p><p><strong>4、Update</strong><br>每一帧执行的，监听用户输入，播放动画，当机器忙或者性能差的时候，他会停止执行，会产生停顿的感觉，例如一个人本来在1米的位置，突然到了5米的位置上，产生了跳帧，而下面的FixedUpdate方法则相反！会一米一米的去执行！（自己调试发现，Update是先于OnGUI执行的，且执行一次Update之后，会执行两次OnGUI）</p><p><strong>5、FixedUpdate</strong><br>不管当前机器忙不忙，都会保证每一帧执行一次！避免跳帧！固定更新。固定更新常用于移动模型等操作。</p><p><strong>6、LateUpdate</strong><br>先执行Update，然后才去执行lateUpdate(Update方法执行完，必定接着执行LateUpdate，而Update和FixedUpdate方法的执行顺序不确定，而且有时候FIxedUpdate执行了多帧，而Update却只执行了一帧，这就是因为跳帧的缘故造成的（取决于你的机器性能）！)，如果现在有100个脚本，分别有100个 Update()函数，其中只有一个LateUpdate，那么在同一帧中，等待100个Update()执行完后，才执行这一个LateUpdate()。</p><p><strong>7、OnGUI</strong><br>在这里面进行GUI的绘制，且GUI是每帧擦除重绘的！仅仅只是绘制！没有生命周期的概念！所有关于绘制GUI的代码，都要直接或者间接地写到OnGUI方法中！</p><p><strong>8、OnDestroy</strong><br>当前脚本销毁时调用</p><p><strong>9、OnEnable</strong><br>脚本可用时被调用、如果脚本是不可用的，将不会被调用！</p><p><strong>11、OnDisable</strong><br>如果脚本被设置为不可用将会被执行，程序结束时可用的脚本也会执行一次这个方法</p><p>OnEnable 和 OnDisable 只受脚本的可用状态的影响（enabled）,而 OnBecameVisible 和 OnBecameInvisible 是受对象是否可见的影响！即使脚本设置为不可用，OnBecameVisible 和 OnBecameInvisible 也会被执行，主要是看对象是否在场景中显示了！</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ugui"><a href="#ugui" class="headerlink" title="ugui"></a>ugui</h2><h3 id="rebatch和rebuild"><a href="#rebatch和rebuild" class="headerlink" title="rebatch和rebuild"></a>rebatch和rebuild</h3><p><a href="https://zhuanlan.zhihu.com/p/266997416">Unity UI 优化学习总结 - 天欲雪的文章 - 知乎</a></p><p><strong>Canvas</strong>（画布），和名字一样，是 UI 绘制的地方，Unity 的渲染系统用其来提供一个可绘制的分层几何。负责将ui几何合批成适合的网格，提交绘制命令给 Unity 的图形系统，这整个过程叫做 <strong>rebatch</strong> 或者 <strong>batch build</strong>。当 Canvas 其子节点下包含 Canvas Renderer 的节点需要进行 rebatch 的时候，就会被标记为脏。</p><p>Graphic 与 Layout 都依赖于 CanvasUpdateRegistry 类。它会定位 Graphic 与 Layout 是否需要更新并加入更新队列，在所在 Canvas 的 willRenderCanvases 事件被触发时对队列中的对象执行真正的更新。</p><h2 id="图集有什么用，适用场景。"><a href="#图集有什么用，适用场景。" class="headerlink" title="图集有什么用，适用场景。"></a>图集有什么用，适用场景。</h2><p>定义<br>图集是将很多零碎的2D小图整合成一张大图，方便unity渲染合批，降低渲染消耗。</p><p>优势<br>1.UI的合批处理，减少DrawCall</p><p>多张图片需要多次DrawCall，合并成一张大图只需要调用一次DrawCall</p><p>2.减少对内存的占用</p><p>OpenGL每张贴图都需要设置为2的N次方才能使用，假设有宽高分别为100x100、10x10的两张图片，如果不合成大贴图，那么就需要分别使用128x128和16x16的图片，会浪费一部分内存空间。</p><p>如果是使用一张大图的话，就可以将两张图片打到128x128的图集，进而减少内存的占用。</p><p>3.提升效率</p><p>图片尺寸为2的次幂时，GPU处理起来会快很多，小图不可能做不到每张图都是2的次幂的，但打成一张大图就可以。<br><a href="https://blog.csdn.net/z2014z/article/details/119654256">https://blog.csdn.net/z2014z/article/details/119654256</a></p><h2 id="屏幕自适应方案"><a href="#屏幕自适应方案" class="headerlink" title="屏幕自适应方案"></a>屏幕自适应方案</h2><p>canvas scaler</p><p>锚点</p><h1 id="批处理和drawcall"><a href="#批处理和drawcall" class="headerlink" title="批处理和drawcall"></a>批处理和drawcall</h1><p><a href="https://zhuanlan.zhihu.com/p/432223843">Unity渲染优化的4种批处理：静态批处理，动态批处理，SRP Batcher 与 GPU Instancing - acnestis的文章 - 知乎</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f5b8402d281543a9debe941f9762889a_r.jpg" alt="img"></p><h1 id="常用的Unity-Atrribute"><a href="#常用的Unity-Atrribute" class="headerlink" title="常用的Unity Atrribute"></a>常用的Unity Atrribute</h1><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>unity脚本生命周期函数。</p><p>Lerp作用</p><p>欧拉角计算，Quaternio.Euler。</p><p>常用的Unity Atrribute</p><p>如何判断是否碰到了场景中的物体？</p><p>Coroutine有什么用，优缺点</p><p>发生碰撞的必要条件。</p><p>ugui如何保证分辨率改变ui大小不变。</p><p>C#List底层数据结构，增加和删除时间复杂度。</p><p>结构体和类的区别。</p><p>引用类型和值类型分别有哪些。</p><p>装箱和拆箱是什么，为什么不要频繁适用?</p><p>简单用代码实现一个单例模式。</p><p>观察模式读代码写结构，用在哪里？</p><p>频繁地对字符串进行分割，写一个代码。（就是分数比如说100000，分成100,000这样）</p><p>分批手段和适用场景。</p><h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>渲染管线就是一系列处理数据的过程</p><h2 id="应用程序阶段"><a href="#应用程序阶段" class="headerlink" title="应用程序阶段"></a>应用程序阶段</h2><p>Unity会知道要渲染哪些模型，还有光源相机的信息也会输入进去，然后就会进行剔除，使用AABB包围盒，只要有一个顶点在摄像机的可视范围里面，就不会剔除，然后把这些输入进GPU里面。</p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><p>这个阶段是可以编程写shader的阶段，主要是把空间中的网格顶点编程屏幕上的网格顶点。顶点着色器，对每一个顶点都进行操作，可以简单的传递到下一个阶段，也可以做一些几何变换或者光源颜色相关的变换。</p><p>细分着色器，几何着色器，图元装配</p><p><img src="https://pic4.zhimg.com/v2-470a9d8b774085665f07fae572cc933f_1440w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">Unity知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-游戏相关的一些知识</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</id>
    <published>2024-04-10T16:00:00.000Z</published>
    <updated>2025-01-09T16:25:38.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h1><p><a href="https://www.cnblogs.com/indream/p/3602348.html">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a></p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h2><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-cc979056c26b13f1e63233776fa9e8ad_720w.webp" alt="img"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f49989545904a5b8f3338ab64806450e_720w.webp" alt="img"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-88c91a4203fe50c44ed366de25ee577d_720w.webp" alt="img"></p><h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><p>一种比较简单计算并且比较自然的曲线的方式，利用插值的方式</p><p>博客教程：<a href="https://www.cnblogs.com/msxh/p/6270468.html">https://www.cnblogs.com/msxh/p/6270468.html</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/798142-20170114161306385-735353264.jpg" alt="img"></p><h1 id="游戏AI"><a href="#游戏AI" class="headerlink" title="游戏AI"></a>游戏AI</h1><p>比较常见的有状态机，行为树，效用系统，目标导向</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h2><p>一个比较简单的改进方案是分层状态机，比如把巡逻的都放在一个大的巡逻里面</p><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h2><p>行为树是树型结构的，每个节点都代表了一个行为，每个行为都可以有子行为。</p><p>所有行为都有一个先决条件，就是产生的这些行为的条件。</p><p>整个算法先从树的根部开始，然后开始检查每一个先决条件。树的每一层只可以执行一个行为，所以当一个行为正在执行，它的兄弟节点都不会被检查，但是它们的子节点还是要检查的。相反如果一个行为的先决条件当前并不满足，则跳过判断它的子节点，继续判断它的兄弟节点。一个树全部检查完毕之后，决定执行优先级最大的，然后再依次执行每个动作。</p><p>不同于状态机，行为树是无状态的，不需要记下之前执行的行为，只是判断行为该不该执行。</p><p>行为树的节点之间是不相关的，删除或增加节点，对其他节点都无影响。所以，可扩展性也是行为树的一个优势。另外还可以为决策树添加灵活性与随机性，父节点可以随机决定是否检查子节点。</p><ul><li>序列（Sequence）节点：顺序执行所有子节点返回成功，如果某个子节点失败返回失败。</li><li>循环（Loop）节点：循环执行子节点到指定次数后返回成功，如果循环次数为-1，则无限循环。</li><li>条件（Condition）节点：根据条件的比较结果，返回成功或失败。</li><li>动作（Action）节点：根据动作结果返回成功，失败，或运行。</li><li>等待（Wait）节点：当指定的时间过去后返回成功。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-c4b17080b7a4f12e765fc52edbfbdd4f_720w.webp" alt="img"></p><h2 id="效用系统"><a href="#效用系统" class="headerlink" title="效用系统"></a><strong>效用系统</strong></h2><p>所以有些情况，只是做这些布尔判断是不合适的，会遗漏很多情况，判断也不妥当。比如：我们可能需要同时考虑与敌人的距离、有多少弹药、饥饿程度、HP值，等等。这些判断条件能映射出许多动作，比我们单一的判断做不做这个动作要好很多。utility-based system，基于效用的系统，会根据权重、比率、队列和许多需要考虑的事项来做出最优选择，使AI比普通的行为树更有头脑。根据上面的例子，使用效用系统我们的AI可以做出我们想要的动作，并根据当前情况做出不同强度的动作，使AI真实、更具可能性，也不再是只有一个正确的选择了。决策树就是对AI说，“只是你将要做的一个行为”，效用系统就是对AI说：“这些是你可能要做的行为”</p><h2 id="目标导向型"><a href="#目标导向型" class="headerlink" title="目标导向型"></a><strong>目标导向型</strong></h2><p>GOAP来源于STRIPS方法，这两种都是让AI创造他们自己的方法去解决问题，我们提供给它一系列可能的动作作为对这个世界的描述，和每个动作使用的先决条件，和行动带来的影响。AI拥有一个初始状态和他需要达到的目标。有一组目标，AI可以通过优先级或当前状态选择一个。计划系统决定一个动作序列来满足当前目标，计划出一个像路径一样的能最简单达到目标状态的动作序列。</p><p>GOAP是一个反向链接搜索，从要实现的目标开始，找到什么动作能实现目标，在寻找刚才动作的先决条件，一直往前推，知道达到你的当前（初始）状态。这种反向链接搜索替代了启发式的前向链接搜索。</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p><a href="https://blog.codingnow.com/2018/08/lockstep.html">lockstep 网络游戏同步方案-云风blog</a></p><p><a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/164686867">细谈网络同步在游戏历史中的发展变化（中） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下） - 网易游戏雷火事业群的文章 - 知乎</a></p><h2 id="帧同步如何要实现什么东西"><a href="#帧同步如何要实现什么东西" class="headerlink" title="帧同步如何要实现什么东西"></a>帧同步如何要实现什么东西</h2><h3 id="确定性的数学和物理运算框架"><a href="#确定性的数学和物理运算框架" class="headerlink" title="确定性的数学和物理运算框架"></a>确定性的数学和物理运算框架</h3><p>计算逻辑采用定点数</p><p>逻辑层表现层分离，表现层可以浮点数</p><h3 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h3><p>UDP加冗余包来保证可靠性</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><h3 id="比赛回放"><a href="#比赛回放" class="headerlink" title="比赛回放"></a>比赛回放</h3><h3 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h3><h1 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><h3 id="描述一下A-算法"><a href="#描述一下A-算法" class="headerlink" title="描述一下A*算法"></a>描述一下A*算法</h3><ol><li>把起点加入 open list 。</li><li>重复如下过程：</li></ol><p>a.         遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。</p><p>b.         把这个节点移到 close list 。</p><p>c.         对当前方格的 8 个相邻方格的每一个方格？</p><p>◆     如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。</p><p>◆     如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。</p><p>◆     如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。</p><p>d.    停止条件</p><p>◆     把终点加入到了 open list 中，此时路径已经找到了，或者</p><p>◆     查找终点失败，并且 open list 是空的，此时没有路径。</p><ol start="3"><li>保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。</li></ol><p>F &#x3D; G + H</p><p>这里，</p><p>G &#x3D; 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。</p><p>H &#x3D; 从指定的方格移动到终点 B 的估算成本。这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 ) 。</p><h3 id="openlist和closelist的作用？"><a href="#openlist和closelist的作用？" class="headerlink" title="openlist和closelist的作用？"></a>openlist和closelist的作用？</h3><p>openlist就是还要搜索的列表，相比于dfs的盲目搜索更加有效率，</p><p>closelist就是已经搜过的或者不可搜的节点，加速过程。</p><h1 id="红点系统"><a href="#红点系统" class="headerlink" title="红点系统"></a>红点系统</h1><p><a href="https://zhuanlan.zhihu.com/p/85978429">Unity手游实战：从0开始SLG——独立功能扩展（三）用树实现客户端红点系统 - 放牛的星星的文章 - 知乎</a></p><p>规划红点系统的时候，我们将整个系统分为独立的三个部分：结构层、驱动层和表现层。</p><p>结构层用来部署红点的层级结构，使用树结构。</p><p>驱动层是指，如何驱动这个树结构产生状态变化，以及状态变化之后如何将变化的行为通知到指定的表现层，在一定的程度上将数据和表现分离开。</p><p>表现层就专门承担表现的职责，比如有的红点就是一个单纯的红点，有的需要显示数字，有的可能是图标晃动，有的是显示new标签，有的是播放特效等等。这些都可以归属在表现层统一去管控。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="https://zhuanlan.zhihu.com/p/23821422">【游戏设计模式】之四 《游戏编程模式》全书内容提炼总结 - 毛星云的文章 - 知乎</a></p><p><a href="https://gpp.tkchu.me/architecture-performance-and-games.html">游戏设计模式</a></p><p>要结合项目中能用到的东西来记忆 </p><h2 id="一、常用GOF设计模式"><a href="#一、常用GOF设计模式" class="headerlink" title="一、常用GOF设计模式"></a>一、常用GOF设计模式</h2><h3 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式"></a>1.命令模式</h3><h3 id="2-享元模式"><a href="#2-享元模式" class="headerlink" title="2.享元模式"></a>2.享元模式</h3><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><h3 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5.单例模式"></a>5.单例模式</h3><h3 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6.状态模式"></a>6.状态模式</h3><h2 id="二、序列型模式"><a href="#二、序列型模式" class="headerlink" title="二、序列型模式"></a>二、序列型模式</h2><h3 id="7-双缓冲模式"><a href="#7-双缓冲模式" class="headerlink" title="7.双缓冲模式"></a>7.双缓冲模式</h3><h3 id="8-游戏循环"><a href="#8-游戏循环" class="headerlink" title="8.游戏循环"></a>8.游戏循环</h3><h3 id="9-更新方法"><a href="#9-更新方法" class="headerlink" title="9.更新方法"></a>9.更新方法</h3><h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><h3 id="10-字节码"><a href="#10-字节码" class="headerlink" title="10.字节码"></a>10.字节码</h3><h3 id="11-子类沙箱"><a href="#11-子类沙箱" class="headerlink" title="11.子类沙箱"></a>11.子类沙箱</h3><h3 id="12-类型对象"><a href="#12-类型对象" class="headerlink" title="12.类型对象"></a>12.类型对象</h3><h2 id="四、解耦型模式"><a href="#四、解耦型模式" class="headerlink" title="四、解耦型模式"></a>四、解耦型模式</h2><p>这个更加像是写代码的方法论。</p><h3 id="13-组件模式"><a href="#13-组件模式" class="headerlink" title="13.组件模式"></a>13.组件模式</h3><h3 id="14-事件队列"><a href="#14-事件队列" class="headerlink" title="14.事件队列"></a>14.事件队列</h3><h3 id="15-服务定位器"><a href="#15-服务定位器" class="headerlink" title="15.服务定位器"></a>15.服务定位器</h3><h2 id="五、优化型模式"><a href="#五、优化型模式" class="headerlink" title="五、优化型模式"></a>五、优化型模式</h2><p>这个可能更偏向于应用。</p><h3 id="16-数据局部性"><a href="#16-数据局部性" class="headerlink" title="16.数据局部性"></a>16.数据局部性</h3><h3 id="17-脏标识模式"><a href="#17-脏标识模式" class="headerlink" title="17.脏标识模式"></a>17.脏标识模式</h3><p>有一些更新很需要花时间的数据，每次循环的时候，加一个标志，如果没有改变就不tick这里。</p><h3 id="18-对象池模式"><a href="#18-对象池模式" class="headerlink" title="18.对象池模式"></a>18.对象池模式</h3><h3 id="19-空间分区"><a href="#19-空间分区" class="headerlink" title="19.空间分区"></a>19.空间分区</h3><h1 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h1><p>ORCA</p>]]></content>
    
    
    <summary type="html">一些乱七八糟的东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
</feed>
