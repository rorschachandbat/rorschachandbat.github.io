<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>R</title>
  
  
  <link href="https://rorschachandbat.github.io/atom.xml" rel="self"/>
  
  <link href="https://rorschachandbat.github.io/"/>
  <updated>2024-12-24T15:51:46.379Z</updated>
  <id>https://rorschachandbat.github.io/</id>
  
  <author>
    <name>R</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动作游戏的方方面面</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</id>
    <published>2024-12-23T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.379Z</updated>
    
    <content type="html"><![CDATA[<p>动作游戏系统设计</p><p>镜头选型，运动系统，输入模块，战斗能力。</p><h1 id="战斗系统？"><a href="#战斗系统？" class="headerlink" title="战斗系统？"></a>战斗系统？</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>好的攻击方式应该兼具优点和缺点，比如范围大那么久伤害低，伤害高但是攻速慢，或者需要某些特定的资源，或者具有冷却时间</p><p>攻速其实是动画的帧动画</p><p>前摇，判定和后摇</p><p>动画取消</p><p>范围：吸附的范围</p><p>不同的按键组合是不同的攻击方式，当然也可以是和位置不同而变化，比如背刺之类的。</p><h2 id="连招"><a href="#连招" class="headerlink" title="连招"></a>连招</h2><p>一定顺序，准确时机可以打出不同的连招</p><h2 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h2><p>防御或者闪避</p><p>弹反和招架：有可能过于强大，让整个游戏都变成了等待</p><p>可以增加弹反惩罚，或者限制弹反次数，或者降低弹反收益：比如只是单纯地给一点子弹时间。</p><p>当然你也要防止你的玩家完全不防御，防止让他一直压制敌人，比如给怪加体力条，体力条没了才能僵直，或者让他面对很多个怪物。</p><p>好的动作游戏，应该鼓励玩家在攻击和防守之间积极地变换。</p><h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><p>敌人的进攻应该有明显的提示，比如画面之类的。</p><p>并且最好不要设计成单一武器才能杀死的敌人 </p><p>如何鼓励玩家进攻多样而不是复读？</p><p>连击有特殊动画，或者直接设计连击分数（比如鬼泣或者猎天使魔女），还有受伤掉分</p><p>如果程序检测到玩家复读某一招，可以相对应地用表现得不一样，这些可以给玩家他适应了你的打法一样（街霸的ai也有类似的感觉，可以学习）</p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>巨大的前摇+飞速的打击动作+判定帧短暂的暂停+后摇缓慢的回复</p><p>刀光特效</p><p>震动屏幕</p><p>爽快的音效</p><h1 id="打击感-1"><a href="#打击感-1" class="headerlink" title="打击感"></a>打击感</h1><p><a href="https://www.bilibili.com/video/BV1g741157RC/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【暖风游戏厅】打击感是如何炼成的</a> </p><p>攻击角色击中被击角色的瞬间，游戏给玩家的反馈所形成的的体验。</p><p>打击感是击中的瞬间，手感是玩家输入的瞬间</p><p>被击动作、特效、静止帧、音效和振动</p><h2 id="被击动作"><a href="#被击动作" class="headerlink" title="被击动作"></a>被击动作</h2><p>首先是攻击动作和被击动作要匹配，方向和力度。</p><p>被击动作需要播放地够快。</p><p>如果是一个很大的boss，可以考虑做局部肢体的抖动。对骨骼施加物理力，然后和动作进行融合，这样做不会让被击方停止动作，一举两得。</p><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><p>最重要的功能是告诉玩家自己的攻击击中了，必须及时，准确和明显。</p><p>两种比较常见的，爆炸和飙血。前者是拳脚或者钝器（街霸），后者是利器（血缘）</p><h2 id="静止帧"><a href="#静止帧" class="headerlink" title="静止帧"></a>静止帧</h2><p>用来模拟现实打击中的顿滞感，拳头和钝器会慢一点，利器会快一点。也和敌人属性有关，比如穿了厚重的铠甲就会慢一点，破衣服就快一点。</p><p>全局或者局部</p><p>全局是整个游戏都暂停，局部是只用双方暂停。</p><p>战神利用了ik（反向动力学）来制作静止帧，斧子在击中敌人的一瞬间会卡肉，然后手臂会继续运动，直到一定程度才会完成打击动作。</p><h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><p>依旧是合适和及时，不同属性不同力度要对应。</p><h2 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h2><h2 id="另一种理解"><a href="#另一种理解" class="headerlink" title="另一种理解"></a>另一种理解</h2><p>打击感是一瞬间的信息和力度，要专注这一瞬间的反馈。</p><p>命中</p><p>信息：信息要准确，丰富有层次</p><p>强度：强度要有对比，要有层次和疏密，最重要的是符合直觉</p><p>连招开启的卡肉，就像街霸里的确认一样，用来告诉你你可以开始爽快的连招了</p><p>第一法则：“0延迟”的即时反馈 </p><p>第二法则：制造预期，让玩家有所期待 </p><p>第三法则：符合预期，回应玩家的期待 </p><p>第四法则：简洁：明了清晰，弱化不必要的 </p><p>第五法则：夸张：强化重要的 </p><p>第六法则：回味：让玩家有时间和机会回味，延长令玩家愉悦的感觉 </p><p>第七法则：拟真：真实感的模拟（如果你不知道从什么地方开始，那么就向大自然和实际生活学习）</p><h1 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h1><p>重点是解决一下三个问题：</p><p><strong>如何让玩家探索战胜敌人的方式？</strong></p><p>敌人的形象设计；攻击提示；仇恨范围；攻击欲望；连招系统；战斗策略；指令输入；能力限制一级敌我对等程度；对峙突围能力……</p><p><strong>如何让玩家不断磨练自己的技术</strong></p><p>角色的成长策略；获胜的条件；游戏综合速度；不同情绪切换；基础物理法则；战场结构；纵向层次；角色能力提升曲线与自我技术革新……</p><p><strong>如何让玩家不会轻易放弃？</strong></p><p>游戏的核心挑战；次要挑战；游戏整体难度；死亡机制与死亡惩罚；角色的容错率；玩家的学习曲线；玩家操纵角色的综合能力……</p><h1 id="难度曲线"><a href="#难度曲线" class="headerlink" title="难度曲线"></a>难度曲线</h1><p>确保每一种类型的玩家都有自己的乐趣所在，初学者，玩家和大师</p><h1 id="进阶循环"><a href="#进阶循环" class="headerlink" title="进阶循环"></a>进阶循环</h1>]]></content>
    
    
    <summary type="html">总结一下一个好的动作游戏的方方面面</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Lua高性能编程</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Lua%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h1><p>在代码运行前，Lua会把源码预编译成一种中间码，类似于Java的虚拟机。这种格式然后会通过C的解释器进行解释，整个过程其实就是通过一个while循环，里面有很多的switch…case语句，一个case对应一条指令来解析。</p><p>自Lua 5.0之后，Lua采用了一种类似于寄存器的虚拟机模式。Lua用栈来储存其寄存器。每一个活动的函数，Lua都会其分配一个栈，这个栈用来储存函数里的活动记录。每一个函数的栈都可以储存至多250个寄存器，因为栈的长度是用8个比特表示的。</p><p>有了这么多的寄存器，Lua的预编译器能把所有的local变量储存在其中。这就使得Lua在获取local变量时其效率十分的高。</p><h2 id="使用local引用global变量"><a href="#使用local引用global变量" class="headerlink" title="使用local引用global变量"></a>使用local引用global变量</h2><p>Lua对本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&zhida_source=entity">局部变量</a>的访问是一个O(1)的操作（等价于一个数组地址+偏移），而global变量的获取需要一次<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=hash%E6%9F%A5%E6%89%BE&zhida_source=entity">hash查找</a>。local比global快很多（特别是在计算比较简单时，hash查找的开销反而是大头），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">sin</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>除了本地<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=local%E5%8F%98%E9%87%8F&zhida_source=entity">local变量</a>以外，upvalue的访问也比global快很多（访问上一层upvalue，等价于一次间接跳转之后再访问上一层函数的局部变量，基本还是一个O(1)的开销），比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="使用local缓存table查找结果"><a href="#使用local缓存table查找结果" class="headerlink" title="使用local缓存table查找结果"></a>使用local缓存table查找结果</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 30% faster</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">sin</span> = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sin</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> <span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>        x = x + <span class="hljs-built_in">sin</span>(i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="3R原则"><a href="#3R原则" class="headerlink" title="3R原则"></a>3R原则</h1><h2 id="Reducing"><a href="#Reducing" class="headerlink" title="Reducing"></a>Reducing</h2><p>避免创建新对象和节约内存</p><h3 id="把table变成数组"><a href="#把table变成数组" class="headerlink" title="把table变成数组"></a>把table变成数组</h3><h3 id="把常量对象的创建放在循环的外面"><a href="#把常量对象的创建放在循环的外面" class="headerlink" title="把常量对象的创建放在循环的外面"></a>把常量对象的创建放在循环的外面</h3><p>xxxxxxxxxx void Awake(){    objects &#x3D; new List<Transform>();}​void CreateObject(){    Transform t &#x3D; Instantiatie(prefab);    t.loactionPosition &#x3D; Random.insideUnitSphere * 5f;    t.locationRotation &#x3D; Random.rotation;    t.localScale &#x3D; Vector3.one * Random.Range(0.1f, 1f);    objects.Add(t);}c#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125; <span class="hljs-comment">--unnecessary redeclare</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> v = t[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span> <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">--这里每次循环会创建一个匿名函数对象</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b,func)</span></span><br>    <span class="hljs-keyword">return</span> func(a+b)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">local</span> func2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = func1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, fun2) <span class="hljs-comment">--重用循环外定义的func2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Reusing"><a href="#Reusing" class="headerlink" title="Reusing"></a>Reusing</h2><h3 id="复用对象"><a href="#复用对象" class="headerlink" title="复用对象"></a>复用对象</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123; year = i, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;) <span class="hljs-comment">--每次循环创建一个表</span><br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- good: 1000% faster</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> aux = &#123; year = <span class="hljs-literal">nil</span>, month = <span class="hljs-number">6</span>, day = <span class="hljs-number">14</span> &#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1970</span>, <span class="hljs-number">2000</span> <span class="hljs-keyword">do</span><br>    aux.year = i <span class="hljs-comment">-- 重用循环外定义的aux</span><br>    t[i] = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(aux)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="Recycling"><a href="#Recycling" class="headerlink" title="Recycling"></a>Recycling</h2><h3 id="避免GC对象的创建"><a href="#避免GC对象的创建" class="headerlink" title="避免GC对象的创建"></a>避免GC对象的创建</h3><p>string有intenalize管理的开销，table需要开辟内存，lua中所有的function都是闭包，创建开销也不低，此外它们都会增加gc的开销。</p><h3 id="传参时避免构造table"><a href="#传参时避免构造table" class="headerlink" title="传参时避免构造table"></a>传参时避免构造table</h3><p>参数的数量不多时，尽量用独立的变量传递参数，而非构造一个table。</p><h2 id="宿主语言接口调用"><a href="#宿主语言接口调用" class="headerlink" title="宿主语言接口调用"></a>宿主语言接口调用</h2><p>尽量在lua内部完成计算，调用宿主语言接口会带来明显的<a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&zhida_source=entity">上下文切换</a>开销，如果不是一个复杂的计算过程，不值的浪费这个开销。</p><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>Lua的表分为两个部分：数组(array)部分和哈希(hash)部分。数组部分包含所有从1到n的整数键，其他的所有键都储存在哈希部分中。</p><p>哈希部分其实就是一个哈希表，哈希表本质是一个数组，它利用哈希算法将键转化为数组下标，若下标有冲突(即同一个下标对应了两个不同的键)，则它会将冲突的下标上创建一个链表，将不同的键串在这个链表上，这种解决冲突的方法叫做：链地址法。</p><p>当我们把一个新键值赋给表时，若数组和哈希表已经满了，则会触发一个再哈希(rehash)。再哈希的代价是高昂的。首先会在内存中分配一个新的长度的数组，然后将所有记录再全部哈希一遍，将原来的记录转移到新数组中。新哈希表的长度是最接近于所有元素数目的2的乘方。</p><h2 id="创建table时初始化数据"><a href="#创建table时初始化数据" class="headerlink" title="创建table时初始化数据"></a>创建table时初始化数据</h2><p>为了减少不必要的内存开销，table在创建时不会分配任何额外内存，早期几个元素的插入都必然导致rehash操作，这个特性对小table的创建影响特别显著，创建时一并指定初始化数据可以避免rehash的开销。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- bad</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br>t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>t[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>t[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br> <br><span class="hljs-comment">-- good: 200% faster</span><br><span class="hljs-keyword">local</span> t = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="高效的遍历"><a href="#高效的遍历" class="headerlink" title="高效的遍历*"></a>高效的遍历*</h2><p>paris和iparis有函数调用的开销，因此效率不高。在性能敏感的场合，最好缓存table的size，然后使用for loop。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- pairs: 3.078 (217%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">--- ipairs: 3.344 (236%)</span><br><span class="hljs-keyword">for</span> j,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(a) <span class="hljs-keyword">do</span><br>    x=v<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,x do: 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,#atable do 1.422 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,#a <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- for i=1,atable_length do: 1.562 (110%)</span><br><span class="hljs-keyword">local</span> length = #a<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,length <span class="hljs-keyword">do</span><br>    x=a[i]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的插入"><a href="#高效的插入" class="headerlink" title="高效的插入*"></a>高效的插入*</h2><p>table.insert有函数调用的开销，因此性能不高。在性能敏感的场合，最好缓存table的size，然后指定下标赋值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- table.insert: 1.250 (727%)</span><br><span class="hljs-keyword">local</span> tinsert = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    tinsert(a,i)<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[i]: 0.172 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[i]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[#a+1]=x: 0.453 (263%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    a[#a+<span class="hljs-number">1</span>]=i<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- a[count++]=x: 0.203 (118%)</span><br><span class="hljs-keyword">local</span> count = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    d[count]=i<br>    count=count+<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="高效的unpack"><a href="#高效的unpack" class="headerlink" title="高效的unpack*"></a>高效的unpack*</h2><p>性能敏感的场合不要使用unpack，选择手动展开。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- with [ ]: 0.485 (100%)</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],a[<span class="hljs-number">3</span>],a[<span class="hljs-number">4</span>] )<br><span class="hljs-keyword">end</span><br> <br><span class="hljs-comment">-- unpack(): 1.093 (225%)</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">unpack</span> = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> x = <span class="hljs-built_in">min</span>( <span class="hljs-built_in">unpack</span>(a) )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="array或者hash"><a href="#array或者hash" class="headerlink" title="array或者hash*"></a><a href="https://zhida.zhihu.com/search?content_id=228328778&content_type=Article&match_order=1&q=array&zhida_source=entity">array</a>或者hash*</h2><p>table有array和hash两部分存储，一般来讲array的存储开销要比hash小一些，访问速度也比hash查找要快，可能的话尽量选array。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 使用hash，内存开销最大 400%</span><br>polyline = &#123;<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>  &#123;x= <span class="hljs-number">10.3</span>, y = <span class="hljs-number">18.3</span>&#125;,<br>  &#123;x= <span class="hljs-number">15.0</span>, y = <span class="hljs-number">98.5</span>&#125;,<br>&#125;  <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 使用数组，内存开销降低 250%</span><br>polyline = &#123;<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">98.5</span> &#125;,<br>  &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">18.3</span> &#125;,<br>  &#123; <span class="hljs-number">15.0</span>, <span class="hljs-number">98.5</span> &#125;,<br>  ...<br>&#125; <span class="hljs-comment">--(tables used: 1 + n)</span><br> <br><span class="hljs-comment">-- 还可以进一步减少table本身的内存开销，只3个table 100%</span><br>polyline = &#123;<br>  x = &#123; <span class="hljs-number">10.3</span>, <span class="hljs-number">10.3</span>, <span class="hljs-number">15.0</span>, ... &#125;,<br>  y = &#123; <span class="hljs-number">98.5</span>, <span class="hljs-number">18.3</span>, <span class="hljs-number">98.5</span>, ... &#125;<br>&#125; <span class="hljs-comment">--(tables used: 3)</span><br></code></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>与其他主流脚本语言不同的是，Lua在实现字符串类型有两方面不同。</p><p>所有的字符串在Lua中都只储存一份拷贝。当新字符串出现时，Lua检查是否有其相同的拷贝，若没有则创建它，否则，指向这个拷贝。这可以使得字符串比较和表索引变得相当的快，因为比较字符串只需要检查引用是否一致即可；但是这也降低了创建字符串时的效率，因为Lua需要去查找比较一遍。</p><p>第二，所有的字符串变量，只保存字符串引用，而不保存它的buffer。这使得字符串的赋值变得十分高效。例如在Perl中，$x &#x3D; $y，会将$y的buffer整个的复制到$x的buffer中，当字符串很长时，这个操作的代价将十分昂贵。而在Lua，同样的赋值，只复制引用，十分的高效。</p><p>但是只保存引用会降低在字符串连接时的速度。在Perl中，$s &#x3D; $s . ‘x’和$s .&#x3D; ‘x’的效率差距惊人。前者，将会获取整个$s的拷贝，并将’x’添加到它的末尾；而后者，将直接将’x’插入到$x的buffer末尾。</p><p>由于后者不需要进行拷贝，所以其效率和$s的长度无关，因为十分高效。</p><h2 id="缓存字符串"><a href="#缓存字符串" class="headerlink" title="缓存字符串"></a>缓存字符串</h2><p>避免在运行时构造字符串，尽量缓存那些常量字符串。</p><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>大字符串的拼接，使用table.concat。</p><p>在lua中可以用table来模拟buffer</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> s = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">30000</span> <span class="hljs-keyword">do</span><br>    t[#t+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">end</span><br>s = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(t, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="语言之外的东西"><a href="#语言之外的东西" class="headerlink" title="语言之外的东西"></a>语言之外的东西</h1><p>使用<a href="http://luajit.org/">LuaJIT</a>，LuaJIT可以使你在不修改代码的情况下获得平均约5倍的加速。查看LuaJIT在<a href="http://luajit.org/performance_x86.html">x86&#x2F;x64下的性能提升比</a>。</p><p>第二、将瓶颈部分用C&#x2F;C++来写。因为Lua和C的天生近亲关系，使得Lua和C可以混合编程。但是C和Lua之间的通讯会抵消掉一部分C带来的优势。</p>]]></content>
    
    
    <summary type="html">关于如何写Lua高性能编程的一些建议</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>基于蓝图的多人游戏玩法设计</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%9F%BA%E4%BA%8E%E8%93%9D%E5%9B%BE%E7%9A%84%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-21T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.130Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18Y41187vo/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2021]与众乐乐 - 基于蓝图的多人游戏玩法设计 | Epic Games 何骞</a> </p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221120244763.png"></p><p>复制Replication</p>]]></content>
    
    
    <summary type="html">一个关于如何用蓝图开发多人游戏的演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>UE蓝图开发最佳实践</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/%E8%93%9D%E5%9B%BE%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-12-20T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.364Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1oG411M7Y6/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">[UOD2022]蓝图开发最佳实践 | Epic 何骞</a> </p><h1 id="命名相关"><a href="#命名相关" class="headerlink" title="命名相关"></a>命名相关</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000001964.png"></p><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000142710.png"></p><p>减少冗余信息</p><h2 id="函数命名规则"><a href="#函数命名规则" class="headerlink" title="函数命名规则"></a>函数命名规则</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000236767.png"></p><h1 id="蓝图如何保持整洁"><a href="#蓝图如何保持整洁" class="headerlink" title="蓝图如何保持整洁"></a>蓝图如何保持整洁</h1><h2 id="避免过长的蓝图逻辑，屏幕长度有限"><a href="#避免过长的蓝图逻辑，屏幕长度有限" class="headerlink" title="避免过长的蓝图逻辑，屏幕长度有限"></a>避免过长的蓝图逻辑，屏幕长度有限</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000410021.png"></p><h2 id="事件左对齐"><a href="#事件左对齐" class="headerlink" title="事件左对齐"></a>事件左对齐</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000501706.png"></p><p>保证更改逻辑的时候不会改错</p><h2 id="通过Re-route来减少连线"><a href="#通过Re-route来减少连线" class="headerlink" title="通过Re-route来减少连线"></a>通过Re-route来减少连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000527244.png"></p><h2 id="避免错乱事件连线"><a href="#避免错乱事件连线" class="headerlink" title="避免错乱事件连线"></a>避免错乱事件连线</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000700985.png"></p><p>不要想到一个事件就立马create出来</p><h2 id="重用Getter或者Pure节点"><a href="#重用Getter或者Pure节点" class="headerlink" title="重用Getter或者Pure节点"></a>重用Getter或者Pure节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000813646.png"></p><h2 id="清晰的返回节点"><a href="#清晰的返回节点" class="headerlink" title="清晰的返回节点"></a>清晰的返回节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000841491.png"></p><p>越复杂的函数为什么return，为什么early return需要写清楚</p><h2 id="Select节点"><a href="#Select节点" class="headerlink" title="Select节点"></a>Select节点</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000918576.png"></p><p>Text替代String</p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221000954247.png"></p><h1 id="蓝图注释规则"><a href="#蓝图注释规则" class="headerlink" title="蓝图注释规则"></a>蓝图注释规则</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001053596.png"></p><h2 id="分不同的颜色，规则不一样"><a href="#分不同的颜色，规则不一样" class="headerlink" title="分不同的颜色，规则不一样"></a>分不同的颜色，规则不一样</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001141232.png"></p><h2 id="注释的细节"><a href="#注释的细节" class="headerlink" title="注释的细节"></a>注释的细节</h2><p><strong>每个事件都编写注释</strong></p><p><strong>Sequence的每一段都写注释</strong></p><p>把长的拆分成sequence也可以做</p><p><strong>为复杂的逻辑写注释</strong></p><p><strong>为复杂的函数返回写注释</strong></p><h1 id="如何创建稳固更新的生产线？"><a href="#如何创建稳固更新的生产线？" class="headerlink" title="如何创建稳固更新的生产线？"></a>如何创建稳固更新的生产线？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221001347062.png"></p><p>不是一开始就设计好，而是在项目进行到一定阶段在解耦。</p><p>不要复制黏贴，而是作为抽离成function</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>每次冷启动，可以通过log（Unreal Inside）来观察哪里加载的久。</p><p>以及每次添加新节点的时间</p><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p><strong>减少不必要的Cast，特别是复杂蓝图类的cast</strong>。</p><p><strong>用Gameplay Tag和blueprint Interface</strong></p><p><strong>活用命名空间</strong></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002004041.png"></p><p>可以规定某个蓝图这是哪种玩法会用到的，这样就可以减少加载</p><p><strong>减少Hard Reference</strong></p><p>因为每个hard Reference都会加载在内存里面，会影响包体大小，考虑用Tag或者Soft Reference来替换</p><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002514037.png"></p><p>一个比较好的方式是，脚本语言不去改蓝图function的实现，然后划分好哪些变量会修改，这样也可以作为一个新的category来分类</p><h2 id="蓝图审核"><a href="#蓝图审核" class="headerlink" title="蓝图审核"></a>蓝图审核</h2><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002854518.png"></p><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221002937518.png"></p><p>可以持续更新一个Best Practice文档</p><h1 id="编辑器拓展"><a href="#编辑器拓展" class="headerlink" title="编辑器拓展"></a>编辑器拓展</h1><p>Assest Action Utility（这里没太听懂，到时候学习一下）</p><h1 id="如何平衡蓝图和C-？"><a href="#如何平衡蓝图和C-？" class="headerlink" title="如何平衡蓝图和C++？"></a>如何平衡蓝图和C++？</h1><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241221003705495.png"></p><p><strong>不用过早优化</strong></p><p>因为变化可能很快</p><p><strong>有安全性问题的时候可以考虑转</strong></p><p>比如拿的很多信息不是在本地，而是要通过服务器来request，这种可能放在C++核心类比较好</p><p><strong>直接重定向</strong></p><p>在C++里面写一个<strong>MigrateProperty</strong>这样一个函数，可以把哪些变量，CDO准确的转化过来</p>]]></content>
    
    
    <summary type="html">一个关于如何有效率地编写蓝图演讲的笔记</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-垃圾回收</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2024-12-17T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>也是采用标记清除的方式，会从根出发，标记所有</p><h2 id="堆内存分配和回收机制"><a href="#堆内存分配和回收机制" class="headerlink" title="堆内存分配和回收机制"></a>堆内存分配和回收机制</h2><p>堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。</p><p>堆上的变量在存储的时候，主要分为以下几步：</p><ul><li>首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应的内存单元；</li><li>如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够的内存单元，则进行内存分配。</li><li>如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应的内存单元给变量。</li></ul><p>堆内存的分配有可能会变得十分缓慢，特别是需要垃圾回收和堆内存需要扩展的情况下。</p><h2 id="垃圾回收时的操作"><a href="#垃圾回收时的操作" class="headerlink" title="垃圾回收时的操作"></a>垃圾回收时的操作</h2><p>当一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。</p><p>每次运行GC的时候，主要进行下面的操作：</p><ul><li>GC会检查堆内存上的每个存储变量；</li><li>对每个变量会检测其引用是否处于激活状态；</li><li>如果变量的引用不再处于激活状态，则会被标记为可回收；</li><li>被标记的变量会被移除，其所占有的内存会被回收到堆内存上。</li></ul><p>GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。</p><h2 id="何时会触发垃圾回收"><a href="#何时会触发垃圾回收" class="headerlink" title="何时会触发垃圾回收"></a>何时会触发垃圾回收</h2><p>主要有三个操作会触发垃圾回收：</p><ul><li>在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；</li><li>GC会自动的触发，不同平台运行频率不一样；</li><li>GC可以被强制执行。</li></ul><h2 id="降低GC的影响的方法"><a href="#降低GC的影响的方法" class="headerlink" title="降低GC的影响的方法"></a><strong>降低GC的影响的方法</strong></h2><p>大体上来说，我们可以通过三种方法来降低GC的影响：</p><ul><li>减少GC的运行次数；</li><li>减少单次GC的运行时间；</li><li>将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC</li></ul><p>基于此，我们可以采用三种策略：</p><ul><li>对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。</li><li>降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存碎片。</li><li>我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响</li></ul><h2 id="降低GC的具体方法"><a href="#降低GC的具体方法" class="headerlink" title="降低GC的具体方法"></a>降低GC的具体方法</h2><h3 id="减少内存垃圾"><a href="#减少内存垃圾" class="headerlink" title="减少内存垃圾"></a>减少内存垃圾</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>比如循环不要每次都创建新的数组，而是提前创建好</p><h4 id="不要在频分调用的函数里面使用堆内存分配"><a href="#不要在频分调用的函数里面使用堆内存分配" class="headerlink" title="不要在频分调用的函数里面使用堆内存分配"></a>不要在频分调用的函数里面使用堆内存分配</h4><p>比如tick和update里面不要分配内存，而是在之前就创建好，或者通过定时器或者脏标记的方法来改进</p><h4 id="减少链表"><a href="#减少链表" class="headerlink" title="减少链表"></a>减少链表</h4><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>减少内存的释放和创建次数</p><h3 id="造成不必要内存的分配的情况"><a href="#造成不必要内存的分配的情况" class="headerlink" title="造成不必要内存的分配的情况"></a>造成不必要内存的分配的情况</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在c#里面字符串不是值类型而是引用，而且值无法改变，所以改变值会直接创建一个新的值</p><p>　1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。</p><p>　　2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件。</p><p>　　3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。</p><p>　　4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>比如说迭代器会产生新的数组（可以通过缓存来解决），调用GameObject.name 或者 GameObject.tag也会有内存垃圾，因为会犯乎一个字符串</p><h4 id="装箱操作"><a href="#装箱操作" class="headerlink" title="装箱操作"></a>装箱操作</h4><p>装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。最好避免。</p><p>比如这种</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> cost = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">string</span> displayString = String.Format(<span class="hljs-string">&quot;Price:&#123;0&#125; gold&quot;</span>,cost);<br></code></pre></td></tr></table></figure><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><h4 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h4><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>6.5之前的版本会因为迭代器有内存垃圾</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>比如把对象里面的string拆出来，这样就不用频繁地在GC里面类型检查</p><h3 id="定时执行GC"><a href="#定时执行GC" class="headerlink" title="定时执行GC"></a>定时执行GC</h3><p>比如过场的时候主动调用GC操作</p><h1 id="UE"><a href="#UE" class="headerlink" title="UE"></a>UE</h1><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><p><a href="https://zhuanlan.zhihu.com/p/133939450">Lua GC机制分析与理解-上 - 小破孩不会编程序的文章 - 知乎</a></p><h2 id="gc的思想"><a href="#gc的思想" class="headerlink" title="gc的思想"></a>gc的思想</h2><p>会遍历所有对象，标记颜色，那些不可达的就是需要gc的对象，又分为双色和三色，双色就是不能中断，三色可以中断，但是实现复杂，</p><h2 id="何时会触发gc？"><a href="#何时会触发gc？" class="headerlink" title="何时会触发gc？"></a>何时会触发gc？</h2><p>分为两种，一种是自动触发</p><p>在以下代码中，使用 luaC_checkGC 检查 gc 阈值 GCdebt ，当 GCdebt 大于0 时，执行 gc<br>1、创建新数据时 string, thread, userdata, table, closure<br>3、语法解析时<br>4、错误发生时<br>5、字符串拼接时 concat<br>6、栈增长时</p><p>一种是手动触发</p><p>使用 lua API：<br>collectgarbage “step”<br>collectgarbage “collect”</p><h2 id="lua-怎么判定数据可达？"><a href="#lua-怎么判定数据可达？" class="headerlink" title="lua 怎么判定数据可达？"></a>lua 怎么判定数据可达？</h2><p>从 GC根集合（root set） 可访问的对象：<br>gc root set包含三部分：<br>1、主协程 g-&gt;mainthread，其栈记录了当前用到的所有对象<br>2、注册表 g-&gt;l_registry，包含了全局table(_G)，记录了全局变量和全局模块，还包括已加载的模块表 package.loaded<br>3、全局元表 g-&gt;mt，每种数据类型各一个，预留9个，暂时只有table和string的实现，效果如io模块的f:read()和 string模块的s:len()</p><h2 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h2><p>程序是无法推断哪些东西是需要回收的，比如说在数组里的元素，虽然我们不用他了，但是数组还在引用，那么lua就无法自动回收它，这时候就需要弱引用表。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python中的垃圾回收是以引用计数为主，分代收集为辅。</p><p>1、导致引用计数+1的情况</p><p>对象被创建，例如a&#x3D;23</p><p>对象被引用，例如b&#x3D;a</p><p>对象被作为参数，传入到一个函数中，例如func(a)</p><p>对象作为一个元素，存储在容器中，例如list1&#x3D;[a,a]</p><p>2、导致引用计数-1的情况</p><p>对象的别名被显式销毁，例如del a</p><p>对象的别名被赋予新的对象，例如a&#x3D;24</p><p>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</p><p>对象所在的容器被销毁，或从容器中删除对象</p><h2 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h2><p>针对循环引用这个问题，比如有两个对象互相引用了对方，当外界没有对他们有任何引用，也就是说他们各自的引用计数都只有1的时候，如果可以识别出这个循环引用，把它们属于循环的计数减掉的话，就可以看到他们的真实引用计数了。基于这样一种考虑，有一种方法，比如从对象A出发，沿着引用寻找到对象B，把对象B的引用计数减去1；然后沿着B对A的引用回到A，把A的引用计数减1，这样就可以把这层循环引用关系给去掉了。</p><p>不过这么做还有一个考虑不周的地方。假如A对B的引用是单向的， 在到达B之前我不知道B是否也引用了A，这样子先给B减1的话就会使得B称为不可达的对象了。为了解决这个问题，python中常常把内存块一分为二，将一部分用于保存真的引用计数，另一部分拿来做为一个引用计数的副本，在这个副本上做一些实验。比如在副本中维护两张链表，一张里面放不可被回收的对象合集，另一张里面放被标记为可以被回收（计数经过上面所说的操作减为0）的对象，然后再到后者中找一些被前者表中一些对象直接或间接单向引用的对象，把这些移动到前面的表里面。这样就可以让不应该被回收的对象不会被回收，应该被回收的对象都被回收了。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h2><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环境的编程中，对于变量在内存中的创建&#x2F;销毁，总有频繁和不那么频繁的。比如任何程序中总有生命周期是全局的、部分的变量。<br>Python将所有的对象分为0，1，2三代；<br>所有的新建对象都是0代对象；<br>当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。</p><p>他们gc的频率不同，这样可以提高性能</p><h1 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h1><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p><a href="https://zhuanlan.zhihu.com/p/34660259">c++经验之谈一：RAII原理介绍 - allen的文章 - 知乎</a></p><p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p>]]></content>
    
    
    <summary type="html">垃圾回收可能会问到的一切东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-UE相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-UE%E7%9B%B8%E5%85%B3/</id>
    <published>2024-12-13T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE最基础的五个类是什么"><a href="#UE最基础的五个类是什么" class="headerlink" title="UE最基础的五个类是什么"></a>UE最基础的五个类是什么</h1><ol><li>GameMode是整个关卡的控制器，用来编写整个关卡的<a href="https://zhida.zhihu.com/search?content_id=212792905&content_type=Article&match_order=1&q=%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91&zhida_source=entity">业务逻辑</a>；</li><li>GameState是整个关卡的状态，用来存储整个关卡的游戏数据；</li><li>DefaultPawn是玩家角色，若是角色扮演类游戏则就是在游戏场景中看到的角色实体；</li><li>PlayerController是玩家的控制器，用来编写和玩家相关的控制逻辑；</li><li>PlayerState是玩家的状态，用来存储和玩家相关的状态数据。</li></ol><h1 id="FName和FString"><a href="#FName和FString" class="headerlink" title="FName和FString"></a>FName和FString</h1><p>① <strong>FName：</strong>着重于表示<strong>名称</strong>，<strong>不区分大小写</strong>，<strong>不可更改</strong>，引擎中的资源名称都是FName类型，通过一个轻型系统重复使用字符串，FName创建时会根据内容创建一个<a href="https://zhida.zhihu.com/search?content_id=178876897&content_type=Article&match_order=1&q=Hash%E5%80%BC&zhida_source=entity">Hash值</a>，且同样的内容只会存储一次。通过Hash值在进行FName的查找和访问时速度较快，而在比较的时，也不需要比较字符串内容，直接比较Hash值来区分不同FName字符串。</p><p>另外两种字符串<strong>到FName的转换</strong>（特别注意的是，<strong>FText不能直接转换到FName</strong>，可<strong>先转换为FString</strong>，再转换为FName）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br> <br><span class="hljs-comment">// FString 转 FName：不可靠，丢失大小写信息</span><br>FName name1 = <span class="hljs-built_in">FName</span>(*str);<br><br>FString strFromTxt = txt.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 先转 FString，再转 FName：不可靠，丢失大小写信息，丢失本地化信息可能导致语言转换的潜在风险</span><br>FName name2 = <span class="hljs-built_in">FName</span>(*strFromTxt);<br></code></pre></td></tr></table></figure><p>② <strong>FString：</strong>最接近std::string，着重在于<strong>字符串的操作</strong>，提供了大量对字符串的操作接口，是<strong>三者中唯一可修改的字符串类型</strong>，也正因如此，FString对比其它两种字符串来说<strong>消耗更高</strong>，<strong>性能更低</strong>。</p><p>另外两种字符串<strong>到FString的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br>FText txt = <span class="hljs-built_in">LOCTEXT</span>(<span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br>FText txtNS = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">&quot;TextNameSpace&quot;</span>, <span class="hljs-string">&quot;keyName&quot;</span>, <span class="hljs-string">&quot;theValue&quot;</span>);<br><br><span class="hljs-comment">// FName 转 FString：可靠</span><br>FString str1 = name.<span class="hljs-built_in">ToString</span>();<br><span class="hljs-comment">// FText 转 FString：不可靠，丢失本地化信息可能导致语言转换的潜在风险</span><br>FString str2 = txt.<span class="hljs-built_in">ToString</span>();<br></code></pre></td></tr></table></figure><p>③ <strong>FText：</strong>着重在于<strong>显示与本地化</strong>，显示可理解玩家能直接看到的信息，本地化即多语言的处理，<strong>不可更改</strong>。相较于另外两种类型，FText会更加的臃肿，但提供了优秀的本地化功能。</p><p>另外两种字符串<strong>到FText的转换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FString str = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello world~&quot;</span>);<br>FName name = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;I am Frank~&quot;</span>);<br><br><span class="hljs-comment">// FString 转 FText：可靠</span><br>FText txt1 = FText::<span class="hljs-built_in">FromString</span>(str);<br><span class="hljs-comment">// FName 转 FText：可靠</span><br>FText txt2 = FText::<span class="hljs-built_in">FromName</span>(name);<br></code></pre></td></tr></table></figure><h1 id="软引用和硬引用"><a href="#软引用和硬引用" class="headerlink" title="软引用和硬引用"></a>软引用和硬引用</h1><p>加载的步骤</p><h1 id="Actor如何实现一个借口类"><a href="#Actor如何实现一个借口类" class="headerlink" title="Actor如何实现一个借口类?"></a>Actor如何实现一个借口类?</h1><h1 id="UE4反射机制"><a href="#UE4反射机制" class="headerlink" title="UE4反射机制"></a>UE4反射机制</h1><p>UHT</p><p><a href="https://zhuanlan.zhihu.com/p/60622181">UE4反射机制</a></p><p><a href="https://blog.csdn.net/duan19920101/article/details/127557454">C++反射机制</a></p><h1 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a>UFUNCTION</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="https://zhuanlan.zhihu.com/p/149392857">UFUNCTION&#x2F;UPROPERTY&#x2F;UCLASS</a></p><p> 反射系统是可以选择加入的。你需要给暴露给反射系统的类型或属性添加注解，这样Unreal Header Tool (UHT)就会在编译工程的时候利用那些信息生成特定的代码。</p><p><strong>标记</strong></p><p>为了标记一个头文件包含反射类型，需要在文件顶部添加一个特殊的include文件。该文件必须放在#include的最后，这让UHT知道它需要考虑这个文件，并且在反射系统的实现里也是需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileName.generated.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>你现在可以使用UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()来在头文件中注解不同的类型以及成员变量。每一个宏都会出现在类型或者成员变量的前面，并且可以包含额外的修饰符关键字。</p><p>C++是没法直接通过函数名来调用的，因为存的都是地址，但是在蓝图里面可以，这就用到了反射机制</p><h2 id="常用的有哪些"><a href="#常用的有哪些" class="headerlink" title="常用的有哪些"></a>常用的有哪些</h2><p><a href="https://blog.csdn.net/ttod/article/details/136396379">简述UE中的UFUNCTION宏和UPROPERTY宏常用属性</a></p><p>UFunction</p><table><thead><tr><th><code>Category = &quot;TopCategory|SubCategory|Etc&quot;</code></th><th>在蓝图编辑工具中显示时指定函数的类别。使用 | 运算符定义嵌套类别。</th></tr></thead><tbody><tr><td><code>Client</code></td><td>此函数仅在拥有在其上调用此函数的对象的客户端上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了<code>_Implementation</code>。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>CustomThunk</code></td><td><code>UnrealHeaderTool</code> 代码生成器将不为此函数生成thunk，用户需要自己通过 <code>DECLARE_FUNCTION</code> 或 <code>DEFINE_FUNCTION</code> 宏来提供thunk。</td></tr><tr><td><code>Exec</code></td><td>此函数可从游戏内控制台执行。仅在特定类中声明时，Exec命令才有效。</td></tr><tr><td><code>NetMulticast</code></td><td>此函数将在服务器上本地执行，也将复制到所有客户端上，无论该Actor的 <code>NetOwner</code> 为何。</td></tr><tr><td><code>Reliable</code></td><td>此函数将通过网络复制，并且一定会到达，即使出现带宽或网络错误。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>SealedEvent</code></td><td>无法在子类中覆盖此函数。<code>SealedEvent</code>关键词只能用于事件。对于非事件函数，请将它们声明为<code>static</code>或<code>final</code>，以密封它们。</td></tr><tr><td><code>ServiceRequest</code></td><td>此函数为RPC（远程过程调用）服务请求。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>ServiceResponse</code></td><td>此函数为RPC服务响应。这意味着 <code>NetMulticast</code> 和 <code>Reliable</code>。</td></tr><tr><td><code>Server</code></td><td>此函数仅在服务器上执行。用于声明名称与主函数相同的附加函数，但是末尾添加了 <code>_Implementation</code>，是写入代码的位置。必要时，此自动生成的代码将调用 <code>_Implementation</code> 方法。</td></tr><tr><td><code>Unreliable</code></td><td>此函数将通过网络复制，但是可能会因带宽限制或网络错误而失败。仅在与<code>Client</code>或<code>Server</code>配合使用时才有效。</td></tr><tr><td><code>WithValidation</code></td><td>用于声明名称与主函数相同的附加函数，但是末尾需要添加<code>_Validate</code>。此函数使用相同的参数，但是会返回<code>bool</code>，以指示是否应继续调用主函数。</td></tr></tbody></table><p>UProperty</p><table><thead><tr><th><code>AdvancedDisplay</code></th><th>属性将被放置在其出现的任意面板的高级（下拉）部分中。</th></tr></thead><tbody><tr><td><code>AssetRegistrySearchable</code></td><td><code>AssetRegistrySearchable</code> 说明符说明此属性与其值将被自动添加到将此包含为成员变量的所有资源类实例的资源注册表。不可在结构体属性或参数上使用。</td></tr><tr><td><code>BlueprintAssignable</code></td><td>只能与组播委托共用。公开属性在蓝图中指定。</td></tr><tr><td><code>BlueprintAuthorityOnly</code></td><td>此属性必须为一个组播委托。在蓝图中，其只接受带 <code>BlueprintAuthorityOnly</code> 标签的事件。</td></tr><tr><td><code>BlueprintCallable</code></td><td>仅用于组播委托。应公开属性在蓝图代码中调用。</td></tr><tr><td><code>BlueprintGetter=GetterFunctionName</code></td><td>此属性指定一个自定义存取器函数。如此属性不带 <code>BlueprintSetter</code> 或 <code>BlueprintReadWrite</code> 标签，则其为隐式 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>BlueprintReadOnly</code></td><td>此属性可由蓝图读取，但不能被修改。此说明符与 <code>BlueprintReadWrite</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintReadWrite</code></td><td>可从蓝图读取或写入此属性。此说明符与 <code>BlueprintReadOnly</code> 说明符不兼容。</td></tr><tr><td><code>BlueprintSetter=SetterFunctionName</code></td><td>此属性拥有一个自定义编译函数，被隐式标记为 <code>BlueprintReadWrite</code>。注意：必须对变异函数进行命名，并为相同类的一部分。</td></tr><tr><td><code>Category=&quot;TopCategory|SubCategory|...&quot;</code></td><td>指定在蓝图编辑工具中显示时的属性类别。使用 | 运算符定义嵌套类目。</td></tr><tr><td><code>Config</code></td><td>此属性将被设为可配置。当前值可被存入与类相关的 <code>.ini</code> 文件中，创建后将被加载。无法在默认属性中给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>DuplicateTransient</code></td><td>说明在任意类型的复制中（复制&#x2F;粘贴、二进制复制等），属性的值应被重设为类默认值。</td></tr><tr><td><code>EditAnywhere</code></td><td>说明此属性可通过属性窗口在原型和实例上进行编辑。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditDefaultsOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>EditFixedSize</code></td><td>只适用于动态数组。这能防止用户通过虚幻编辑器属性窗口修改数组长度。</td></tr><tr><td><code>EditInline</code></td><td>允许用户在虚幻编辑器的属性查看器中编辑此属性所引用的Object的属性（只适用于Object引用，包括Object引用的数组）。</td></tr><tr><td><code>EditInstanceOnly</code></td><td>说明此属性可通过属性窗口进行编辑，但只能在实例上进行，不能在原型上进行。此说明符与所有“可见”说明符均不兼容。</td></tr><tr><td><code>Export</code></td><td>只适用于Object属性（或Object数组）。说明Object被复制时（例如复制&#x2F;粘贴操作）指定到此属性的Object应整体导出为一个子Object块，而非只是输出Object引用本身。</td></tr><tr><td><code>GlobalConfig</code></td><td>工作原理与 <code>Config</code> 相似，不同点是无法在子类中进行覆盖。无法在默认属性中对其给定一个值。暗示为 <code>BlueprintReadOnly</code>。</td></tr><tr><td><code>Instanced</code></td><td>仅限Object（<code>UCLASS</code>）属性。此类的一个实例创建时，其将被给定一个Object的特殊副本，指定到默认项中的此属性。用于实例化类默认属性中定义的子Object。暗示为 <code>EditInline</code> 和 <code>Export</code>。</td></tr><tr><td><code>Interp</code></td><td>说明值可随时间由Sequencer中的一个轨道驱动。</td></tr><tr><td><code>Localized</code></td><td>此属性的值将拥有一个定义的本地化值。多用于字符串。暗示为 <code>ReadOnly</code>。</td></tr><tr><td><code>Native</code></td><td>属性为本地：C++代码负责对其进行序列化并公开到<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-object-handling?application_version=4.27#garbagecollection">垃圾回收</a>。</td></tr><tr><td><code>NoClear</code></td><td>阻止从编辑器将此Object引用设为空。隐藏编辑器中的清除（和浏览）按钮。</td></tr><tr><td><code>NoExport</code></td><td>只适用于本地类。此属性不应包含在自动生成的类声明中。</td></tr><tr><td><code>NonPIEDuplicateTransient</code></td><td>属性将在复制中被重设为默认值，除非其被复制用于PIE会话。</td></tr><tr><td><code>NonTransactional</code></td><td>说明对此属性值的修改不会包含在编辑器的撤销&#x2F;重新执行历史中。</td></tr><tr><td><code>NotReplicated</code></td><td>跳过复制。这只会应用到服务请求函数中的结构体成员和参数。</td></tr><tr><td><code>Replicated</code></td><td>属性应随网络进行复制。</td></tr><tr><td><code>ReplicatedUsing=FunctionName</code></td><td><code>ReplicatedUsing</code> 说明符指定一个回调函数，其在属性通过网络更新时执行。</td></tr><tr><td><code>RepRetry</code></td><td>只适用于结构体属性。如果此属性未能完全发送（举例而言：Object引用尚无法通过网络进行序列化），则重新尝试对其的复制。对简单引用而言，这是默认选择；但对结构体而言，这会产生带宽开销，并非优选项。因此在指定此标签之前其均为禁用状态。</td></tr><tr><td><code>SaveGame</code></td><td>此说明符可简便地将域显式包含，用于属性关卡中的检查点&#x2F;保存系统。应在作为游戏存档一部分的所有域上设置此标签，并使用代理归档器对其进行读写。</td></tr><tr><td><code>SerializeText</code></td><td>本地属性应被序列化为文本（<code>ImportText</code>、<code>ExportText</code>）。</td></tr><tr><td><code>SkipSerialization</code></td><td>此属性不会被序列化，但仍能导出为一个文本格式（例如用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>SimpleDisplay</code></td><td>出现在 <strong>细节</strong> 面板中的可见或可编辑属性，无需打开“高级”部分即可见。</td></tr><tr><td><code>TextExportTransient</code></td><td>此属性将不会导出为一个文本格式（因此其无法用于复制&#x2F;粘贴操作）。</td></tr><tr><td><code>Transient</code></td><td>属性为临时，意味着其无法被保存或加载。以此方法标记的属性将在加载时被零填充。</td></tr><tr><td><code>VisibleAnywhere</code></td><td>说明此属性在所有属性窗口中可见，但无法被编辑。此说明符与“Edit”说明符不兼容。</td></tr><tr><td><code>VisibleDefaultsOnly</code></td><td>说明此属性只在原型的属性窗口中可见，无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr><tr><td><code>VisibleInstanceOnly</code></td><td>说明此属性只在实例的属性窗口中可见（在原型属性窗口中不可见），无法被编辑。此说明符与所有“Edit”说明符均不兼容。</td></tr></tbody></table><h1 id="PUERTS"><a href="#PUERTS" class="headerlink" title="PUERTS"></a>PUERTS</h1><h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><h1 id="ts和js有什么区别"><a href="#ts和js有什么区别" class="headerlink" title="ts和js有什么区别"></a>ts和js有什么区别</h1><h1 id="函数压栈的过程"><a href="#函数压栈的过程" class="headerlink" title="函数压栈的过程"></a>函数压栈的过程</h1><h1 id="四元数和欧拉角"><a href="#四元数和欧拉角" class="headerlink" title="四元数和欧拉角"></a>四元数和欧拉角</h1><h1 id="如何判断在凸多边形的内部还是外部"><a href="#如何判断在凸多边形的内部还是外部" class="headerlink" title="如何判断在凸多边形的内部还是外部"></a>如何判断在凸多边形的内部还是外部</h1><h1 id="如何做一个反弹的手榴弹"><a href="#如何做一个反弹的手榴弹" class="headerlink" title="如何做一个反弹的手榴弹"></a>如何做一个反弹的手榴弹</h1><p>成就系统怎么做</p><p>光照与阴影</p><p>材质系统</p><p>特效</p><p>动画系统</p><h1 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h1><p><a href="https://zhuanlan.zhihu.com/p/434028533">【UE5】给Landscape加一点料-地形篇（零）-前前言 - 徐凯鸣的文章 - 知乎</a></p><p><a href="https://www.youtube.com/watch?v=MRNFcywkUSA&list=PLFt_AvWsXl0eBW2EiBtl_sxmDtSgZBxB3&index=3">Procedural Landmass Generation Youtube</a></p><p>地形编辑</p><p>Houdini</p><h1 id="自定义编辑器FAssetEditorToolkit"><a href="#自定义编辑器FAssetEditorToolkit" class="headerlink" title="自定义编辑器FAssetEditorToolkit"></a>自定义编辑器FAssetEditorToolkit</h1><h3 id="3-1-InitCustomAssetEditor方法："><a href="#3-1-InitCustomAssetEditor方法：" class="headerlink" title="3.1 InitCustomAssetEditor方法："></a><strong>3.1 InitCustomAssetEditor方法：</strong></h3><p>在此方法中，主要分为两个内容：<br><strong>① 初始化编辑器布局，可以使用以下步骤：</strong></p><ol><li>通过创建适当类的实例并设置其属性来定义自定义 FLayout、菜单和工具栏。</li><li>自定义 Slate 窗口现在将绑定到 TabManager，并使用自定义 FLayout、菜单和工具栏显示资产编辑器。</li></ol><p><strong>② 调用父类方法InitAssetEditor将自定义 Slate 窗口绑定到 TabManager。</strong></p><h3 id="3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法："><a href="#3-2-RegistorTabSpawners-x2F-UnRegistorTabSpawner方法：" class="headerlink" title="3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法："></a>3.2 RegistorTabSpawners&#x2F;UnRegistorTabSpawner方法：</h3><p>+ 我们首先需要知道，Tab(SDockTab)是引擎定义的一个控件类，每一个Tab都是可以被关闭或打开的SWidget.Tab类型的窗口右上角包含一个关闭按钮。窗口内则可以包含自定义显示的各种Slate内容。</p><p>+ 我们打开编辑器时，就会根据Layout布局加载对应的Tab控件，并显示其中的内容，即Tab装入的子控件(Child Slate)。</p><p>+ 在此方法中，最重要的是调用TabManager对象，TabManager类主要用于管理编辑器中的布局，创建Tab对象。在类中我们需要定义一个FName类型的TabID变量，用于在该方法中指示一个Slate窗口。我们需要通过调用TabManager的方法RegisterTabSpawner绑定TabID和Slate，用于后续定义Slate控件的显示。</p><h3 id="3-3-SpawnTab-CustomWidget方法"><a href="#3-3-SpawnTab-CustomWidget方法" class="headerlink" title="3.3 SpawnTab_CustomWidget方法"></a>3.3 SpawnTab_CustomWidget方法</h3><p>在此方法中，将会创建并返回一个SWidget实例。<br>而RegistorTabSpawner方法通过调用TabManager的接口，将该Slate控件实例注册，与TabID进行绑定，并能够在InitCustomAssetEditor方法中添加到布局Flayout中被显示出来。<br>我们不仅可以创建简单的Slate控件（如SButton、IDetailsViews）,也可以创建较为复杂的窗口，如SEditorViewport(3D预览窗口)、SGraphEditor(可以连接复杂自定义的节点<a href="https://zhida.zhihu.com/search?content_id=222180537&content_type=Article&match_order=1&q=%E5%9B%BE%E8%A1%A8%E7%B3%BB%E7%BB%9F&zhida_source=entity">图表系统</a>)等内容，并将其添加到我们的自定义编辑器中。<br>在本文实例中，我在该方法中创建了一个最简单的Slate类SButton。</p><h1 id="模拟云"><a href="#模拟云" class="headerlink" title="模拟云"></a>模拟云</h1><p>Worley Noise</p><p>在空间中随机随便放点，然后计算最近的点的距离，为了连续，把这个的点放八个地方</p><h1 id="虚幻渲染编程"><a href="#虚幻渲染编程" class="headerlink" title="虚幻渲染编程"></a>虚幻渲染编程</h1><p><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻4渲染编程专题概述及目录 - YivanLee的文章 - 知乎</a></p><h1 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h1><p><a href="https://zhuanlan.zhihu.com/p/486808688">【Unreal】虚幻GAS系统快速入门 - LunarMaxim的文章 - 知乎</a></p><p><a href="https://github.com/DriedMachine/GASDocumentation5.3_CN">GAS Document中文翻译</a></p><h2 id="包括什么东西"><a href="#包括什么东西" class="headerlink" title="包括什么东西"></a>包括什么东西</h2><p>GAS主要包含以下内容：</p><ul><li>Who:ASC(Ability System Component) 主要组件，由C++编写，代码里有很多方法是蓝图未实现的。</li><li>How:GA(Gameplay Abilities) 角色的技能，包括攻击、疾跑、施法、翻滚、使用道具等，但不包括基础移动和UI</li><li>What:AS(Attribute Set) 角色身上<strong>可以用float表示的属性</strong>，如生命值、体力值、魔力值等，有BaseValue和CurrentValue，方便回滚</li><li>Change:GE(Gameplay Effects) 用于<strong>修改属性</strong>，如增加50移动速度10s；还能配合GA实现更多玩法</li><li>Visual:GC(Gameplay Cues) 播放特效、音效等</li><li>If:Tag:用来分类，底层是FName，用.来分隔</li><li>Async：Task：如果想要异步的做一些东西，比如做完技能播一个蒙太奇，可以用这个来搞</li><li>Send：Event:ASC之间通信</li></ul><h2 id="做冷却"><a href="#做冷却" class="headerlink" title="做冷却"></a>做冷却</h2><p>角色在启动的时候可以保存一个specAbility，然后拿一个他的handle。</p><p>比如我想实现一个技能的冷却，其实就是做一个GE，然后这个GE启动的时候挂上在人物身上挂一个cooldown的tag，这个tag是有一个duration的，然后释放技能的时候加一个条件，有这个tag的时候无法释放，在ASC上面有一个Activation Blocked Tags，在里面加上刚刚搞的那个tag</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://zhuanlan.zhihu.com/p/463272214">【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南 - 水曜日鸡的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/38881269">《Exploring in UE4》多线程机制详解[原理分析] - Jerish的文章 - 知乎</a></p><h2 id="FRunnable"><a href="#FRunnable" class="headerlink" title="FRunnable"></a>FRunnable</h2><p>创建一个继承自FRunnable的类，把这个类要执行的任务分发给其他线程去执行。</p><p><img src="https://picx.zhimg.com/v2-21dde7f72b7b87f9133b60ab9190e5b5_r.jpg" alt="img"></p><h2 id="AsyncTask系统"><a href="#AsyncTask系统" class="headerlink" title="AsyncTask系统"></a>AsyncTask系统</h2><h2 id="TaskGraph系统"><a href="#TaskGraph系统" class="headerlink" title="TaskGraph系统"></a>TaskGraph系统</h2><p>Task Graph 系统是UE4一套抽象的异步任务处理系统，可以创建多个<a href="https://zhida.zhihu.com/search?content_id=7702163&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&zhida_source=entity">多线程任务</a>，指定各个任务之间的依赖关系，按照该关系来依次处理任务。具体的实现方式网上也有很多案例，这里先给出UE4Wiki的教程链接：</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p>《Exploring in UE4》关于网络同步的理解与思考[概念理解] - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/34721113">https://zhuanlan.zhihu.com/p/34721113</a></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>要将一个函数声明为 RPC，您只需将 <code>Server</code>、<code>Client</code> 或 <code>NetMulticast</code> 关键字添加到 <code>UFUNCTION</code> 声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UFUNCTION</span>( Client )<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientRPCFunction</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h1 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h1><p>《Exploring in UE4》RootMotion详解【原理分析】 - Jerish的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/74554876">https://zhuanlan.zhihu.com/p/74554876</a></p><h1 id="DS-专用服务器"><a href="#DS-专用服务器" class="headerlink" title="DS 专用服务器"></a>DS 专用服务器</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/networking-overview-for-unreal-engine#%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">网络概述官方文档</a></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><a href="https://www.bilibili.com/video/BV1mP4y1R7UR/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【[UOD2022]虚幻DS的机遇与挑战 | 晶核 刘豪</a> </p><p>NetworkPrediction</p><h3 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h3><p><img src="https://raw.githubusercontent.com/rorschachandbat/cloudimage/main/image-20241220222047918.png" alt="image-20241220222047918"></p><p>等级低只同步自己</p><p>把宠物，npc全放在逻辑服，不用同步</p><p>大世界网格小，副本网格范围大</p><p>摄像机背后的actor同步频率低</p><p>不移动的时候降低同步频率</p><p>把不需要同步的属性清理掉。</p><p>使用pushModel，手动标记哪些属性需要更新，这样就不需要同步所有的信息</p><h3 id="物理计算优化"><a href="#物理计算优化" class="headerlink" title="物理计算优化"></a>物理计算优化</h3><p>服务器剔除角色身上所有的装饰器组件</p><p>服务器关闭动画计算，只有业务需要具体坐标时才计算。</p>]]></content>
    
    
    <summary type="html">UE知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>试玩的一些推箱子游戏记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E8%AF%95%E7%8E%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%A8%E7%AE%B1%E5%AD%90%E7%81%B5%E6%84%9F/</id>
    <published>2024-12-12T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.389Z</updated>
    
    <content type="html"><![CDATA[<p>记录试玩的一些推箱子的idea，希望自己以后也能做出这种puzzle</p><h1 id="箱子联动"><a href="#箱子联动" class="headerlink" title="箱子联动"></a>箱子联动</h1><p>两个双重箱子会联动，并且推墙也会联动</p><p><a href="https://moonsoup.itch.io/sea-snake-safari">https://moonsoup.itch.io/sea-snake-safari</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121116554.png" alt="image-20241117121116554"></p><h1 id="组合箱子"><a href="#组合箱子" class="headerlink" title="组合箱子"></a>组合箱子</h1><p>需要通过拼接箱子的四个边来解谜，而且还能进入箱子里面来实现一些很有意思的操作</p><p><a href="https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09">https://www.puzzlescript.net/play.html?p=bc8f853dae0cf7a2ad336a75ab24ba09</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121232954.png" alt="image-20241117121232954"></p><h1 id="推箱子点亮房间"><a href="#推箱子点亮房间" class="headerlink" title="推箱子点亮房间"></a>推箱子点亮房间</h1><p><a href="https://theconspiracy.itch.io/single-screen-scream">https://theconspiracy.itch.io/single-screen-scream</a></p><p>是一个迷宫类的游戏，把箱子推到对应的上面会点亮某个房间的地图，你需要自己画一下这个地图的结构，并且来搞</p><p>代码点评：他的代码太粗暴，每一个level都写了对应的操作，或许这个不太适合用这个编辑器来做，直接用引擎来写会更加简洁，不过创意不错</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117121317837.png" alt="image-20241117121317837"></p><h1 id="改变关卡然后再推箱子"><a href="#改变关卡然后再推箱子" class="headerlink" title="改变关卡然后再推箱子"></a>改变关卡然后再推箱子</h1><h2 id="任意的位置"><a href="#任意的位置" class="headerlink" title="任意的位置"></a>任意的位置</h2><p><a href="https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3">https://www.puzzlescript.net/play.html?p=fe33549f62cd7666ea14eedcfc3863a3</a></p><p>需要先规定步数把关卡的墙壁消除，然后再推箱子，这个引擎竟然还可以这样有先后顺序，非常神奇啊，等等研究一下是怎么搞的， 相当牛逼啊</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117124647189.png" alt="image-20241117124647189"></p><h2 id="变身成铲子来改变，位置是有限的"><a href="#变身成铲子来改变，位置是有限的" class="headerlink" title="变身成铲子来改变，位置是有限的"></a>变身成铲子来改变，位置是有限的</h2><p><a href="https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea">https://www.puzzlescript.net/play.html?p=3754910c54ef200ac105b4152654bbea</a></p><p>这个需要捡起铲子来改变地形，会有不同，和自由的不太一样，设计思路也不太一样</p><p>他这个代码也很简单，因为他的规则集很统一，写的很好这个代码，三百行就搞定了</p><p>还讲了个小故事，不赖</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118232458914.png" alt="image-20241118232458914"></p><h2 id="场景中的物体也可以自己编辑"><a href="#场景中的物体也可以自己编辑" class="headerlink" title="场景中的物体也可以自己编辑"></a>场景中的物体也可以自己编辑</h2><p><a href="https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0">https://www.puzzlescript.net/play.html?p=9eb8f8f3df4efb450b798a279eeba2e0</a></p><p>比如这一关是如何把这个小点搞出来</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118235755770.png" alt="image-20241118235755770"></p><h2 id="推箱子本身会改变路"><a href="#推箱子本身会改变路" class="headerlink" title="推箱子本身会改变路"></a>推箱子本身会改变路</h2><p><a href="https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab">https://www.puzzlescript.net/play.html?p=b1c07b54e2091c40221cf48fe66d25ab</a></p><p>箱子本身是一条以自身为中心的十字路，推箱子会改变主人公能走的位置，要通过这个推完成目标</p><p>关卡有点少，只有四关</p><p>一边推一边思考路的过程还是挺有趣的，要考虑的东西有点意思</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085156436.png" alt="image-20241119085156436"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119083807340.png" alt="image-20241119083807340"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084051277.png" alt="image-20241119084051277"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119084505536.png" alt="image-20241119084505536"></p><h1 id="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"><a href="#改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径" class="headerlink" title="改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径"></a>改变路的第二种方式，吃了多少会变成多少的数字，路会变成这个数字，要根据这个来规划路径</h1><p><a href="https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337">https://www.puzzlescript.net/play.html?p=9ebe1e5ad44ac22259343de170a3b337</a></p><p>会变成像素的数字，这个是可以走的路，蛮有意思</p><p>如果你吃的一瞬间路变没了，你也会死</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119100230326.png" alt="image-20241119100230326"></p><h1 id="会连接在一起的箱子，而且中间的线也会挡住东西"><a href="#会连接在一起的箱子，而且中间的线也会挡住东西" class="headerlink" title="会连接在一起的箱子，而且中间的线也会挡住东西"></a>会连接在一起的箱子，而且中间的线也会挡住东西</h1><p>有点拓扑结构的意思</p><p><a href="https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0">https://www.puzzlescript.net/play.html?p=bc59f54ac76fd119991b250979de70e0</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117155008183.png" alt="image-20241117155008183"></p><h1 id="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"><a href="#推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物" class="headerlink" title="推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物"></a>推箱子，要利用特殊的箱子来过关，进入这个特殊箱子会变成电线，然后要用这个性质来穿越障碍物</h1><p><a href="https://notaninart.itch.io/pushing-u">https://notaninart.itch.io/pushing-u</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117163406595.png" alt="image-20241117163406595"></p><h1 id="箱子连接，但是本身自己也可以变成箱子，也可以解冻"><a href="#箱子连接，但是本身自己也可以变成箱子，也可以解冻" class="headerlink" title="箱子连接，但是本身自己也可以变成箱子，也可以解冻"></a>箱子连接，但是本身自己也可以变成箱子，也可以解冻</h1><p><a href="https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29">https://www.puzzlescript.net/play.html?p=44a295d7a2ab17a2048f555d72781a29</a></p><p>非常巧妙，自己可以被冰冻变成箱子，也可以解冻，很地狱笑话，被冰冻才能上飞机，太幽默了。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118155250549.png" alt="image-20241118155250549"></p><h1 id="国际象棋"><a href="#国际象棋" class="headerlink" title="国际象棋"></a>国际象棋</h1><p><a href="https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259">https://www.puzzlescript.net/play.html?p=8ba10d6a0a5a0edd640e0b9431858259</a></p><p>推动国际象棋的棋子，目标是走到对面的皇后位置，不能走到能被吃的位置，但是可以推动棋子可以把推动的棋子给杀了。</p><p>感觉可以做一个中国象棋版的来尝试复刻一下</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241117221156115.png" alt="image-20241117221156115"></p><h1 id="有步数限制的推箱子"><a href="#有步数限制的推箱子" class="headerlink" title="有步数限制的推箱子"></a>有步数限制的推箱子</h1><p><a href="https://galactical.itch.io/at-the-hedges-of-time">https://galactical.itch.io/at-the-hedges-of-time</a></p><p>很好理解，也很简单的创意，一个trick的点是箱子不会随着自己回退</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118145646564.png" alt="image-20241118145646564"></p><h1 id="箱子本身是一个能和周围互动的装置"><a href="#箱子本身是一个能和周围互动的装置" class="headerlink" title="箱子本身是一个能和周围互动的装置"></a>箱子本身是一个能和周围互动的装置</h1><p><a href="https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5">https://www.puzzlescript.net/play.html?p=2fe3172d2b9fe684977d184f1b6226d5</a></p><p>按下开关之后箱子会动，会把自己往什么某个方向推，碰撞体积也会发生改变，</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118171505291.png" alt="image-20241118171505291"></p><p>其实有些关设计的挺有意思的，因为你需要反复来回来利用本身他之后弹开的位置来占住那个开关，然后再去推，这样其实有一种联动的感觉，后面感觉会有那种一下联动好几个然后按顺序搞的感觉，感觉很有意思</p><h1 id="保龄球推箱子"><a href="#保龄球推箱子" class="headerlink" title="保龄球推箱子"></a>保龄球推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9">https://www.puzzlescript.net/play.html?p=7572972f749909993b12d84991e47ec9</a></p><p>推的目标箱子推一次会一直往前滚，所以需要用生成的反射东西来组装好路径来搞，设计的比较简单，但是还是挺有意思的，和我们做的反射光的游戏甚至有点像，他里面有一分为二，还有生成东西的道具</p><p>但是他的关卡太简单了，不够多</p><p>而且他这个能推很多次，如果做成只推一次，会好很多</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118201017238.png" alt="image-20241118201017238"></p><p>他的还有一个机制是遇到已经放好的花朵会导致提前停下，或许就是因为这一点所以他没有做一击通关，这样难度会很高</p><h1 id="不能自己往上的推箱子"><a href="#不能自己往上的推箱子" class="headerlink" title="不能自己往上的推箱子"></a>不能自己往上的推箱子</h1><p><a href="https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb">https://www.puzzlescript.net/play.html?p=58325085befa37ab497168cd803c64cb</a></p><p>因为主角是一个落叶，所以做了往上方向的限制，只能通过喷泉来往上，这种限制也蛮有意思的。但是可以同时推多个箱子，也要利用这个。</p><p>还有一个机制，在水里的话就可以往上推，可以借助水的浮力，比如这一关就是这样</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241118234135382.png" alt="image-20241118234135382"></p><h1 id="推箱子和一笔画？"><a href="#推箱子和一笔画？" class="headerlink" title="推箱子和一笔画？"></a>推箱子和一笔画？</h1><p><a href="https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729">https://www.puzzlescript.net/play.html?p=45f13378f02acf2d2583d91fac32e729</a></p><p>规则很简单，往某个地方推会朝那个方向生成一个箱子，目标是把所有的红色都占满</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119085545410.png" alt="image-20241119085545410"></p><h1 id="箱子的状态会被改变（火）"><a href="#箱子的状态会被改变（火）" class="headerlink" title="箱子的状态会被改变（火）"></a>箱子的状态会被改变（火）</h1><p><a href="https://rosden.itch.io/theflames">https://rosden.itch.io/theflames</a></p><p>被火烧了会有几个状态，中间有四步移动的机会，这时候不会完全变成灰烬，还可以被推，可以用来填补空洞；之后会变成灰烬，不能被推动，也不会挡路（第一关就是教你这个，不挡路）</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241119092837131.png" alt="image-20241119092837131"></p>]]></content>
    
    
    <summary type="html">itch许多类推箱子游戏的游玩记录，总结一下他们的创意</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>我的独立游戏作品合集</title>
    <link href="https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/"/>
    <id>https://rorschachandbat.github.io/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E4%BD%9C%E5%93%81%E5%90%88%E9%9B%86/</id>
    <published>2024-10-27T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完美世界GameJam"><a href="#完美世界GameJam" class="headerlink" title="完美世界GameJam"></a>完美世界GameJam</h1><p>开发日期：2024.3.15</p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a></p><p>一个关于骰子的肉鸽游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20241105193443453.png"></a></p><h1 id="2024CigaGamejam"><a href="#2024CigaGamejam" class="headerlink" title="2024CigaGamejam"></a>2024CigaGamejam</h1><p>主题：有限与无限</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">试玩连接</a></p><p>一个关于1v3的不对成派对游戏</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"></a></p><h1 id="2024下半年Booom"><a href="#2024下半年Booom" class="headerlink" title="2024下半年Booom"></a>2024下半年Booom</h1><p>主题：change_,not change _</p><p>开发日期：2024.7.7-7.8</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">试玩连接</a></p><p>一个类似卡坦岛的生存游戏，美术不错</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"></a></p><h1 id="2024TapTapGameJam"><a href="#2024TapTapGameJam" class="headerlink" title="2024TapTapGameJam"></a>2024TapTapGameJam</h1><p>主题：light</p><p>开发日期：2024.10.25-11.1</p><p><a href="https://rorschachandbat.itch.io/lightpuzzle">试玩连接</a></p><p>一个关于光线解密的游戏，尝试着用ai+godot开发，完成度不错，关卡设计的很有意思</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241029225512.png"></a></p>]]></content>
    
    
    <summary type="html">放一个合集，欢迎大家试玩</summary>
    
    
    
    <category term="随笔" scheme="https://rorschachandbat.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>落井下食开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E8%90%BD%E4%BA%95%E4%B8%8B%E9%A3%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-02T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p class="note note-primary">为了避免危险，你需要派遣伙伴们去合适的地方，它们会帮助你，□□食物，应对晚上的客人。 夜晚来临时，客人们会依次到来，你只需要提供它们需要的食物，它们就会满意的离开。</p><p><a href="https://wwex.lanzout.com/iZwCp28d24bg">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214537289.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214546036.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214555977.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214658802.png" alt="img"></a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214605556.png" alt="img"></a></p><h1 id="Luban导表工具"><a href="#Luban导表工具" class="headerlink" title="Luban导表工具"></a>Luban导表工具</h1><p>这次的项目需要填数据的地方非常多，有了上次做肉鸽小游戏的教训，决定搜寻一下有无更加好用的导表工具，最终找到了luban工具，算是比较方便好用的实现方案。</p><p><a href="https://github.com/focus-creative-games/luban">官方链接</a></p><p>作为一个需要大量配表的游戏，最理想的情况是，策划端只需要用excel就可以搞定，程序端也不需要编写处理db的代码，导表工具会自动生成相应的代码。</p><p>具体的例子直接看文档大概能看的明白，当然也有一些实现的非常草率的地方，</p><p>1.无法动态修改数据，就只能重新创建一个一模一样的结构体，因为他自己生成的结构式是read only的，无法实现修改，感觉这个也是可以细想怎么优雅实现的。</p><p>2.没有加数据校验功能，后期策划在编写的时候会出现填错的情况。</p><p>3.excel表无法实现比较复杂的数据结构。</p><h1 id="JKFrame"><a href="#JKFrame" class="headerlink" title="JKFrame"></a>JKFrame</h1><p><a href="http://www.yfjoker.com/JKFrame/">JKFrame使用手册</a></p><p>本次09老师使用了JKFrame作为编程框架，使用起来比较方便，相当于多了一些库，直接用事件系统和ui系统都很方便，以后也可以多用这个框架尝试。</p><h1 id="六边形地图设计"><a href="#六边形地图设计" class="headerlink" title="六边形地图设计"></a>六边形地图设计</h1><p>六边形地图不能直接用二维坐标来表示，并且因为本次项目不需要动态生成，所以就直接在ui上硬编码了整个地图，感觉更加正常的做法是用tilemap，但是因为时间紧迫所以全部都用ui来做了，之后这里可以研究一下如何更优雅的实现这种六边形地图。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162316080.png" alt="坐标参考"></a></p><p>坐标参考</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901162335018.png" alt="demo图"></a></p><p>demo图</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901214835607.png" alt="最后的成品"></a></p><p>最后的成品</p><p><a href="https://www.redblobgames.com/grids/hexagons/">六边形地图理论基础</a></p><p><a href="https://indienova.com/u/npc233/blogread/11298">六边形地图坐标距离计算（直接看结论版）</a></p><p>计算距离，像这样的坐标体系，有x,y,z三个维度，x,y,z的和始终是0，我们称之为cube坐标，距离计算公式是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br><br>TS<br>diatance=<span class="hljs-built_in">max</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))<br><br>TS<br>func <span class="hljs-built_in">posDistance</span>(pos1,pos2):<br>    <span class="hljs-selector-tag">var</span> cubePos1=<span class="hljs-built_in">getCubePosFromPos</span>(pos1)<br>    <span class="hljs-selector-tag">var</span> cubePos2=<span class="hljs-built_in">getCubePosFromPos</span>(pos2)<br>    <span class="hljs-selector-tag">var</span> distance=(<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.x-cubePos2</span>.x)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.y-cubePos2</span>.y)+<span class="hljs-built_in">abs</span>(cubePos1<span class="hljs-selector-class">.z-cubePos2</span>.z))/<span class="hljs-number">2</span><br>    return distance<br><br>CPP<br></code></pre></td></tr></table></figure><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>做事所花费的时间总是比你预期的要长，即使你的预期中考虑了侯世达定律。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这次项目作为一个ui游戏，简单的使用了MV框架，前期实现整体游戏循环的过程很快，到后面开始拼ui的时候其实有很大的沟通失误，缺少一个统筹规划工作量的人，来预估这个完成的时间。我自己心目中的完成时间点和实际的完全不一样，比如说地图，到了最后几天才分配给我做，我本以为是第二个周末就能完成的事情，我觉得09花了太多的时间来重构代码，并且重构之后也没经过测试，这个风险非常大，我个人认为应该先保证所有功能都完备了再进行重构的工作，不然卡在这里也无法进行下一步的推进。</p><p>其实这又是一个沟通问题，如果没有一个责任人站出来，那么我就会倾向于摆烂，并且祈祷或者默认其他人能完成，这就导致了我们最后ui和玩法上还有很多bug没修完，如果倒数第二个周末就有人站出来规划好预计的时间，或许最后交上去的结果会好很多。</p><h2 id="测试以及策划功能优先级问题"><a href="#测试以及策划功能优先级问题" class="headerlink" title="测试以及策划功能优先级问题"></a>测试以及策划功能优先级问题</h2><p>再来讲讲测试的问题，理想的情况是做完一个功能就马上有人来验收，并且这个人是知道所有的功能细节，这样是效率最高的测试方法，所以要么是程序自测，要么是策划验收，如果再找一个测试来验收就还需要和他沟通具体的细节。</p><p>但是中期出现的问题是，队伍策划需要干的事情实在<strong>太多了</strong>，既要设计玩法，还要调整数值，还要设计ui，还要验收功能。但是这些事情我认为应该是有优先级的，应该是要保证完成游戏完整性而服务，也就是设计ui和验收功能为更优先，因为这些都是会影响其他人的工作流的，一旦这个地方卡住了，其他人就要<strong>等待这里完成</strong>，会陷入到无事可干，并且必须要完成好最终确定的游戏，才能开始跑游戏测试数值。</p><p>而关于数值设计，既然我们已经分离开了数据和玩法，大可之后再根据测试的反馈来更改数值，数值设计应该也是需要有一套<strong>方法论</strong>的，这个是需要思考学习的。</p><h2 id="玩法设计"><a href="#玩法设计" class="headerlink" title="玩法设计"></a>玩法设计</h2><p>在前期的设计阶段，我总是觉得已有的玩法过于简单，能够一眼望穿，所以提出了很多想要增加策略性的建议，比如增加道具种类，地图增加走格子玩法，白天从三个动物变成牌组的形式，但其实最后做下来，看玩家的反馈已经足够复杂。我开始意识到我走入了一个非常大的误区，作为开发者，对于自己的游戏当然足够熟悉，所以总是会觉得过于简单，而失去了站在旁观者来审视游戏复杂度的能力，很容易把游戏玩法膨胀得很难。当然，这也和我前面提到的<strong>快速测试并且验证思路</strong>有关，总是因为我们没有快速验证的过程，所以会让我有这种恐慌。</p><h2 id="主题和音乐和美术"><a href="#主题和音乐和美术" class="headerlink" title="主题和音乐和美术"></a>主题和音乐和美术</h2><p>这次游戏的另一个教训是有关于游戏的其他方面，我总是太过于在于游戏机制的设计，但是忽略了其他人看中的部分，比如主题、美术和音乐的统一性，ui设计的合理性，还是提到的一点，每个人对于jam最终作品的想象不一样，我所追求的是一个好玩的东西。但是可能其他人更愿意的是一个完整的作品，一个从机制到主题到美术音乐统一并且完整的作品，那就必然牺牲一部分有趣度的考量，而</p><p>这点以后要改进的是，和别人一开始就要沟通清楚<strong>自己的愿景</strong>，这样才能共同朝着一个方向努力。</p><h1 id="获得的一些灵感"><a href="#获得的一些灵感" class="headerlink" title="获得的一些灵感"></a>获得的一些灵感</h1><p><strong>西西弗斯</strong><br>糯米团子，做一个自动放置小游戏，不过是翻山，讽刺一下西西弗这个意象。</p><p><strong>todolist直接改的模拟经营</strong><br>模拟经营，但是像babaisyou一样，目标是可以根据自己的东西来拖动的，比如需要10个肉直接变成需要10个草。</p><p><strong>放置挂机+自走棋</strong></p><p>白天放置挂机拿资源，晚上自走棋战斗，更加纯粹简单的快乐。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次作品的完整性还是相当高的，作为一个三周的作品美术音乐音效玩法都非常融洽，给自己朋友家人试玩也是相当开心，作为自己第一个完整度这么高的作品也是相当开心了。真的相当感谢队友们的付出，队友们都非常给力，性格也相当nice，沟通起来都非常舒服，感谢队友的配合，学到了很多，希望以后能再次合作。</p><h1 id="还需要研究的问题"><a href="#还需要研究的问题" class="headerlink" title="还需要研究的问题"></a>还需要研究的问题</h1><p>1.六边形地图如何优雅实现</p><p>2.导表的问题</p><p>3.学习数值设计方法论</p><p>4.如何导网页端游戏</p>]]></content>
    
    
    <summary type="html">2024下半年Booom参赛作品</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E5%88%AB%E6%91%B8%E5%8F%A4%E8%BF%B9%E5%85%B7%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://wwex.lanzout.com/itHmd28tyhkb">放一个试玩连接</a></p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211645122.png" alt="image-20240901211645122"></a></p><p>image-20240901211645122</p><p>游戏玩法是1v3的不平衡对抗，每局游戏开始前每个人都会随机到一个关于自身能力的一个buff和一个debuff（比如跳跃次数增加和奔跑速度变慢），人类方的</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>这次比赛的主题是limited and limitless，所以我一开始想的是，给玩家可以自由调控自己的任何能力值，比如奔跑速度，跳跃高度，跳跃次数，冲刺距离……但是你加了一方面的buff，就要选择另一个其他的debuff，然后设计一系列的关卡，看你如何通过你的搭配来最快的过关。这个核心规则比较简单但是变化也相当多，不过被否定了，理由是1.在这种现场试玩做这种一次性的解密游戏很容易让游戏失去游戏性，因为别人看一次就知道怎么玩了，2.可能没有那么多时间来设计关卡。所以他们最后还是决定做一个party game。</p><h1 id="Corgi引擎"><a href="#Corgi引擎" class="headerlink" title="Corgi引擎"></a>Corgi引擎</h1><p><a href="https://corgi-engine-docs.moremountains.com/">corgi引擎文档</a></p><p>先说下corigi引擎的优点，有非常多已经实现的平台跳跃功能，包括丰富的平台，以及人物不同的能力（飞翔，滑翔背包，冲刺），这些都是以</p><h1 id="编码思路和组件思维"><a href="#编码思路和组件思维" class="headerlink" title="编码思路和组件思维"></a>编码思路和组件思维</h1><h1 id="水面shader"><a href="#水面shader" class="headerlink" title="水面shader"></a>水面shader</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160644645.png" alt="一开始的效果"></a></p><p>一开始的效果</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901160615288.png" alt="加了水面shader的效果"></a></p><p>加了水面shader的效果</p><p>一开始的加一个镜面反射和流动水的效果，就好看许多</p><h1 id="测试暴露的问题"><a href="#测试暴露的问题" class="headerlink" title="测试暴露的问题"></a>测试暴露的问题</h1><h2 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h2><p>最理想的情况是策划来进行这个关卡的设计，但因为这次的策划是一个比较新手的人，到了最后也没能成功下载unity，并且也没有任何设计关卡的经验，所以只能由我自己来拼一个关卡了。</p><p>我的设计思路是观看我最喜欢的partygame，move or die的一些地图，然后再摆出目前能实现的平台：长条，斜坡，弹跳蘑菇，下落方块，（和mod里面差的也就是一个传送门）当然corgi里面还实现了很多其他平台效果但是都因为我们缺少美术就没有做了，根据</p><h2 id="跳跃手感"><a href="#跳跃手感" class="headerlink" title="跳跃手感"></a>跳跃手感</h2><p>作为一个平台跳跃，跳跃手感是至关重要的，一个很重要的标准是，就算没有任何的关卡，没有任何的剧情，你只需要操控着你的角色跑一下挑一下，如果你觉得很畅快那就是一个好的手感，</p><p>关于手感有许多很好的视频，</p><p><a href="https://www.bilibili.com/video/BV1M441197sr/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【游戏制作工具箱】《蔚蓝》的手感为何迷人？</a></p><p><a href="https://www.bilibili.com/video/BV15C411r7Ju/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">【GMTK|中英字幕】马里奥跳跃的秘密</a></p><p>事实上corgi游戏里面已经对跳跃的参数给了很多自由的参数，比如</p><h2 id="试玩的插曲"><a href="#试玩的插曲" class="headerlink" title="试玩的插曲"></a>试玩的插曲</h2><p>线下试玩非常有趣，遇到了一个非常精通平台跳跃的玩家，蔚蓝打通c面的那种，我和他1v1打了许久，一开始我想着让一下他，不要打消他的热情，但是再玩了几把之后我发现是他是真的很强，所以索性放开了跟他玩，但是他还是偶尔能赢，不过由于某些关卡设计和机制设计，让他随机到了只能跳一次就基本赢不了，所以我索性在给他开放了冲刺的功能，让他</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>corgi引擎</p><h2 id="体量"><a href="#体量" class="headerlink" title="体量"></a>体量</h2><p>人手还是不够，这次光是画好人物和boss就已经差不多了，关卡的布置只能自己来搞了，所以做的不是特别好。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计问题也有很多，比如一开始说到的只能四个人玩，导致在现场体验的时候很难凑到四个人，这点还是致命伤啊。</p>]]></content>
    
    
    <summary type="html">2024CigaGamejam</summary>
    
    
    
    <category term="游戏开发日志" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>dicehero开发日志</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/dicehero%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-08-31T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏玩法介绍"><a href="#游戏玩法介绍" class="headerlink" title="游戏玩法介绍"></a>游戏玩法介绍</h1><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/c81d01aa7f8bf309780773358cda379.png"></a></p><p>首先简单介绍一下游戏玩法，你和boss会轮流骰两个骰子，你需要选择是分开触发骰子还是合成触发，比如扔到4和6，你可以选择触发4扇区和6扇区，也可以选择只触发10扇区，每个扇区的牌有主动效果和被动效果，自己回合触发的是主动效果，boss回合触发的被动效果，当然每个回合还可以买牌，所以是一个需要你控制概率的肉鸽游戏。</p><p><a href="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20240901211828904.png"></a></p><p><a href="https://wwex.lanzout.com/ipMLb28ud89g">下载体验地址</a>(温馨提示，此版本未经过任何的数值调整，平衡和体验都及其不成熟)</p><h1 id="灵感和讨论过程"><a href="#灵感和讨论过程" class="headerlink" title="灵感和讨论过程"></a>灵感和讨论过程</h1><p>本次gamejam的主题是做你想做的游戏，并且也不要求你做出一个可玩的游戏，你做出关于游戏的ppt就能算完成。由此可见完美这次压根就不是想做一个jam，而是抱着一种想要偷你点子给公司赚钱的目的，所以我们索性就做一个自己想玩的游戏算了。</p><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h1 id="技能设计"><a href="#技能设计" class="headerlink" title="技能设计"></a>技能设计</h1><h1 id="dotween"><a href="#dotween" class="headerlink" title="dotween"></a>dotween</h1><h1 id="桌游转电子游戏的痛点和思考"><a href="#桌游转电子游戏的痛点和思考" class="headerlink" title="桌游转电子游戏的痛点和思考"></a>桌游转电子游戏的痛点和思考</h1><p>桌游的乐趣和电子游戏的乐趣非常难转换，桌游的乐趣在于与人互动，虽然也有很多自闭刷分的游戏，但是也是要与人交互的，他要求人与人之间是平等的决策思路，而单机游戏如果简单的转换成打boss，那就会变得很不一样，相当难转换，这就是为什么很多桌游的机制不能用在电子游戏上来，当然这个是一个值得持续思考的问题。</p><h1 id="题外话和八卦"><a href="#题外话和八卦" class="headerlink" title="题外话和八卦"></a>题外话和八卦</h1><p>非常可笑的是，做完jam的第二周，我就被通知优化了，真是唏嘘啊。</p>]]></content>
    
    
    <summary type="html">在完美的最后一舞</summary>
    
    
    
    <category term="游戏锐评" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>UE引擎LGUI框架记录</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/UE%E5%BC%95%E6%93%8ELGUI%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>注册事件的写法</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在EventDefine.ts里添加对应的枚举和interface</span><br><br><span class="hljs-title class_">GuideGroupOpening</span>, <span class="hljs-comment">//引导组打开</span><br>    <br>[<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideFocusNeedUiTabView</span>]: <span class="hljs-function">(<span class="hljs-params">stepInfo: GuideStepInfo, focusConf: GuideFocusNew</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>        <br><span class="hljs-comment">// 在对应的Controller的OnAddEvents和OnRemoveEvents添加</span><br>        <br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Add</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Remove</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">OnGuideGroupOpening</span>);<br><br><br><span class="hljs-comment">// 在对应的Model代码添加触发器</span><br><span class="hljs-title class_">EventSystem</span>.<span class="hljs-title class_">Emit</span>(<span class="hljs-title class_">EEventName</span>.<span class="hljs-property">GuideGroupOpening</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Owner</span>!.<span class="hljs-property">Id</span>, isPreExecute);<br></code></pre></td></tr></table></figure><h1 id="LGUI在TS中的绑定写法"><a href="#LGUI在TS中的绑定写法" class="headerlink" title="LGUI在TS中的绑定写法"></a>LGUI在TS中的绑定写法</h1><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><p>prefab会有一个LGUIComponentsRegistry组件，定义了引用的顺序，例如：</p><p><img src="C:\Users\jiangliyong\AppData\Roaming\Typora\typora-user-images\image-20240619141651430.png" alt="image-20240619141651430"></p><p>然后在OnRegisterComponen方法里面按照熟悉绑定即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">ButtonMask</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextName</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>        [<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextureBg</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UITexture</span>],<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p><a href="https://kurogame.feishu.cn/wiki/LR2lwhGmci2wxGk0ISPcCp9Enwf">‌⁠‬‌‬‬‬﻿‬﻿‌‌‍‌‬﻿﻿‬⁠‍﻿LGUI设计说明文档 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcn93vYNH8Hduj3SAJaSPuG8f">‌﻿﻿‍⁠⁠‬‬﻿‬﻿‍‬‬‌‍﻿‌‌‌Ts Ui框架说明 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/JicQw8apsiUMXukKIhacLdNInYf">‌⁠‌‬﻿‬‍﻿‌⁠‍‌⁠﻿⁠﻿‌‌⁠‌⁠‌‌‍‬‍‌﻿业务UI框架重构 - 飞书云文档 (feishu.cn)</a></p><p>一些关键的基类：ComponentAction（所有UI类和UIBehavior类的共同最终基类，实现了一套带状态的生命周期调度和可重载接口）、UIPanelBase（提供给小UI，即界面中的格子、小界面等继承，拥有丰富的UI相关操作能力）、UIViewBase（提供给界面继承，它本身也继承自UIPanelBase，在其上扩展了动画、场景、事件、读取UI配置表的能力），继承关系ComponentAction-&gt;UIPanelBase-&gt;UIViewBase</p><p>UiPanelBase.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">ComponentRegisterInfos</span>: <span class="hljs-title class_">TComponentsRegisterInfo</span>[] = [];<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">BtnBindInfo</span>: <span class="hljs-title class_">TBtnBindInfo</span>[] = []; <span class="hljs-comment">//所有按钮绑定事件的定义</span><br><br><span class="hljs-comment">// 重写OnRegisterComponent方法</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnRegisterComponent</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ComponentRegisterInfos</span> = [<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CgTextureBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">CaptionText</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIText</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnAuto</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIItem</span>],<br>            [<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">BtnHide</span>, <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">UIButtonComponent</span>],<br>        ];<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>生命周期函数（带Async是异步版本）</p><p>OnRegisterComponent：绑定具体界面定义的enum里面的控件。</p><p>OnAddEventListener：添加ui事件监听，按钮啥的</p><p>控件相关的api在UIItem.d.ts里面</p><p>比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetButton</span>(<span class="hljs-title class_">EVideoView</span>.<span class="hljs-property">SkipBtn</span>)!.<span class="hljs-property">RootUIComp</span>.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h1 id="预制体中组件的显示与隐藏"><a href="#预制体中组件的显示与隐藏" class="headerlink" title="预制体中组件的显示与隐藏"></a>预制体中组件的显示与隐藏</h1><p>SetUIActive</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetItem</span>(<span class="hljs-title class_">ETutorialsPopupComponents</span>.<span class="hljs-property">PnlBottom</span>)!.<span class="hljs-title class_">SetUIActive</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="UI动画调用"><a href="#UI动画调用" class="headerlink" title="UI动画调用"></a>UI动画调用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LevelSequencePlayer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">RootItem</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Start&#x27;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">LevelSequencePlayer</span>!.<span class="hljs-title class_">PlayLevelSequenceByName</span>(<span class="hljs-string">&#x27;Loop&#x27;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="游戏中LGUI层级结构"><a href="#游戏中LGUI层级结构" class="headerlink" title="游戏中LGUI层级结构"></a>游戏中LGUI层级结构</h1><p><a href="https://kurogame.feishu.cn/wiki/wikcntd0SV4OAJV1fG3Md9LxpHV">‌‍‍‌⁠‌﻿⁠‌﻿‬⁠﻿⁠‍‬⁠‌‌‌‍﻿‌‍‌⁠﻿UI层级节点描述文档，包含容器逻辑实现规则 - 飞书云文档 (feishu.cn)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnNqg8wjO5u8dNApZbfzoJMe">屏幕空间UI层级说明 - 飞书云文档 (feishu.cn)</a></p><h2 id="Hud层"><a href="#Hud层" class="headerlink" title="Hud层"></a>Hud层</h2><p>交互和剧情界面旁白</p><h2 id="Normal层"><a href="#Normal层" class="headerlink" title="Normal层"></a>Normal层</h2><p>常规系统界面，只显示最表面的界面</p><h2 id="NormalMask层"><a href="#NormalMask层" class="headerlink" title="NormalMask层"></a>NormalMask层</h2><p>Normal层的点击阻挡遮罩</p><h2 id="Pop层"><a href="#Pop层" class="headerlink" title="Pop层"></a>Pop层</h2><p>可交互弹窗</p><h2 id="Float层"><a href="#Float层" class="headerlink" title="Float层"></a>Float层</h2><p>飘字和提示</p><h2 id="NetWork层"><a href="#NetWork层" class="headerlink" title="NetWork层"></a>NetWork层</h2><p>网络提示相关的ui</p><h2 id="Mark层"><a href="#Mark层" class="headerlink" title="Mark层"></a>Mark层</h2><p>以上所有层的点击阻挡遮罩</p><h2 id="Pool层"><a href="#Pool层" class="headerlink" title="Pool层"></a>Pool层</h2><p>对象池界面，优化性能使用</p><h1 id="播放声音"><a href="#播放声音" class="headerlink" title="播放声音"></a>播放声音</h1><p>使用AudioSystem</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">const LOOP_DIGITAL_SCREEN = <span class="hljs-string">&#x27;play_ui_digital_screen&#x27;</span><span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.PostEvent(LOOP_DIGITAL_SCREEN)<span class="hljs-comment">;</span><br>Audio<span class="hljs-params">System</span>.ExecuteAction(LOOP_DIGITAL_SCREEN, UE.EAudioActionType.Stop)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="修改某一个组件的具体参数"><a href="#修改某一个组件的具体参数" class="headerlink" title="修改某一个组件的具体参数"></a>修改某一个组件的具体参数</h1><p>使用SetCustomMaterialScalarParameter，这里要用到FName</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> factor = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-title class_">FName</span>(<span class="hljs-string">&#x27;factor&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetCustomMaterialScalarParameter</span>(<br>            factor,<br>            <span class="hljs-title class_">ModelManager</span>.<span class="hljs-property">DigitalScreenModel</span>?.<span class="hljs-property">TextFactor</span> ?? <span class="hljs-number">0.2</span>,<br>        );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UE引擎LGUI框架记录</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript知识点总结</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/TypeScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.126Z</updated>
    
    <content type="html"><![CDATA[<p>PuerTS的常用写法，</p><h1 id="TS基础写法"><a href="#TS基础写法" class="headerlink" title="TS基础写法"></a>TS基础写法</h1><p><a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">PlayStateCheckHandle</span>: <span class="hljs-title class_">TimerHandle</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>|表示联合类型，表示既可以是TimerHandle也可以是undefined</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Proto</span><span class="hljs-attr">_Nodes</span>: &#123; [<span class="hljs-attr">k</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">IProto_NodeInfo</span> &#125;;<br></code></pre></td></tr></table></figure><p> 表示一个索引签名（index signature），用于定义一个对象类型，其中键（key）是字符串类型，而值（value）是 <code>Aki.Protocol.IProto_NodeInfo</code> 类型。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可变长参数</p><p>…args</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">first: <span class="hljs-built_in">number</span>, ...rest: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`First argument is <span class="hljs-subst">$&#123;first&#125;</span>`</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> rest) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myFunction</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);  <span class="hljs-comment">// 输出: First argument is 1, hello, world, !</span><br></code></pre></td></tr></table></figure><p>在 TypeScript 中，函数内部创建的局部变量确实可以返回并在函数外部被直接修改，但这通常适用于可变类型（mutable types），如对象（包括 <code>Map</code>、<code>Set</code>、数组等）和函数。对于不可变类型（immutable types），如原始数据类型（数字、字符串、布尔值等），则不能直接修改。</p><p><strong>可变类型：</strong></p><p>当函数返回一个可变类型的值时，实际上返回的是这个值的引用（reference）。因此，通过这个引用所做的任何修改都会反映到原始对象上。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">复制function createObject() &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-keyword">prop</span>: 1 &#125;;<br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回对象的引用</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = createObject();<br>myObj.<span class="hljs-keyword">prop</span> = 2; <span class="hljs-comment">// 直接修改了 createObject 函数内部创建的对象</span><br>console.<span class="hljs-built_in">log</span>(myObj.<span class="hljs-keyword">prop</span>); <span class="hljs-comment">// 输出: 2</span><br></code></pre></td></tr></table></figure><p>这个是因为看的时候看到一段对我来说比较吊诡的代码，在一个私有函数创建了一个map(nodes)，直接set到了另一个map(NodesGroupByStatus)里面，但是直接返回nodes，在另一个函数里面可以直接修改，后面查了才知道，ts如果返回maps这种可修改的变量相当于返回的是引用，所以就是改的原始的nodes</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> <span class="hljs-title class_">AddNodeGroup</span>(<span class="hljs-attr">group</span>: <span class="hljs-title class_">ENodeGroup</span>): <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">TBehaviorNode</span>&gt;();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">NodesGroupByStatus</span>!.<span class="hljs-title function_">set</span>(group, nodes);<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">AddNodeToStatusGroup</span>(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TBehaviorNode</span>, <span class="hljs-attr">newStatus</span>: <span class="hljs-title class_">Aki</span>.<span class="hljs-property">Protocol</span>.<span class="hljs-property">Proto_NodeStatus</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">const</span> groupId = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetGroupIdByStatus</span>(newStatus);<br>    <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetNodesByGroupId</span>(groupId);<br>    <span class="hljs-keyword">if</span> (!nodes) &#123;<br>        nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">AddNodeGroup</span>(groupId);<br>    &#125;<br><br>    nodes.<span class="hljs-title function_">set</span>(node.<span class="hljs-property">NodeId</span>, node);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>继承extends</p><p><strong>super关键字</strong></p><ol><li><strong>调用父类构造函数</strong>：当你定义一个子类时，如果需要调用其父类的构造函数，可以使用 <code>super()</code>。这是必须的步骤，因为子类的实例在JavaScript&#x2F;TypeScript中总是通过父类的构造函数创建的。</li><li><strong>访问父类成员</strong>：<code>super</code> 也可以用来访问父类中定义的属性和方法，这在你想要扩展或重写父类成员时非常有用。</li><li><strong>访问父类的静态成员</strong>：使用 <code>super</code> 关键字，也可以访问父类的静态属性或方法</li><li><strong>在构造函数中</strong>：在构造函数中使用 <code>super</code> 必须作为第一条语句，因为子类实例的创建是基于父类构造函数的。</li><li><strong>在派生类的静态方法中</strong>：在静态方法中使用 <code>super</code> 来访问父类的静态成员。</li><li><strong>在派生类的方法中</strong>：在非静态方法中使用 <code>super</code> 来访问父类的非静态成员。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>一开始看这个OnUpdate的时候非常懵逼</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">OnUpdate</span>(<span class="hljs-attr">newUpdate</span>: $Undefinable&lt;$Delegate&lt;<span class="hljs-function">(<span class="hljs-params">InProgress: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;&gt;) : $Undefinable&lt;<span class="hljs-title class_">LTweener</span>&gt;;    <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-title class_">OnTick</span>(<span class="hljs-attr">deltaTime</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-keyword">const</span> tween = <span class="hljs-variable language_">this</span>.<span class="hljs-property">TextPlayTweenComp</span>!.<span class="hljs-title class_">GetPlayTween</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">UE</span>.<span class="hljs-property">LGUIPlayTween_Int</span>;<br>        <span class="hljs-keyword">const</span> tweener = tween?.<span class="hljs-title class_">GetTweener</span>();<br>        <span class="hljs-keyword">if</span> (tweener) &#123;<br>            tweener.<span class="hljs-title class_">OnUpdate</span>(<br>                <span class="hljs-title function_">toManualReleaseDelegate</span>((<span class="hljs-attr">progress</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">const</span> pro = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(progress * (tween.<span class="hljs-property">to</span> - tween.<span class="hljs-property">from</span>)) + tween.<span class="hljs-property">from</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> &lt; pro) &#123;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span> = pro;<br>                        <span class="hljs-variable language_">this</span>.<span class="hljs-title class_">GetText</span>(<span class="hljs-title class_">EDigitalScreenView</span>.<span class="hljs-property">TextList</span>)?.<span class="hljs-title class_">SetText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">Text</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">Progress</span>));<br>                    &#125;<br>                &#125;),<br>            );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">基础类型 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>类型断言，有点类似其他语言的类型转换，通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>const id &#x3D; a ? b : c;</p><p>条件 ? 表达式1 : 表达式2</p><ul><li>如果 <code>条件</code>（在这里是变量 <code>a</code>）为真（truthy），那么整个表达式的结果是 <code>表达式1</code>（在这里是变量 <code>b</code>）。</li><li>如果 <code>条件</code> 为假（falsy），那么结果是 <code>表达式2</code>（在这里是变量 <code>c</code>）。</li></ul><h3 id="x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D"><a href="#x3D-x3D-和-x3D-x3D-x3D-和-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;"></a>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;和!&#x3D;&#x3D;</h3><ol><li><strong>严格等于 (<code>===</code>)</strong>:<ul><li><code>===</code> 是严格等于运算符，它比较两个值是否完全相等，包括它们的类型。</li><li>如果两个操作数的类型不同，<code>===</code> 返回 <code>false</code>。</li><li>只有当两个操作数的类型和值都相同时，<code>===</code> 才返回 <code>true</code>。</li></ul></li><li><strong>等于 (<code>==</code>)</strong>:<ul><li><code>==</code> 是等于运算符，它比较两个值是否等价。</li><li>如果操作数的类型不同，JavaScript 会进行类型转换，然后再比较它们的值。</li><li><code>==</code> 会根据需要将操作数转换为数字或字符串，然后进行比较。</li></ul></li><li>!&#x3D;&#x3D;</li></ol><p>​不相等，但是不会进行类型转换</p><h3 id="和"><a href="#和" class="headerlink" title="?.和!."></a>?.和!.</h3><p><code>!</code> 被称为非空断言操作符，它用来告诉 TypeScript 编译器，某个位置的值不应该为 <code>null</code> 或 <code>undefined</code>。</p><p>?.是一种语法糖， 如果多层访问中间有null或者undefined就会返回undefined，不用自己再另写类型检查</p><h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>表示调用这个对象或者参数的时候这个参数可选</p><h3 id="-1"><a href="#-1" class="headerlink" title="??"></a>??</h3><p>逻辑运算符，用于返回两个操作数中第一个非空值（non-nullish value），或者在两个操作数都为空值（null 或 undefined）时返回右侧的操作数。</p><h1 id="UE4容器使用"><a href="#UE4容器使用" class="headerlink" title="UE4容器使用"></a>UE4容器使用</h1><h2 id="TArray"><a href="#TArray" class="headerlink" title="TArray"></a>TArray</h2><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TArrays/">TArray：虚幻引擎中的数组 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h3 id="创建和填充"><a href="#创建和填充" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建</span><br>TArray&lt;int32&gt; IntArray;<br><br><span class="hljs-comment">// 填充</span><br>IntArray.<span class="hljs-built_in">Init</span>(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 等价于下面</span><br><span class="hljs-comment">// IntArray = [10, 10, 10, 10, 10]</span><br><br><span class="hljs-comment">// 在末尾增加用Add或者Emplace</span><br><span class="hljs-comment">// Add会创建一个新实例，Emplace不会</span><br><br>TArray&lt;FString&gt; StrArr;<br>StrArr.<span class="hljs-built_in">Add</span>    (<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>StrArr.<span class="hljs-built_in">Emplace</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;World&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;]</span><br><br><span class="hljs-comment">// 利用 Append 可一次性添加其他 TArray 中的多个元素</span><br><br>FString Arr[] = &#123; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;of&quot;</span>), <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Tomorrow&quot;</span>) &#125;;<br>StrArr.<span class="hljs-built_in">Append</span>(Arr, <span class="hljs-built_in">ARRAY_COUNT</span>(Arr));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;]</span><br><br><span class="hljs-comment">// 仅在尚不存在等值元素时， AddUnique 才会向容器添加新元素。</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr == [&quot;Hello&quot;,&quot;World&quot;,&quot;of&quot;,&quot;Tomorrow&quot;,&quot;!&quot;]</span><br><br>StrArr.<span class="hljs-built_in">AddUnique</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// StrArr is unchanged as &quot;!&quot; is already an element</span><br><br><span class="hljs-comment">// Insert</span><br><br>StrArr.<span class="hljs-built_in">Insert</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Brave&quot;</span>), <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// SetNum,如新数量大于当前数量，则使用元素类型的默认构造函数新建元素</span><br><span class="hljs-comment">// 如新数量小于当前数量， SetNum 将移除元素。</span><br><br><br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ranged-for</span><br>FString JoinedStr;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; Str :StrArr)<br>&#123;<br>    JoinedStr+=Str;<br>&#125;<br><br><span class="hljs-comment">// 直接for循环</span><br><span class="hljs-keyword">for</span> (int32 Index = <span class="hljs-number">0</span>; Index != StrArr.<span class="hljs-built_in">Num</span>(); ++Index)<br>&#123;<br>    JoinedStr += StrArr[Index];<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 数组迭代器:CreateIterator读写；CreateConstIterator只读</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> It = StrArr.<span class="hljs-built_in">CreateConstIterator</span>();It;++It)<br>&#123;<br>    JoinedStr += *It;<br>    JoinedStr += <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Sort，基于快排</span><br><span class="hljs-comment">// HeapSort，堆排序</span><br><span class="hljs-comment">// StableSort，基于归并排序，可以保证等值元素的相对顺序，上面两个无法保证</span><br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Num，查询数量</span><br><br><span class="hljs-comment">// GetData,返回指针元素</span><br><br><span class="hljs-comment">// Contains，查询是否包含特定元素</span><br><br><span class="hljs-comment">// ContainsByPredicate,可自己写规则</span><br><br><span class="hljs-type">bool</span> bHello   = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-type">bool</span> bGoodbye = StrArr.<span class="hljs-built_in">Contains</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Goodbye&quot;</span>));<br><span class="hljs-comment">// bHello   == true</span><br><span class="hljs-comment">// bGoodbye == false</span><br><br><span class="hljs-type">bool</span> bLen5 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">5</span>;<br>&#125;);<br><span class="hljs-type">bool</span> bLen6 = StrArr.<span class="hljs-built_in">ContainsByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> Str.<span class="hljs-built_in">Len</span>() == <span class="hljs-number">6</span>;<br>&#125;);<br><span class="hljs-comment">// bLen5 == true</span><br><span class="hljs-comment">// bLen6 == false</span><br><br><span class="hljs-comment">// Find，返回找到的第一个元素的索引</span><br><span class="hljs-comment">// FindLast,范围找到的最后一个元素的索引</span><br>int32 IndexLast;<br><span class="hljs-keyword">if</span> (StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>), IndexLast))<br>&#123;<br>    <span class="hljs-comment">// IndexLast == 3, because there aren&#x27;t any duplicates</span><br>&#125;<br><br><span class="hljs-comment">// 上面时返回布尔值，也可以直接返回索引，未找到时INDEX_NONE</span><br>int32 Index2     = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexLast2 = StrArr.<span class="hljs-built_in">FindLast</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br>int32 IndexNone  = StrArr.<span class="hljs-built_in">Find</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;None&quot;</span>));<br><span class="hljs-comment">// Index2     == 3</span><br><span class="hljs-comment">// IndexLast2 == 3</span><br><span class="hljs-comment">// IndexNone  == INDEX_NONE</span><br><br><span class="hljs-comment">// IndexOfByKey</span><br><span class="hljs-comment">// IndexOfByPredicate</span><br><br><span class="hljs-comment">// FilterByPredicate可以直接找到匹配的元素数组</span><br><span class="hljs-keyword">auto</span> Filter = StrArray.<span class="hljs-built_in">FilterByPredicate</span>([](<span class="hljs-type">const</span> FString&amp; Str)&#123;<br>    <span class="hljs-keyword">return</span> !Str.<span class="hljs-built_in">IsEmpty</span>() &amp;&amp; Str[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&#x27;M&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除所有提供元素等值的元素</span><br><span class="hljs-comment">// RemoveSingle,移除首个匹配元素</span><br><span class="hljs-comment">// RemoveAt，移除特定位置元素</span><br><span class="hljs-comment">// RemoveAll,可以自己定义规则</span><br><br><br><span class="hljs-comment">// 如果不需要保证排序，可以用下面的来加快速度</span><br><span class="hljs-comment">// RemoveSwap,RemoveAtSwap,RemoveAllSwap</span><br><br><span class="hljs-comment">// Empty 清空</span><br></code></pre></td></tr></table></figure><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// +=，串联</span><br><br><span class="hljs-comment">// MoveTemp，移动语义，清空源数组</span><br>ValArr3 = <span class="hljs-built_in">MoveTemp</span>(ValArr4);<br><span class="hljs-comment">// ValArr3 == [5,2,3,1,2,3]</span><br><span class="hljs-comment">// ValArr4 == []</span><br><br><span class="hljs-comment">// == 和 != 进行比较，必须排序和数量都一样</span><br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h2 id="TMap"><a href="#TMap" class="headerlink" title="TMap"></a>TMap</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/">TMap | 虚幻引擎4.27文档 (unrealengine.com)</a></p><p>TMap键不能重复，TMultiMap键不唯一</p><h3 id="创建和填充-1"><a href="#创建和填充-1" class="headerlink" title="创建和填充"></a>创建和填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TMap&lt;int32, FString&gt; FruiMap;<br><br><span class="hljs-comment">// 填充都一样，但是要是填重复的键会覆盖之前的值</span><br><br></code></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>类似TArrays，不过迭代元素是TPair</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Contains来查询是否包含特定键</span><br><br><span class="hljs-comment">// Find，失败返回null</span><br><br><span class="hljs-comment">// FindOrAdd，不存在该键会新创建一个元素</span><br><br><span class="hljs-comment">// FindRef，没找到会返回默认值，不会创建新元素</span><br><br>FString&amp; Ref7 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// Ref7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;</span><br><span class="hljs-comment">// ]</span><br>FString&amp; Ref8 = FruitMap.<span class="hljs-built_in">FindOrAdd</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// Ref8     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br>FString Val7 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">7</span>);<br>FString Val6 = FruitMap.<span class="hljs-built_in">FindRef</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// Val7     == &quot;Pineapple&quot;</span><br><span class="hljs-comment">// Val6     == &quot;&quot;</span><br><span class="hljs-comment">// FruitMap == [</span><br><span class="hljs-comment">//  &#123; Key:5, Value:&quot;Mango&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:2, Value:&quot;Pear&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:7, Value:&quot;Pineapple&quot; &#125;,</span><br><span class="hljs-comment">//  &#123; Key:4, Value:&quot;Kiwi&quot;      &#125;,</span><br><span class="hljs-comment">//  &#123; Key:3, Value:&quot;Orange&quot;    &#125;,</span><br><span class="hljs-comment">//  &#123; Key:9, Value:&quot;Melon&quot;     &#125;,</span><br><span class="hljs-comment">//  &#123; Key:8, Value:&quot;&quot;          &#125;</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// FindKey，按值查找</span><br></code></pre></td></tr></table></figure><h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Remove，移除对应键的元素</span><br>FruitMap.<span class="hljs-built_in">Remove</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// FindAndRemoveChecked，移除元素并返回该值</span><br>FString Removed7 = FruitMap.<span class="hljs-built_in">FindAndRemoveChecked</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// RemoveAndCopyValue 函数的作用与 Remove 相似，不同点是会将已移除元素的值复制到引用参数</span><br>FString Removed;<br><span class="hljs-type">bool</span> bFound2 = FruitMap.<span class="hljs-built_in">RemoveAndCopyValue</span>(<span class="hljs-number">2</span>, Removed);<br><br><span class="hljs-comment">// Empty和Reset，清空</span><br></code></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KeySort或者ValueSort</span><br>FruitMap.<span class="hljs-built_in">KeySort</span>([](int32 A, int32 B) &#123;<br>    <span class="hljs-keyword">return</span> A &gt; B; <span class="hljs-comment">// sort keys in reverse</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h3><p>有复制和移动语义</p><h3 id="Slack-1"><a href="#Slack-1" class="headerlink" title="Slack"></a>Slack</h3><h3 id="KeyFuncs"><a href="#KeyFuncs" class="headerlink" title="KeyFuncs"></a>KeyFuncs</h3><h2 id="TSet"><a href="#TSet" class="headerlink" title="TSet"></a>TSet</h2><h1 id="UE4回调"><a href="#UE4回调" class="headerlink" title="UE4回调"></a>UE4回调</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/Delegates/">委托 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate - 知乎 (zhihu.com)</a></p><p>UE支持三种委托：单点委托，组播委托（事件），动态委托</p><h3 id="单点委托"><a href="#单点委托" class="headerlink" title="单点委托"></a>单点委托</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><h3 id="动态委托"><a href="#动态委托" class="headerlink" title="动态委托"></a>动态委托</h3><h1 id="UE4对象函数"><a href="#UE4对象函数" class="headerlink" title="UE4对象函数"></a>UE4对象函数</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Functions/">UFunctions | 虚幻引擎4.26文档 (unrealengine.com)</a></p><h1 id="UE4引用"><a href="#UE4引用" class="headerlink" title="UE4引用"></a>UE4引用</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/Assets/ReferencingAssets/">引用资源 | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/ReferenceAssets/">引用 Actor | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p><a href="https://kurogame.feishu.cn/wiki/wikcnLhvL7EdoiVzOhE8P2cjTCh">UE引用类型说明 - 飞书云文档 (feishu.cn)</a></p><p>引用分为两种，硬性引用，即对象 A 引用对象 B，并导致对象 B 在对象 A 加载时加载；软性引用，即对象 A 通过间接机制（例如字符串形式的对象路径）来引用对象 B。</p><p>一种是通过UPROPERTY</p><p><strong>直接属性引用</strong></p><p>通过设置变量的UPROPERTY直接在编辑器设置对应资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** construction start sound stinger */</span><br><br><span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Building)<br><br>USoundCue* ConstructionStartStinger;<br></code></pre></td></tr></table></figure><p><strong>构造时引用</strong></p><p>构造时加载对应资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/** gray health bar texture */</span><br><br><span class="hljs-constructor">UPROPERTY()</span><br><br><span class="hljs-keyword">class</span> UTexture2D* BarFillTexture;<br><br>AStrategyHUD::<span class="hljs-constructor">AStrategyHUD(<span class="hljs-params">const</span> FObjectInitializer&amp; ObjectInitializer)</span> :<br>    <span class="hljs-constructor">Super(ObjectInitializer)</span><br>&#123;<br>    static ConstructorHelpers::FObjectFinder&lt;UTexture2D&gt; <span class="hljs-constructor">BarFillObj(TEXT(<span class="hljs-string">&quot;/Game/UI/HUD/BarFill&quot;</span>)</span>);<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    </span>BarFillTexture = BarFillObj.Object;<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>一种是用字符串来引用，如果UObject已经加载就用FindObject&lt;&gt;()，没有加载就使用LoadObject&lt;&gt;()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">AFunctionalTest* TestToRun = <span class="hljs-built_in">FindObject</span>&lt;AFunctionalTest&gt;(TestsOuter, *TestName);<br>GridTexture = <span class="hljs-built_in">LoadObject</span>&lt;UTexture2D&gt;(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;/Engine/EngineMaterials/DefaultWhiteGrid.DefaultWhiteGrid&quot;</span>), <span class="hljs-literal">NULL</span>, LOAD_None, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h1 id="UE4FName"><a href="#UE4FName" class="headerlink" title="UE4FName"></a>UE4FName</h1><p><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/StringHandling/FName/">FName | 虚幻引擎4.26文档 (unrealengine.com)</a></p><p>在 <strong>内容浏览器</strong> 中为新资源命名时，变更动态材质实例中的参数或访问骨骼网格体中的一块骨骼时需要使用 <strong>FNames</strong> 。 FName 通过一个轻型系统使用字符串。在此系统中，特定字符串即使会被重复使用，在数据表中也只存储一次。</p><p>FNames 不区分大小写。它们为不可变，无法被操作。FNames 的存储系统和静态特性决定了通过键进行 FNames 的查找和访问速度较快。 FName 子系统的另一个功能是使用散列表为 FName 转换提供快速字符串。</p><p>FNames 不区分大小写，作为索引组合存储在唯一字符串和实例编号的表格中。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FName TestName = <span class="hljs-built_in">FName</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Test&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FMame到FString</span><br>TestString = TestName.<span class="hljs-built_in">ToSring</span>();<br><br><span class="hljs-comment">// FName到FText</span><br>TestText = FText::<span class="hljs-built_in">FromName</span>(TestName);<br><br><span class="hljs-comment">// Fstring和FText到Fname都不可靠，因为FName不区分大小写</span><br><br><span class="hljs-comment">// FString到FName</span><br>TestName = <span class="hljs-built_in">FName</span>(*TextString);<br><br><span class="hljs-comment">// FText无法直接到FName</span><br></code></pre></td></tr></table></figure><p>对比是否相同直接比较索引的数值，不用执行字符串的对比</p>]]></content>
    
    
    <summary type="html">TypeScript知识点总结</summary>
    
    
    
    <category term="游戏杂货铺" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B4%A7%E9%93%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>鸣潮体验报告</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/%E9%B8%A3%E6%BD%AE%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h1><p>经过这一个月的体验，优点和缺点都挺明显的，一度也非常上头，优点就是战斗机制，动作，以及声骸系统比较有趣，缺点就是有一些玩法的手感和设计体验可以改进，以下是一些具体的讲述。</p><h1 id="战斗"><a href="#战斗" class="headerlink" title="战斗"></a>战斗</h1><h2 id="动作系统设计"><a href="#动作系统设计" class="headerlink" title="动作系统设计"></a>动作系统设计</h2><p>战斗的深度还是比较丰富的，有闪避，拼刀，普攻，重击，声骸技能，小技能，大招，换人技能，绳索，跳跃，而且基本所有动作都可以取消，这就给动作系统延伸了很多深度，给了玩家很多进阶技巧的可能，比如跳跃：比如各种换人使用声骸技能无限上天或者一路冲过去不落地，这都是非常有意思的技巧，我觉得官方甚至可以在大地图上放一些只能通过这些特殊技巧才能到达的地点，然后放一些小奖励，作为彩蛋来奖励掌握了这些深度技巧的玩家，类似马里奥奥德赛会在一个非常难跳上去的地方放一堆金币。</p><p>又比如战斗的时候卡延奏技能来打破怪物的拼刀圈，这是非常爽的，有一瞬间打出高伤害的快感。</p><h2 id="战斗模式"><a href="#战斗模式" class="headerlink" title="战斗模式"></a>战斗模式</h2><p>不同的模式侧重点不一样，比如深塔要求速通，可能连招拉怪就比较固定，讲究效率；全息挑战有一种魂类的感觉，一板一眼不能乱吃一招；肉鸽要求策略搭配，随机的快乐。这些战斗模式可以满足不同玩家的需求，</p><h3 id="深塔挑战"><a href="#深塔挑战" class="headerlink" title="深塔挑战"></a>深塔挑战</h3><p>限时挑战</p><h3 id="大boss挑战"><a href="#大boss挑战" class="headerlink" title="大boss挑战"></a>大boss挑战</h3><p>这个主要是通过增加数值来增加玩家的失误惩罚，但是血太厚了也有点无力感，毕竟也有限时的要求，感觉可以把限时给去掉，让人有刮死的可能</p><h3 id="肉鸽"><a href="#肉鸽" class="headerlink" title="肉鸽"></a>肉鸽</h3><p>我非常喜欢肉鸽模式，套路成型之后非常有一种割草的爽感，其中的乌龟套盾流更是相当的爽，只要能拿到满血加攻击力暴击这个buff就能无脑割草。</p><p>目前的肉鸽模式中，有两个build的方向，一个是凑词条来解锁开局带的声骸的技能上限，一个是选buff来产生combo，个人认为前者build起来后比较爽， 无论是化身无冠者战斗还是乌龟套盾都很快乐，但是后者的buff有点过于平淡普通了，大多是简单的加伤害暴击这些数值上的buff，非常简单粗暴，希望接下来可以出一些机制上的buff，这样可以加深肉鸽的策略深度。</p><p>还有一点的话是否可以开启无尽模式，让大家来多爽一下构建好的build。</p><h1 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h1><p>游戏整体的开图比较偏向于强引导，前期的各种boss都是通过支线任务引导见面的，支线任务有些太套路化了， 每次结束都是打一个新的boss，毫无新鲜感，而且这也破坏了玩家自主探索地图的过程。</p><p>另外一个破坏探索感的点是，打开地图可以直接看到所有的塔和传送点，或许这是因为出于剧情和难度考虑，不过对于我来说，因为地图上的传送点完全可以在地图上预览到，这就完全失去了开图的乐趣。并且也让地图设计的动线流程，引导全部失去了作用。</p><p>我的开图体验就是标一个还没开的点，然后直直的跑过去，途中如果有正好的宝箱会开一下，但是不会在意其他东西，然后面对着全部打开的地图，就失去了逛街的欲望；或许是不是可以让玩家自己选择游戏模式，可以把未知的传送点和塔设置为隐藏，这样或许能达到我一开始玩塞尔达的那种体验，追着高高的塔去探索，只知道一个大致的方向，然后中途被各种有趣的东西吸引，结果越走越远，越走越分叉，当然这也要求地图上的东西足够有趣，</p><h1 id="任务-amp-剧情"><a href="#任务-amp-剧情" class="headerlink" title="任务&amp;剧情"></a>任务&amp;剧情</h1><p>我觉得加了直接跳过有点破坏体验，中间有很多支线任务我都是直接全部跳过剧情，然后前往下一个点按一下f，或者打一下怪，游戏变成了一个大大的to-do list，并且显示十分枯燥，真就变成了一只在斯金纳箱的小白鼠，一直不停的跳过跳过只为了最后的奖励。</p><p>所以我觉得加剧情梗概或者快进是一个非常重要的功能，既能让玩家感受到剧情也能减负。或者可以考虑做一个galgame里面常见的历史对话，让玩家可以自己读跳过的对话。</p><h1 id="养成玩法"><a href="#养成玩法" class="headerlink" title="养成玩法"></a>养成玩法</h1><p>能养成的丰富度还是有的，人物等级，人物命座，武器等级，人物技能，声骸等级，声骸初始属性，声骸升级词条；其中声骸相关的是刷的重点，不过声骸的刷要从能稳定出金才开始，也就是大概数据坞18级（记不太清了），所以前三十级升声骸比较亏，因为无法把别的词条转移。</p><p>除了声骸是赌博玩法之外其他都是看得见的积累，这一点相对来说比较没那么坑，但是后续的数值养成是否会深度不够？不过这个方面我也不太懂。</p><h1 id="解谜和小玩法"><a href="#解谜和小玩法" class="headerlink" title="解谜和小玩法"></a>解谜和小玩法</h1><h2 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h2><p>这个玩法比较有趣，一笔画，其实可以借鉴一下the witness或者mini metro这些一笔画游戏，可以把这个趣味性做的更有深度。</p><h2 id="2d玩法"><a href="#2d玩法" class="headerlink" title="2d玩法"></a>2d玩法</h2><p>凌阳任务有一段转变成2d的玩法，这一段挺有意思，但是跳跃和冲刺的手感有点打磨不够好，跳起来感觉轻飘飘的，冲刺的速度没有明显加速，似乎是直接把3d里面的跳跃和冲刺参数直接拿过来，而且似乎没有土狼时间，所以导致跑起来手感很奇怪。</p><p>我觉得2d玩法挺有意思的，一开始3d转2d的时候非常有意思，之后如果有想法可以多做一些这种关卡和解谜，参考fez和马里奥奥德赛。</p><h2 id="找金币跑酷"><a href="#找金币跑酷" class="headerlink" title="找金币跑酷"></a>找金币跑酷</h2><p>每次遇到这个玩法我都无法收集完全部的金币，体验比较差，能否能在玩法开始前拉一个远镜头，告诉玩家大概得路线是怎样的，或者对于一些比较长的路线做一个预览图，告诉玩家路线。可以参考马里奥奥德赛里面的金币收集小玩法，还有一个</p><h2 id="声骸玩法"><a href="#声骸玩法" class="headerlink" title="声骸玩法"></a>声骸玩法</h2><p>变身成声骸跑酷还是比较有意思的，很有马里奥奥德赛里面附身变身的快乐，不过做的玩法有好有坏，以下是简单点评。</p><h3 id="蝴蝶"><a href="#蝴蝶" class="headerlink" title="蝴蝶"></a>蝴蝶</h3><p>这个玩法在电脑上体验一开始上手有点反逻辑，因为从wasd控制方向直接变成了鼠标完全控制方向，键盘仅仅用于加减速，而且某些移动靶想要完美通过的接口确实比较难。不过这个思路是挺有趣的，相对的变身成河豚跑酷就好很多。</p><h3 id="河豚"><a href="#河豚" class="headerlink" title="河豚"></a>河豚</h3><p>这个操作感就好一点，并且喷水加速的感觉很有奥德赛里面的变身成墨鱼喷水加速飞天的感觉，所以玩起来很快乐。</p><h3 id="鸟追逐战"><a href="#鸟追逐战" class="headerlink" title="鸟追逐战"></a>鸟追逐战</h3><p>一开始知道支线能变身鸟飞来作战非常期待，但是实际玩起来有点失望， 因为不用自己控制方法，只需要点击左键攻击和放大招就完事了，少了一点操纵感，如果未来还要类似的可以考虑增加玩家的操作维度。</p><h3 id="蜥蜴烧荆棘"><a href="#蜥蜴烧荆棘" class="headerlink" title="蜥蜴烧荆棘"></a>蜥蜴烧荆棘</h3><p>我记得一开始遇到一个荆棘挡路的时候，下意识地用了蜥蜴喷火的声骸技能，结果真的烧起来了，这个一开始见到还是比较经验的，颇有塞尔达点火射箭然后解谜过关的感觉，但是后面很多次我想继续重复这个知识，结果只能用旁边的爆炸球来解决眼前的荆棘，这个体验有点不好。</p><h3 id="未来可能"><a href="#未来可能" class="headerlink" title="未来可能"></a>未来可能</h3><p>未来是否有可能在大世界里加入更多声骸玩法，类似帕鲁，或者奥德赛这样直接变身声骸赶路，或者做一些特定解谜，然后把跑酷玩法手感优化。</p><h3 id="3d限时跑酷"><a href="#3d限时跑酷" class="headerlink" title="3d限时跑酷"></a>3d限时跑酷</h3><h2 id="音游"><a href="#音游" class="headerlink" title="音游"></a>音游</h2><p>手机上体验有一个反直觉的点，我一开始以为可以直接按中间的下落界面来操作，类似节奏大师，但是结果只有右下角的按钮才能响应操作，很奇怪，期待之后能做出更多音游玩法。</p><h2 id="控物填满拼图"><a href="#控物填满拼图" class="headerlink" title="控物填满拼图"></a>控物填满拼图</h2><p>这个玩法不太行， 主要是因为控物的操作太复杂了，首先这不是一个一眼能看出的谜题，所以就需要比较多的试错，传统的拼图puzzle一般是直接用鼠标拖动，这样试错起来就很简单，但是大世界里面采用控物来拼图，不仅要求对准，而且旋转和放下的操作也很缓慢，所以就很容易让人很暴躁，可以考虑简化操作。这个玩法的两个，打通光路和拼石头都比较体验不好。</p><p>其实控物这个操作还是挺有意思，但是操作感太差了，我一开始下意识以为能像王国之泪那样调整远近啊，旋转啊这样，但是其实并没有做到，希望未来可以改进，或许可以加入更多相关的解谜玩法。</p>]]></content>
    
    
    <summary type="html">鸣潮体验报告</summary>
    
    
    
    <category term="游戏锐评" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E9%94%90%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-Unity相关</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-Unity%E7%9B%B8%E5%85%B3/</id>
    <published>2024-04-11T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/20201004160417460.png" alt="生命周期"></p><p><strong>1、静态构造函数</strong><br>当程序集被加载的时候就被调用了，如果你的unity处于编辑状态时，此时你保存一个脚本（从而迫使重新编译），静态构造函数会立即被调用，因为unity加载了DLL。并且它将不会再次运行，永远只会执行一次，unity运行时，是不会再次执行了！在一个已部署的游戏上，这个构造器将会在unity加载过程的早期被调用！</p><p><strong>2、Awake</strong><br>只会被调用一次，在Start方法之前被调用！ 主要用于字段值的初始化工作，禁用脚本，创建游戏对象，或者 Resources.Load(Prefab) 对象</p><p><strong>3、Start</strong><br>只执行一次，在Awake方法执行结束后执行，但在Update方法执行前执行， 主要用于程序UI的初始化操作，比如获取游戏对象或者组件</p><p><strong>4、Update</strong><br>每一帧执行的，监听用户输入，播放动画，当机器忙或者性能差的时候，他会停止执行，会产生停顿的感觉，例如一个人本来在1米的位置，突然到了5米的位置上，产生了跳帧，而下面的FixedUpdate方法则相反！会一米一米的去执行！（自己调试发现，Update是先于OnGUI执行的，且执行一次Update之后，会执行两次OnGUI）</p><p><strong>5、FixedUpdate</strong><br>不管当前机器忙不忙，都会保证每一帧执行一次！避免跳帧！固定更新。固定更新常用于移动模型等操作。</p><p><strong>6、LateUpdate</strong><br>先执行Update，然后才去执行lateUpdate(Update方法执行完，必定接着执行LateUpdate，而Update和FixedUpdate方法的执行顺序不确定，而且有时候FIxedUpdate执行了多帧，而Update却只执行了一帧，这就是因为跳帧的缘故造成的（取决于你的机器性能）！)，如果现在有100个脚本，分别有100个 Update()函数，其中只有一个LateUpdate，那么在同一帧中，等待100个Update()执行完后，才执行这一个LateUpdate()。</p><p><strong>7、OnGUI</strong><br>在这里面进行GUI的绘制，且GUI是每帧擦除重绘的！仅仅只是绘制！没有生命周期的概念！所有关于绘制GUI的代码，都要直接或者间接地写到OnGUI方法中！</p><p><strong>8、OnDestroy</strong><br>当前脚本销毁时调用</p><p><strong>9、OnEnable</strong><br>脚本可用时被调用、如果脚本是不可用的，将不会被调用！</p><p><strong>11、OnDisable</strong><br>如果脚本被设置为不可用将会被执行，程序结束时可用的脚本也会执行一次这个方法</p><p>OnEnable 和 OnDisable 只受脚本的可用状态的影响（enabled）,而 OnBecameVisible 和 OnBecameInvisible 是受对象是否可见的影响！即使脚本设置为不可用，OnBecameVisible 和 OnBecameInvisible 也会被执行，主要是看对象是否在场景中显示了！</p><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="ugui"><a href="#ugui" class="headerlink" title="ugui"></a>ugui</h2><h3 id="rebatch和rebuild"><a href="#rebatch和rebuild" class="headerlink" title="rebatch和rebuild"></a>rebatch和rebuild</h3><p><a href="https://zhuanlan.zhihu.com/p/266997416">Unity UI 优化学习总结 - 天欲雪的文章 - 知乎</a></p><p><strong>Canvas</strong>（画布），和名字一样，是 UI 绘制的地方，Unity 的渲染系统用其来提供一个可绘制的分层几何。负责将ui几何合批成适合的网格，提交绘制命令给 Unity 的图形系统，这整个过程叫做 <strong>rebatch</strong> 或者 <strong>batch build</strong>。当 Canvas 其子节点下包含 Canvas Renderer 的节点需要进行 rebatch 的时候，就会被标记为脏。</p><p>Graphic 与 Layout 都依赖于 CanvasUpdateRegistry 类。它会定位 Graphic 与 Layout 是否需要更新并加入更新队列，在所在 Canvas 的 willRenderCanvases 事件被触发时对队列中的对象执行真正的更新。</p><h2 id="图集有什么用，适用场景。"><a href="#图集有什么用，适用场景。" class="headerlink" title="图集有什么用，适用场景。"></a>图集有什么用，适用场景。</h2><p>定义<br>图集是将很多零碎的2D小图整合成一张大图，方便unity渲染合批，降低渲染消耗。</p><p>优势<br>1.UI的合批处理，减少DrawCall</p><p>多张图片需要多次DrawCall，合并成一张大图只需要调用一次DrawCall</p><p>2.减少对内存的占用</p><p>OpenGL每张贴图都需要设置为2的N次方才能使用，假设有宽高分别为100x100、10x10的两张图片，如果不合成大贴图，那么就需要分别使用128x128和16x16的图片，会浪费一部分内存空间。</p><p>如果是使用一张大图的话，就可以将两张图片打到128x128的图集，进而减少内存的占用。</p><p>3.提升效率</p><p>图片尺寸为2的次幂时，GPU处理起来会快很多，小图不可能做不到每张图都是2的次幂的，但打成一张大图就可以。<br><a href="https://blog.csdn.net/z2014z/article/details/119654256">https://blog.csdn.net/z2014z/article/details/119654256</a></p><h2 id="屏幕自适应方案"><a href="#屏幕自适应方案" class="headerlink" title="屏幕自适应方案"></a>屏幕自适应方案</h2><p>canvas scaler</p><p>锚点</p><h1 id="批处理和drawcall"><a href="#批处理和drawcall" class="headerlink" title="批处理和drawcall"></a>批处理和drawcall</h1><p><a href="https://zhuanlan.zhihu.com/p/432223843">Unity渲染优化的4种批处理：静态批处理，动态批处理，SRP Batcher 与 GPU Instancing - acnestis的文章 - 知乎</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f5b8402d281543a9debe941f9762889a_r.jpg" alt="img"></p><h1 id="常用的Unity-Atrribute"><a href="#常用的Unity-Atrribute" class="headerlink" title="常用的Unity Atrribute"></a>常用的Unity Atrribute</h1><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>unity脚本生命周期函数。</p><p>Lerp作用</p><p>欧拉角计算，Quaternio.Euler。</p><p>常用的Unity Atrribute</p><p>如何判断是否碰到了场景中的物体？</p><p>Coroutine有什么用，优缺点</p><p>发生碰撞的必要条件。</p><p>ugui如何保证分辨率改变ui大小不变。</p><p>C#List底层数据结构，增加和删除时间复杂度。</p><p>结构体和类的区别。</p><p>引用类型和值类型分别有哪些。</p><p>装箱和拆箱是什么，为什么不要频繁适用?</p><p>简单用代码实现一个单例模式。</p><p>观察模式读代码写结构，用在哪里？</p><p>频繁地对字符串进行分割，写一个代码。（就是分数比如说100000，分成100,000这样）</p><p>分批手段和适用场景。</p><h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><p>渲染管线就是一系列处理数据的过程</p><h2 id="应用程序阶段"><a href="#应用程序阶段" class="headerlink" title="应用程序阶段"></a>应用程序阶段</h2><p>Unity会知道要渲染哪些模型，还有光源相机的信息也会输入进去，然后就会进行剔除，使用AABB包围盒，只要有一个顶点在摄像机的可视范围里面，就不会剔除，然后把这些输入进GPU里面。</p><h2 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h2><p>这个阶段是可以编程写shader的阶段，主要是把空间中的网格顶点编程屏幕上的网格顶点。顶点着色器，对每一个顶点都进行操作，可以简单的传递到下一个阶段，也可以做一些几何变换或者光源颜色相关的变换。</p><p>细分着色器，几何着色器，图元装配</p><p><img src="https://pic4.zhimg.com/v2-470a9d8b774085665f07fae572cc933f_1440w.jpg" alt="img"></p>]]></content>
    
    
    <summary type="html">Unity知识</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-游戏相关的一些知识</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E6%B8%B8%E6%88%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</id>
    <published>2024-04-10T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h1><p><a href="https://www.cnblogs.com/indream/p/3602348.html">从Script到Code Blocks、Code Behind到MVC、MVP、MVVM</a></p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h2><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-cc979056c26b13f1e63233776fa9e8ad_720w.webp" alt="img"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-f49989545904a5b8f3338ab64806450e_720w.webp" alt="img"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-88c91a4203fe50c44ed366de25ee577d_720w.webp" alt="img"></p><h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><p>一种比较简单计算并且比较自然的曲线的方式，利用插值的方式</p><p>博客教程：<a href="https://www.cnblogs.com/msxh/p/6270468.html">https://www.cnblogs.com/msxh/p/6270468.html</a></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/798142-20170114161306385-735353264.jpg" alt="img"></p><h1 id="游戏AI"><a href="#游戏AI" class="headerlink" title="游戏AI"></a>游戏AI</h1><p>比较常见的有状态机，行为树，效用系统，目标导向</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a><strong>状态机</strong></h2><p>一个比较简单的改进方案是分层状态机，比如把巡逻的都放在一个大的巡逻里面</p><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a><strong>行为树</strong></h2><p>行为树是树型结构的，每个节点都代表了一个行为，每个行为都可以有子行为。</p><p>所有行为都有一个先决条件，就是产生的这些行为的条件。</p><p>整个算法先从树的根部开始，然后开始检查每一个先决条件。树的每一层只可以执行一个行为，所以当一个行为正在执行，它的兄弟节点都不会被检查，但是它们的子节点还是要检查的。相反如果一个行为的先决条件当前并不满足，则跳过判断它的子节点，继续判断它的兄弟节点。一个树全部检查完毕之后，决定执行优先级最大的，然后再依次执行每个动作。</p><p>不同于状态机，行为树是无状态的，不需要记下之前执行的行为，只是判断行为该不该执行。</p><p>行为树的节点之间是不相关的，删除或增加节点，对其他节点都无影响。所以，可扩展性也是行为树的一个优势。另外还可以为决策树添加灵活性与随机性，父节点可以随机决定是否检查子节点。</p><ul><li>序列（Sequence）节点：顺序执行所有子节点返回成功，如果某个子节点失败返回失败。</li><li>循环（Loop）节点：循环执行子节点到指定次数后返回成功，如果循环次数为-1，则无限循环。</li><li>条件（Condition）节点：根据条件的比较结果，返回成功或失败。</li><li>动作（Action）节点：根据动作结果返回成功，失败，或运行。</li><li>等待（Wait）节点：当指定的时间过去后返回成功。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-c4b17080b7a4f12e765fc52edbfbdd4f_720w.webp" alt="img"></p><h2 id="效用系统"><a href="#效用系统" class="headerlink" title="效用系统"></a><strong>效用系统</strong></h2><p>所以有些情况，只是做这些布尔判断是不合适的，会遗漏很多情况，判断也不妥当。比如：我们可能需要同时考虑与敌人的距离、有多少弹药、饥饿程度、HP值，等等。这些判断条件能映射出许多动作，比我们单一的判断做不做这个动作要好很多。utility-based system，基于效用的系统，会根据权重、比率、队列和许多需要考虑的事项来做出最优选择，使AI比普通的行为树更有头脑。根据上面的例子，使用效用系统我们的AI可以做出我们想要的动作，并根据当前情况做出不同强度的动作，使AI真实、更具可能性，也不再是只有一个正确的选择了。决策树就是对AI说，“只是你将要做的一个行为”，效用系统就是对AI说：“这些是你可能要做的行为”</p><h2 id="目标导向型"><a href="#目标导向型" class="headerlink" title="目标导向型"></a><strong>目标导向型</strong></h2><p>GOAP来源于STRIPS方法，这两种都是让AI创造他们自己的方法去解决问题，我们提供给它一系列可能的动作作为对这个世界的描述，和每个动作使用的先决条件，和行动带来的影响。AI拥有一个初始状态和他需要达到的目标。有一组目标，AI可以通过优先级或当前状态选择一个。计划系统决定一个动作序列来满足当前目标，计划出一个像路径一样的能最简单达到目标状态的动作序列。</p><p>GOAP是一个反向链接搜索，从要实现的目标开始，找到什么动作能实现目标，在寻找刚才动作的先决条件，一直往前推，知道达到你的当前（初始）状态。这种反向链接搜索替代了启发式的前向链接搜索。</p><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1><p><a href="https://blog.codingnow.com/2018/08/lockstep.html">lockstep 网络游戏同步方案-云风blog</a></p><p><a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/164686867">细谈网络同步在游戏历史中的发展变化（中） - 网易游戏雷火事业群的文章 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下） - 网易游戏雷火事业群的文章 - 知乎</a></p><h2 id="帧同步如何要实现什么东西"><a href="#帧同步如何要实现什么东西" class="headerlink" title="帧同步如何要实现什么东西"></a>帧同步如何要实现什么东西</h2><h3 id="确定性的数学和物理运算框架"><a href="#确定性的数学和物理运算框架" class="headerlink" title="确定性的数学和物理运算框架"></a>确定性的数学和物理运算框架</h3><p>计算逻辑采用定点数</p><p>逻辑层表现层分离，表现层可以浮点数</p><h3 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h3><p>UDP加冗余包来保证可靠性</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><h3 id="比赛回放"><a href="#比赛回放" class="headerlink" title="比赛回放"></a>比赛回放</h3><h3 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h3><h1 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h1><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><h3 id="描述一下A-算法"><a href="#描述一下A-算法" class="headerlink" title="描述一下A*算法"></a>描述一下A*算法</h3><ol><li>把起点加入 open list 。</li><li>重复如下过程：</li></ol><p>a.         遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。</p><p>b.         把这个节点移到 close list 。</p><p>c.         对当前方格的 8 个相邻方格的每一个方格？</p><p>◆     如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。</p><p>◆     如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。</p><p>◆     如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。</p><p>d.    停止条件</p><p>◆     把终点加入到了 open list 中，此时路径已经找到了，或者</p><p>◆     查找终点失败，并且 open list 是空的，此时没有路径。</p><ol start="3"><li>保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。</li></ol><p>F &#x3D; G + H</p><p>这里，</p><p>G &#x3D; 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。</p><p>H &#x3D; 从指定的方格移动到终点 B 的估算成本。这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 ) 。</p><h3 id="openlist和closelist的作用？"><a href="#openlist和closelist的作用？" class="headerlink" title="openlist和closelist的作用？"></a>openlist和closelist的作用？</h3><p>openlist就是还要搜索的列表，相比于dfs的盲目搜索更加有效率，</p><p>closelist就是已经搜过的或者不可搜的节点，加速过程。</p><h1 id="红点系统"><a href="#红点系统" class="headerlink" title="红点系统"></a>红点系统</h1><p><a href="https://zhuanlan.zhihu.com/p/85978429">Unity手游实战：从0开始SLG——独立功能扩展（三）用树实现客户端红点系统 - 放牛的星星的文章 - 知乎</a></p><p>规划红点系统的时候，我们将整个系统分为独立的三个部分：结构层、驱动层和表现层。</p><p>结构层用来部署红点的层级结构，使用树结构。</p><p>驱动层是指，如何驱动这个树结构产生状态变化，以及状态变化之后如何将变化的行为通知到指定的表现层，在一定的程度上将数据和表现分离开。</p><p>表现层就专门承担表现的职责，比如有的红点就是一个单纯的红点，有的需要显示数字，有的可能是图标晃动，有的是显示new标签，有的是播放特效等等。这些都可以归属在表现层统一去管控。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a href="https://zhuanlan.zhihu.com/p/23821422">【游戏设计模式】之四 《游戏编程模式》全书内容提炼总结 - 毛星云的文章 - 知乎</a></p><p><a href="https://gpp.tkchu.me/architecture-performance-and-games.html">游戏设计模式</a></p><p>要结合项目中能用到的东西来记忆 </p><h2 id="一、常用GOF设计模式"><a href="#一、常用GOF设计模式" class="headerlink" title="一、常用GOF设计模式"></a>一、常用GOF设计模式</h2><h3 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式"></a>1.命令模式</h3><h3 id="2-享元模式"><a href="#2-享元模式" class="headerlink" title="2.享元模式"></a>2.享元模式</h3><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><h3 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5.单例模式"></a>5.单例模式</h3><h3 id="6-状态模式"><a href="#6-状态模式" class="headerlink" title="6.状态模式"></a>6.状态模式</h3><h2 id="二、序列型模式"><a href="#二、序列型模式" class="headerlink" title="二、序列型模式"></a>二、序列型模式</h2><h3 id="7-双缓冲模式"><a href="#7-双缓冲模式" class="headerlink" title="7.双缓冲模式"></a>7.双缓冲模式</h3><h3 id="8-游戏循环"><a href="#8-游戏循环" class="headerlink" title="8.游戏循环"></a>8.游戏循环</h3><h3 id="9-更新方法"><a href="#9-更新方法" class="headerlink" title="9.更新方法"></a>9.更新方法</h3><h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><h3 id="10-字节码"><a href="#10-字节码" class="headerlink" title="10.字节码"></a>10.字节码</h3><h3 id="11-子类沙箱"><a href="#11-子类沙箱" class="headerlink" title="11.子类沙箱"></a>11.子类沙箱</h3><h3 id="12-类型对象"><a href="#12-类型对象" class="headerlink" title="12.类型对象"></a>12.类型对象</h3><h2 id="四、解耦型模式"><a href="#四、解耦型模式" class="headerlink" title="四、解耦型模式"></a>四、解耦型模式</h2><p>这个更加像是写代码的方法论。</p><h3 id="13-组件模式"><a href="#13-组件模式" class="headerlink" title="13.组件模式"></a>13.组件模式</h3><h3 id="14-事件队列"><a href="#14-事件队列" class="headerlink" title="14.事件队列"></a>14.事件队列</h3><h3 id="15-服务定位器"><a href="#15-服务定位器" class="headerlink" title="15.服务定位器"></a>15.服务定位器</h3><h2 id="五、优化型模式"><a href="#五、优化型模式" class="headerlink" title="五、优化型模式"></a>五、优化型模式</h2><p>这个可能更偏向于应用。</p><h3 id="16-数据局部性"><a href="#16-数据局部性" class="headerlink" title="16.数据局部性"></a>16.数据局部性</h3><h3 id="17-脏标识模式"><a href="#17-脏标识模式" class="headerlink" title="17.脏标识模式"></a>17.脏标识模式</h3><p>有一些更新很需要花时间的数据，每次循环的时候，加一个标志，如果没有改变就不tick这里。</p><h3 id="18-对象池模式"><a href="#18-对象池模式" class="headerlink" title="18.对象池模式"></a>18.对象池模式</h3><h3 id="19-空间分区"><a href="#19-空间分区" class="headerlink" title="19.空间分区"></a>19.空间分区</h3><h1 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h1><p>ORCA</p>]]></content>
    
    
    <summary type="html">一些乱七八糟的东西</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-刷题语法和一些经典算法题思路</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95%E5%92%8C%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/</id>
    <published>2024-04-09T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><strong>分割分号</strong></p><p>  stringstream ss(s);</p><p>  while(getline(ss,t,’;’))</p><p><strong>正则</strong></p><p>​    string temp &#x3D; t.substr(1);</p><p>​    if(regex_match(temp, regex(“[0-9]*”))){</p><p>}</p><p><strong>cout输出格式</strong></p><p>  cout &lt;&lt; setiosflags(ios::fixed);</p><p>  cout.precision(2);   </p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; ary, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> n = ary.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> m = ary[mid];<br>        <span class="hljs-keyword">if</span>(m==target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m&lt;target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a><strong>快排</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">1000001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span><span class="hljs-comment">//应用二分思想</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mid=a[(l+r)/<span class="hljs-number">2</span>];<span class="hljs-comment">//中间数</span><br>    <span class="hljs-type">int</span> i=l,j=r;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">while</span>(a[i]&lt;mid) i++;<span class="hljs-comment">//查找左半部分比中间数大的数</span><br>        <span class="hljs-keyword">while</span>(a[j]&gt;mid) j--;<span class="hljs-comment">//查找右半部分比中间数小的数</span><br>        <span class="hljs-keyword">if</span>(i&lt;=j)<span class="hljs-comment">//如果有一组不满足排序条件（左小右大）的数</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//交换</span><br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(i&lt;=j);<span class="hljs-comment">//这里注意要有=</span><br>    <span class="hljs-keyword">if</span>(l&lt;j) <span class="hljs-built_in">qsort</span>(l,j);<span class="hljs-comment">//递归搜索左半部分</span><br>    <span class="hljs-keyword">if</span>(i&lt;r) <span class="hljs-built_in">qsort</span>(i,r);<span class="hljs-comment">//递归搜索右半部分</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="椭球公式"><a href="#椭球公式" class="headerlink" title="椭球公式"></a><strong>椭球公式</strong></h2><p>x2 &#x2F; a2+y2 &#x2F; b2+z2 &#x2F; c2&#x3D;1。</p><p>当x^2&#x2F;a^2+y^2&#x2F;b^2+z^2&#x2F;c^2&lt;1时　则点(x,y,z)在内部</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><strong>反转链表</strong></h2><h2 id="删除导数第N个数"><a href="#删除导数第N个数" class="headerlink" title="删除导数第N个数"></a><strong>删除导数第N个数</strong></h2><p>总体很简单，有两个特殊的需要注意，第一是只有一个数或者零个数，第二个是需要删除的是第一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!head || !head -&gt; next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//判断是否只有一个数或者零个数</span><br>ListNode* first = head;<br>ListNode* second = head;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) second = second-&gt;next;<br><span class="hljs-keyword">if</span>(!second) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">//判断是否要删的是第一个数，因为你要是走完发现走到了尽头就说明倒数第N个数是开头，那么久直接返回head-&gt;next就行，用源代码会有bug</span><br></code></pre></td></tr></table></figure><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a><strong>高精度加法</strong></h2><p>一个很妙的不用判断进位并且前面0的处理方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(n1&gt;=<span class="hljs-number">0</span> || n2&gt;=<span class="hljs-number">0</span> || jw)&#123;<br>    <span class="hljs-type">int</span> x = n1 &gt;= <span class="hljs-number">0</span> ? num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> y = n2 &gt;= <span class="hljs-number">0</span> ? num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="n变成1"><a href="#n变成1" class="headerlink" title="n变成1"></a><strong>n变成1</strong></h2><p>n如果是奇数就变成n-1或者n+1，如果是偶数就变成n&#x2F;2</p><p>用动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; dp;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) dp[i] = dp[i/<span class="hljs-number">2</span>] +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure><h2 id="寻找第k大"><a href="#寻找第k大" class="headerlink" title="寻找第k大"></a><strong>寻找第k大</strong></h2><p>（1）基于快排，每轮划分选择一个基准值，把比它小的数放在左边，大的放在右边，函数返回基准值的位置，如果该位置恰好是K，就说明了这是第K小的数，所以从0-基准值位置的数是序列中的前K小数。若返回基准值的位置小于或者大于K，再进行相应调整：如果返回的基准值大于k，在基准值左边序列查找，如果小于，在基准值右边进行查找。递归地进行快排，直到返回的结果&#x3D;K；时间复杂度为O(n)。</p><p>（2）基于堆排序，求前K个最小的数用最大顶堆，求前K个最大的数用最小顶堆。以最大顶堆为例，要维护一个大小为K的顶堆，就是先将K个数插入堆中，随后，对每一个数，与堆顶的最大元素比较，若该数比堆顶元素小，则替换掉堆顶元素，然后调整堆，若大于堆顶元素，则不管，那么将所有元素比较和插入后，该堆维护的就是最小的K个数。求前k小的数用最大顶堆的目的(原理）：这是一种局部淘汰的思想，尽量的把小的数都放在堆中，最后使得即使堆中最大的数，也比外界的所有数都小，就达到了目的。</p><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a><strong>洗牌算法</strong></h2><p>遍历1到n，生成一个随机数，然后把当前位置的和生成位置的交换，复杂度O（n）</p><h2 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a>二叉树镜像</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分割分号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  stringstream ss(s);&lt;/p&gt;
&lt;p&gt;  while(getl</summary>
      
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>面经-计算机基础</title>
    <link href="https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://rorschachandbat.github.io/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E7%BB%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2024-03-25T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="incline"><a href="#incline" class="headerlink" title="incline"></a>incline</h3><p>inline是先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销；</p><p>内联函数是⼀种特殊的函数，会进行类型检查；对编译器的⼀种请求，编译器有可能拒绝这种请求； </p><p>C++中inline编译限制：</p><ol><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数体不能过于庞⼤</li><li>内联函数声明必须在调⽤语句之前</li></ol><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol><li>修饰变量<br>修改了变量的作用域和生命周期，存储在静态区域。生命周期和程序相同，作用域分为全局变量和局部变量。局部变量仅在函数内可用，全局变量仅在当前源文件中可用。</li><li>修饰函数<br>表明函数的作用域仅在当前源文件中。</li><li>修饰成员变量<br>静态成员变量为全局类对象所共享，仅有一份拷贝。类中声明，类外定义和初始化。</li><li>修饰成员函数<br>静态成员函数为全局类对象所共享。没有this指针，仅能访问静态成员变量和函数，虚函数不能为静态成员函数。【虚函数运行时绑定，静态成员函数编译时绑定】</li></ol><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ol><li><p>修饰变量：变量声明，表明变量在此处引用，在其他源文件中定义。</p></li><li><p>修饰函数：表明函数在其他源文件中定义。</p></li><li><p>extern “C”：编译器用C的命名规范去编译函数，链接器用C的命名规范进行链接。因为C++支持函数重载，而C不支持。</p><p>例如，假设某个函数的原型为：void</p><p>foo( int x, int y);该函数被C编译器编译后在符号库中的名字为 _ foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</p></li></ol><h3 id="constexpr-和-const"><a href="#constexpr-和-const" class="headerlink" title="constexpr 和 const"></a>constexpr 和 const</h3><p>constexpr：告诉编译器我可以是编译期间可知的，尽情的优化我吧。</p><p>const：告诉程序员没人动得了我，放心的把我传出去；或者放心的把变量交给我，我啥也不动就瞅瞅。</p><p>修饰对象的时候两者之间最基本的区别是：</p><ul><li>const修饰一个对象表示它是常量。这暗示对象一经初始化就不会再变动了，并且允许编译器使用这个特点优化程序。这也防止程序员修改了本不应该修改的对象。</li><li>constexpr是修饰一个常量表达式。但请注意constexpr不是修饰常量表达式的唯一途径。</li></ul><p>修饰函数的时候两者之间最基本的区别是：</p><ul><li>const只能用于非静态成员的函数而不是所有函数。它保证成员函数不修改任何非静态数据。</li><li>constexpr可以用于含参和无参函数。constexpr函数适用于常量表达式，只有在下面的情况下编译器才会接受constexpr函数：                                                        </li><li>1.函数体必须足够简单，除了typedef和静态元素，只允许有return语句。如构造函数只能有初始化列表，typedef和静态元素      (实际上在C++14标准中已经允许定义语句存在于constexpr函数体内了)                                                                       2.参数和返回值必须是字面值类</li></ul><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof计算的是在栈中分配的内存大小。</p><p>（1） sizeof不计算static变量占的内存；</p><p>（2） 32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；</p><p>（3） char型占1个字节，int占4个字节，short int占2个字节</p><p>long int占4个字节，float占4字节，double占8字节，string占4字节</p><p>一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节</p><p>（4） 数组的长度：</p><p>若指定了数组长度，则不看元素个数，总字节数&#x3D;数组长度*sizeof（元素类型）</p><p>若没有指定长度，则按实际元素个数类确定</p><p>Ps：若是字符数组，则应考虑末尾的空字符。</p><p>（5） 结构体对象的长度</p><p>在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。</p><p>（6） unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）&#x3D;4</p><p>（7） 自定义类型的sizeof取值等于它的类型原型取sizeof</p><p>（8） 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替</p><p>（9） sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符</p><p>（10） 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸</p><p><strong>为什么空类大小不是0？</strong></p><p>为了确保两个不同对象的地址不同，必须如此。</p><p>类的实例化是在内存中分配⼀块地址，每个实例在内存中都有独⼀⽆⼆的地址。 </p><p>同样，空类也会实例化，所以编译器会给空类隐含的添加⼀个字节，这样空类实例化后就有独⼀⽆⼆的地址了。 </p><p>所以，空类的sizeof为1，⽽不是0。</p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>不会计算字符串最末尾的’&#x2F;0’，sizeof会计算</p><h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack()"></a>#pragma pack()</h3><p>#pragma pack()不带参数时，可以取消之前自定义的字节对齐方式，恢复默认的自然对齐。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>int i &#x3D; (int)p; 等同于 int i &#x3D; static_cast<int>(p);</p><p>(int)p是C风格的强制类型转换</p><p>static_cast<int>(p)是C++的类型转换</p><p>对于指针到整数的转换，使用static_cast</p><p>各种类型转换：</p><p>const_cast：去除const属性</p><p>dynamic_cast：安全的向下转型</p><p>static_cast：编译时静态转换</p><p>reinterpret_cast：重新解释底层内存</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p> dynamic_cast 是 C++中的一个类型转换操作符，它主要用于处理多态类型的安全向下转换（<strong>也就是父类向子类转换</strong>）。 如果转换不合法，对于指针类型，dynamic_cast 会返回空指针 nullptr ； 对于<a href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B&zhida_source=entity">引用类型</a>，它会抛出 std::bda_cast 异常</p><blockquote><p>注意：dynamic_cast是在运行时检查，并且 使用dynamic_cast 转换时，涉及的类通常至少需要有一个虚函数（比如<a href="https://zhida.zhihu.com/search?content_id=239130146&content_type=Article&match_order=1&q=%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">虚析构函数</a>），这样编译器才能再运行时使用类型信息和执行转换。<br>另外在转换前，也得 Base* base &#x3D;new Derived1; 指向这个对象，不然会存在 和reinterpret_cast一样的问题</p></blockquote><h4 id="static-cast和dynamic-cast的区别"><a href="#static-cast和dynamic-cast的区别" class="headerlink" title="static_cast和dynamic_cast的区别"></a>static_cast和dynamic_cast的区别</h4><ol><li><strong>类型检查时机</strong> ：</li></ol><ul><li><code>static_cast</code>：在编译时进行类型检查。它根据转换语句中提供的信息（尖括号中的类型）进行转换，不执行运行时类型检查。</li><li><code>dynamic_cast</code>：在运行时进行类型检查。它通过检查对象的实际类型来确定转换是否安全。如果转换不安全，<code>dynamic_cast</code>会返回空指针（对于指针类型）或抛出<code>std::bad_cast</code>异常（对于引用类型）。</li></ul><ol><li><strong>安全性</strong> ：</li></ol><ul><li><code>static_cast</code>：不如<code>dynamic_cast</code>安全，因为它不进行运行时类型检查，可能会在类型不匹配的情况下导致未定义行为。例如，将一个子类对象强制转换为父类对象是安全的，但将一个父类对象强制转换为子类对象可能会导致错误。</li><li><code>dynamic_cast</code>：在类层次结构中用于安全的下行转换（从基类指针或引用转换为派生类指针或引用）。它依赖于虚函数表（vtable）来确保转换的安全性。如果基类没有虚函数，<code>dynamic_cast</code>将无法进行类型检查，从而无法保证转换的安全性。</li></ul><h3 id="funture和promise"><a href="#funture和promise" class="headerlink" title="funture和promise"></a>funture和promise</h3><h4 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h4><ul><li>**<code>std::promise</code>**：<ul><li>用于在一个线程中设置值或异常。</li><li>与 <code>std::future</code> 配对使用。</li></ul></li><li>**<code>std::future</code>**：<ul><li>用于在另一个线程中获取由 <code>std::promise</code> 设置的值或异常。</li></ul></li></ul><h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ol><li><strong>绑定关系</strong>：<ul><li>一个 <code>std::promise</code> 与一个 <code>std::future</code> 成对使用。</li><li>当通过 <code>std::promise</code> 设置值时，绑定的 <code>std::future</code> 可以访问该值。</li></ul></li><li><strong>线程间通信</strong>：<ul><li><code>std::promise</code> 通常由生产者线程持有，用于设置数据。</li><li><code>std::future</code> 通常由消费者线程持有，用于获取数据。</li></ul></li><li><strong>延迟获取</strong>：<ul><li>使用 <code>future.get()</code> 阻塞当前线程，直到 <code>promise</code> 提供值。</li></ul></li></ol><h4 id="3-通信方式"><a href="#3-通信方式" class="headerlink" title="3. 通信方式"></a>3. 通信方式</h4><ul><li><strong>传递值</strong>：通过 <code>promise.set_value()</code> 设置值，<code>future.get()</code> 获取值。</li><li><strong>传递异常</strong>：通过 <code>promise.set_exception()</code> 传递异常，<code>future.get()</code> 捕获异常。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用和指针的区别？从底层角度考虑"><a href="#引用和指针的区别？从底层角度考虑" class="headerlink" title="引用和指针的区别？从底层角度考虑"></a>引用和指针的区别？从底层角度考虑</h3><p>引用必须初始化，不能改变引用的指向，从汇编的角度来看，引用就是一个const指针</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="C-中的智能指针有哪些，各自有什么作用"><a href="#C-中的智能指针有哪些，各自有什么作用" class="headerlink" title="C++中的智能指针有哪些，各自有什么作用?"></a>C++中的智能指针有哪些，各自有什么作用?</h3><p><a href="http://t.csdnimg.cn/SaXIX">C++智能指针weak_ptr详解</a></p><p>智能指针主要解决一个内存泄露的问题，它可以自动地释放内存空间。因为它本身是一个类，当函数结束的时候会调用析构函数，并由析构函数释放内存空间。智能指针分为共享指针(shared_ptr), 独占指针(unique_ptr)和弱指针(weak_ptr)：</p><p>（1）shared_ptr ，多个共享指针可以指向相同的对象，采用了引用计数的机制，当最后一个引用销毁时，释放内存空间；</p><p>（2）unique_ptr，保证同一时间段内只有一个智能指针能指向该对象（可通过move操作来传递unique_ptr）；</p><p>（3）weak_ptr，用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><h3 id="shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"><a href="#shared-ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？" class="headerlink" title="shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？"></a>shared_ptr的实现原理是什么？构造函数、拷贝构造函数和赋值运算符怎么写？</h3><p>（1）shared_ptr是通过引用计数机制实现的，引用计数存储着有几个shared_ptr指向相同的对象，当引用计数下降至0时就会自动销毁这个对象；</p><p>（2）具体实现：</p><p>1）构造函数：将指针指向该对象，引用计数置为1；</p><p>2）拷贝构造函数：将指针指向该对象，引用计数++；</p><p>3）赋值运算符：&#x3D;号左边的shared_ptr的引用计数-1，右边的shared_ptr的引用计数+1，如果左边的引用技术降为0，还要销毁shared_ptr指向对象，释放内存空间。</p><h3 id="shareptr引用计数数据类型"><a href="#shareptr引用计数数据类型" class="headerlink" title="shareptr引用计数数据类型"></a>shareptr引用计数数据类型</h3><p>long</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><h3 id="静态多态和动态多态的区别？"><a href="#静态多态和动态多态的区别？" class="headerlink" title="静态多态和动态多态的区别？"></a>静态多态和动态多态的区别？</h3><p><strong>何为静态多态</strong>？</p><p>又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数。例如：函数重载，通过类成员运算符指定的运算。</p><p><strong>何为动态多态？</strong></p><p>动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。<br>动态多态是在虚函数的基础上实现的，而实现的条件有：<br>(1) 在类中声明为虚函数</p><p>(2) 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同（否则是函数重载的条件）</p><p>(3) 将子类对象的指针（或以引用形式）赋值给父类对象的指针（或引用），再用该指向父类对象的指针（或引用）调用虚函数<br>如此，便可以实现动态多态，程序会按照实际对象类型来选择要实行的函数具体时哪一个。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p><a href="https://zhuanlan.zhihu.com/p/688090551">C++11、C++14、C++17、C++20新特性总结 - cpp后端技术的文章 - 知乎</a></p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><h3 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h3><h3 id="函数模板的更改"><a href="#函数模板的更改" class="headerlink" title="函数模板的更改"></a>函数模板的更改</h3><p>支持默认参数</p><p>支持可变参数</p><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><p>新的std</p><p>tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>Lambda可以很方便的定义函数列表的个数，以及获取方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">[] 什么也不捕获，无法lambda函数体使用任何<br><br>[=] 按值的方式捕获所有变量<br><br>[&amp;] 按引用的方式捕获所有变量<br><br>[=, &amp;a] 除了变量a之外，按值的方式捕获所有局部变量，变量a使用引用的方式来捕获。这里可以按引用捕获多个，例如 [=, &amp;a, &amp;b,&amp;c]。这里注意，如果前面加了=，后面加的具体的参数必须以引用的方式来捕获，否则会报错。<br><br>[&amp;, a] 除了变量a之外，按引用的方式捕获所有局部变量，变量a使用值的方式来捕获。这里后面的参数也可以多个，例如 [&amp;, a, b, c]。这里注意，如果前面加了&amp;，后面加的具体的参数必须以值的方式来捕获。<br><br>[a, &amp;b] 以值的方式捕获a，引用的方式捕获b，也可以捕获多个。<br><br>[<span class="hljs-keyword">this</span>] 在成员函数中，也可以直接捕获<span class="hljs-keyword">this</span>指针，其实在成员函数中，[=]和[&amp;]也会捕获<span class="hljs-keyword">this</span>指针。<br></code></pre></td></tr></table></figure><p>如果想要修改外部变量，可以用mutable，但是也只是修改拷贝的那一份变量，真正外部不会修改</p><h3 id="for循环的新方式"><a href="#for循环的新方式" class="headerlink" title="for循环的新方式"></a>for循环的新方式</h3><p>之前只能三段式，现在可以直接auto来for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> arc[] = <span class="hljs-string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;<br>    <span class="hljs-comment">//for循环遍历普通数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : arc) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span> &lt;&lt; endl;<br>    vector&lt;<span class="hljs-type">char</span>&gt;<span class="hljs-built_in">myvector</span>(arc, arc + <span class="hljs-number">23</span>);<br>    <span class="hljs-comment">//for循环遍历 vector 容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : myvector) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;!&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 2)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">6</span> + <span class="hljs-number">4</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 3)</span><br><span class="hljs-type">int</span> length = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> url[length];<span class="hljs-comment">//错误，length是变量</span><br></code></pre></td></tr></table></figure><p>C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><h4 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h4><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p><h4 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h4><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p><p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p><p>1.整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const最好只用来用作只读的作用，要注意只读不意味不可以修改，可以通过其他的来改</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是当外部函数返回内部函数时，内部函数随后在不同的范围内执行，内部函数继续保持对外部函数变量的访问，即使外部函数不再存在。</p><p>就比如一个function再套一个function</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> helloWorld = <span class="hljs-title function_">hello</span>();<br><br><span class="hljs-title function_">helloWorld</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>1.定义一个函数(outer)，该函数存在声明的局部变量(b)</p><p>2.该函数的返回值也是一个函数(inner)</p><p>3.返回的函数(inner)调用了该函数声明的局部变量(b)</p><p>4.该函数被调用(outer)</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a href="https://www.zhihu.com/question/23971699/answer/2358595798">c++虚函数的作用是什么？ - 心试的回答 - 知乎</a></p><p>每个子类会生成一个虚函数表，根据这个子类有无重写父类的虚函数，重写了会覆盖对应的内存空间</p><p>一个继承一个比较好理解，一个继承了多个可以看下面的图</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-04eed39e986d359dcdd32ac2b8c5e658_720w.webp"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/v2-01056f4f051d715cc5de57314b0e9ba1_720w.webp"></p><p>每一个类会有一个虚函数表，然后这个类的多个对象都会共享这一张虚函数表，新创建的对象会保存虚函数指针。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p><strong>纯虚函数是指在基类中定义的没有实现的虚函数</strong>。使用纯虚函数可以使该函数只有<a href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22629281871%22%7D">函数原型</a>，而没有具体的实现。注：这里的“&#x3D;0”表示该函数为纯虚函数。</p><p>纯虚函数的作用是让子类必须实现该函数，并且不能直接创建该类对象（即该类为抽象类）。</p><p><strong>抽象类是包含纯虚函数的类</strong>，它们不能被实例化，只能被继承。抽象类只能用作其他类的基类。如果一个类继承了抽象类，则必须实现所有的纯虚函数，否则该类也会成为抽象类。</p><h3 id="哪些函数不能声明成虚函数？"><a href="#哪些函数不能声明成虚函数？" class="headerlink" title="哪些函数不能声明成虚函数？"></a>哪些函数不能声明成虚函数？</h3><p><strong>非成员函数</strong></p><p>非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？</p><p><strong>构造函数</strong></p><p>要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了。</p><p>友元函数</p><p><strong>静态成员函数</strong></p><p>静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象。虚函数必须根据对象类型才能知道调用哪一个虚函数，故虚函数是一定要在对象的基础上才可以的，两者一个是与实例相关，一个是与类相关。</p><p><strong>内联成员函数</strong></p><p>内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数。</p><h3 id="虚析构函数有什么作用？"><a href="#虚析构函数有什么作用？" class="headerlink" title="虚析构函数有什么作用？"></a>虚析构函数有什么作用？</h3><p>在Effective C++ 中，Scott Meyers在《条款07:为多态基类声明virtual析构函数》中提到，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果未有定义——实际执行时通常发生的是对象的derived成分没有被销毁。也就是说，如果派生类继承了父类的情况下，如果父类的析构函数不是虚函数，而在使用中用了多态的写法，就会导致没有调用到派生类的析构函数，导致资源没有释放，造成泄漏。</p><p>总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说<strong>虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的</strong>。<br> （1）<strong>如果父类的析构函数不加virtual关键字</strong><br> 当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。<br> （2）<strong>如果父类的析构函数加virtual关键字</strong><br> 当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。</p><h3 id="一个指向nullptr的类能调用虚函数吗？"><a href="#一个指向nullptr的类能调用虚函数吗？" class="headerlink" title="一个指向nullptr的类能调用虚函数吗？"></a>一个指向nullptr的类能调用虚函数吗？</h3><p>这种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f1&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;<span class="hljs-string">&quot;f2&quot;</span>&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> </span>&#123;cout&lt;&lt;<span class="hljs-string">&quot;f4&quot;</span>&lt;&lt;endl; &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>A* pa = <span class="hljs-literal">NULL</span>;<br>pa-&gt;<span class="hljs-built_in">f1</span>();<span class="hljs-comment">//正常</span><br>pa-&gt;<span class="hljs-built_in">f2</span>();   <span class="hljs-comment">//正常</span><br>pa-&gt;<span class="hljs-built_in">f3</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>pa-&gt;<span class="hljs-built_in">f4</span>();   <span class="hljs-comment">//错误，提示段错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不能，但是可以调用成员函数和static的成员函数（不能使用这个类的成员变量），因为成员函数地址已经确定了，和你的类其实是无关的，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">A *pa = <span class="hljs-literal">NULL</span>;<br>pa-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func(pa, 2);且pa==NULL</span><br>((A*)<span class="hljs-literal">NULL</span>)-&gt;<span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//在编译器看来就好像是 A_func( ((A*)NULL), 2);</span><br></code></pre></td></tr></table></figure><p>类的成员函数并不与具体对象绑定，所有的对象共用同一份成员函数体，当程序被编译后，成员函数的地址即已确定，这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是隐式传递给成员函数的this指针，成员函数中对成员变量的访问都是转化成”this-&gt;数据成员”的方式。因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的this指针。而类的静态成员函数只能访问<a href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">静态成员变量</a>，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。<br>有了上面的分析，就可以解释为什么空对象指针对f1, f2的调用成功，对f3的调用不成功。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存空间有哪些分类？"><a href="#内存空间有哪些分类？" class="headerlink" title="内存空间有哪些分类？"></a>内存空间有哪些分类？</h3><p>（1）堆，使用malloc、free动态分配和释放空间，能分配较大的内存；</p><p>（2）栈，为函数的局部变量分配内存，能分配较小的内存；</p><p>（3）全局&#x2F;静态存储区，用于存储全局变量和静态变量；</p><p>（4）常量存储区，专门用来存放常量；</p><p>（5）自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。</p><h3 id="malloc和new有什么区别？"><a href="#malloc和new有什么区别？" class="headerlink" title="malloc和new有什么区别？"></a>malloc和new有什么区别？</h3><p>（1）new分配内存空间无需指定分配内存大小，malloc需要；</p><p>（2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；</p><p>（3）new是从自由存储区获得内存，malloc从堆中获取内存；</p><p>（4）对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/image-20220309220924444.png" alt="image-20220309220924444"></p><h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>直接用new是自动给你分配，但是要用placement new可以在已分配的内存里面创建对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">A* p=<span class="hljs-built_in">new</span> (ptr)A<br></code></pre></td></tr></table></figure><p>1）用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象。如本例就是在栈上生成一个对象。</p><p>（2）使用语句A* p&#x3D;new (mem) A;定位生成对象时，指针p和数组名mem指向同一片存储区。所以，与其说定位放置new操作是申请空间，还不如说是利用已经请好的空间，真正的申请空间的工作是在此之前完成的。</p><p>（3）使用语句A *p&#x3D;new (mem) A;定位生成对象时，会自动调用类A的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&zhida_source=entity">构造函数</a>，但是由于对象的空间不会自动释放（对象实际上是借用别人的空间），所以必须显示的调用类的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&zhida_source=entity">析构函数</a>，如本例中的p-&gt;~A()。</p><p>（4）如果有这样一个场景，我们需要大量的申请一块类似的内存空间，然后又释放掉，比如在在一个server中对于客户端的请求，每个客户端的每一次上行数据我们都需要为此申请一块内存，当我们处理完请求给客户端下行回复时释放掉该内存，表面上看者符合c++的内存管理要求，没有什么错误，但是仔细想想很不合理，为什么我们每个请求都要重新申请一块内存呢，要知道每一次内从的申请，系统都要在内存中找到一块合适大小的连续的内存空间，这个过程是很慢的（相对而言)，极端情况下，如果当前系统中有大量的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87&zhida_source=entity">内存碎片</a>，并且我们申请的空间很大，甚至有可能失败。为什么我们不能共用一块我们事先准备好的内存呢？可以的，我们可以使用<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=2&q=placement+new&zhida_source=entity">placement new</a>来<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=1&q=%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1&zhida_source=entity">构造对象</a>，那么就会在我们指定的<a href="https://zhida.zhihu.com/search?content_id=138800873&content_type=Article&match_order=3&q=%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4&zhida_source=entity">内存空间</a>中构造对象。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h3><ol><li><p>默认构造函数（Default Constructor）：没有参数的构造函数。如果在类中没有定义构造函数，编译器会自动生成一个默认构造函数。默认构造函数用于创建对象时进行默认的初始化操作。</p></li><li><p>参数化构造函数（Parameterized Constructor）：带有参数的构造函数。参数化构造函数可以接受不同的参数，并根据参数的值来初始化对象的数据成员。</p></li><li><p>拷贝构造函数：使用一个对象初始化另一个对象。拷贝构造函数的参数为同类对象的引用。它将被复制的对象的数据成员值复制给新创建的对象。</p></li><li><p>移动构造函数（Move Constructor）：C++11引入的特性，用于实现对象的移动语义。移动构造函数通过接管另一个对象的资源而避免进行深拷贝，提高了性能。</p></li></ol><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><p>传入右值，直接浅拷贝，右值用std::move来生成</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="stl底层实现"><a href="#stl底层实现" class="headerlink" title="stl底层实现"></a><strong>stl底层实现</strong></h3><p>vector：数组</p><p>Dequeue（双端队列）：二维数组</p><p>List：环状双向链表</p><p>set（集合）：平衡的红黑树</p><p>multiset：红黑树</p><p>map：平衡二叉树</p><p>unordered_map：散列表（哈希表）</p><p><strong>而C++ STL 标准库中，不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表。</strong></p><h3 id="哈希表原理"><a href="#哈希表原理" class="headerlink" title="哈希表原理"></a>哈希表原理</h3><p>首先是哈希函数，就是把一个长的二级制数据转换成一个短的二进制数据的函数；然后就是解决哈希冲突的方法，常见的有开放寻址法和链表法，前者是通过探测并占用下一个可用的存储位置，后者是在冲突的位置用链表记录多个值。</p><h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>有三种类型</p><p>模板实际上分为三类：</p><p>类型模板参数（类型模板）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><p>非类型模板参数（常量模板）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> Size&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><p>模板模板参数（模板的模板参数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;;<br></code></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="类型模板参数（通用游戏对象）"><a href="#类型模板参数（通用游戏对象）" class="headerlink" title="类型模板参数（通用游戏对象）"></a>类型模板参数（通用游戏对象）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameObject</span> &#123;<br>    T position;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(T delta)</span> </span>&#123;<br>        position += delta;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 可以用于不同类型的位置表示</span><br>GameObject&lt;Vector2&gt; player;<br>GameObject&lt;Vector3&gt; enemy3D;<br></code></pre></td></tr></table></figure><h3 id="非类型模板参数（固定大小游戏数组）"><a href="#非类型模板参数（固定大小游戏数组）" class="headerlink" title="非类型模板参数（固定大小游戏数组）"></a>非类型模板参数（固定大小游戏数组）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> MaxUnits = <span class="hljs-number">100</span>&gt;<br><span class="hljs-keyword">class</span> ArmyManager &#123;<br>    Unit units[MaxUnits];<br>    <span class="hljs-type">int</span> currentUnitCount = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 编译期确定最大单位数</span><br>ArmyManager&lt;<span class="hljs-number">50</span>&gt; smallArmy;<br>ArmyManager&lt;<span class="hljs-number">200</span>&gt; largeArmy;<br></code></pre></td></tr></table></figure><h3 id="模板模板参数（容器策略）"><a href="#模板模板参数（容器策略）" class="headerlink" title="模板模板参数（容器策略）"></a>模板模板参数（容器策略）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inventory</span> &#123;<br>    Container&lt;T&gt; items;<br>&#125;;<br><br><span class="hljs-comment">// 可以使用不同容器</span><br>Inventory&lt;Weapon, vector&gt; playerWeapons;<br>Inventory&lt;Weapon, list&gt; backupWeapons;<br></code></pre></td></tr></table></figure><h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>（1）预处理阶段处理头文件包含关系，对预编译命令进行替换，生成预编译文件；包括展开宏定义，处理条件编译指令，包含头文件</p><p>（2）编译阶段将预编译文件编译，删除注释，生成汇编文件（编译的过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码)；</p><p>（3）汇编阶段将汇编文件转换成机器码，生成可重定位目标文件（.obj文件）（汇编器是将汇编代码转变成机器可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）；</p><p>（4）链接阶段，将多个目标文件和所需要的库连接成可执行文件（.exe文件）</p><h3 id="＃include-lt-file-h-gt-与-＃include-“file-h”的区别？"><a href="#＃include-lt-file-h-gt-与-＃include-“file-h”的区别？" class="headerlink" title="＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？"></a>＃include&lt;file.h&gt; 与 ＃include “file.h”的区别？</h3><p>前者从标准库查找寻找和引用file.h，后者从当前路径寻找和引用</p><h3 id="main函数执行之前会执行什么？执行之后还能执行代码吗？"><a href="#main函数执行之前会执行什么？执行之后还能执行代码吗？" class="headerlink" title="main函数执行之前会执行什么？执行之后还能执行代码吗？"></a>main函数执行之前会执行什么？执行之后还能执行代码吗？</h3><p>（1）全局对象的构造函数会在main函数之前执行；</p><p>（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;</p><p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。</p><p>比如全局变量的初始化，就不是由main函数引起的</p><p>举例： class A{};</p><p>A a; &#x2F;&#x2F;a的构造函数限执行</p><p>int main() {}</p><h3 id="动态库和静态库优缺点"><a href="#动态库和静态库优缺点" class="headerlink" title="动态库和静态库优缺点"></a>动态库和静态库优缺点</h3><p><strong>静态库</strong></p><p><strong>优点</strong></p><ol><li>代码装载速度快，执行速度比动态链接库略快</li><li>只需要开发者有lib就行，不需要考虑用户电脑上有无lib。</li></ol><p><strong>缺点</strong></p><p>生成的体积较大，包含相同的公共代码，造成浪费</p><p><strong>动态库</strong></p><p><strong>优点</strong></p><ol><li>节省内存</li><li>dll和exe独立，更换dll就可以改变函数内容，提高可维护性和可拓展性</li><li>不同编程语言只要按照函数调用约定可以用同一个dll</li><li>耦合度小，开发过程独立</li></ol><p><strong>缺点</strong></p><p>用户电脑里面需要有dll</p><h1 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h1><h2 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h2><h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>在C#中，unsafe 关键字用于标识包含不安全代码块的上下文，允许直接使用指针和执行不安全的操作。</p><p>优点：</p><ol><li><p>更高的性能： 使用指针直接操作内存可以提高性能，特别是在处理大量数据或需要高效访问内存的场景下。</p></li><li><p>与非托管代码交互： 允许与非托管代码进行更直接的交互，例如调用 Windows API 或者使用一些底层的系统功能。</p></li><li><p>灵活性： 可以执行一些 C# 中无法直接实现的操作，如访问特定的内存地址或进行底层的位操作。</p></li></ol><p>缺点：</p><ol><li><p>安全性风险： 使用 unsafe 可能导致程序出现潜在的安全漏洞，因为绕过了 C# 的类型安全检查和边界检查。</p></li><li><p>可读性下降： 使用指针和不安全的操作会增加代码的复杂性，并且降低代码的可读性和可维护性。</p></li><li><p>难以调试： 不安全的代码可能更难调试和定位错误，因为涉及到直接操作内存的技术细节。</p></li></ol><h3 id="const和readonly有什么区别？"><a href="#const和readonly有什么区别？" class="headerlink" title="const和readonly有什么区别？"></a>const和readonly有什么区别？</h3><p>都可以标识一个常量。主要有以下区别：<br>1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值;<br>2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段<br>3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。<br>4、const默认是静态的；而readonly如果设置成静态需要显示声明<br>5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。</p><h2 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h2><p>要用到特性就必须要用反射，比如说你要序列化一个类，如果直接写接口来实现，你不知道这个类有哪些属性，而且还要写很多不同的接口，但是用反射可以很优雅地实现，如下。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Serialize</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>&#123;<br>     <span class="hljs-keyword">var</span> res = obj<br>         .GetType()<br>         .GetProperties(BindingFlag.Public | BindingFlags.Instance)<br>         .Where(pi =&gt;<br>                &#123;<br>                    <span class="hljs-keyword">var</span> attr = pi.GetCustomAttribute&lt;BrowsableAtrribute&gt;();<br>                    <span class="hljs-keyword">if</span>(attr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> attr.Browable;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;)<br>         .Select(pi =&gt; <span class="hljs-keyword">new</span>&#123;Key = pi.Name, Value = pi.GetValue(obj)&#125;)<br>         .Select(o =&gt; <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;o.Key&#125;</span> : <span class="hljs-subst">&#123;o.Value&#125;</span>&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Join(Environment.NewLine, res);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    [<span class="hljs-meta">Browsable(false)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><h2 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h2><p>C#中定义的值类型包括原类型（Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举(enum)、结构(struct)，引用类型包括：类、数组、接口、委托、字符串等，引用型是在堆中分配内存，初始化为null，引用型是需要GARBAGE COLLECTION来回收内存的，值型不用，超出了作用范围，系统就会自动释放！</p><h2 id="结构体和类区别"><a href="#结构体和类区别" class="headerlink" title="结构体和类区别"></a>结构体和类区别</h2><h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="线程和进程和协程"><a href="#线程和进程和协程" class="headerlink" title="线程和进程和协程"></a>线程和进程和协程</h3><p><a href="https://zhuanlan.zhihu.com/p/279383752">Unity协程的原理与应用 - 宇亓的文章 - 知乎</a></p><p>（1）进程是运行时的程序，是系统进行资源分配和调度的基本单位，它实现了系统的并发；</p><p>（2）线程是进程的子单位，也称为轻量级进程，它是CPU进行分配和调度的基本单位，也是独立运行的基本单位，它实现了进程内部的并发；</p><p>（3）一个程序至少拥有一个进程，一个进程至少拥有一个线程，线程依赖于进程而存在；</p><p>（4）进程拥有独立的内存空间，而线程是共享进程的内存空间的，自己不占用资源；</p><p>（5）线程的优势：线程之间的信息共享和通讯比较方便，不需要资源的切换等.</p><p>每一个进程都独立拥有自己的指令和数据，所以称为资源分配的基本单位。其中数据又分布在内存的不同区域，我们在C语言课程中学习过内存四区的概念，一个运行中的进程所占有的内存大体可以分为四个区域：栈区、堆区、数据区、代码区。其中代码区存储指令，另外三个区存储数据。</p><p>线程是处理器调度和执行的基本单位，一个线程往往和一个函数调用栈绑定，一个进程有多个线程，每个线程拥有自己的函数调用栈，同时共用进程的堆区，数据区，代码区。操作系统会不停地在不同线程之间切换来营造出一个并行的效果，这个策略称为时间片轮转法。</p><p>那么协程在其中又处于什么地位呢？ <strong>一切用户自己实现的，类似于线程的轮子，都可以称之为是协程。</strong></p><h3 id="线程的独占资源和共享资源"><a href="#线程的独占资源和共享资源" class="headerlink" title="线程的独占资源和共享资源"></a>线程的独占资源和共享资源</h3><p><strong>独占资源</strong></p><ol><li>线程就是函数的运行，所以运行时候的信息都是独占的，包括返回值，局部变量，寄存器信息等，每个进程有自己独占的栈区。</li><li>每个线程有自己独立的线程id，独立的调度优先级和错误返回码。</li></ol><p><strong>共享资源</strong></p><ol><li>共享进程的代码区</li><li>共享进程的数据区，即全局变量和静态变量。</li><li>共享进程的堆区。</li><li>动态链接库。</li><li>文件，打开的文件信息。</li><li>共享当前工作目录，以及用户id和组id。</li></ol><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>“线程安全”也不是指线程的安全，而是指内存的安全，在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。</p><p><strong>如何避免</strong>？</p><p>私有化内存</p><p>栈内存</p><h3 id="使用多进程与多线程的区别？"><a href="#使用多进程与多线程的区别？" class="headerlink" title="使用多进程与多线程的区别？"></a>使用多进程与多线程的区别？</h3><p>（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。</p><p>（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；</p><p>（3）线程产生的速度快，线程间通信快、切换快；</p><p>（4）线程的资源利用率比较好；</p><p>（5）线程使用公共变量或者资源时需要同步机制。</p><h3 id="操作系统如何保证每个进程都有独立的空间？"><a href="#操作系统如何保证每个进程都有独立的空间？" class="headerlink" title="操作系统如何保证每个进程都有独立的空间？"></a>操作系统如何保证每个进程都有独立的空间？</h3><p>通过虚拟内存来实现，</p><p>首先是虚拟内存分页，</p><p>然后是页表映射，给每个进程维护一个页表，记录了虚拟地址和物理地址的映射关系</p><p>之后是内存保护，操作系统会给分配的进程页表有一些额外的标志，用于控制进程对内存的访问权限。</p><p>之后是上下文切换，<strong>当操作系统切换到一个新的进程时，它会保存当前进程的页表以及其他的上下文信息，并加载下一个进程的页表</strong>。这样，每个进程在运行时拥有自己独立的虚拟地址空间，与其他进程的内存空间相隔离。</p><p>通过虚拟内存机制，操作系统能够为每个进程提供独立的内存空间，<strong>无论是代码、数据还是堆栈，每个进程都认为自己独占系统的整个内存空间</strong>。这种内存隔离保证了每个进程的数据安全和保密性，并且允许操作系统有效地管理和保护进城间的内存使用</p><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p><a href="https://zhuanlan.zhihu.com/p/461063930">线程同步的几种方式 - TOMOCAT的文章 - 知乎</a></p><p>同步指的是按一定的顺序依次执行</p><p><strong>互斥锁</strong></p><p><strong>读写锁</strong></p><p><strong>条件变量</strong></p><p><strong>信号量</strong></p><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3><p>（1）TCP是传输控制协议，UDP是用户数据报协议；</p><p>（2）TCP是面向连接的，可靠的数据传输协议，它要通过三次握手来建立连接，UDP是无连接的，不可靠的数据传输协议，采取尽力而为的策略，不保证接收方一定能收到正确的数据；</p><p>（3）TCP面向的是字节流，UDP面向的是数据报；</p><p>（4）TCP只支持点对点，UDP支持一对一，一对多和多对多；</p><p>（5）TCP有拥塞控制机制，UDP没有。</p><h3 id="tcp三次握手的过程"><a href="#tcp三次握手的过程" class="headerlink" title="tcp三次握手的过程"></a>tcp三次握手的过程</h3><p>三次握手的本质是确认通信双方收发数据的能力</p><p>首先，我让信使运输一份信件给对方，<strong>对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</strong></p><p>于是他给我回信，<strong>我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</strong></p><p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次<strong>，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</strong></p><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h3 id="https为什么更加安全？"><a href="#https为什么更加安全？" class="headerlink" title="https为什么更加安全？"></a>https为什么更加安全？</h3><p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理 - 顾伊凡 YGY的文章 - 知乎</a></p><p>http是明文传输，对称加密虽然性能好但有密钥泄漏的风险，非对称加密（2组公钥+2私钥双向传输）安全但性能低下，因此考虑用非对称加密来传输对称加密所需的密钥，然后进行对称加密，但是为了防止非对称过程产生的中间人攻击，需要对服务器公钥和服务器身份进行配对的数字认证，然后引入了CA数字签名+数字证书验证的方式！</p><p>https基本采用以下流程，即非对称+对称</p><ol><li><p>某网站拥有用于非对称加密的公钥A、私钥A’。</p></li><li><p>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</p></li><li><p>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</p></li><li><p>服务器拿到后用私钥A’解密得到密钥X。</p></li><li><p>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</p></li></ol><p>但是可能会遭受中间人攻击，即在传输过程中把明文的公钥替换，那么如何保证浏览器收到的公钥就是服务器的公钥？所以就需要CA证书，CA证书本身也需要加密生成一个签名来保证没有被掉包。</p><p>而且也不用每次传输都传输密钥，服务器会为每个浏览器（或<a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2243789231%22%7D">客户端</a>软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p><h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>（1）应用程序阶段，该阶段主要是在软件层面上执行的一些工作，包括空间加速算法、视锥剔除、碰撞检测、动画物理模拟等。大体逻辑是：执行视锥剔除，查询出可能需要绘制的图元并生成渲染数据，设置渲染状态和绑定各种Shader参数，调用DrawCall，进入到下一个阶段，GPU渲染管线。</p><p>（2）几何阶段，包含顶点着色、投影变换、裁剪和屏幕映射阶段。</p><p>a. 顶点处理阶段：这个阶段会执行<strong>顶点变换</strong>和<strong>顶点着色</strong>的工作。通过模型矩阵、观察矩阵和投影矩阵(也就是MVP矩阵)计算出顶点在裁剪空间下的位置(clip space)，以便后续阶段转化为标准化设备坐标系(NDC)下的位置。也可能会计算出顶点的法线(需要有法线变换矩阵)和纹理坐标等。同时，在这个阶段也可能会进行顶点的着色计算，如平面着色 (Flat Shading)和高洛德着色 (Gouraud Shading)都是在顶点着色器中进行着色计算。因为这个阶段是完全可控制的，因此执行什么样的操作由程序员来决定。（此外，在顶点处理阶段的末尾，还有一些可选的阶段，包括曲面细分(tessellation)、几何着色(geometry shading)和流输出(stream output)，此处不详细描述）</p><p>b. 裁剪阶段：简单来说就是两次裁剪的粒度不同，前者是在物体对象层面的，一般对对象的包围盒做剔除，剔除掉不在视锥体内的物体，NDC裁剪是在三角形层面做的，裁剪掉不在屏幕内的像素。</p><p>c. 屏幕映射阶段：主要目的是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p><p>（3）光栅化阶段，包含三角形设置和三角形遍历阶段。</p><p>a. 三角形设置(图元装配)，计算出三角形的一些重要数据(如三条边的方程、深度值等)以供三角形遍历阶段使用，这些数据同样可用于各种着色数据的插值。</p><p>b. 三角形遍历，找到哪些像素被三角形所覆盖，并对这些像素的属性值进行插值。通过判断像素的中心采样点是否被三角形覆盖来决定该像素是否要生成片段。通过三角形三个顶点的属性数据，插值得到每个像素的属性值。此外透视校正插值也在这个阶段执行。</p><p>这两个阶段是完全硬件控制的，不可进行任何操作。</p><p>（4）<strong>像素处理阶段</strong>，包括像素着色和测试合并。</p><p>a. 像素着色，进行光照计算和阴影处理，决定屏幕像素的最终颜色。各种复杂的着色模型、光照计算都是在这个阶段完成。</p><p>b. 测试合并，包括各种测试和混合操作，如裁剪测试、透明测试、模板测试、深度测试以及色彩混合等。经过了测试合并阶段，并存到帧缓冲的像素值，才是最终呈现在屏幕上的图像。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>面经：<a href="https://zhuanlan.zhihu.com/p/417640759">https://zhuanlan.zhihu.com/p/417640759</a></p><p>设计模式：<a href="https://zhuanlan.zhihu.com/p/23821422">https://zhuanlan.zhihu.com/p/23821422</a></p><p>C++面经：<a href="https://github.com/huihut/interview?tab=readme-ov-file">https://github.com/huihut/interview?tab=readme-ov-file</a></p><p><a href="https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file">https://github.com/guaguaupup/cpp_interview?tab=readme-ov-file</a></p>]]></content>
    
    
    <summary type="html">痛定思痛决定好好重新整理一份八股文</summary>
    
    
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>《妙趣横生的游戏制作之旅》读书笔记</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%8A%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%97%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%8A%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F%E7%9A%84%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%97%85%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-24T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、构思——制作想法"><a href="#一、构思——制作想法" class="headerlink" title="一、构思——制作想法"></a>一、构思——制作想法</h1><h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1.如何开始"></a>1.如何开始</h2><p>作者介绍了三种方法：头脑风暴、调研和原型</p><h2 id="2-头脑风暴"><a href="#2-头脑风暴" class="headerlink" title="2.头脑风暴"></a>2.头脑风暴</h2><p>头脑风暴最好有一些基本规则，比如：</p><p>设定时间限制；注重数量而不是质量；一次只有一人发言；让一个人来协调大家；让每个人都能发言；把一切都写下来；欢迎奇怪的想法；多肯定别人的想法；不要深入讨论出现的想法。</p><p><strong>评估头脑风暴结果</strong></p><p>做表列出根据不同维度的指标打分，“最重要的是选出团队都能接受的方案。“</p><p><strong>一些其他的奇思妙想的方法</strong></p><p>思维导图：一直链接</p><p>自动化：放空大脑让自己在纸上随便写点画点东西。</p><p>剪贴法：拿一个笔记本随时记录自己的想法。</p><h2 id="3-调研"><a href="#3-调研" class="headerlink" title="3.调研"></a>3.调研</h2><p>互联网；图片；实地考察；访谈；影子观察法：这个挺有意思，观察一个人的一天，游戏测试也有用到。</p><h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p><strong>游戏原型不是游戏的演示</strong></p><p><strong>每一个原型都会为你的游戏探索一个或多个想法</strong></p><p>在构思阶段，可以尽可能多地制作原型，一个原型能验证一个有趣的想法就够了。</p><p>用每一个原型来回答一个问题，比如：“用鼠标控制钓鱼是否可行？“</p><h3 id="三种原型设计方式"><a href="#三种原型设计方式" class="headerlink" title="三种原型设计方式"></a>三种原型设计方式</h3><p><strong>趣味原型设计</strong></p><p>直接拿现成的玩具，或者干脆用动作来演示你想做的游戏是怎么玩的。</p><p><strong>实物原型设计</strong></p><p>做一个桌游，这里有一个孤星猎人的验证思路视频，很有意思，<a href="https://www.bilibili.com/video/BV1fw4m1R75K/?share_source=copy_web&vd_source=5d07d04eb2516df147034367e7af6fd2">可以看看</a></p><p>视频里也演示了实物的优势，就是迭代很快，可以验证想法的可行性。</p><p><strong>数字原型设计</strong></p><h1 id="二、预制作——通过制作进行设计"><a href="#二、预制作——通过制作进行设计" class="headerlink" title="二、预制作——通过制作进行设计"></a>二、预制作——通过制作进行设计</h1>]]></content>
    
    
    <summary type="html">记录一下这本书的内容，帮助自己梳理游戏制作的方法和流程。</summary>
    
    
    
    <category term="读书笔记" scheme="https://rorschachandbat.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="找工作" scheme="https://rorschachandbat.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="游戏制作" scheme="https://rorschachandbat.github.io/tags/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【GDC讲座】万智牌的20个教训</title>
    <link href="https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E4%B8%87%E6%99%BA%E7%89%8C%E7%9A%8420%E4%B8%AA%E6%95%99%E8%AE%AD/"/>
    <id>https://rorschachandbat.github.io/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E3%80%90gdc%E8%AE%B2%E5%BA%A7%E3%80%91%E4%B8%87%E6%99%BA%E7%89%8C%E7%9A%8420%E4%B8%AA%E6%95%99%E8%AE%AD/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2024-12-24T15:51:46.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跟人性作对是自寻死路"><a href="#1-跟人性作对是自寻死路" class="headerlink" title="1.跟人性作对是自寻死路"></a>1.跟人性作对是自寻死路</h1><p>有一个机制是延缓，得等三回合才能攻击，但是万智牌的规则不允许等待之后立马攻击，所以改了很多次都无法改好，最后改成能立马攻击了，所以要为了你的玩家来调整游戏而不是相反。</p><h1 id="2-美感很重要"><a href="#2-美感很重要" class="headerlink" title="2.美感很重要"></a>2.美感很重要</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119153159053.png" alt="image-20240119153159053"></p><p>这张牌被吐槽了很多，既不是因为他的强度，他的受欢迎度，而是因为他的攻击力是7，生命是7，效果是花七点血摸七张牌，但是他的花费是八点水晶（哈哈哈哈）</p><p>平衡感，对称感，整体感，不要和人类感知作对。</p><h1 id="3-共鸣很重要"><a href="#3-共鸣很重要" class="headerlink" title="3.共鸣很重要"></a>3.共鸣很重要</h1><p>玩家是有一些预先的知识和概念的，所以设计师不是从无到有地设计，你需要基于这一基础制作出更丰富的情感体验</p><h1 id="4-借用常识"><a href="#4-借用常识" class="headerlink" title="4.借用常识"></a>4.借用常识</h1><p>用已经存在的知识作为游戏信息，可以让游戏更加容易上手。</p><p>把木马（借用了特洛伊木马的点子）改成狮子之后会让玩家困惑这张牌的作用。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119153954784.png" alt="image-20240119153954784"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119154004563.png" alt="image-20240119154004563"></p><p>下面是一个植物大战僵尸的例子，他的设计师在设计的时候，觉得塔防游戏如果放了塔就不能移动显得很不符合逻辑，为什么这里其他地方需要帮忙他的士兵不能过去，所以他在想什么东西会更加符合直觉，于是他选择了植物，因为植物一旦放下就不能移动。然后怪物需要是一种不断靠近的生物，所以他选择了僵尸，看上去是为了幽默的两种组合其实也是经过思考的。</p><h1 id="5-不要错把“听起来有意思”当成真的“好玩”"><a href="#5-不要错把“听起来有意思”当成真的“好玩”" class="headerlink" title="5.不要错把“听起来有意思”当成真的“好玩”"></a>5.不要错把“听起来有意思”当成真的“好玩”</h1><p>理性觉得好玩不一定真的好玩</p><h1 id="6-理解你游戏希望唤醒的情感"><a href="#6-理解你游戏希望唤醒的情感" class="headerlink" title="6.理解你游戏希望唤醒的情感"></a>6.理解你游戏希望唤醒的情感</h1><p>为了让玩家感受到恐怖，设计了双面牌（比如一面是科学家一面是狼人），还有返场法术，亡语。</p><p>游戏的所有元素都要为了游戏的情感服务</p><h1 id="7-允许玩家有能力将游戏与自己联系起来"><a href="#7-允许玩家有能力将游戏与自己联系起来" class="headerlink" title="7.允许玩家有能力将游戏与自己联系起来"></a>7.允许玩家有能力将游戏与自己联系起来</h1><p>把基础枯燥的地卡的图片放大，每一张地卡都用不同的团，甚至用真实地形，这会让玩家很有参与感，让玩家对游戏产生更亲密的个人联系很重要，玩家越觉得游戏是为他们自己而设计的，他们就会越觉得游戏越棒。（熟悉感&#x3D;品质）</p><p>方法即使：多给玩家选择， 给他们不同资源，不同思路，不同表达方式，给他们选择和不选择的权利，让玩家觉得是他们自己做出的选择</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119160250626.png" alt="image-20240119160250626"></p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119160229907.png" alt="image-20240119160229907"></p><h1 id="8-细节是让玩家爱上你游戏的原因"><a href="#8-细节是让玩家爱上你游戏的原因" class="headerlink" title="8.细节是让玩家爱上你游戏的原因"></a>8.细节是让玩家爱上你游戏的原因</h1><p>玩家需要细节来和游戏产生羁绊</p><h1 id="9-要让玩家有拥有感"><a href="#9-要让玩家有拥有感" class="headerlink" title="9.要让玩家有拥有感"></a>9.要让玩家有拥有感</h1><p>受到玩家自制规则指挥赛的启发（就是一张传奇卡+99张同颜色卡），官方出了很多很多dlc，所以当玩家对某些细节产生好感之后，你需要给他们制作与众不同内容的能力，（电子游戏或许就是给他们打mod？），关键在于自定义，你要让他们实现与众不同的事，完成他们自己的创作（用自己构筑的卡组用了</p><h1 id="10-给玩家空间自己探索"><a href="#10-给玩家空间自己探索" class="headerlink" title="10.给玩家空间自己探索"></a>10.给玩家空间自己探索</h1><p>举了一个他们设计卡的时候没想到的联动（这种在炉石啊也很常见，这很有趣</p><p>不要给玩家灌输思想，让他们自己思考，因为人更关心自己发起的事情</p><h1 id="11-如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败"><a href="#11-如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败" class="headerlink" title="11.如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败"></a>11.如果所有人喜欢你的游戏，但没人爱你的游戏，游戏会失败</h1><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119171325042.png" alt="image-20240119171325042"></p><p>别担心唤起负面情绪，多担心如恶化才能唤起一种强烈的感受</p><h1 id="12-别为了证明自己去设计"><a href="#12-别为了证明自己去设计" class="headerlink" title="12.别为了证明自己去设计"></a>12.别为了证明自己去设计</h1><p>做了一张两费的英雄卡（planeswalkers），做成两费是因为已经做过了三费四费五费的，所以想尝试一张两费的， 但是玩家觉得太垃圾了，因为强度太低，他们喜欢英雄卡是因为通常很强，但是两费的限制让他不能太强。</p><p>做游戏不是为了自己开心或是证明自己的能力，而是为了好玩，为了玩家。</p><h1 id="13-让好玩的玩法同样也是赢得游戏的正确策略"><a href="#13-让好玩的玩法同样也是赢得游戏的正确策略" class="headerlink" title="13.让好玩的玩法同样也是赢得游戏的正确策略"></a>13.让好玩的玩法同样也是赢得游戏的正确策略</h1><p>万智牌加入过一种搞笑机制，Gocha（大意就是做了某些事就可以拿回这张卡，类似不要做挑战），这样会让游戏变得很沉闷，因为玩家想要赢的话就最好什么都不要做，不要笑不要说话之类的，所以体验会很糟糕。</p><h1 id="14-不要担心用简单粗暴的手段"><a href="#14-不要担心用简单粗暴的手段" class="headerlink" title="14.不要担心用简单粗暴的手段"></a>14.不要担心用简单粗暴的手段</h1><h1 id="15-为目标用户设计内容"><a href="#15-为目标用户设计内容" class="headerlink" title="15.为目标用户设计内容"></a>15.为目标用户设计内容</h1><p>弄清用户的需求，做游戏里的宜家</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119173137436.png" alt="image-20240119173137436"></p><p>一张卡有投硬币的机制（能带来兴奋），也很平衡，但是两者都想讨好的结果就是大家都不喜欢。</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119173302969.png" alt="image-20240119173302969"></p><h1 id="16-宁可尝试打破常规，也不要墨守成规让玩家觉得无聊"><a href="#16-宁可尝试打破常规，也不要墨守成规让玩家觉得无聊" class="headerlink" title="16.宁可尝试打破常规，也不要墨守成规让玩家觉得无聊"></a>16.宁可尝试打破常规，也不要墨守成规让玩家觉得无聊</h1><p>一开始设计饼干卡的时候除了自己和创始人没人喜欢，但是还是坚持下去了，结果大受欢迎</p><h1 id="17-你不需要做太多变动就可以改变全局"><a href="#17-你不需要做太多变动就可以改变全局" class="headerlink" title="17.你不需要做太多变动就可以改变全局"></a>17.你不需要做太多变动就可以改变全局</h1><p>由多色玩法引申而来，想要做一个另一个多色系列，如何做出不一样的感觉？改成双色的组合就大受欢迎</p><p><img src="https://gitee.com/jiang_liyong/cloudimage/raw/master/images/image-20240119174256154.png" alt="image-20240119174256154"></p><h1 id="18-限制是创造力的温床"><a href="#18-限制是创造力的温床" class="headerlink" title="18.限制是创造力的温床"></a>18.限制是创造力的温床</h1><p>选择越多不一定创造力更强</p><h1 id="19-你的受众很擅长指出问题，但不擅长解决问题"><a href="#19-你的受众很擅长指出问题，但不擅长解决问题" class="headerlink" title="19.你的受众很擅长指出问题，但不擅长解决问题"></a>19.你的受众很擅长指出问题，但不擅长解决问题</h1><h1 id="20-所有经验教训都是相互关联的"><a href="#20-所有经验教训都是相互关联的" class="headerlink" title="20.所有经验教训都是相互关联的"></a>20.所有经验教训都是相互关联的</h1>]]></content>
    
    
    <summary type="html">设计万智牌20年总结的20条经验 - 万智牌首席设计师Mark Rosewater经验分享</summary>
    
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="游戏设计" scheme="https://rorschachandbat.github.io/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="GDC讲座" scheme="https://rorschachandbat.github.io/tags/GDC%E8%AE%B2%E5%BA%A7/"/>
    
  </entry>
  
</feed>
